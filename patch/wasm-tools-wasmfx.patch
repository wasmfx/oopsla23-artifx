diff --git a/.github/workflows/main.yml b/.github/workflows/main.yml
index 93af94af..234513f5 100644
--- a/.github/workflows/main.yml
+++ b/.github/workflows/main.yml
@@ -48,29 +48,6 @@ jobs:
     - run: cmake -S ${{github.workspace}}/examples -B ${{github.workspace}}/examples/build -DCMAKE_BUILD_TYPE=Release
     - run: cmake --build ${{github.workspace}}/examples/build --config Release
 
-  wasm:
-    name: Test on WebAssembly
-    runs-on: ubuntu-latest
-    steps:
-    - uses: actions/checkout@v2
-      with:
-        submodules: true
-    - name: Install Rust
-      run: rustup update stable --no-self-update && rustup default stable
-    - run: rustup target add wasm32-wasi
-    - run: |
-        tag=v10.0.1
-        curl -LO https://github.com/bytecodealliance/wasmtime/releases/download/${tag}/wasmtime-${tag}-x86_64-linux.tar.xz
-        tar xf wasmtime-${tag}-x86_64-linux.tar.xz
-        echo `pwd`/wasmtime-${tag}-x86_64-linux >> $GITHUB_PATH
-        echo CARGO_TARGET_WASM32_WASI_RUNNER='wasmtime run --dir . --' >> $GITHUB_ENV
-        echo CARGO_BUILD_TARGET='wasm32-wasi' >> $GITHUB_ENV
-    - run: |
-        cargo test --workspace \
-          --exclude fuzz-stats \
-          --exclude wasm-tools-fuzz \
-          --exclude wasm-mutate-stats
-
   rustfmt:
     name: Rustfmt
     runs-on: ubuntu-latest
@@ -112,8 +89,6 @@ jobs:
       - run: cargo check --no-default-features --features demangle
       - run: cargo check --no-default-features --features component
       - run: cargo check --no-default-features --features metadata
-      - run: cargo check --no-default-features --features wit-smith
-      - run: cargo check --no-default-features --features addr2line
 
   doc:
     runs-on: ubuntu-latest
diff --git a/.gitignore b/.gitignore
index 6e309e08..14d925d6 100644
--- a/.gitignore
+++ b/.gitignore
@@ -6,4 +6,3 @@ publish
 *.wasm
 *.wat
 test.config
-
diff --git a/Cargo.toml b/Cargo.toml
index ce316301..3a84f35f 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -1,6 +1,6 @@
 [package]
 name = "wasm-tools"
-version = "1.0.36"
+version = "1.0.28"
 authors = ["The Wasmtime Project Developers"]
 edition.workspace = true
 description = "CLI tools for interoperating with WebAssembly files"
@@ -30,34 +30,30 @@ arbitrary = "1.1.0"
 clap = { version = "4.0.0", features = ["derive"] }
 criterion = "0.3.3"
 env_logger = "0.9"
-indexmap = "2.0.0"
+indexmap = "1.9.1"
 leb128 = "0.2.4"
 libfuzzer-sys = "0.4.0"
 log = "0.4.17"
 num_cpus = "1.13"
 rand = { version = "0.8.4", features = ["small_rng"] }
 rayon = "1.3"
-serde = { version = "1.0.166", features = ["derive"] }
-wasmtime = { version = "3.0.0", default-features = false, features = [
-  'cranelift',
-] }
+serde = { version = "1.0.137", features = ["derive"] }
+wasmtime = { version = "3.0.0", default-features = false, features = ['cranelift'] }
 url = "2.0.0"
 pretty_assertions = "1.3.0"
-semver = "1.0.0"
-
-wasm-encoder = { version = "0.30.0", path = "crates/wasm-encoder" }
-wasm-compose = { version = "0.3.0", path = "crates/wasm-compose" }
-wasm-metadata = { version = "0.9.0", path = "crates/wasm-metadata" }
-wasm-mutate = { version = "0.2.28", path = "crates/wasm-mutate" }
-wasm-shrink = { version = "0.1.29", path = "crates/wasm-shrink" }
-wasm-smith = { version = "0.12.11", path = "crates/wasm-smith" }
-wasmparser = { version = "0.108.0", path = "crates/wasmparser" }
-wasmprinter = { version = "0.2.60", path = "crates/wasmprinter" }
-wast = { version = "61.0.0", path = "crates/wast" }
-wat = { version = "1.0.67", path = "crates/wat" }
-wit-component = { version = "0.12.0", path = "crates/wit-component" }
-wit-parser = { version = "0.9.0", path = "crates/wit-parser" }
-wit-smith = { version = "0.1.6", path = "crates/wit-smith" }
+
+wasm-encoder = { version = "0.25.0", path = "crates/wasm-encoder"}
+wasm-compose = { version = "0.2.11", path = "crates/wasm-compose"}
+wasm-metadata = { version = "0.3.1", path = "crates/wasm-metadata" }
+wasm-mutate = { version = "0.2.22", path = "crates/wasm-mutate" }
+wasm-shrink = { version = "0.1.23", path = "crates/wasm-shrink" }
+wasm-smith = { version = "0.12.5", path = "crates/wasm-smith" }
+wasmparser = { version = "0.102.0", path = "crates/wasmparser" }
+wasmprinter = { version = "0.2.54", path = "crates/wasmprinter" }
+wast = { version = "55.0.0", path = "crates/wast" }
+wat = { version = "1.0.61", path = "crates/wat" }
+wit-component = { version = "0.7.4", path = "crates/wit-component" }
+wit-parser = { version = "0.6.4", path = "crates/wit-parser" }
 
 [dependencies]
 anyhow = { workspace = true }
@@ -67,7 +63,6 @@ log = { workspace = true }
 clap = { workspace = true }
 tempfile = "3.2.0"
 wat = { workspace = true }
-termcolor = "1.2.0"
 
 # Dependencies of `validate`
 wasmparser = { workspace = true, optional = true }
@@ -84,6 +79,7 @@ wasm-smith = { workspace = true, features = ["_internal_cli"], optional = true }
 
 # Dependencies of `shrink`
 wasm-shrink = { workspace = true, features = ["clap"], optional = true }
+is_executable = { version = "1.0.1", optional = true }
 
 # Dependencies of `mutate`
 wasm-mutate = { workspace = true, features = ["clap"], optional = true }
@@ -100,25 +96,13 @@ rustc-demangle = { version = "0.1.21", optional = true }
 cpp_demangle = { version = "0.4.0", optional = true }
 
 # Dependencies of `component`
-wit-component = { workspace = true, optional = true, features = [
-  'dummy-module',
-] }
+wit-component = { workspace = true, optional = true, features = ['dummy-module'] }
 wit-parser = { workspace = true, optional = true }
 wast = { workspace = true, optional = true }
 
 # Dependencies of `metadata`
 wasm-metadata = { workspace = true, features = ["clap"], optional = true }
 
-# Dependencies of `wit-smith`
-wit-smith = { workspace = true, features = ["clap"], optional = true }
-
-# Dependencies of `addr2line`
-addr2line = { version = "0.20.0", optional = true }
-gimli = { version = "0.27.2", optional = true }
-
-[target.'cfg(not(target_family = "wasm"))'.dependencies]
-is_executable = { version = "1.0.1", optional = true }
-
 [dev-dependencies]
 serde_json = "1.0"
 tempfile = "3.1"
@@ -150,29 +134,19 @@ default = [
   'demangle',
   'component',
   'metadata',
-  'wit-smith',
-  'addr2line',
 ]
 
 # Each subcommand is gated behind a feature and lists the dependencies it needs
-validate = ['dep:wasmparser', 'rayon']
+validate = ['wasmparser', 'rayon']
 print = []
 parse = []
 smith = ['wasm-smith', 'arbitrary', 'serde', 'serde_json']
 shrink = ['wasm-shrink', 'is_executable']
 mutate = ['wasm-mutate']
-dump = ['dep:wasmparser']
-objdump = ['dep:wasmparser']
-strip = ['wasm-encoder', 'dep:wasmparser', 'regex']
+dump = ['wasmparser']
+objdump = ['wasmparser']
+strip = ['wasm-encoder', 'wasmparser', 'regex']
 compose = ['wasm-compose']
-demangle = ['rustc-demangle', 'cpp_demangle', 'dep:wasmparser', 'wasm-encoder']
-component = [
-  'wit-component',
-  'wit-parser',
-  'wast',
-  'wasm-encoder',
-  'dep:wasmparser',
-]
-metadata = ['dep:wasmparser', 'wasm-metadata', 'serde_json']
-wit-smith = ['dep:wit-smith', 'arbitrary']
-addr2line = ['dep:addr2line', 'dep:gimli', 'dep:wasmparser']
+demangle = ['rustc-demangle', 'cpp_demangle', 'wasmparser', 'wasm-encoder']
+component = ['wit-component', 'wit-parser', 'wast', 'wasm-encoder', 'wasmparser']
+metadata = ['wasmparser', 'wasm-metadata', 'serde_json' ]
diff --git a/README.md b/README.md
index 06ae5a74..8ed0a896 100644
--- a/README.md
+++ b/README.md
@@ -57,7 +57,6 @@ programmatically as well:
 | `wasm-tools component embed` |  | Embed a `component-type` custom section in a core wasm binary |
 | `wasm-tools metadata show` |  [wasm-metadata] | Show name and producer metadata in a component or module |
 | `wasm-tools metadata add` |  | Add name or producer metadata to a component or module |
-| `wasm-tools addr2line` |  | Translate wasm offsets to filename/line numbers with DWARF |
 
 [wasmparser]: https://crates.io/crates/wasmparser
 [wat]: https://crates.io/crates/wat
diff --git a/ci/publish.rs b/ci/publish.rs
index 756fdac0..dab31eba 100644
--- a/ci/publish.rs
+++ b/ci/publish.rs
@@ -26,8 +26,8 @@ use std::time::Duration;
 
 // Crates we care about publishing sorted topologically.
 const CRATES_TO_PUBLISH: &[&str] = &[
-    "wasm-encoder",
     "wasmparser",
+    "wasm-encoder",
     "wasmprinter",
     "wast",
     "wat",
@@ -35,11 +35,10 @@ const CRATES_TO_PUBLISH: &[&str] = &[
     "wasm-smith",
     "wasm-mutate",
     "wasm-shrink",
+    "wasm-compose",
     "wit-parser",
     "wasm-metadata",
     "wit-component",
-    "wasm-compose",
-    "wit-smith",
     "wasm-tools",
 ];
 
diff --git a/crates/c-api/src/lib.rs b/crates/c-api/src/lib.rs
index 1542dd1a..0c20668b 100644
--- a/crates/c-api/src/lib.rs
+++ b/crates/c-api/src/lib.rs
@@ -30,13 +30,8 @@ pub extern "C" fn wasm_tools_byte_vec_delete(bytes: &mut wasm_tools_byte_vec_t)
     }
 }
 
-/// Create a new WebAssembly module with the given seed.
-///
-/// # Safety
-///
-/// `seed` must be a valid pointer to `seed_len` bytes of memory.
 #[no_mangle]
-pub unsafe extern "C" fn wasm_smith_create(
+pub extern "C" fn wasm_smith_create(
     seed: *const u8,
     seed_len: usize,
     bytes: &mut wasm_tools_byte_vec_t,
diff --git a/crates/wasm-compose/CONFIG.md b/crates/wasm-compose/CONFIG.md
index f27d782c..c43f71f9 100644
--- a/crates/wasm-compose/CONFIG.md
+++ b/crates/wasm-compose/CONFIG.md
@@ -7,21 +7,18 @@ To specify the configuration file to use, pass the `--config` option to
 
 The configuration file has the following top-level fields:
 
-* `search-paths` : `list<string>` (optional) - a list of paths to search for
-dependencies.
-* `skip-validation` : `bool` (optional) - a boolean indicating whether to skip
-validation of the resulting composed component.
-* `dependencies` : `map<string, dependency>` (optional) - a map specifying the
-explicit locations of transitive dependencies.
-* `instantiations` : `map<string, instantiation>` (optional) - a map specifying
-the explicit instantiations of transitive dependencies.
-* `definitions` : `list<string>` (optional) - a list of paths to _definition_
-components.
+* `search-paths` : `list<string>` (optional) - a list of paths to search for dependencies.
+* `skip-validation` : `bool` (optional) - a boolean indicating whether to skip 
+  validation of the resulting composed component.
+* `dependencies` : `map<string, dependency>` (optional) - a map specifying the explicit
+  locations of transitive dependencies.
+* `instantiations` : `map<string, instantiation>` (optional) - a map specifying the explicit
+  instantiations of transitive dependencies.
 
 ## Dependencies
 
-Each `dependency` specifies a path where `wasm-compose` may locate a
-dependency, rather than searching the configured search paths.
+Each `dependency` specifies a path where `wasm-compose` may locate a dependency, rather
+than searching the configured search paths.
 
 A dependency has the following fields:
 
@@ -49,35 +46,30 @@ dependencies:
 
 In the above example, two dependencies are defined in the configuration:
 
-* `a` - the contents of `a.wasm` will be defined directly in the composed
-component.
-* `b` - a component of the same type as `b.wasm` will be imported in the
-composed component with name `b`; the original file will not be embedded in the
-composed component.
+* `a` - the contents of `a.wasm` will be defined directly in the composed component.
+* `b` - a component of the same type as `b.wasm` will be imported in the composed
+  component with name `b`; the original file will not be embedded in the composed
+  component.
 
-_Note: importing components from a composed component is not currently
-supported in [Wasmtime](https://github.com/bytecodealliance/wasmtime)._
+_Note: importing components from a composed component is not currently supported in_
+_[Wasmtime](https://github.com/bytecodealliance/wasmtime)._
 
-Dependency names should match the expected name of imports from components in
-the component graph.
+Dependency names should match the expected name of imports from components in the
+component graph.
 
 ## Instantiations
 
-Each `instantiation` specifies how a particular dependency is to be
-instantiated, even allowing a dependency to be instantiated multiple times.
+Each `instantiation` specifies how a particular dependency is to be instantiated, even
+allowing a dependency to be instantiated multiple times.
 
 An instantiation has the following fields:
 
-* `dependency` : `string` (optional) - the name of the dependency to
-  instantiate.
+* `dependency` : `string` (optional) - the name of the dependency to instantiate.
+  If unspecified, the instantiation will be for a dependency of the same name as the
+  instantiation itself.
 
-  If unspecified, the instantiation will be for a dependency of the same name
-  as the instantiation itself.
-
-* `arguments` : `map<string, argument>` (optional) - a mapping of argument
-  names to arguments.
-
-  Argument names match the names of the imports of the dependency being
+* `arguments` : `map<string, argument>` (optional) - a mapping of argument names to
+  arguments; argument names match the names of the imports of the dependency being
   instantiated.
 
 Note that the instantiation name `$input` is special and signifies how the input
@@ -85,17 +77,16 @@ component is to be instantiated.
 
 ### Instantiation arguments
 
-Each `argument` specifies exactly which instance should be provided as argument
-to the instantiation of a dependency.
+Each `argument` specifies exactly which instance should be provided as argument to the
+instantiation of a dependency.
 
 An argument has the following fields:
 
 * `instance` : `string` - the name of the instance to pass as the argument.
 
-* `export` : `string` (optional) - the name of the exported instance on
-  `instance` to use as the argument.
-
-  If not present, the instance specified by `instance` will be passed directly.
+* `export` : `string` (optional) - the name of the exported instance on `instance` to use
+  as the argument; if not present, the instance specified by `instance` will be passed
+  directly.
 
 Arguments may be specified as a `string` rather than a `map`, in which case
 it is treated as having an `instance` field with the value of the string.
@@ -118,36 +109,15 @@ instantiations:
     dependency: f
 ```
 
-In the above example, the `$input` instantiation (i.e. the root instantiation)
-has explicitly specified that the argument named `a` is to be provided instance
-`b`.
-
-It also defines an instantiation named `b` which is to be passed an instance
-export named `e` from instance `d` (of a dependency named `f`) for the
-instantiation argument named `c`.
-
-By default, `wasm-compose` will minimize the number of instantiations and
-dependencies which share an import of the same name will share the same
-instance of that dependency, provided that the instance is compatible with
-every import.
-
-Configuring instantiations for `wasm-compose` allows for a custom instantiation
-graph to be constructed in the composed component.
-
-## Definition components
-
-A _definition_ component is a component that exports instances that are
-automatically used to satisfy any instance import in the composition with a
-matching name.
+In the above example, the `$input` instantiation (i.e. the root instantiation) has explicitly
+specified that the argument named `a` is to be provided instance `b`.
 
-A typical use case for definition components is to provide a _virtualized_
-implementation of common interfaces.
+It also defines an instantiation named `b` which is to be passed an instance export named `e`
+from instance `d` (of a dependency named `f`) for the instantiation argument named `c`.
 
-For example, a definition component might export a virtualized implementation
-of the `wasi:filesystem/types` interface that serves files via inline data
-segments instead of by accessing the host filesystem.
+By default, `wasm-compose` will minimize the number of instantiations and dependencies which share
+an import of the same name will share the same instance of that dependency, provided that the
+instance is compatible with every import.
 
-By providing such a definition component to the composition, any use of the
-WASI filesystem interface by the root component (or its dependencies) will
-automatically use the implementation provided by the definition component
-instead of importing it from the host environment.
+Configuring instantiations for `wasm-compose` allows for a custom instantiation graph to be
+constructed in the composed component.
diff --git a/crates/wasm-compose/Cargo.toml b/crates/wasm-compose/Cargo.toml
index d3fdd682..829ce279 100644
--- a/crates/wasm-compose/Cargo.toml
+++ b/crates/wasm-compose/Cargo.toml
@@ -1,6 +1,6 @@
 [package]
 name = "wasm-compose"
-version = "0.3.0"
+version = "0.2.11"
 edition.workspace = true
 authors = ["Peter Huene <peter@huene.dev>"]
 license = "Apache-2.0 WITH LLVM-exception"
@@ -32,4 +32,3 @@ cli = ["clap"]
 glob = "0.3.0"
 pretty_assertions = "1.2.1"
 wasmprinter = { workspace = true }
-wit-component = { workspace = true }
diff --git a/crates/wasm-compose/example/README.md b/crates/wasm-compose/example/README.md
index 7d378c76..2c0f8678 100644
--- a/crates/wasm-compose/example/README.md
+++ b/crates/wasm-compose/example/README.md
@@ -14,7 +14,7 @@ There are three subdirectories in this example:
 
 ## Overview
 
-The server will listen for `POST` requests at `http://localhost:8080`.
+The server will listen for `POST` requests at `http://localhost:8080`. 
 
 When it receives a request, the server will instantiate a service component
 and forward it the request.
@@ -41,10 +41,10 @@ interface handler {
 }
 ```
 
-A service handler will be passed a `request` containing only the headers and
+A service handler will be passed a `request` containing only the headers and 
 body and respond with a `response` containing only the headers and body.
 
-Note that this is an overly-simplistic (and inefficient) interface for
+Note that this is an overly-simplistic (and inefficient) interface for 
 describing HTTP request processing.
 
 ### Execution flow
@@ -86,10 +86,6 @@ The components in this example will be built with [`cargo component`](https://gi
 Follow the [installation instructions](https://github.com/bytecodealliance/cargo-component#installation)
 to install `cargo component` locally.
 
-> *Note*: `cargo component` is under active development. This example has been tested
-> with git sha [`df2eb26`](https://github.com/bytecodealliance/cargo-component/commit/df2eb2633fa6d0c234372fb0471b8e9867d135c6)
-> and may not work with other versions of `cargo component`.
-
 Additionally, it is assumed that `wasm-tools` has been installed from the
 root of this repository.
 
@@ -118,7 +114,7 @@ The server can be run with `cargo run`:
 
 ```sh
 cd server
-cargo run --release -- ../service/target/wasm32-wasi/release/svc.wasm
+cargo run --release -- ../service/target/wasm32-unknown-unknown/release/svc.wasm
 ```
 
 This will start a HTTP server that listens at `http://localhost:8080`.
@@ -144,13 +140,13 @@ This should output something like this:
 > Accept: */*
 > Content-Type: text/plain
 > Content-Length: 13
->
+> 
 * Mark bundle as not supporting multiuse
 < HTTP/1.1 200 OK
 < content-length: 35
 < content-type: text/plain
 < date: Fri, 05 Aug 2022 01:39:43 GMT
-<
+< 
 * Connection #0 to host localhost left intact
 The request body was: Hello, world!
 ```
@@ -160,8 +156,8 @@ compressed.
 
 ## Composing with a middleware
 
-If we want to instead compress the response bodies for the service, we can
-easily compose a new component that sends requests through the `middleware`
+If we want to instead compress the response bodies for the service, we can 
+easily compose a new component that sends requests through the `middleware` 
 component without rebuilding any of the previously built components.
 
 The `server/config.yml` file contains the configuration needed to compose a new
@@ -171,7 +167,7 @@ Run `wasm-compose` to compose the new component:
 
 ```sh
 cd server
-wasm-tools compose -c config.yml -o service.wasm ../middleware/target/wasm32-wasi/release/middleware.wasm
+wasm-tools compose -c config.yml -o service.wasm ../middleware/target/wasm32-unknown-unknown/release/middleware.wasm
 ```
 
 This results in a new `service.wasm` in the `server` directory where the
@@ -213,14 +209,14 @@ This should output something like this:
 > Accept-Encoding: deflate, gzip
 > Content-Type: text/plain
 > Content-Length: 13
->
+> 
 * Mark bundle as not supporting multiuse
 < HTTP/1.1 200 OK
 < content-encoding: gzip
 < content-length: 58
 < content-type: text/plain
 < date: Fri, 05 Aug 2022 01:47:59 GMT
-<
+< 
 * Connection #0 to host localhost left intact
 The request body was: Hello, world!
 ```
diff --git a/crates/wasm-compose/example/middleware/Cargo.toml b/crates/wasm-compose/example/middleware/Cargo.toml
index a1404e9c..ee2df4e8 100644
--- a/crates/wasm-compose/example/middleware/Cargo.toml
+++ b/crates/wasm-compose/example/middleware/Cargo.toml
@@ -6,12 +6,12 @@ publish = false
 
 [dependencies]
 flate2 = "1.0.24"
-wit-bindgen = { version = "0.6.0", default_features = false }
+wit-bindgen = { version = "0.3.0", default_features = false }
 
 [lib]
 crate-type = ["cdylib"]
 
 [package.metadata.component]
-target = { path = "../service.wit", world = "middleware" }
+target = { path = "../service.wit", world = "service.middleware" }
 
 [workspace]
diff --git a/crates/wasm-compose/example/middleware/src/lib.rs b/crates/wasm-compose/example/middleware/src/lib.rs
index 9dcdeea1..fa292ceb 100644
--- a/crates/wasm-compose/example/middleware/src/lib.rs
+++ b/crates/wasm-compose/example/middleware/src/lib.rs
@@ -1,5 +1,7 @@
-use bindings::example::service::handler as downstream;
-use bindings::exports::example::service::handler::{Error, Handler, Request, Response};
+use bindings::{
+    downstream,
+    handler::{Error, Handler, Request, Response},
+};
 use flate2::{write::GzEncoder, Compression};
 use std::io::Write;
 
@@ -7,10 +9,16 @@ struct Component;
 
 impl Handler for Component {
     fn execute(req: Request) -> Result<Response, Error> {
+        let headers: Vec<_> = req
+            .headers
+            .iter()
+            .map(|(k, v)| (k.as_slice(), v.as_slice()))
+            .collect();
+
         // Send the request to the downstream service
-        let mut response = downstream::execute(&downstream::Request {
-            headers: req.headers,
-            body: req.body,
+        let mut response = downstream::execute(downstream::Request {
+            headers: &headers,
+            body: &req.body,
         })
         .map(|r| Response {
             headers: r.headers,
diff --git a/crates/wasm-compose/example/server/Cargo.toml b/crates/wasm-compose/example/server/Cargo.toml
index 3ecdb0b7..9ba66fbc 100644
--- a/crates/wasm-compose/example/server/Cargo.toml
+++ b/crates/wasm-compose/example/server/Cargo.toml
@@ -9,9 +9,7 @@ async-std = { version = "1.12.0", features = ["attributes"] }
 clap = { version = "3.2.23", features = ["derive"] }
 driftwood = "0.0.6"
 tide = "0.16.0"
-wasmtime = { git = "https://github.com/bytecodealliance/wasmtime", rev = "46826c62735dc22cc512fd5d23aa702a92e8a364", features = ["component-model"] }
-wasmtime-wasi = { git = "https://github.com/bytecodealliance/wasmtime", rev = "46826c62735dc22cc512fd5d23aa702a92e8a364" }
-wasi-cap-std-sync = { git = "https://github.com/bytecodealliance/wasmtime", rev = "46826c62735dc22cc512fd5d23aa702a92e8a364" }
-anyhow = "1.0.71"
+wasmtime = { version = "6.0.0", features = ["component-model"] }
+wasmtime-component-macro = "6.0.0"
 
 [workspace]
diff --git a/crates/wasm-compose/example/server/config.yml b/crates/wasm-compose/example/server/config.yml
index 69d1b597..f370858b 100644
--- a/crates/wasm-compose/example/server/config.yml
+++ b/crates/wasm-compose/example/server/config.yml
@@ -1,7 +1,7 @@
 search-paths:
-  - ../service/target/wasm32-wasi/release
+  - ../service/target/wasm32-unknown-unknown/release
 
 instantiations:
   $input:
     arguments:
-      example:service/handler: svc
+      downstream: svc
diff --git a/crates/wasm-compose/example/server/src/main.rs b/crates/wasm-compose/example/server/src/main.rs
index 3297567e..a9108c0d 100644
--- a/crates/wasm-compose/example/server/src/main.rs
+++ b/crates/wasm-compose/example/server/src/main.rs
@@ -8,16 +8,11 @@ use tide::{
     utils::After,
     Request, Response, StatusCode,
 };
-
 use wasmtime::{component::*, Config, Engine, Store};
-use wasmtime_wasi::preview2::{wasi, Table, WasiCtx, WasiCtxBuilder, WasiView};
-
-use exports::example::service::*;
 
-wasmtime::component::bindgen!({
+wasmtime_component_macro::bindgen!({
     path: "../service.wit",
-    world: "service",
-    async: true
+    world: "service"
 });
 
 /// Represents state stored in the tide application context.
@@ -35,7 +30,6 @@ impl State {
         // Enable component model support in Wasmtime
         let mut config = Config::default();
         config.wasm_component_model(true);
-        config.async_support(true);
 
         // Load the component from the given path
         let engine = Engine::new(&config)?;
@@ -123,66 +117,23 @@ impl ServerApp {
 
         // Create a new store for the request
         let state = req.state();
-        let mut linker = Linker::new(&state.engine);
-        wasi::filesystem::filesystem::add_to_linker(&mut linker, |x| x)?;
-        wasi::io::streams::add_to_linker(&mut linker, |x| x)?;
-        wasi::cli_base::environment::add_to_linker(&mut linker, |x| x)?;
-        wasi::cli_base::preopens::add_to_linker(&mut linker, |x| x)?;
-        wasi::cli_base::exit::add_to_linker(&mut linker, |x| x)?;
-        wasi::cli_base::stdin::add_to_linker(&mut linker, |x| x)?;
-        wasi::cli_base::stdout::add_to_linker(&mut linker, |x| x)?;
-        wasi::cli_base::stderr::add_to_linker(&mut linker, |x| x)?;
-
-        let wasi_view = ServerWasiView::new()?;
-        let mut store = Store::new(&state.engine, wasi_view);
-        let (service, _) = Service::instantiate_async(&mut store, &state.component, &linker).await?;
+        let linker: Linker<()> = Linker::new(&state.engine);
+        let mut store = Store::new(&state.engine, ());
+        let (service, _) = Service::instantiate(&mut store, &state.component, &linker)?;
         service
-            .example_service_handler()
+            .handler
             .call_execute(
                 &mut store,
                 handler::Request {
                     headers: &headers,
                     body: &body,
                 },
-            )
-            .await?
+            )?
             .map(TryInto::try_into)
             .map_err(handler::Error::into_tide)?
     }
 }
 
-struct ServerWasiView {
-    table: Table,
-    ctx: WasiCtx,
-}
-
-impl ServerWasiView {
-    fn new() -> Result<Self, anyhow::Error> {
-        let mut table = Table::new();
-        let ctx = WasiCtxBuilder::new().inherit_stdio().build(&mut table)?;
-
-        Ok(Self { table, ctx })
-    }
-}
-
-impl WasiView for ServerWasiView {
-    fn table(&self) -> &Table {
-        &self.table
-    }
-
-    fn table_mut(&mut self) -> &mut Table {
-        &mut self.table
-    }
-
-    fn ctx(&self) -> &WasiCtx {
-        &self.ctx
-    }
-
-    fn ctx_mut(&mut self) -> &mut WasiCtx {
-        &mut self.ctx
-    }
-}
-
 #[async_std::main]
 async fn main() -> tide::Result<()> {
     // Parse the command line arguments and run the application
diff --git a/crates/wasm-compose/example/service.wit b/crates/wasm-compose/example/service.wit
index daeacb2c..f4bbc805 100644
--- a/crates/wasm-compose/example/service.wit
+++ b/crates/wasm-compose/example/service.wit
@@ -1,5 +1,3 @@
-package example:service
-
 interface handler {
     record request {
         headers: list<tuple<list<u8>, list<u8>>>,
@@ -18,11 +16,11 @@ interface handler {
     execute: func(req: request) -> result<response, error>
 }
 
-world service {
-    export handler
+default world service {
+    export handler: self.handler
 }
 
 world middleware {
-    import handler
-    export handler
+    import downstream: self.handler
+    export handler: self.handler
 }
diff --git a/crates/wasm-compose/example/service/Cargo.toml b/crates/wasm-compose/example/service/Cargo.toml
index 5146cc10..5a82c1e4 100644
--- a/crates/wasm-compose/example/service/Cargo.toml
+++ b/crates/wasm-compose/example/service/Cargo.toml
@@ -5,12 +5,12 @@ edition = "2021"
 publish = false
 
 [dependencies]
-wit-bindgen = { version = "0.6.0", default_features = false }
+wit-bindgen = { version = "0.3.0", default_features = false }
 
 [lib]
 crate-type = ["cdylib"]
 
 [package.metadata.component]
-target = { path = "../service.wit",  world = "service" }
+target = { path = "../service.wit" }
 
 [workspace]
diff --git a/crates/wasm-compose/example/service/src/lib.rs b/crates/wasm-compose/example/service/src/lib.rs
index 47d49f5e..0d05a240 100644
--- a/crates/wasm-compose/example/service/src/lib.rs
+++ b/crates/wasm-compose/example/service/src/lib.rs
@@ -1,4 +1,4 @@
-use bindings::exports::example::service::handler::{Error, Handler, Request, Response};
+use bindings::handler::{Error, Handler, Request, Response};
 use std::str;
 
 struct Component;
diff --git a/crates/wasm-compose/src/cli.rs b/crates/wasm-compose/src/cli.rs
index 112d5124..359031a2 100644
--- a/crates/wasm-compose/src/cli.rs
+++ b/crates/wasm-compose/src/cli.rs
@@ -20,10 +20,6 @@ pub struct WasmComposeCommand {
     #[clap(long, short = 'c', value_name = "CONFIG")]
     pub config: Option<PathBuf>,
 
-    /// Definition components whose exports define import dependencies to fulfill from.
-    #[clap(long = "definitions", short = 'd', value_name = "DEFS")]
-    pub defs: Vec<PathBuf>,
-
     /// A path to search for imports.
     #[clap(long = "search-path", short = 'p', value_name = "PATH")]
     pub paths: Vec<PathBuf>,
@@ -97,15 +93,7 @@ impl WasmComposeCommand {
             }
         };
 
-        // Use paths relative to the current directory; otherwise, the paths are interpreted as
-        // relative to the configuration file.
-        let cur_dir = std::env::current_dir().context("failed to get current directory")?;
-        config
-            .definitions
-            .extend(self.defs.iter().map(|p| cur_dir.join(p)));
-        config
-            .search_paths
-            .extend(self.paths.iter().map(|p| cur_dir.join(p)));
+        config.search_paths.extend(self.paths.iter().cloned());
         config.skip_validation |= self.skip_validation;
         config.disallow_imports |= self.disallow_imports;
         Ok(config)
diff --git a/crates/wasm-compose/src/composer.rs b/crates/wasm-compose/src/composer.rs
index b54d5787..582977c5 100644
--- a/crates/wasm-compose/src/composer.rs
+++ b/crates/wasm-compose/src/composer.rs
@@ -8,11 +8,11 @@ use crate::{
         InstanceId,
     },
 };
-use anyhow::{anyhow, bail, Context, Result};
+use anyhow::{anyhow, bail, Result};
 use indexmap::IndexMap;
-use std::{collections::VecDeque, ffi::OsStr, path::Path};
+use std::{collections::VecDeque, path::Path};
 use wasmparser::{
-    types::{ComponentEntityType, TypeId, TypesRef},
+    types::{ComponentInstanceType, TypesRef},
     ComponentExternalKind, ComponentTypeRef,
 };
 
@@ -28,33 +28,16 @@ pub(crate) struct InstanceImportRef {
     pub(crate) import: ImportIndex,
 }
 
-/// Represents the kind of dependency to process.
-enum DependencyKind {
-    /// The dependency is on a configured instance.
-    Instance {
-        /// The name of the instance from the instantiation argument.
-        instance: String,
-        /// The name of the export on the instance to use as the instantiation argument.
-        export: Option<String>,
-    },
-
-    /// The dependency is on a definition component.
-    Definition {
-        /// The index into `definitions` for the dependency.
-        index: usize,
-        /// The export on the definition component to use as the instantiation argument.
-        export: ExportIndex,
-    },
-}
-
 /// An instance dependency to process in the composer.
 struct Dependency {
     /// The index into `instances` for the dependent instance.
     dependent: usize,
     /// The instance import reference on the dependent instance.
     import: InstanceImportRef,
-    /// The kind of dependency.
-    kind: DependencyKind,
+    /// The name of the instance from the instantiation argument.
+    instance: String,
+    /// The name of the export on the instance to use as the instantiation argument.
+    export: Option<String>,
 }
 
 /// A composition graph builder that wires up instances from components
@@ -66,8 +49,6 @@ struct CompositionGraphBuilder<'a> {
     graph: CompositionGraph<'a>,
     /// A map from instance name to graph instance id.
     instances: IndexMap<String, InstanceId>,
-    /// The definition components in the graph.
-    definitions: Vec<(ComponentId, Option<InstanceId>)>,
 }
 
 impl<'a> CompositionGraphBuilder<'a> {
@@ -75,28 +56,10 @@ impl<'a> CompositionGraphBuilder<'a> {
         let mut graph = CompositionGraph::new();
         graph.add_component(Component::from_file(ROOT_COMPONENT_NAME, root_path)?)?;
 
-        let definitions = config
-            .definitions
-            .iter()
-            .map(|path| {
-                let name = path.file_stem().and_then(OsStr::to_str).with_context(|| {
-                    format!(
-                        "invalid definition component path `{path}`",
-                        path = path.display()
-                    )
-                })?;
-
-                let component = Component::from_file(name, config.dir.join(path))?;
-
-                Ok((graph.add_component(component)?, None))
-            })
-            .collect::<Result<_>>()?;
-
         Ok(Self {
             config,
             graph,
             instances: Default::default(),
-            definitions,
         })
     }
 
@@ -161,7 +124,7 @@ impl<'a> CompositionGraphBuilder<'a> {
 
     /// Instantiates an instance with the given name into the graph.
     ///
-    /// Returns an index into `instances` for the instance being instantiated.
+    /// Returns an index into `dependencies` for the instance being instantiated.
     ///
     /// Returns `Ok(None)` if a component to instantiate cannot be found.
     fn instantiate(&mut self, name: &str, component_name: &str) -> Result<Option<(usize, bool)>> {
@@ -198,7 +161,7 @@ impl<'a> CompositionGraphBuilder<'a> {
         instance: usize,
         dependent: usize,
         arg_name: &str,
-        ty: TypeId,
+        ty: &ComponentInstanceType,
         types: TypesRef,
     ) -> Result<Option<ExportIndex>> {
         let (instance_name, instance_id) = self.instances.get_index(instance).unwrap();
@@ -241,24 +204,19 @@ impl<'a> CompositionGraphBuilder<'a> {
         instance: usize,
         dependent_path: &Path,
         arg_name: &str,
-        ty: TypeId,
+        ty: &ComponentInstanceType,
         types: TypesRef,
     ) -> Result<ExportIndex> {
         let (_, instance_id) = self.instances.get_index(instance).unwrap();
         let (_, component) = self.graph.get_component_of_instance(*instance_id).unwrap();
         match component.export_by_name(export) {
-            Some((export_index, kind, index)) if kind == ComponentExternalKind::Instance => {
-                let export_ty = component.types.component_instance_at(index);
-                if !ComponentEntityType::is_subtype_of(
-                    &ComponentEntityType::Instance(export_ty),
-                    component.types(),
-                    &ComponentEntityType::Instance(ty),
-                    types,
-                ) {
+            Some((export_index, _, kind, index)) if kind == ComponentExternalKind::Instance => {
+                let export_ty = component.types.component_instance_at(index).unwrap();
+                if !ComponentInstanceType::is_subtype_of(export_ty, component.types(), ty, types) {
                     bail!("component `{path}` exports an instance named `{export}` but it is not compatible with import `{arg_name}` of component `{dependent_path}`",
-                        path = component.path().unwrap().display(),
-                        dependent_path = dependent_path.display(),
-                    )
+                            path = component.path().unwrap().display(),
+                            dependent_path = dependent_path.display(),
+                        )
                 }
 
                 Ok(export_index)
@@ -271,94 +229,57 @@ impl<'a> CompositionGraphBuilder<'a> {
     }
 
     /// Resolves an import instance reference.
-    fn resolve_import_ref(&self, r: InstanceImportRef) -> (&Component, &str, TypeId) {
+    fn resolve_import_ref(
+        &self,
+        r: InstanceImportRef,
+    ) -> (&Component, &str, &ComponentInstanceType) {
         let component = self.graph.get_component(r.component).unwrap();
-        let (name, ty) = component.import(r.import).unwrap();
+        let (name, _, ty) = component.import(r.import).unwrap();
         match ty {
-            ComponentTypeRef::Instance(index) => {
-                (component, name, component.types.component_type_at(index))
-            }
+            ComponentTypeRef::Instance(index) => (
+                component,
+                name,
+                component
+                    .types
+                    .type_at(index, false)
+                    .unwrap()
+                    .as_component_instance_type()
+                    .unwrap(),
+            ),
             _ => unreachable!("should not have an instance import ref to a non-instance import"),
         }
     }
 
     /// Processes a dependency in the graph.
-    ///
-    /// Returns `Ok(Some(index))` if the dependency resulted in a new dependency instance being created.
-    fn process_dependency(&mut self, dependency: Dependency) -> Result<Option<usize>> {
-        match dependency.kind {
-            DependencyKind::Instance { instance, export } => self.process_instance_dependency(
-                dependency.dependent,
-                dependency.import,
-                &instance,
-                export.as_deref(),
-            ),
-            DependencyKind::Definition { index, export } => {
-                // The dependency is on a definition component, so we simply connect the dependent to the definition's export
-                let (component_id, instance_id) = &mut self.definitions[index];
-                let instance_id = *instance_id
-                    .get_or_insert_with(|| self.graph.instantiate(*component_id).unwrap());
-
-                self.graph
-                    .connect(
-                        instance_id,
-                        Some(export),
-                        self.instances[dependency.dependent],
-                        dependency.import.import,
-                    )
-                    .with_context(|| {
-                        let name = self.instances.get_index(dependency.dependent).unwrap().0;
-                        format!(
-                            "failed to connect instance `{name}` to definition component `{path}`",
-                            path = self
-                                .graph
-                                .get_component(*component_id)
-                                .unwrap()
-                                .path()
-                                .unwrap()
-                                .display(),
-                        )
-                    })?;
-
-                // No new dependency instance was created
-                Ok(None)
-            }
-        }
-    }
-
-    fn process_instance_dependency(
-        &mut self,
-        dependent_index: usize,
-        import: InstanceImportRef,
-        instance: &str,
-        export: Option<&str>,
-    ) -> Result<Option<usize>> {
-        let name = self.config.dependency_name(instance);
+    fn process_dependency(&mut self, dependency: Dependency) -> Result<Option<(usize, bool)>> {
+        let name = self.config.dependency_name(&dependency.instance);
 
         log::info!(
             "processing dependency `{name}` from instance `{dependent_name}` to instance `{instance}`",
-            dependent_name = self.instances.get_index(dependent_index).unwrap().0,
+            dependent_name = self.instances.get_index(dependency.dependent).unwrap().0,
+            instance = dependency.instance
         );
 
-        match self.instantiate(instance, name)? {
+        match self.instantiate(&dependency.instance, name)? {
             Some((instance, existing)) => {
-                let (dependent, import_name, import_type) = self.resolve_import_ref(import);
+                let (dependent, import_name, import_type) =
+                    self.resolve_import_ref(dependency.import);
 
-                let export = match export {
+                let export = match &dependency.export {
                     Some(export) => Some(self.resolve_export_index(
                         export,
                         instance,
                         dependent.path().unwrap(),
                         import_name,
                         import_type,
-                        dependent.types(),
+                        dependent.types.as_ref(),
                     )?),
                     None => self.find_compatible_instance(
                         instance,
-                        dependent_index,
+                        dependency.dependent,
                         import_name,
                         import_type,
-                        dependent.types(),
+                        dependent.types.as_ref(),
                     )?,
                 };
 
@@ -366,18 +287,14 @@ impl<'a> CompositionGraphBuilder<'a> {
                 self.graph.connect(
                     self.instances[instance],
                     export,
-                    self.instances[dependent_index],
-                    import.import,
+                    self.instances[dependency.dependent],
+                    dependency.import.import,
                 )?;
 
-                if existing {
-                    return Ok(None);
-                }
-
-                Ok(Some(instance))
+                Ok(Some((instance, existing)))
             }
             None => {
-                if let Some(export) = export {
+                if let Some(export) = &dependency.export {
                     bail!("an explicit export `{export}` cannot be specified for imported instance `{name}`");
                 }
                 Ok(None)
@@ -388,12 +305,12 @@ impl<'a> CompositionGraphBuilder<'a> {
     /// Push dependencies of the given instance to the dependency queue.
     fn push_dependencies(&self, instance: usize, queue: &mut VecDeque<Dependency>) -> Result<()> {
         let (instance_name, instance_id) = self.instances.get_index(instance).unwrap();
-        let instantiation = self.config.instantiations.get(instance_name);
+        let config = self.config.instantiations.get(instance_name);
         let (component_id, component) = self.graph.get_component_of_instance(*instance_id).unwrap();
         let count = queue.len();
 
         // Push a dependency for every instance import
-        'outer: for (import, name, ty) in component.imports() {
+        for (import, name, _, ty) in component.imports() {
             match ty {
                 ComponentTypeRef::Instance(_) => {}
                 _ => bail!(
@@ -404,51 +321,23 @@ impl<'a> CompositionGraphBuilder<'a> {
 
             log::debug!("adding dependency for argument `{name}` (import index {import}) from instance `{instance_name}` to the queue", import = import.0);
 
-            // Search for a matching definition export for this import
-            for (index, (def_component_id, _)) in self.definitions.iter().enumerate() {
-                let def_component = self.graph.get_component(*def_component_id).unwrap();
-
-                match def_component.export_by_name(name) {
-                    Some((export, ComponentExternalKind::Instance, _)) => {
-                        log::debug!(
-                            "found matching instance export `{name}` in definition component `{path}`",
-                            path = def_component.path().unwrap().display()
-                        );
-
-                        queue.push_back(Dependency {
-                            dependent: instance,
-                            import: InstanceImportRef {
-                                component: component_id,
-                                import,
-                            },
-                            kind: DependencyKind::Definition { index, export },
-                        });
-
-                        continue 'outer;
-                    }
-                    _ => continue,
-                }
-            }
-
-            let arg = instantiation.and_then(|c| c.arguments.get(name));
+            let arg = config.and_then(|c| c.arguments.get(name));
             queue.push_back(Dependency {
                 dependent: instance,
                 import: InstanceImportRef {
                     component: component_id,
                     import,
                 },
-                kind: DependencyKind::Instance {
-                    instance: arg
-                        .map(|arg| arg.instance.clone())
-                        .unwrap_or_else(|| name.to_string()),
-                    export: arg.and_then(|arg| arg.export.clone()),
-                },
+                instance: arg
+                    .map(|arg| arg.instance.clone())
+                    .unwrap_or_else(|| name.to_string()),
+                export: arg.and_then(|arg| arg.export.clone()),
             });
         }
 
         // Ensure every explicit argument is a valid import name
-        if let Some(instantiation) = instantiation {
-            for arg in instantiation.arguments.keys() {
+        if let Some(config) = config {
+            for arg in config.arguments.keys() {
                 if !component.imports.contains_key(arg) {
                     bail!(
                         "component `{path}` has no import named `{arg}`",
@@ -484,8 +373,11 @@ impl<'a> CompositionGraphBuilder<'a> {
 
         // Process all remaining dependencies in the queue
         while let Some(dependency) = queue.pop_front() {
-            if let Some(instance) = self.process_dependency(dependency)? {
-                self.push_dependencies(instance, &mut queue)?;
+            if let Some((instance, existing)) = self.process_dependency(dependency)? {
+                // Add dependencies only for new instances in the graph
+                if !existing {
+                    self.push_dependencies(instance, &mut queue)?;
+                }
             }
         }
 
diff --git a/crates/wasm-compose/src/config.rs b/crates/wasm-compose/src/config.rs
index 82029a7b..547dff91 100644
--- a/crates/wasm-compose/src/config.rs
+++ b/crates/wasm-compose/src/config.rs
@@ -77,10 +77,6 @@ pub struct Config {
     #[serde(skip)]
     pub dir: PathBuf,
 
-    /// Components whose exports define import dependencies to fulfill from.
-    #[serde(default)]
-    pub definitions: Vec<PathBuf>,
-
     /// The paths to search when automatically resolving dependencies.
     ///
     /// The config directory is always searched first.
diff --git a/crates/wasm-compose/src/encoding.rs b/crates/wasm-compose/src/encoding.rs
index 8021a1f6..af84e892 100644
--- a/crates/wasm-compose/src/encoding.rs
+++ b/crates/wasm-compose/src/encoding.rs
@@ -12,8 +12,7 @@ use std::{
 };
 use wasm_encoder::*;
 use wasmparser::{
-    names::KebabString,
-    types::{ComponentEntityType, Type, TypeId, Types},
+    types::{ComponentEntityType, KebabString, Type, TypeId, Types},
     ComponentExternalKind,
 };
 
@@ -132,20 +131,20 @@ impl<'a> TypeEncoder<'a> {
 
     pub fn component<I, E>(&self, imports: I, exports: E) -> ComponentType
     where
-        I: IntoIterator<Item = (&'a str, wasmparser::types::ComponentEntityType)>,
-        E: IntoIterator<Item = (&'a str, wasmparser::types::ComponentEntityType)>,
+        I: IntoIterator<Item = (&'a str, &'a str, wasmparser::types::ComponentEntityType)>,
+        E: IntoIterator<Item = (&'a str, &'a str, wasmparser::types::ComponentEntityType)>,
     {
         let mut encoded = ComponentType::new();
         let mut types = TypeMap::new();
 
-        for (name, ty) in imports {
+        for (name, url, ty) in imports {
             let ty = self.component_entity_type(&mut encoded, &mut types, ty);
-            encoded.import(name, ty);
+            encoded.import(name, url, ty);
         }
 
-        for (name, ty) in exports {
-            let export = self.export(ty, &mut encoded, &mut types);
-            encoded.export(name, export);
+        for (name, url, ty) in exports {
+            let ty = self.component_entity_type(&mut encoded, &mut types, ty);
+            encoded.export(name, url, ty);
         }
 
         encoded
@@ -153,14 +152,14 @@ impl<'a> TypeEncoder<'a> {
 
     pub fn instance<E>(&self, exports: E) -> InstanceType
     where
-        E: IntoIterator<Item = (&'a str, wasmparser::types::ComponentEntityType)>,
+        E: IntoIterator<Item = (&'a str, &'a str, wasmparser::types::ComponentEntityType)>,
     {
         let mut encoded = InstanceType::new();
         let mut types = TypeMap::new();
 
-        for (name, ty) in exports {
-            let export = self.export(ty, &mut encoded, &mut types);
-            encoded.export(name, export);
+        for (name, url, ty) in exports {
+            let ty = self.component_entity_type(&mut encoded, &mut types, ty);
+            encoded.export(name, url, ty);
         }
 
         encoded
@@ -195,11 +194,11 @@ impl<'a> TypeEncoder<'a> {
     ) -> EntityType {
         match ty {
             wasmparser::types::EntityType::Func(id) => {
-                let ty = &self.0[id];
+                let ty = self.0.type_from_id(id).unwrap();
                 let idx = match types.entry(PtrKey(ty)) {
                     Entry::Occupied(e) => *e.get(),
                     Entry::Vacant(e) => {
-                        let ty = ty.unwrap_func();
+                        let ty = ty.as_func_type().unwrap();
                         let index = encodable.type_count();
                         encodable.ty().function(
                             ty.params().iter().copied().map(Self::val_type),
@@ -214,11 +213,11 @@ impl<'a> TypeEncoder<'a> {
             wasmparser::types::EntityType::Memory(ty) => EntityType::Memory(Self::memory_type(ty)),
             wasmparser::types::EntityType::Global(ty) => EntityType::Global(Self::global_type(ty)),
             wasmparser::types::EntityType::Tag(id) => {
-                let ty = &self.0[id];
+                let ty = self.0.type_from_id(id).unwrap();
                 let idx = match types.entry(PtrKey(ty)) {
                     Entry::Occupied(e) => *e.get(),
                     Entry::Vacant(e) => {
-                        let ty = ty.unwrap_func();
+                        let ty = ty.as_func_type().unwrap();
                         let index = encodable.type_count();
                         encodable.ty().function(
                             ty.params().iter().copied().map(Self::val_type),
@@ -252,7 +251,7 @@ impl<'a> TypeEncoder<'a> {
                 ComponentTypeRef::Value(self.component_val_type(encodable, types, ty))
             }
             wasmparser::types::ComponentEntityType::Type { created, .. } => {
-                ComponentTypeRef::Type(TypeBounds::Eq(self.ty(encodable, types, created)))
+                ComponentTypeRef::Type(TypeBounds::Eq, self.ty(encodable, types, created))
             }
             wasmparser::types::ComponentEntityType::Instance(id) => {
                 ComponentTypeRef::Instance(self.component_instance_type(encodable, types, id))
@@ -276,19 +275,11 @@ impl<'a> TypeEncoder<'a> {
 
     fn ref_type(ty: wasmparser::RefType) -> RefType {
         RefType {
-            nullable: ty.is_nullable(),
-            heap_type: match ty.heap_type() {
+            nullable: ty.nullable,
+            heap_type: match ty.heap_type {
                 wasmparser::HeapType::Func => HeapType::Func,
                 wasmparser::HeapType::Extern => HeapType::Extern,
-                wasmparser::HeapType::Any => HeapType::Any,
-                wasmparser::HeapType::None => HeapType::None,
-                wasmparser::HeapType::NoExtern => HeapType::NoExtern,
-                wasmparser::HeapType::NoFunc => HeapType::NoFunc,
-                wasmparser::HeapType::Eq => HeapType::Eq,
-                wasmparser::HeapType::Struct => HeapType::Struct,
-                wasmparser::HeapType::Array => HeapType::Array,
-                wasmparser::HeapType::I31 => HeapType::I31,
-                wasmparser::HeapType::Indexed(i) => HeapType::Indexed(i),
+                wasmparser::HeapType::TypedFunc(i) => HeapType::TypedFunc(i.into()),
             },
         }
     }
@@ -341,11 +332,11 @@ impl<'a> TypeEncoder<'a> {
         types: &mut TypeMap<'a>,
         id: TypeId,
     ) -> u32 {
-        let ty = &self.0[id];
+        let ty = self.0.type_from_id(id).unwrap();
         match types.entry(PtrKey(ty)) {
             Entry::Occupied(e) => *e.get(),
             Entry::Vacant(e) => {
-                let ty = ty.unwrap_module();
+                let ty = ty.as_module_type().unwrap();
 
                 let module = self.module(
                     ty.imports
@@ -367,12 +358,14 @@ impl<'a> TypeEncoder<'a> {
         types: &mut TypeMap<'a>,
         id: TypeId,
     ) -> u32 {
-        let ty = &self.0[id];
+        let ty = self.0.type_from_id(id).unwrap();
         match types.entry(PtrKey(ty)) {
             Entry::Occupied(e) => *e.get(),
             Entry::Vacant(e) => {
-                let ty = ty.unwrap_component_instance();
-                let instance = self.instance(ty.exports.iter().map(|(n, t)| (n.as_str(), *t)));
+                let ty = ty.as_component_instance_type().unwrap();
+                let instance = self.instance(ty.exports(self.0.as_ref()).map(|(n, u, t)| {
+                    (n.as_str(), u.as_ref().map(|u| u.as_str()).unwrap_or(""), t)
+                }));
                 let index = encodable.type_count();
                 encodable.ty().instance(&instance);
                 *e.insert(index)
@@ -386,15 +379,19 @@ impl<'a> TypeEncoder<'a> {
         types: &mut TypeMap<'a>,
         id: TypeId,
     ) -> u32 {
-        let ty = &self.0[id];
+        let ty = self.0.type_from_id(id).unwrap();
         match types.entry(PtrKey(ty)) {
             Entry::Occupied(e) => *e.get(),
             Entry::Vacant(e) => {
-                let ty = ty.unwrap_component();
+                let ty = ty.as_component_type().unwrap();
 
                 let component = self.component(
-                    ty.imports.iter().map(|(n, t)| (n.as_str(), *t)),
-                    ty.exports.iter().map(|(n, t)| (n.as_str(), *t)),
+                    ty.imports.iter().map(|(n, (u, t))| {
+                        (n.as_str(), u.as_ref().map(|u| u.as_str()).unwrap_or(""), *t)
+                    }),
+                    ty.exports.iter().map(|(n, (u, t))| {
+                        (n.as_str(), u.as_ref().map(|u| u.as_str()).unwrap_or(""), *t)
+                    }),
                 );
 
                 let index = encodable.type_count();
@@ -410,12 +407,12 @@ impl<'a> TypeEncoder<'a> {
         types: &mut TypeMap<'a>,
         id: TypeId,
     ) -> u32 {
-        let ty = &self.0[id];
+        let ty = self.0.type_from_id(id).unwrap();
         if let Some(idx) = types.get(&PtrKey(ty)) {
             return *idx;
         }
 
-        let func_ty = ty.unwrap_component_func();
+        let func_ty = ty.as_component_func_type().unwrap();
 
         let params = func_ty
             .params
@@ -459,16 +456,21 @@ impl<'a> TypeEncoder<'a> {
     }
 
     fn ty(&self, encodable: &mut impl Encodable, types: &mut TypeMap<'a>, id: TypeId) -> u32 {
-        match &self.0[id] {
-            Type::Sub(_) | Type::Instance(_) => {
+        let ty = self.0.type_from_id(id).unwrap();
+
+        match ty {
+            wasmparser::types::Type::Func(_) | wasmparser::types::Type::Instance(_) | wasmparser::types::Type::Cont(_) => {
                 unreachable!()
             }
-            Type::Module(_) => self.module_type(encodable, types, id),
-            Type::Component(_) => self.component_type(encodable, types, id),
-            Type::ComponentInstance(_) => self.component_instance_type(encodable, types, id),
-            Type::ComponentFunc(_) => self.component_func_type(encodable, types, id),
-            Type::Defined(_) => self.defined_type(encodable, types, id),
-            Type::Resource(_) => unimplemented!(),
+            wasmparser::types::Type::Module(_) => self.module_type(encodable, types, id),
+            wasmparser::types::Type::Component(_) => self.component_type(encodable, types, id),
+            wasmparser::types::Type::ComponentInstance(_) => {
+                self.component_instance_type(encodable, types, id)
+            }
+            wasmparser::types::Type::ComponentFunc(_) => {
+                self.component_func_type(encodable, types, id)
+            }
+            wasmparser::types::Type::Defined(_) => self.defined_type(encodable, types, id),
         }
     }
 
@@ -494,12 +496,12 @@ impl<'a> TypeEncoder<'a> {
         types: &mut TypeMap<'a>,
         id: TypeId,
     ) -> u32 {
-        let ty = &self.0[id];
+        let ty = self.0.type_from_id(id).unwrap();
         if let Some(idx) = types.get(&PtrKey(ty)) {
             return *idx;
         }
 
-        let defined_ty = ty.unwrap_defined();
+        let defined_ty = ty.as_defined_type().unwrap();
 
         let index = match defined_ty {
             wasmparser::types::ComponentDefinedType::Primitive(ty) => {
@@ -527,18 +529,6 @@ impl<'a> TypeEncoder<'a> {
             wasmparser::types::ComponentDefinedType::Result { ok, err } => {
                 self.result(encodable, types, *ok, *err)
             }
-            wasmparser::types::ComponentDefinedType::Own(id) => {
-                let i = self.defined_type(encodable, types, *id);
-                let index = encodable.type_count();
-                encodable.ty().defined_type().own(i);
-                index
-            }
-            wasmparser::types::ComponentDefinedType::Borrow(id) => {
-                let i = self.defined_type(encodable, types, *id);
-                let index = encodable.type_count();
-                encodable.ty().defined_type().borrow(i);
-                index
-            }
         };
 
         types.insert(PtrKey(ty), index);
@@ -676,27 +666,6 @@ impl<'a> TypeEncoder<'a> {
         encodable.ty().defined_type().result(ok, err);
         index
     }
-
-    fn export(
-        &self,
-        export: ComponentEntityType,
-        encoded: &mut impl Encodable,
-        types: &mut TypeMap<'a>,
-    ) -> ComponentTypeRef {
-        // Check if the export is a type; if so, we need to update the index of the
-        // type to point to the export instead of the original definition
-        let id = match export {
-            ComponentEntityType::Type { created: id, .. } => Some(id),
-            _ => None,
-        };
-        let export = self.component_entity_type(encoded, types, export);
-        if let Some(id) = id {
-            // Update the index in the type map to point to this export
-            let ty = &self.0[id];
-            types.insert(PtrKey(ty), encoded.type_count());
-        }
-        export
-    }
 }
 
 /// Represents an instance index in a composition graph.
@@ -713,13 +682,24 @@ enum ArgumentImportKind<'a> {
     /// Instances are unioned together to form a single instance to
     /// import that will satisfy all instantiation arguments that
     /// reference the import.
-    Instance(IndexMap<&'a str, (&'a crate::graph::Component<'a>, ComponentEntityType)>),
+    Instance(
+        IndexMap<
+            &'a str,
+            (
+                &'a str,
+                &'a crate::graph::Component<'a>,
+                ComponentEntityType,
+            ),
+        >,
+    ),
 }
 
 /// Represents an import for an instantiation argument.
 struct ArgumentImport<'a> {
     // The name of the import.
     name: &'a str,
+    /// The URL of the import.
+    url: &'a str,
     /// The kind of import.
     kind: ArgumentImportKind<'a>,
     /// The instances that will use the import for an argument.
@@ -734,14 +714,24 @@ impl ArgumentImport<'_> {
         // If the existing import is an instance, convert this argument import to
         // a merged instance import.
         if let ArgumentImportKind::Item(component, ComponentEntityType::Instance(id)) = &self.kind {
-            let exports = component.types[*id]
-                .unwrap_component_instance()
-                .exports
-                .iter();
+            let exports = component
+                .types
+                .type_from_id(*id)
+                .unwrap()
+                .as_component_instance_type()
+                .unwrap()
+                .exports(component.types.as_ref());
 
             let mut map = IndexMap::with_capacity(exports.len());
-            for (name, ty) in exports {
-                map.insert(name.as_str(), (*component, *ty));
+            for (name, url, ty) in exports {
+                map.insert(
+                    name.as_ref(),
+                    (
+                        url.as_ref().map(|u| u.as_str()).unwrap_or(""),
+                        *component,
+                        ty,
+                    ),
+                );
             }
 
             self.kind = ArgumentImportKind::Instance(map);
@@ -757,19 +747,31 @@ impl ArgumentImport<'_> {
                 ArgumentImportKind::Instance(exports),
                 ArgumentImportKind::Item(new_component, ComponentEntityType::Instance(id)),
             ) => {
-                for (name, new_type) in new_component.types[id]
-                    .unwrap_component_instance()
-                    .exports
-                    .iter()
+                if arg.url != self.url {
+                    bail!(
+                        "cannot import instance with name `{name}` because import URL `{url}` conflicts with `{other}`",
+                        name = self.name,
+                        url = self.url,
+                        other = arg.url,
+                    );
+                }
+
+                for (name, url, new_type) in new_component
+                    .types
+                    .type_from_id(id)
+                    .unwrap()
+                    .as_component_instance_type()
+                    .unwrap()
+                    .exports(new_component.types.as_ref())
                 {
-                    match exports.entry(name.as_str()) {
+                    match exports.entry(name) {
                         indexmap::map::Entry::Occupied(mut e) => {
-                            let (existing_component, existing_type) = e.get_mut();
+                            let (_, existing_component, existing_type) = e.get_mut();
                             match Self::compatible_type(
                                 existing_component,
                                 *existing_type,
                                 new_component,
-                                *new_type,
+                                new_type,
                             ) {
                                 Some((c, ty)) => {
                                     *existing_component = c;
@@ -784,7 +786,11 @@ impl ArgumentImport<'_> {
                             }
                         }
                         indexmap::map::Entry::Vacant(e) => {
-                            e.insert((new_component, *new_type));
+                            e.insert((
+                                url.as_ref().map(|u| u.as_str()).unwrap_or(""),
+                                new_component,
+                                new_type,
+                            ));
                         }
                     }
                 }
@@ -810,6 +816,16 @@ impl ArgumentImport<'_> {
                     new_type,
                 ) {
                     Some((c, ty)) => {
+                        if arg.url != self.url {
+                            bail!(
+                                "cannot import {ty} with name `{name}` because import URL `{url}` conflicts with `{other}`",
+                                ty = type_desc(new_type),
+                                name = self.name,
+                                url = self.url,
+                                other = arg.url
+                            );
+                        }
+
                         *existing_component = c;
                         *existing_type = ty;
                     }
@@ -911,15 +927,16 @@ impl<'a> ImportMap<'a> {
             let instance_index = InstanceIndex(instance_index);
 
             // Import any unconnected instantiation arguments for the instance
-            for (import_index, name, _) in entry.component.imports() {
+            for (import_index, name, _, _) in entry.component.imports() {
                 if instance.connected.contains(&import_index) {
                     continue;
                 }
 
-                let (_, ty) = entry.component.import_entity_type(import_index).unwrap();
+                let (_, url, ty) = entry.component.import_entity_type(import_index).unwrap();
 
                 let arg = ArgumentImport {
                     name,
+                    url,
                     kind: ArgumentImportKind::Item(&entry.component, ty),
                     instances: smallvec::smallvec![(instance_index, import_index)],
                 };
@@ -1037,7 +1054,7 @@ impl<'a> CompositionGraphEncoder<'a> {
         for (name, entry) in imports.0 {
             match entry {
                 ImportMapEntry::Component(component) => {
-                    self.encode_component_import(encoded, name.as_ref(), component);
+                    self.encode_component_import(encoded, name.as_ref(), "", component);
                 }
                 ImportMapEntry::Argument(arg) => {
                     let index = match arg.kind {
@@ -1045,11 +1062,12 @@ impl<'a> CompositionGraphEncoder<'a> {
                             encoded,
                             &mut type_map,
                             name.as_ref(),
+                            arg.url,
                             component,
                             ty,
                         ),
                         ArgumentImportKind::Instance(exports) => {
-                            self.encode_instance_import(encoded, name.as_ref(), exports)
+                            self.encode_instance_import(encoded, name.as_ref(), arg.url, exports)
                         }
                     };
 
@@ -1066,10 +1084,11 @@ impl<'a> CompositionGraphEncoder<'a> {
         &mut self,
         encoded: &mut Component,
         name: &str,
+        url: &str,
         component: &'a crate::graph::Component,
     ) -> u32 {
         let type_index = self.define_component_type(encoded, component);
-        let index = self.import(encoded, name, ComponentTypeRef::Component(type_index));
+        let index = self.import(encoded, name, url, ComponentTypeRef::Component(type_index));
 
         assert!(self
             .encoded_components
@@ -1084,6 +1103,7 @@ impl<'a> CompositionGraphEncoder<'a> {
         encoded: &mut Component,
         type_map: &mut TypeMap<'a>,
         name: &str,
+        url: &str,
         component: &'a crate::graph::Component,
         ty: ComponentEntityType,
     ) -> u32 {
@@ -1108,21 +1128,22 @@ impl<'a> CompositionGraphEncoder<'a> {
             self.types += type_section.len();
         }
 
-        self.import(encoded, name, ty)
+        self.import(encoded, name, url, ty)
     }
 
     fn encode_instance_import(
         &mut self,
         encoded: &mut Component,
         name: &str,
-        exports: IndexMap<&'a str, (&'a crate::graph::Component, ComponentEntityType)>,
+        url: &str,
+        exports: IndexMap<&'a str, (&'a str, &'a crate::graph::Component, ComponentEntityType)>,
     ) -> u32 {
         let mut instance_type = InstanceType::new();
         let mut types = TypeMap::new();
-        for (name, (component, ty)) in exports {
+        for (name, (url, component, ty)) in exports {
             let encoder = TypeEncoder::new(&component.types);
-            let export = encoder.export(ty, &mut instance_type, &mut types);
-            instance_type.export(name, export);
+            let ty = encoder.component_entity_type(&mut instance_type, &mut types, ty);
+            instance_type.export(name, url, ty);
         }
 
         let index = self.types;
@@ -1131,7 +1152,7 @@ impl<'a> CompositionGraphEncoder<'a> {
         encoded.section(&type_section);
         self.types += 1;
 
-        self.import(encoded, name, ComponentTypeRef::Instance(index))
+        self.import(encoded, name, url, ComponentTypeRef::Instance(index))
     }
 
     fn encode_instantiations(&mut self, encoded: &mut Component) -> Result<()> {
@@ -1165,7 +1186,7 @@ impl<'a> CompositionGraphEncoder<'a> {
 
         let mut alias_section = ComponentAliasSection::new();
         let mut export_section = ComponentExportSection::new();
-        for (export_index, export_name, kind, _) in entry.component.exports() {
+        for (export_index, export_name, export_url, kind, _) in entry.component.exports() {
             let kind = match kind {
                 ComponentExternalKind::Module => ComponentExportKind::Module,
                 ComponentExternalKind::Func => ComponentExportKind::Func,
@@ -1189,7 +1210,7 @@ impl<'a> CompositionGraphEncoder<'a> {
                 }
             };
 
-            export_section.export(export_name, kind, index, None);
+            export_section.export(export_name, export_url, kind, index, None);
         }
 
         if !alias_section.is_empty() {
@@ -1314,10 +1335,11 @@ impl<'a> CompositionGraphEncoder<'a> {
 
             for (import_index, export_index) in map {
                 // Check to see if we need to alias the item from the source instance
-                let (name, ty) = component.import(*import_index).unwrap();
+                let (name, _, ty) = component.import(*import_index).unwrap();
                 let index = match export_index {
                     Some(export_index) => {
-                        let (export_name, _, _) = source_component.export(*export_index).unwrap();
+                        let (export_name, _, _, _) =
+                            source_component.export(*export_index).unwrap();
                         match self.aliases.get(&(source_id, *export_index)) {
                             Some(index) => *index,
                             None => {
@@ -1339,7 +1361,7 @@ impl<'a> CompositionGraphEncoder<'a> {
         }
 
         // Finally, add any instantiation arguments that are being imported
-        for (i, (name, ty)) in component.imports.iter().enumerate() {
+        for (i, (name, (_, ty))) in component.imports.iter().enumerate() {
             let import_index = ImportIndex(i);
             if instance.connected.contains(&import_index) {
                 continue;
@@ -1352,12 +1374,18 @@ impl<'a> CompositionGraphEncoder<'a> {
         args
     }
 
-    fn import(&mut self, encoded: &mut Component, name: &str, ty: ComponentTypeRef) -> u32 {
+    fn import(
+        &mut self,
+        encoded: &mut Component,
+        name: &str,
+        url: &str,
+        ty: ComponentTypeRef,
+    ) -> u32 {
         let (desc, count) = match ty {
             ComponentTypeRef::Module(_) => ("module", &mut self.modules),
             ComponentTypeRef::Func(_) => ("function", &mut self.funcs),
             ComponentTypeRef::Value(_) => ("value", &mut self.values),
-            ComponentTypeRef::Type(_) => ("type", &mut self.types),
+            ComponentTypeRef::Type(_, _) => ("type", &mut self.types),
             ComponentTypeRef::Instance(_) => ("instance", &mut self.instances),
             ComponentTypeRef::Component(_) => ("component", &mut self.components),
         };
@@ -1365,7 +1393,7 @@ impl<'a> CompositionGraphEncoder<'a> {
         log::debug!("importing {desc} with `{name}` (encoded index {count}) in composed component");
 
         let mut import_section = ComponentImportSection::new();
-        import_section.import(name, ty);
+        import_section.import(name, url, ty);
         encoded.section(&import_section);
 
         let index = *count;
diff --git a/crates/wasm-compose/src/graph.rs b/crates/wasm-compose/src/graph.rs
index 787d7946..32626d0d 100644
--- a/crates/wasm-compose/src/graph.rs
+++ b/crates/wasm-compose/src/graph.rs
@@ -10,7 +10,7 @@ use std::{
     sync::atomic::{AtomicUsize, Ordering},
 };
 use wasmparser::{
-    types::{ComponentEntityType, TypeId, Types, TypesRef},
+    types::{ComponentEntityType, ComponentInstanceType, Types, TypesRef},
     Chunk, ComponentExternalKind, ComponentTypeRef, Encoding, Parser, Payload, ValidPayload,
     Validator, WasmFeatures,
 };
@@ -37,9 +37,9 @@ pub struct Component<'a> {
     /// The type information of the component.
     pub(crate) types: Types,
     /// The import map of the component.
-    pub(crate) imports: IndexMap<String, ComponentTypeRef>,
+    pub(crate) imports: IndexMap<String, (String, ComponentTypeRef)>,
     /// The export map of the component.
-    pub(crate) exports: IndexMap<String, (ComponentExternalKind, u32)>,
+    pub(crate) exports: IndexMap<String, (String, ComponentExternalKind, u32)>,
 }
 
 impl<'a> Component<'a> {
@@ -122,25 +122,19 @@ impl<'a> Component<'a> {
                                 Payload::ComponentImportSection(s) => {
                                     for import in s {
                                         let import = import?;
-                                        let name = match import.name {
-                                            wasmparser::ComponentExternName::Kebab(s)
-                                            | wasmparser::ComponentExternName::Interface(s) => {
-                                                s.to_string()
-                                            }
-                                        };
-                                        imports.insert(name, import.ty);
+                                        imports.insert(
+                                            import.name.to_string(),
+                                            (import.url.to_string(), import.ty),
+                                        );
                                     }
                                 }
                                 Payload::ComponentExportSection(s) => {
                                     for export in s {
                                         let export = export?;
-                                        let name = match export.name {
-                                            wasmparser::ComponentExternName::Kebab(s)
-                                            | wasmparser::ComponentExternName::Interface(s) => {
-                                                s.to_string()
-                                            }
-                                        };
-                                        exports.insert(name, (export.kind, export.index));
+                                        exports.insert(
+                                            export.name.to_string(),
+                                            (export.url.to_string(), export.kind, export.index),
+                                        );
                                     }
                                 }
                                 _ => {}
@@ -199,51 +193,58 @@ impl<'a> Component<'a> {
     pub fn export(
         &self,
         index: impl Into<ExportIndex>,
-    ) -> Option<(&str, ComponentExternalKind, u32)> {
+    ) -> Option<(&str, &str, ComponentExternalKind, u32)> {
         let index = index.into();
         self.exports
             .get_index(index.0)
-            .map(|(name, (kind, index))| (name.as_str(), *kind, *index))
+            .map(|(name, (url, kind, index))| (name.as_str(), url.as_str(), *kind, *index))
     }
 
     /// Gets an export from the component for the given export name.
-    pub fn export_by_name(&self, name: &str) -> Option<(ExportIndex, ComponentExternalKind, u32)> {
+    pub fn export_by_name(
+        &self,
+        name: &str,
+    ) -> Option<(ExportIndex, &str, ComponentExternalKind, u32)> {
         self.exports
             .get_full(name)
-            .map(|(i, _, (kind, index))| (ExportIndex(i), *kind, *index))
+            .map(|(i, _, (url, kind, index))| (ExportIndex(i), url.as_str(), *kind, *index))
     }
 
     /// Gets an iterator over the component's exports.
     pub fn exports(
         &self,
-    ) -> impl ExactSizeIterator<Item = (ExportIndex, &str, ComponentExternalKind, u32)> {
+    ) -> impl ExactSizeIterator<Item = (ExportIndex, &str, &str, ComponentExternalKind, u32)> {
         self.exports
             .iter()
             .enumerate()
-            .map(|(i, (name, (kind, index)))| (ExportIndex(i), name.as_str(), *kind, *index))
+            .map(|(i, (name, (url, kind, index)))| {
+                (ExportIndex(i), name.as_str(), url.as_str(), *kind, *index)
+            })
     }
 
     /// Gets an import from the component for the given import index.
-    pub fn import(&self, index: impl Into<ImportIndex>) -> Option<(&str, ComponentTypeRef)> {
+    pub fn import(&self, index: impl Into<ImportIndex>) -> Option<(&str, &str, ComponentTypeRef)> {
         let index = index.into();
         self.imports
             .get_index(index.0)
-            .map(|(name, ty)| (name.as_str(), *ty))
+            .map(|(name, (url, ty))| (name.as_str(), url.as_str(), *ty))
     }
 
     /// Gets an import from the component for the given import name.
-    pub fn import_by_name(&self, name: &str) -> Option<(ImportIndex, ComponentTypeRef)> {
+    pub fn import_by_name(&self, name: &str) -> Option<(ImportIndex, &str, ComponentTypeRef)> {
         self.imports
             .get_full(name)
-            .map(|(i, _, ty)| (ImportIndex(i), *ty))
+            .map(|(i, _, (url, ty))| (ImportIndex(i), url.as_str(), *ty))
     }
 
     /// Gets an iterator over the component's imports.
-    pub fn imports(&self) -> impl ExactSizeIterator<Item = (ImportIndex, &str, ComponentTypeRef)> {
+    pub fn imports(
+        &self,
+    ) -> impl ExactSizeIterator<Item = (ImportIndex, &str, &str, ComponentTypeRef)> {
         self.imports
             .iter()
             .enumerate()
-            .map(|(i, (name, ty))| (ImportIndex(i), name.as_str(), *ty))
+            .map(|(i, (name, (url, ty)))| (ImportIndex(i), name.as_str(), url.as_str(), *ty))
     }
 
     pub(crate) fn ty(&self) -> wasm_encoder::ComponentType {
@@ -260,35 +261,35 @@ impl<'a> Component<'a> {
     pub(crate) fn export_entity_type(
         &self,
         index: ExportIndex,
-    ) -> Option<(&str, ComponentEntityType)> {
-        let (name, _kind, _index) = self.export(index)?;
-        Some((name, self.types.component_entity_type_of_export(name)?))
+    ) -> Option<(&str, &str, ComponentEntityType)> {
+        let (name, url, _kind, _index) = self.export(index)?;
+        Some((name, url, self.types.component_entity_type_of_extern(name)?))
     }
 
     pub(crate) fn import_entity_type(
         &self,
         index: ImportIndex,
-    ) -> Option<(&str, ComponentEntityType)> {
-        let (name, _ty) = self.import(index)?;
-        Some((name, self.types.component_entity_type_of_import(name)?))
+    ) -> Option<(&str, &str, ComponentEntityType)> {
+        let (name, url, _ty) = self.import(index)?;
+        Some((name, url, self.types.component_entity_type_of_extern(name)?))
     }
 
     /// Finds a compatible instance export on the component for the given instance type.
     pub(crate) fn find_compatible_export(
         &self,
-        ty: TypeId,
+        ty: &ComponentInstanceType,
         types: TypesRef,
     ) -> Option<ExportIndex> {
         self.exports
             .iter()
-            .position(|(_, (kind, index))| {
+            .position(|(_, (_, kind, index))| {
                 if *kind != ComponentExternalKind::Instance {
                     return false;
                 }
-                ComponentEntityType::is_subtype_of(
-                    &ComponentEntityType::Instance(self.types.component_instance_at(*index)),
-                    self.types(),
-                    &ComponentEntityType::Instance(ty),
+                ComponentInstanceType::is_subtype_of(
+                    self.types.component_instance_at(*index).unwrap(),
+                    self.types.as_ref(),
+                    ty,
                     types,
                 )
             })
@@ -297,14 +298,18 @@ impl<'a> Component<'a> {
 
     /// Checks to see if an instance of this component would be a
     /// subtype of the given instance type.
-    pub(crate) fn is_instance_subtype_of(&self, ty: TypeId, types: TypesRef) -> bool {
-        let exports = types[ty].unwrap_component_instance().exports.iter();
+    pub(crate) fn is_instance_subtype_of(
+        &self,
+        ty: &ComponentInstanceType,
+        types: TypesRef,
+    ) -> bool {
+        let exports = ty.exports(types);
 
-        for (k, b) in exports {
+        for (k, _, b) in exports {
             match self.exports.get_full(k.as_str()) {
                 Some((ai, _, _)) => {
-                    let (_, a) = self.export_entity_type(ExportIndex(ai)).unwrap();
-                    if !ComponentEntityType::is_subtype_of(&a, self.types(), b, types) {
+                    let (_, _, a) = self.export_entity_type(ExportIndex(ai)).unwrap();
+                    if !ComponentEntityType::is_subtype_of(&a, self.types.as_ref(), &b, types) {
                         return false;
                     }
                 }
@@ -726,7 +731,7 @@ impl<'a> CompositionGraph<'a> {
             .ok_or_else(|| anyhow!("the target instance does not exist in the graph"))?;
 
         let target_component = &self.components[&target_instance.component].component;
-        let (import_name, import_ty) = target_component
+        let (import_name, _, import_ty) = target_component
             .import_entity_type(target_import)
             .ok_or_else(|| anyhow!("the target import index is invalid"))?;
 
@@ -738,15 +743,15 @@ impl<'a> CompositionGraph<'a> {
         }
 
         if let Some(export_index) = source_export {
-            let (export_name, export_ty) = source_component
+            let (export_name, _, export_ty) = source_component
                 .export_entity_type(export_index)
                 .ok_or_else(|| anyhow!("the source export index is invalid"))?;
 
             if !ComponentEntityType::is_subtype_of(
                 &export_ty,
-                source_component.types(),
+                source_component.types.as_ref(),
                 &import_ty,
-                target_component.types(),
+                target_component.types.as_ref(),
             ) {
                 bail!(
                     "source {export_ty} export `{export_name}` is not compatible with target {import_ty} import `{import_name}`",
@@ -756,14 +761,19 @@ impl<'a> CompositionGraph<'a> {
             }
         } else {
             let ty = match import_ty {
-                ComponentEntityType::Instance(id) => id,
+                ComponentEntityType::Instance(id) => target_component
+                    .types
+                    .type_from_id(id)
+                    .unwrap()
+                    .as_component_instance_type()
+                    .unwrap(),
                 _ => bail!(
                     "source instance is not compatible with target {import_ty} import `{import_name}`",
                     import_ty = type_desc(import_ty)
                 ),
             };
 
-            if !source_component.is_instance_subtype_of(ty, target_component.types()) {
+            if !source_component.is_instance_subtype_of(ty, target_component.types.as_ref()) {
                 bail!(
                     "source instance is not compatible with target {import_ty} import `{import_name}`",
                     import_ty = type_desc(import_ty)
@@ -1115,7 +1125,7 @@ mod test {
             validate: true,
         })?;
 
-        let wat = wasmprinter::print_bytes(encoded)?;
+        let wat = wasmprinter::print_bytes(&encoded)?;
         assert_eq!(r#"(component)"#, wat);
 
         Ok(())
@@ -1135,7 +1145,7 @@ mod test {
             validate: true,
         })?;
 
-        let wat = wasmprinter::print_bytes(encoded)?.replace("\r\n", "\n");
+        let wat = wasmprinter::print_bytes(&encoded)?.replace("\r\n", "\n");
         assert_eq!(
             r#"(component
   (type (;0;)
@@ -1164,7 +1174,7 @@ mod test {
             validate: true,
         })?;
 
-        let wat = wasmprinter::print_bytes(encoded)?.replace("\r\n", "\n");
+        let wat = wasmprinter::print_bytes(&encoded)?.replace("\r\n", "\n");
         assert_eq!(
             r#"(component
   (component (;0;))
@@ -1227,7 +1237,7 @@ mod test {
             validate: true,
         })?;
 
-        let wat = wasmprinter::print_bytes(encoded)?.replace("\r\n", "\n");
+        let wat = wasmprinter::print_bytes(&encoded)?.replace("\r\n", "\n");
         assert_eq!(
             r#"(component
   (type (;0;)
@@ -1252,7 +1262,7 @@ mod test {
   )
   (import "i4" (core module (;0;) (type 0)))
   (type (;3;) (tuple u32 u32))
-  (import "i5" (type (;4;) (eq 3)))
+  (import "i5" (type (eq 3)))
   (component (;1;)
     (type (;0;) (tuple u32 u32))
     (type (;1;)
@@ -1274,7 +1284,7 @@ mod test {
       (module)
     )
     (import "i4" (core module (;0;) (type 0)))
-    (import "i5" (type (;4;) (eq 0)))
+    (import "i5" (type (eq 0)))
     (export (;1;) "e1" (instance 0))
     (export (;1;) "e2" (func 0))
     (export (;1;) "e3" (component 0))
@@ -1302,7 +1312,7 @@ mod test {
       (module)
     )
     (import "i4" (core module (;0;) (type 0)))
-    (import "i5" (type (;4;) (eq 0)))
+    (import "i5" (type (eq 0)))
   )
   (instance (;1;) (instantiate 1
       (with "i1" (instance 0))
diff --git a/crates/wasm-compose/tests/compose.rs b/crates/wasm-compose/tests/compose.rs
index ff2ed13e..6e30626f 100644
--- a/crates/wasm-compose/tests/compose.rs
+++ b/crates/wasm-compose/tests/compose.rs
@@ -1,7 +1,6 @@
 use anyhow::{bail, Context, Result};
 use pretty_assertions::assert_eq;
 use std::fs;
-use std::io;
 use wasm_compose::{composer::ComponentComposer, config::Config};
 use wasmparser::{Validator, WasmFeatures};
 
@@ -52,29 +51,13 @@ fn component_composing() -> Result<()> {
         let (output, baseline_path) = if error_path.is_file() {
             match r {
                 Ok(_) => bail!("composition should fail for test case `{}`", test_case),
-                Err(e) => {
-                    let mut err = format!("{e}");
-                    let causes = e.chain();
-                    let ncauses = causes.len();
-                    if ncauses > 1 {
-                        err.push_str("\n\nCaused by:");
-                    }
-                    for (i, cause) in causes.skip(1).enumerate() {
-                        err.push_str("\n    ");
-                        if ncauses > 2 {
-                            err.push_str(&format!("{i}: "))
-                        }
-                        match cause.downcast_ref::<io::Error>() {
-                            Some(_) => {
-                                err.push_str("platform-specific error");
-                            }
-                            None => {
-                                err.push_str(&cause.to_string());
-                            }
-                        }
-                    }
-                    (err.replace('\\', "/"), &error_path)
-                }
+                Err(e) => (
+                    format!("{:?}", e).replace('\\', "/").replace(
+                        "The system cannot find the file specified.",
+                        "No such file or directory",
+                    ),
+                    &error_path,
+                ),
             }
         } else {
             let bytes =
@@ -92,13 +75,6 @@ fn component_composing() -> Result<()> {
                 )
             })?;
 
-            wit_component::decode(&bytes).with_context(|| {
-                format!(
-                    "failed to decode WIT from component bytes for test case `{}`",
-                    test_case
-                )
-            })?;
-
             (
                 wasmprinter::print_bytes(&bytes).with_context(|| {
                     format!(
@@ -111,10 +87,10 @@ fn component_composing() -> Result<()> {
         };
 
         if std::env::var_os("BLESS").is_some() {
-            fs::write(baseline_path, output + "\n")?;
+            fs::write(&baseline_path, output + "\n")?;
         } else {
             assert_eq!(
-                fs::read_to_string(baseline_path)
+                fs::read_to_string(&baseline_path)
                     .with_context(|| format!(
                         "failed to read component baseline `{}`",
                         baseline_path.display()
diff --git a/crates/wasm-compose/tests/compositions/complex-import/composed.wat b/crates/wasm-compose/tests/compositions/complex-import/composed.wat
index 54398478..c63ee59e 100644
--- a/crates/wasm-compose/tests/compositions/complex-import/composed.wat
+++ b/crates/wasm-compose/tests/compositions/complex-import/composed.wat
@@ -7,8 +7,8 @@
           (export (;0;) "m" (func (type 0)))
         )
       )
-      (import "b1" (instance (;0;) (type 0)))
-      (import "b2" (instance (;1;) (type 0)))
+      (import "b1" (instance (type 0)))
+      (import "b2" (instance (type 0)))
       (type (;1;) (func (param "x" string) (result string)))
       (export (;0;) "m1" (func (type 1)))
       (export (;1;) "m2" (func (type 1)))
@@ -47,44 +47,44 @@
           (export (;12;) "m" (func (type 12)))
           (type (;13;) (record (field "a" s8) (field "b" u8) (field "c" s16) (field "d" u16) (field "e" s32) (field "f" u32) (field "g" s64) (field "h" u64) (field "i" float32) (field "j" float64) (field "k" bool) (field "l" string)))
           (export (;14;) "record1" (type (eq 13)))
-          (type (;15;) (func (param "x" 14)))
+          (type (;15;) (func (param "x" 13)))
           (export (;13;) "n" (func (type 15)))
-          (type (;16;) (list 14))
+          (type (;16;) (list 13))
           (type (;17;) (func (param "x" 16)))
           (export (;14;) "o" (func (type 17)))
-          (type (;18;) (tuple 14 string))
+          (type (;18;) (tuple 13 string))
           (type (;19;) (func (param "x" 18)))
           (export (;15;) "p" (func (type 19)))
           (type (;20;) (flags "a" "b" "c"))
           (export (;21;) "flags1" (type (eq 20)))
-          (type (;22;) (func (param "x" 21)))
+          (type (;22;) (func (param "x" 20)))
           (export (;16;) "q" (func (type 22)))
           (type (;23;) (enum "a" "b" "c"))
           (export (;24;) "enum1" (type (eq 23)))
-          (type (;25;) (func (param "x" 24)))
+          (type (;25;) (func (param "x" 23)))
           (export (;17;) "r" (func (type 25)))
-          (type (;26;) (union s8 string 14))
+          (type (;26;) (union s8 string 13))
           (export (;27;) "union1" (type (eq 26)))
-          (type (;28;) (func (param "x" 27)))
+          (type (;28;) (func (param "x" 26)))
           (export (;18;) "s" (func (type 28)))
-          (type (;29;) (variant (case "a" s8) (case "b" u8) (case "c" s16) (case "d" u16) (case "e" s32) (case "f" u32) (case "g" s64) (case "h" u64) (case "i" float32) (case "j" float64) (case "k" bool) (case "l" string) (case "m" 14)))
+          (type (;29;) (variant (case "a" s8) (case "b" u8) (case "c" s16) (case "d" u16) (case "e" s32) (case "f" u32) (case "g" s64) (case "h" u64) (case "i" float32) (case "j" float64) (case "k" bool) (case "l" string) (case "m" 13)))
           (export (;30;) "variant1" (type (eq 29)))
-          (type (;31;) (option 30))
+          (type (;31;) (option 29))
           (type (;32;) (func (param "x" 31)))
           (export (;19;) "t" (func (type 32)))
-          (type (;33;) (result 14 (error string)))
+          (type (;33;) (result 13 (error string)))
           (type (;34;) (func (result 33)))
           (export (;20;) "u" (func (type 34)))
         )
       )
-      (import "a" (instance (;0;) (type 0)))
+      (import "a" (instance (type 0)))
       (type (;1;)
         (instance
           (type (;0;) (func (param "x" string) (result string)))
           (export (;0;) "m" (func (type 0)))
         )
       )
-      (export (;1;) "x" (instance (type 1)))
+      (export (;0;) "x" (instance (type 1)))
     )
   )
   (import "b" (component (;1;) (type 1)))
@@ -96,9 +96,9 @@
       (export (;3;) "flags1" (type (eq 2)))
       (type (;4;) (enum "a" "b" "c"))
       (export (;5;) "enum1" (type (eq 4)))
-      (type (;6;) (union s8 string 1))
+      (type (;6;) (union s8 string 0))
       (export (;7;) "union1" (type (eq 6)))
-      (type (;8;) (variant (case "a" s8) (case "b" u8) (case "c" s16) (case "d" u16) (case "e" s32) (case "f" u32) (case "g" s64) (case "h" u64) (case "i" float32) (case "j" float64) (case "k" bool) (case "l" string) (case "m" 1)))
+      (type (;8;) (variant (case "a" s8) (case "b" u8) (case "c" s16) (case "d" u16) (case "e" s32) (case "f" u32) (case "g" s64) (case "h" u64) (case "i" float32) (case "j" float64) (case "k" bool) (case "l" string) (case "m" 0)))
       (export (;9;) "variant1" (type (eq 8)))
       (type (;10;) (func))
       (export (;0;) "a" (func (type 10)))
@@ -126,24 +126,24 @@
       (export (;11;) "l" (func (type 21)))
       (type (;22;) (func (param "x" string)))
       (export (;12;) "m" (func (type 22)))
-      (type (;23;) (func (param "x" 1)))
+      (type (;23;) (func (param "x" 0)))
       (export (;13;) "n" (func (type 23)))
-      (type (;24;) (list 1))
+      (type (;24;) (list 0))
       (type (;25;) (func (param "x" 24)))
       (export (;14;) "o" (func (type 25)))
-      (type (;26;) (tuple 1 string))
+      (type (;26;) (tuple 0 string))
       (type (;27;) (func (param "x" 26)))
       (export (;15;) "p" (func (type 27)))
-      (type (;28;) (func (param "x" 3)))
+      (type (;28;) (func (param "x" 2)))
       (export (;16;) "q" (func (type 28)))
-      (type (;29;) (func (param "x" 5)))
+      (type (;29;) (func (param "x" 4)))
       (export (;17;) "r" (func (type 29)))
-      (type (;30;) (func (param "x" 7)))
+      (type (;30;) (func (param "x" 6)))
       (export (;18;) "s" (func (type 30)))
-      (type (;31;) (option 9))
+      (type (;31;) (option 8))
       (type (;32;) (func (param "x" 31)))
       (export (;19;) "t" (func (type 32)))
-      (type (;33;) (result 1 (error string)))
+      (type (;33;) (result 0 (error string)))
       (type (;34;) (func (result 33)))
       (export (;20;) "u" (func (type 34)))
     )
diff --git a/crates/wasm-compose/tests/compositions/complex/a.wat b/crates/wasm-compose/tests/compositions/complex/a.wat
index e40fcc74..3491a03d 100644
--- a/crates/wasm-compose/tests/compositions/complex/a.wat
+++ b/crates/wasm-compose/tests/compositions/complex/a.wat
@@ -1,39 +1,39 @@
 (component
-  (type $t0 (func))
-  (type $t1 (func (param "x" s8)))
-  (type $t2 (func (param "x" u8)))
-  (type $t3 (func (param "x" s16)))
-  (type $t4 (func (param "x" u16)))
-  (type $t5 (func (param "x" s32)))
-  (type $t6 (func (param "x" u32)))
-  (type $t7 (func (param "x" s64)))
-  (type $t8 (func (param "x" u64)))
-  (type $t9 (func (param "x" float32)))
-  (type $t10 (func (param "x" float64)))
-  (type $t11 (func (param "x" bool)))
-  (type $t12 (func (param "x" string)))
-  (type $t13' (record (field "a" s8) (field "b" u8) (field "c" s16) (field "d" u16) (field "e" s32) (field "f" u32) (field "g" s64) (field "h" u64) (field "i" float32) (field "j" float64) (field "k" bool) (field "l" string)))
-  (export $t13 "record1" (type $t13'))
-  (type $t14 (func (param "x" $t13)))
-  (type $t15 (list $t13))
-  (type $t16 (func (param "x" $t15)))
-  (type $t17 (tuple $t13 string))
-  (type $t18 (func (param "x" $t17)))
-  (type $t19' (flags "a" "b" "c"))
-  (export $t19 "flags1" (type $t19'))
-  (type $t20 (func (param "x" $t19)))
-  (type $t21' (enum "a" "b" "c"))
-  (export $t21 "enum1" (type $t21'))
-  (type $t22 (func (param "x" $t21)))
-  (type $t23' (union s8 string $t13))
-  (export $t23 "union1" (type $t23'))
-  (type $t24 (func (param "x" $t23)))
-  (type $t25' (variant (case "a" s8) (case "b" u8) (case "c" s16) (case "d" u16) (case "e" s32) (case "f" u32) (case "g" s64) (case "h" u64) (case "i" float32) (case "j" float64) (case "k" bool) (case "l" string) (case "m" $t13)))
-  (export $t25 "variant1" (type $t25'))
-  (type $t26 (option $t25))
-  (type $t27 (func (param "x" $t26)))
-  (type $t28 (result $t13 (error string)))
-  (type $t29 (func (result $t28)))
+  (type (func))
+  (type (func (param "x" s8)))
+  (type (func (param "x" u8)))
+  (type (func (param "x" s16)))
+  (type (func (param "x" u16)))
+  (type (func (param "x" s32)))
+  (type (func (param "x" u32)))
+  (type (func (param "x" s64)))
+  (type (func (param "x" u64)))
+  (type (func (param "x" float32)))
+  (type (func (param "x" float64)))
+  (type (func (param "x" bool)))
+  (type (func (param "x" string)))
+  (type (record (field "a" s8) (field "b" u8) (field "c" s16) (field "d" u16) (field "e" s32) (field "f" u32) (field "g" s64) (field "h" u64) (field "i" float32) (field "j" float64) (field "k" bool) (field "l" string)))
+  (type (func (param "x" 13)))
+  (type (list 13))
+  (type (func (param "x" 15)))
+  (type (tuple 13 string))
+  (type (func (param "x" 17)))
+  (type (flags "a" "b" "c"))
+  (type (func (param "x" 19)))
+  (type (enum "a" "b" "c"))
+  (type (func (param "x" 21)))
+  (type (union s8 string 13))
+  (type (func (param "x" 23)))
+  (type (variant (case "a" s8) (case "b" u8) (case "c" s16) (case "d" u16) (case "e" s32) (case "f" u32) (case "g" s64) (case "h" u64) (case "i" float32) (case "j" float64) (case "k" bool) (case "l" string) (case "m" 13)))
+  (type (option 25))
+  (type (func (param "x" 26)))
+  (type (result 13 (error string)))
+  (type (func (result 28)))
+  (export "record1" (type 13))
+  (export "flags1" (type 19))
+  (export "enum1" (type 21))
+  (export "union1" (type 23))
+  (export "variant1" (type 25))
   (core module
     (func $a unreachable)
     (func $b (param i32) unreachable)
@@ -83,69 +83,69 @@
     (export "canonical_abi_realloc" (func $canonical_abi_realloc))
   )
   (core instance (instantiate 0))
-  (alias core export 0 "memory" (core memory (;0;)))
-  (alias core export 0 "canonical_abi_realloc" (core func (;0;)))
-  (alias core export 0 "a" (core func (;1;)))
-  (alias core export 0 "b" (core func (;2;)))
-  (alias core export 0 "c" (core func (;3;)))
-  (alias core export 0 "d" (core func (;4;)))
-  (alias core export 0 "e" (core func (;5;)))
-  (alias core export 0 "f" (core func (;6;)))
-  (alias core export 0 "g" (core func (;7;)))
-  (alias core export 0 "h" (core func (;8;)))
-  (alias core export 0 "i" (core func (;9;)))
-  (alias core export 0 "j" (core func (;10;)))
-  (alias core export 0 "k" (core func (;11;)))
-  (alias core export 0 "l" (core func (;12;)))
-  (alias core export 0 "m" (core func (;13;)))
-  (alias core export 0 "n" (core func (;14;)))
-  (alias core export 0 "o" (core func (;15;)))
-  (alias core export 0 "p" (core func (;16;)))
-  (alias core export 0 "q" (core func (;17;)))
-  (alias core export 0 "r" (core func (;18;)))
-  (alias core export 0 "s" (core func (;19;)))
-  (alias core export 0 "t" (core func (;20;)))
-  (alias core export 0 "u" (core func (;21;)))
-  (func (;0;) (type $t0) (canon lift (core func 1)))
-  (func (;1;) (type $t1) (canon lift (core func 2)))
-  (func (;2;) (type $t2) (canon lift (core func 3)))
-  (func (;3;) (type $t3) (canon lift (core func 4)))
-  (func (;4;) (type $t4) (canon lift (core func 5)))
-  (func (;5;) (type $t5) (canon lift (core func 6)))
-  (func (;6;) (type $t6) (canon lift (core func 7)))
-  (func (;7;) (type $t7) (canon lift (core func 8)))
-  (func (;8;) (type $t8) (canon lift (core func 9)))
-  (func (;9;) (type $t9) (canon lift (core func 10)))
-  (func (;10;) (type $t10) (canon lift (core func 11)))
-  (func (;11;) (type $t11) (canon lift (core func 12)))
-  (func (;12;) (type $t12) (canon lift (core func 13) (memory 0) (realloc 0) string-encoding=utf8))
-  (func (;13;) (type $t14) (canon lift (core func 14) (memory 0) (realloc 0) string-encoding=utf8))
-  (func (;14;) (type $t16) (canon lift (core func 15) (memory 0) (realloc 0) string-encoding=utf8))
-  (func (;15;) (type $t18) (canon lift (core func 16) (memory 0) (realloc 0) string-encoding=utf8))
-  (func (;16;) (type $t20) (canon lift (core func 17)))
-  (func (;17;) (type $t22) (canon lift (core func 18)))
-  (func (;18;) (type $t24) (canon lift (core func 19) (memory 0) (realloc 0) string-encoding=utf8))
-  (func (;19;) (type $t27) (canon lift (core func 20) (memory 0) (realloc 0) string-encoding=utf8))
-  (func (;20;) (type $t29) (canon lift (core func 21) (memory 0) (realloc 0) string-encoding=utf8))
-  (export (;21;) "a" (func 0))
-  (export (;22;) "b" (func 1))
-  (export (;23;) "c" (func 2))
-  (export (;24;) "d" (func 3))
-  (export (;25;) "e" (func 4))
-  (export (;26;) "f" (func 5))
-  (export (;27;) "g" (func 6))
-  (export (;28;) "h" (func 7))
-  (export (;29;) "i" (func 8))
-  (export (;30;) "j" (func 9))
-  (export (;31;) "k" (func 10))
-  (export (;32;) "l" (func 11))
-  (export (;33;) "m" (func 12))
-  (export (;34;) "n" (func 13))
-  (export (;35;) "o" (func 14))
-  (export (;36;) "p" (func 15))
-  (export (;37;) "q" (func 16))
-  (export (;38;) "r" (func 17))
-  (export (;39;) "s" (func 18))
-  (export (;40;) "t" (func 19))
-  (export (;41;) "u" (func 20))
+  (alias core export 0 "memory" (core memory))
+  (alias core export 0 "canonical_abi_realloc" (core func))
+  (alias core export 0 "a" (core func))
+  (alias core export 0 "b" (core func))
+  (alias core export 0 "c" (core func))
+  (alias core export 0 "d" (core func))
+  (alias core export 0 "e" (core func))
+  (alias core export 0 "f" (core func))
+  (alias core export 0 "g" (core func))
+  (alias core export 0 "h" (core func))
+  (alias core export 0 "i" (core func))
+  (alias core export 0 "j" (core func))
+  (alias core export 0 "k" (core func))
+  (alias core export 0 "l" (core func))
+  (alias core export 0 "m" (core func))
+  (alias core export 0 "n" (core func))
+  (alias core export 0 "o" (core func))
+  (alias core export 0 "p" (core func))
+  (alias core export 0 "q" (core func))
+  (alias core export 0 "r" (core func))
+  (alias core export 0 "s" (core func))
+  (alias core export 0 "t" (core func))
+  (alias core export 0 "u" (core func))
+  (func (type 0) (canon lift (core func 1)))
+  (func (type 1) (canon lift (core func 2)))
+  (func (type 2) (canon lift (core func 3)))
+  (func (type 3) (canon lift (core func 4)))
+  (func (type 4) (canon lift (core func 5)))
+  (func (type 5) (canon lift (core func 6)))
+  (func (type 6) (canon lift (core func 7)))
+  (func (type 7) (canon lift (core func 8)))
+  (func (type 8) (canon lift (core func 9)))
+  (func (type 9) (canon lift (core func 10)))
+  (func (type 10) (canon lift (core func 11)))
+  (func (type 11) (canon lift (core func 12)))
+  (func (type 12) (canon lift (core func 13) (memory 0) (realloc 0) string-encoding=utf8))
+  (func (type 14) (canon lift (core func 14) (memory 0) (realloc 0) string-encoding=utf8))
+  (func (type 16) (canon lift (core func 15) (memory 0) (realloc 0) string-encoding=utf8))
+  (func (type 18) (canon lift (core func 16) (memory 0) (realloc 0) string-encoding=utf8))
+  (func (type 20) (canon lift (core func 17)))
+  (func (type 22) (canon lift (core func 18)))
+  (func (type 24) (canon lift (core func 19) (memory 0) (realloc 0) string-encoding=utf8))
+  (func (type 27) (canon lift (core func 20) (memory 0) (realloc 0) string-encoding=utf8))
+  (func (type 29) (canon lift (core func 21) (memory 0) (realloc 0) string-encoding=utf8))
+  (export "a" (func 0))
+  (export "b" (func 1))
+  (export "c" (func 2))
+  (export "d" (func 3))
+  (export "e" (func 4))
+  (export "f" (func 5))
+  (export "g" (func 6))
+  (export "h" (func 7))
+  (export "i" (func 8))
+  (export "j" (func 9))
+  (export "k" (func 10))
+  (export "l" (func 11))
+  (export "m" (func 12))
+  (export "n" (func 13))
+  (export "o" (func 14))
+  (export "p" (func 15))
+  (export "q" (func 16))
+  (export "r" (func 17))
+  (export "s" (func 18))
+  (export "t" (func 19))
+  (export "u" (func 20))
 )
diff --git a/crates/wasm-compose/tests/compositions/complex/b.wat b/crates/wasm-compose/tests/compositions/complex/b.wat
index 83cf1cad..0ae06e7a 100644
--- a/crates/wasm-compose/tests/compositions/complex/b.wat
+++ b/crates/wasm-compose/tests/compositions/complex/b.wat
@@ -1,19 +1,36 @@
 (component
+  (type $f1 (func))
+  (type $f2 (func (param "x" s8)))
+  (type $f3 (func (param "x" u8)))
+  (type $f4 (func (param "x" s16)))
+  (type $f5 (func (param "x" u16)))
+  (type $f6 (func (param "x" s32)))
+  (type $f7 (func (param "x" u32)))
+  (type $f8 (func (param "x" s64)))
+  (type $f9 (func (param "x" u64)))
+  (type $f10 (func (param "x" float32)))
+  (type $f11 (func (param "x" float64)))
+  (type $f12 (func (param "x" bool)))
+  (type $f13 (func (param "x" string)))
+  (type $t1 (record (field "a" s8) (field "b" u8) (field "c" s16) (field "d" u16) (field "e" s32) (field "f" u32) (field "g" s64) (field "h" u64) (field "i" float32) (field "j" float64) (field "k" bool) (field "l" string)))
+  (type $f14 (func (param "x" 13)))
+  (type $t2 (list 13))
+  (type $f15 (func (param "x" 15)))
+  (type $t3 (tuple 13 string))
+  (type $f16 (func (param "x" 17)))
+  (type $t4 (flags "a" "b" "c"))
+  (type $f17 (func (param "x" 19)))
+  (type $t5 (enum "a" "b" "c"))
+  (type $f18 (func (param "x" 21)))
+  (type $t6 (union s8 string 13))
+  (type $f19 (func (param "x" 23)))
+  (type $t7 (variant (case "a" s8) (case "b" u8) (case "c" s16) (case "d" u16) (case "e" s32) (case "f" u32) (case "g" s64) (case "h" u64) (case "i" float32) (case "j" float64) (case "k" bool) (case "l" string) (case "m" 13)))
+  (type $t8 (option 25))
+  (type $f20 (func (param "x" 26)))
+  (type $t9 (result 13 (error string)))
+  (type $f21 (func (result 28)))
   (type $i1
     (instance
-      (type $f1 (func))
-      (type $f2 (func (param "x" s8)))
-      (type $f3 (func (param "x" u8)))
-      (type $f4 (func (param "x" s16)))
-      (type $f5 (func (param "x" u16)))
-      (type $f6 (func (param "x" s32)))
-      (type $f7 (func (param "x" u32)))
-      (type $f8 (func (param "x" s64)))
-      (type $f9 (func (param "x" u64)))
-      (type $f10 (func (param "x" float32)))
-      (type $f11 (func (param "x" float64)))
-      (type $f12 (func (param "x" bool)))
-      (type $f13 (func (param "x" string)))
       (export "a" (func (type $f1)))
       (export "b" (func (type $f2)))
       (export "c" (func (type $f3)))
@@ -27,35 +44,18 @@
       (export "k" (func (type $f11)))
       (export "l" (func (type $f12)))
       (export "m" (func (type $f13)))
-      (type $t1' (record (field "a" s8) (field "b" u8) (field "c" s16) (field "d" u16) (field "e" s32) (field "f" u32) (field "g" s64) (field "h" u64) (field "i" float32) (field "j" float64) (field "k" bool) (field "l" string)))
-      (export $t1 "record1"  (type (eq $t1')))
-      (type $f14 (func (param "x" $t1)))
+      (export "record1"  (type (eq $t1)))
       (export "n" (func (type $f14)))
-      (type $t2 (list $t1))
-      (type $f15 (func (param "x" $t2)))
       (export "o" (func (type $f15)))
-      (type $t3 (tuple $t1 string))
-      (type $f16 (func (param "x" $t3)))
       (export "p" (func (type $f16)))
-      (type $t4' (flags "a" "b" "c"))
-      (export $t4 "flags1"  (type (eq $t4')))
-      (type $f17 (func (param "x" $t4)))
+      (export "flags1"  (type (eq $t4)))
       (export "q" (func (type $f17)))
-      (type $t5' (enum "a" "b" "c"))
-      (export $t5 "enum1"  (type (eq $t5')))
-      (type $f18 (func (param "x" $t5)))
+      (export "enum1"  (type (eq $t5)))
       (export "r" (func (type $f18)))
-      (type $t6' (union s8 string $t1))
-      (export $t6 "union1"  (type (eq $t6')))
-      (type $f19 (func (param "x" $t6)))
+      (export "union1"  (type (eq $t6)))
       (export "s" (func (type $f19)))
-      (type $t7' (variant (case "a" s8) (case "b" u8) (case "c" s16) (case "d" u16) (case "e" s32) (case "f" u32) (case "g" s64) (case "h" u64) (case "i" float32) (case "j" float64) (case "k" bool) (case "l" string) (case "m" $t1)))
-      (export $t7 "variant1"  (type (eq $t7')))
-      (type $t8 (option $t7))
-      (type $f20 (func (param "x" $t8)))
+      (export "variant1"  (type (eq $t7)))
       (export "t" (func (type $f20)))
-      (type $t9 (result $t1 (error string)))
-      (type $f21 (func (result $t9)))
       (export "u" (func (type $f21)))
     )
   )
diff --git a/crates/wasm-compose/tests/compositions/complex/composed.wat b/crates/wasm-compose/tests/compositions/complex/composed.wat
index 00c822a2..20b22575 100644
--- a/crates/wasm-compose/tests/compositions/complex/composed.wat
+++ b/crates/wasm-compose/tests/compositions/complex/composed.wat
@@ -14,67 +14,93 @@
     (export (;3;) "m2" (func 1))
   )
   (component (;1;)
-    (type $i1 (;0;)
+    (type $f1 (;0;) (func))
+    (type $f2 (;1;) (func (param "x" s8)))
+    (type $f3 (;2;) (func (param "x" u8)))
+    (type $f4 (;3;) (func (param "x" s16)))
+    (type $f5 (;4;) (func (param "x" u16)))
+    (type $f6 (;5;) (func (param "x" s32)))
+    (type $f7 (;6;) (func (param "x" u32)))
+    (type $f8 (;7;) (func (param "x" s64)))
+    (type $f9 (;8;) (func (param "x" u64)))
+    (type $f10 (;9;) (func (param "x" float32)))
+    (type $f11 (;10;) (func (param "x" float64)))
+    (type $f12 (;11;) (func (param "x" bool)))
+    (type $f13 (;12;) (func (param "x" string)))
+    (type $t1 (;13;) (record (field "a" s8) (field "b" u8) (field "c" s16) (field "d" u16) (field "e" s32) (field "f" u32) (field "g" s64) (field "h" u64) (field "i" float32) (field "j" float64) (field "k" bool) (field "l" string)))
+    (type $f14 (;14;) (func (param "x" $t1)))
+    (type $t2 (;15;) (list $t1))
+    (type $f15 (;16;) (func (param "x" $t2)))
+    (type $t3 (;17;) (tuple $t1 string))
+    (type $f16 (;18;) (func (param "x" $t3)))
+    (type $t4 (;19;) (flags "a" "b" "c"))
+    (type $f17 (;20;) (func (param "x" $t4)))
+    (type $t5 (;21;) (enum "a" "b" "c"))
+    (type $f18 (;22;) (func (param "x" $t5)))
+    (type $t6 (;23;) (union s8 string $t1))
+    (type $f19 (;24;) (func (param "x" $t6)))
+    (type $t7 (;25;) (variant (case "a" s8) (case "b" u8) (case "c" s16) (case "d" u16) (case "e" s32) (case "f" u32) (case "g" s64) (case "h" u64) (case "i" float32) (case "j" float64) (case "k" bool) (case "l" string) (case "m" $t1)))
+    (type $t8 (;26;) (option $t7))
+    (type $f20 (;27;) (func (param "x" $t8)))
+    (type $t9 (;28;) (result $t1 (error string)))
+    (type $f21 (;29;) (func (result $t9)))
+    (type $i1 (;30;)
       (instance
-        (type (;0;) (func))
-        (type (;1;) (func (param "x" s8)))
-        (type (;2;) (func (param "x" u8)))
-        (type (;3;) (func (param "x" s16)))
-        (type (;4;) (func (param "x" u16)))
-        (type (;5;) (func (param "x" s32)))
-        (type (;6;) (func (param "x" u32)))
-        (type (;7;) (func (param "x" s64)))
-        (type (;8;) (func (param "x" u64)))
-        (type (;9;) (func (param "x" float32)))
-        (type (;10;) (func (param "x" float64)))
-        (type (;11;) (func (param "x" bool)))
-        (type (;12;) (func (param "x" string)))
+        (alias outer 1 $f1 (type (;0;)))
         (export (;0;) "a" (func (type 0)))
+        (alias outer 1 $f2 (type (;1;)))
         (export (;1;) "b" (func (type 1)))
+        (alias outer 1 $f3 (type (;2;)))
         (export (;2;) "c" (func (type 2)))
+        (alias outer 1 $f4 (type (;3;)))
         (export (;3;) "d" (func (type 3)))
+        (alias outer 1 $f5 (type (;4;)))
         (export (;4;) "e" (func (type 4)))
+        (alias outer 1 $f6 (type (;5;)))
         (export (;5;) "f" (func (type 5)))
+        (alias outer 1 $f7 (type (;6;)))
         (export (;6;) "g" (func (type 6)))
+        (alias outer 1 $f8 (type (;7;)))
         (export (;7;) "h" (func (type 7)))
+        (alias outer 1 $f9 (type (;8;)))
         (export (;8;) "i" (func (type 8)))
+        (alias outer 1 $f10 (type (;9;)))
         (export (;9;) "j" (func (type 9)))
+        (alias outer 1 $f11 (type (;10;)))
         (export (;10;) "k" (func (type 10)))
+        (alias outer 1 $f12 (type (;11;)))
         (export (;11;) "l" (func (type 11)))
+        (alias outer 1 $f13 (type (;12;)))
         (export (;12;) "m" (func (type 12)))
-        (type (;13;) (record (field "a" s8) (field "b" u8) (field "c" s16) (field "d" u16) (field "e" s32) (field "f" u32) (field "g" s64) (field "h" u64) (field "i" float32) (field "j" float64) (field "k" bool) (field "l" string)))
+        (alias outer 1 $t1 (type (;13;)))
         (export (;14;) "record1" (type (eq 13)))
-        (type (;15;) (func (param "x" 14)))
+        (alias outer 1 $f14 (type (;15;)))
         (export (;13;) "n" (func (type 15)))
-        (type (;16;) (list 14))
-        (type (;17;) (func (param "x" 16)))
-        (export (;14;) "o" (func (type 17)))
-        (type (;18;) (tuple 14 string))
-        (type (;19;) (func (param "x" 18)))
-        (export (;15;) "p" (func (type 19)))
-        (type (;20;) (flags "a" "b" "c"))
-        (export (;21;) "flags1" (type (eq 20)))
-        (type (;22;) (func (param "x" 21)))
-        (export (;16;) "q" (func (type 22)))
-        (type (;23;) (enum "a" "b" "c"))
-        (export (;24;) "enum1" (type (eq 23)))
-        (type (;25;) (func (param "x" 24)))
-        (export (;17;) "r" (func (type 25)))
-        (type (;26;) (union s8 string 14))
-        (export (;27;) "union1" (type (eq 26)))
-        (type (;28;) (func (param "x" 27)))
-        (export (;18;) "s" (func (type 28)))
-        (type (;29;) (variant (case "a" s8) (case "b" u8) (case "c" s16) (case "d" u16) (case "e" s32) (case "f" u32) (case "g" s64) (case "h" u64) (case "i" float32) (case "j" float64) (case "k" bool) (case "l" string) (case "m" 14)))
-        (export (;30;) "variant1" (type (eq 29)))
-        (type (;31;) (option 30))
-        (type (;32;) (func (param "x" 31)))
-        (export (;19;) "t" (func (type 32)))
-        (type (;33;) (result 14 (error string)))
-        (type (;34;) (func (result 33)))
-        (export (;20;) "u" (func (type 34)))
+        (alias outer 1 $f15 (type (;16;)))
+        (export (;14;) "o" (func (type 16)))
+        (alias outer 1 $f16 (type (;17;)))
+        (export (;15;) "p" (func (type 17)))
+        (alias outer 1 $t4 (type (;18;)))
+        (export (;19;) "flags1" (type (eq 18)))
+        (alias outer 1 $f17 (type (;20;)))
+        (export (;16;) "q" (func (type 20)))
+        (alias outer 1 $t5 (type (;21;)))
+        (export (;22;) "enum1" (type (eq 21)))
+        (alias outer 1 $f18 (type (;23;)))
+        (export (;17;) "r" (func (type 23)))
+        (alias outer 1 $t6 (type (;24;)))
+        (export (;25;) "union1" (type (eq 24)))
+        (alias outer 1 $f19 (type (;26;)))
+        (export (;18;) "s" (func (type 26)))
+        (alias outer 1 $t7 (type (;27;)))
+        (export (;28;) "variant1" (type (eq 27)))
+        (alias outer 1 $f20 (type (;29;)))
+        (export (;19;) "t" (func (type 29)))
+        (alias outer 1 $f21 (type (;30;)))
+        (export (;20;) "u" (func (type 30)))
       )
     )
-    (type $f22 (;1;) (func (param "x" string) (result string)))
+    (type $f22 (;31;) (func (param "x" string) (result string)))
     (import "a" (instance $i1 (;0;) (type $i1)))
     (core module $m0 (;0;)
       (type (;0;) (func (param i32 i32)))
@@ -318,41 +344,41 @@
     (export (;2;) "x" (instance $x))
   )
   (component (;2;)
-    (type $t0 (;0;) (func))
-    (type $t1 (;1;) (func (param "x" s8)))
-    (type $t2 (;2;) (func (param "x" u8)))
-    (type $t3 (;3;) (func (param "x" s16)))
-    (type $t4 (;4;) (func (param "x" u16)))
-    (type $t5 (;5;) (func (param "x" s32)))
-    (type $t6 (;6;) (func (param "x" u32)))
-    (type $t7 (;7;) (func (param "x" s64)))
-    (type $t8 (;8;) (func (param "x" u64)))
-    (type $t9 (;9;) (func (param "x" float32)))
-    (type $t10 (;10;) (func (param "x" float64)))
-    (type $t11 (;11;) (func (param "x" bool)))
-    (type $t12 (;12;) (func (param "x" string)))
-    (type $t13' (;13;) (record (field "a" s8) (field "b" u8) (field "c" s16) (field "d" u16) (field "e" s32) (field "f" u32) (field "g" s64) (field "h" u64) (field "i" float32) (field "j" float64) (field "k" bool) (field "l" string)))
-    (export $t13 (;14;) "record1" (type $t13'))
-    (type $t14 (;15;) (func (param "x" $t13)))
-    (type $t15 (;16;) (list $t13))
-    (type $t16 (;17;) (func (param "x" $t15)))
-    (type $t17 (;18;) (tuple $t13 string))
-    (type $t18 (;19;) (func (param "x" $t17)))
-    (type $t19' (;20;) (flags "a" "b" "c"))
-    (export $t19 (;21;) "flags1" (type $t19'))
-    (type $t20 (;22;) (func (param "x" $t19)))
-    (type $t21' (;23;) (enum "a" "b" "c"))
-    (export $t21 (;24;) "enum1" (type $t21'))
-    (type $t22 (;25;) (func (param "x" $t21)))
-    (type $t23' (;26;) (union s8 string $t13))
-    (export $t23 (;27;) "union1" (type $t23'))
-    (type $t24 (;28;) (func (param "x" $t23)))
-    (type $t25' (;29;) (variant (case "a" s8) (case "b" u8) (case "c" s16) (case "d" u16) (case "e" s32) (case "f" u32) (case "g" s64) (case "h" u64) (case "i" float32) (case "j" float64) (case "k" bool) (case "l" string) (case "m" $t13)))
-    (export $t25 (;30;) "variant1" (type $t25'))
-    (type $t26 (;31;) (option $t25))
-    (type $t27 (;32;) (func (param "x" $t26)))
-    (type $t28 (;33;) (result $t13 (error string)))
-    (type $t29 (;34;) (func (result $t28)))
+    (type (;0;) (func))
+    (type (;1;) (func (param "x" s8)))
+    (type (;2;) (func (param "x" u8)))
+    (type (;3;) (func (param "x" s16)))
+    (type (;4;) (func (param "x" u16)))
+    (type (;5;) (func (param "x" s32)))
+    (type (;6;) (func (param "x" u32)))
+    (type (;7;) (func (param "x" s64)))
+    (type (;8;) (func (param "x" u64)))
+    (type (;9;) (func (param "x" float32)))
+    (type (;10;) (func (param "x" float64)))
+    (type (;11;) (func (param "x" bool)))
+    (type (;12;) (func (param "x" string)))
+    (type (;13;) (record (field "a" s8) (field "b" u8) (field "c" s16) (field "d" u16) (field "e" s32) (field "f" u32) (field "g" s64) (field "h" u64) (field "i" float32) (field "j" float64) (field "k" bool) (field "l" string)))
+    (type (;14;) (func (param "x" 13)))
+    (type (;15;) (list 13))
+    (type (;16;) (func (param "x" 15)))
+    (type (;17;) (tuple 13 string))
+    (type (;18;) (func (param "x" 17)))
+    (type (;19;) (flags "a" "b" "c"))
+    (type (;20;) (func (param "x" 19)))
+    (type (;21;) (enum "a" "b" "c"))
+    (type (;22;) (func (param "x" 21)))
+    (type (;23;) (union s8 string 13))
+    (type (;24;) (func (param "x" 23)))
+    (type (;25;) (variant (case "a" s8) (case "b" u8) (case "c" s16) (case "d" u16) (case "e" s32) (case "f" u32) (case "g" s64) (case "h" u64) (case "i" float32) (case "j" float64) (case "k" bool) (case "l" string) (case "m" 13)))
+    (type (;26;) (option 25))
+    (type (;27;) (func (param "x" 26)))
+    (type (;28;) (result 13 (error string)))
+    (type (;29;) (func (result 28)))
+    (export (;30;) "record1" (type 13))
+    (export (;31;) "flags1" (type 19))
+    (export (;32;) "enum1" (type 21))
+    (export (;33;) "union1" (type 23))
+    (export (;34;) "variant1" (type 25))
     (core module (;0;)
       (type (;0;) (func))
       (type (;1;) (func (param i32)))
@@ -481,27 +507,27 @@
     (alias core export 0 "s" (core func (;19;)))
     (alias core export 0 "t" (core func (;20;)))
     (alias core export 0 "u" (core func (;21;)))
-    (func (;0;) (type $t0) (canon lift (core func 1)))
-    (func (;1;) (type $t1) (canon lift (core func 2)))
-    (func (;2;) (type $t2) (canon lift (core func 3)))
-    (func (;3;) (type $t3) (canon lift (core func 4)))
-    (func (;4;) (type $t4) (canon lift (core func 5)))
-    (func (;5;) (type $t5) (canon lift (core func 6)))
-    (func (;6;) (type $t6) (canon lift (core func 7)))
-    (func (;7;) (type $t7) (canon lift (core func 8)))
-    (func (;8;) (type $t8) (canon lift (core func 9)))
-    (func (;9;) (type $t9) (canon lift (core func 10)))
-    (func (;10;) (type $t10) (canon lift (core func 11)))
-    (func (;11;) (type $t11) (canon lift (core func 12)))
-    (func (;12;) (type $t12) (canon lift (core func 13) (memory 0) (realloc 0) string-encoding=utf8))
-    (func (;13;) (type $t14) (canon lift (core func 14) (memory 0) (realloc 0) string-encoding=utf8))
-    (func (;14;) (type $t16) (canon lift (core func 15) (memory 0) (realloc 0) string-encoding=utf8))
-    (func (;15;) (type $t18) (canon lift (core func 16) (memory 0) (realloc 0) string-encoding=utf8))
-    (func (;16;) (type $t20) (canon lift (core func 17)))
-    (func (;17;) (type $t22) (canon lift (core func 18)))
-    (func (;18;) (type $t24) (canon lift (core func 19) (memory 0) (realloc 0) string-encoding=utf8))
-    (func (;19;) (type $t27) (canon lift (core func 20) (memory 0) (realloc 0) string-encoding=utf8))
-    (func (;20;) (type $t29) (canon lift (core func 21) (memory 0) (realloc 0) string-encoding=utf8))
+    (func (;0;) (type 0) (canon lift (core func 1)))
+    (func (;1;) (type 1) (canon lift (core func 2)))
+    (func (;2;) (type 2) (canon lift (core func 3)))
+    (func (;3;) (type 3) (canon lift (core func 4)))
+    (func (;4;) (type 4) (canon lift (core func 5)))
+    (func (;5;) (type 5) (canon lift (core func 6)))
+    (func (;6;) (type 6) (canon lift (core func 7)))
+    (func (;7;) (type 7) (canon lift (core func 8)))
+    (func (;8;) (type 8) (canon lift (core func 9)))
+    (func (;9;) (type 9) (canon lift (core func 10)))
+    (func (;10;) (type 10) (canon lift (core func 11)))
+    (func (;11;) (type 11) (canon lift (core func 12)))
+    (func (;12;) (type 12) (canon lift (core func 13) (memory 0) (realloc 0) string-encoding=utf8))
+    (func (;13;) (type 14) (canon lift (core func 14) (memory 0) (realloc 0) string-encoding=utf8))
+    (func (;14;) (type 16) (canon lift (core func 15) (memory 0) (realloc 0) string-encoding=utf8))
+    (func (;15;) (type 18) (canon lift (core func 16) (memory 0) (realloc 0) string-encoding=utf8))
+    (func (;16;) (type 20) (canon lift (core func 17)))
+    (func (;17;) (type 22) (canon lift (core func 18)))
+    (func (;18;) (type 24) (canon lift (core func 19) (memory 0) (realloc 0) string-encoding=utf8))
+    (func (;19;) (type 27) (canon lift (core func 20) (memory 0) (realloc 0) string-encoding=utf8))
+    (func (;20;) (type 29) (canon lift (core func 21) (memory 0) (realloc 0) string-encoding=utf8))
     (export (;21;) "a" (func 0))
     (export (;22;) "b" (func 1))
     (export (;23;) "c" (func 2))
diff --git a/crates/wasm-compose/tests/compositions/component-missing/error.txt b/crates/wasm-compose/tests/compositions/component-missing/error.txt
index 8b88baf3..61c880b6 100644
--- a/crates/wasm-compose/tests/compositions/component-missing/error.txt
+++ b/crates/wasm-compose/tests/compositions/component-missing/error.txt
@@ -1,5 +1,5 @@
 failed to parse component `tests/compositions/component-missing/a.wat`
 
 Caused by:
-    0: failed to read from `tests/compositions/component-missing/a.wat`
-    1: platform-specific error
+    0: failed to read from `tests/compositions/component-missing/a.wat`: No such file or directory (os error 2)
+    1: No such file or directory (os error 2)
diff --git a/crates/wasm-compose/tests/compositions/component-not-wat/error.txt b/crates/wasm-compose/tests/compositions/component-not-wat/error.txt
index 8d8d29ed..39d3ab04 100644
--- a/crates/wasm-compose/tests/compositions/component-not-wat/error.txt
+++ b/crates/wasm-compose/tests/compositions/component-not-wat/error.txt
@@ -2,7 +2,7 @@ failed to parse component `tests/compositions/component-not-wat/root.wat`
 
 Caused by:
     expected `(`
-     --> tests/compositions/component-not-wat/root.wat:1:1
-      |
-    1 | not valid
-      | ^
+         --> tests/compositions/component-not-wat/root.wat:1:1
+          |
+        1 | not valid
+          | ^
diff --git a/crates/wasm-compose/tests/compositions/def-mismatch/config.yml b/crates/wasm-compose/tests/compositions/def-mismatch/config.yml
deleted file mode 100644
index 77a13f0f..00000000
--- a/crates/wasm-compose/tests/compositions/def-mismatch/config.yml
+++ /dev/null
@@ -1 +0,0 @@
-definitions: ['definitions.wat']
diff --git a/crates/wasm-compose/tests/compositions/def-mismatch/definitions.wat b/crates/wasm-compose/tests/compositions/def-mismatch/definitions.wat
deleted file mode 100644
index 7e263d14..00000000
--- a/crates/wasm-compose/tests/compositions/def-mismatch/definitions.wat
+++ /dev/null
@@ -1,4 +0,0 @@
-(component
-  (instance)
-  (export "foo" (instance 0))
-)
diff --git a/crates/wasm-compose/tests/compositions/def-mismatch/error.txt b/crates/wasm-compose/tests/compositions/def-mismatch/error.txt
deleted file mode 100644
index 984c5854..00000000
--- a/crates/wasm-compose/tests/compositions/def-mismatch/error.txt
+++ /dev/null
@@ -1,4 +0,0 @@
-failed to connect instance `$input` to definition component `tests/compositions/def-mismatch/definitions.wat`
-
-Caused by:
-    source instance export `foo` is not compatible with target instance import `foo`
diff --git a/crates/wasm-compose/tests/compositions/def-mismatch/root.wat b/crates/wasm-compose/tests/compositions/def-mismatch/root.wat
deleted file mode 100644
index 2fc7c23a..00000000
--- a/crates/wasm-compose/tests/compositions/def-mismatch/root.wat
+++ /dev/null
@@ -1,3 +0,0 @@
-(component
-  (import "foo" (instance (export "foo" (func))))
-)
diff --git a/crates/wasm-compose/tests/compositions/defs/cli.wat b/crates/wasm-compose/tests/compositions/defs/cli.wat
deleted file mode 100644
index 425e23fd..00000000
--- a/crates/wasm-compose/tests/compositions/defs/cli.wat
+++ /dev/null
@@ -1,70 +0,0 @@
-(component
-  (core module (;0;)
-    (type (;0;) (func))
-    (type (;1;) (func (result i32)))
-    (type (;2;) (func (param i32)))
-    (type (;3;) (func (param i32 i32) (result i32)))
-    (type (;4;) (func (param i32 i32 i32)))
-    (type (;5;) (func (param i32 i32 i32 i32) (result i32)))
-    (type (;6;) (func (param i32) (result i32)))
-    (type (;7;) (func (param i32 i32)))
-    (type (;8;) (func (param i32 i32 i32) (result i32)))
-    (func $__wasm_call_ctors (;0;) (type 0))
-    (func $wasi:cli-base/environment#get-environment (;1;) (type 1) (result i32)
-      i32.const 0
-    )
-    (func $cabi_post_wasi:cli-base/environment#get-environment (;2;) (type 2) (param i32))
-    (func $wasi:cli-base/environment#get-arguments (;3;) (type 1) (result i32)
-      i32.const 0
-    )
-    (func $cabi_post_wasi:cli-base/environment#get-arguments (;4;) (type 2) (param i32))
-    (func $cabi_realloc (;10;) (type 5) (param i32 i32 i32 i32) (result i32)
-      i32.const 0
-    )
-    (table (;0;) 1 1 funcref)
-    (memory (;0;) 17)
-    (global $__stack_pointer (;0;) (mut i32) i32.const 1048576)
-    (export "memory" (memory 0))
-    (export "wasi:cli-base/environment#get-environment" (func $wasi:cli-base/environment#get-environment))
-    (export "cabi_post_wasi:cli-base/environment#get-environment" (func $cabi_post_wasi:cli-base/environment#get-environment))
-    (export "wasi:cli-base/environment#get-arguments" (func $wasi:cli-base/environment#get-arguments))
-    (export "cabi_post_wasi:cli-base/environment#get-arguments" (func $cabi_post_wasi:cli-base/environment#get-arguments))
-    (export "cabi_realloc" (func $cabi_realloc))
-  )
-  (core instance (;0;) (instantiate 0))
-  (alias core export 0 "memory" (core memory (;0;)))
-  (alias core export 0 "cabi_realloc" (core func (;0;)))
-  (type (;0;) (tuple string string))
-  (type (;1;) (list 0))
-  (type (;2;) (func (result 1)))
-  (alias core export 0 "wasi:cli-base/environment#get-environment" (core func (;1;)))
-  (alias core export 0 "cabi_post_wasi:cli-base/environment#get-environment" (core func (;2;)))
-  (func (;0;) (type 2) (canon lift (core func 1) (memory 0) string-encoding=utf8 (post-return 2)))
-  (type (;3;) (list string))
-  (type (;4;) (func (result 3)))
-  (alias core export 0 "wasi:cli-base/environment#get-arguments" (core func (;3;)))
-  (alias core export 0 "cabi_post_wasi:cli-base/environment#get-arguments" (core func (;4;)))
-  (func (;1;) (type 4) (canon lift (core func 3) (memory 0) string-encoding=utf8 (post-return 4)))
-  (component (;0;)
-    (type (;0;) (tuple string string))
-    (type (;1;) (list 0))
-    (type (;2;) (func (result 1)))
-    (import "import-func-get-environment" (func (;0;) (type 2)))
-    (type (;3;) (list string))
-    (type (;4;) (func (result 3)))
-    (import "import-func-get-arguments" (func (;1;) (type 4)))
-    (type (;5;) (tuple string string))
-    (type (;6;) (list 5))
-    (type (;7;) (func (result 6)))
-    (export (;2;) "get-environment" (func 0) (func (type 7)))
-    (type (;8;) (list string))
-    (type (;9;) (func (result 8)))
-    (export (;3;) "get-arguments" (func 1) (func (type 9)))
-  )
-  (instance (;0;) (instantiate 0
-      (with "import-func-get-environment" (func 0))
-      (with "import-func-get-arguments" (func 1))
-    )
-  )
-  (export (;1;) (interface "wasi:cli-base/environment") (instance 0))
-)
diff --git a/crates/wasm-compose/tests/compositions/defs/composed.wat b/crates/wasm-compose/tests/compositions/defs/composed.wat
deleted file mode 100644
index 8c9e4844..00000000
--- a/crates/wasm-compose/tests/compositions/defs/composed.wat
+++ /dev/null
@@ -1,173 +0,0 @@
-(component
-  (component (;0;)
-    (type (;0;)
-      (instance
-        (type (;0;) (tuple string string))
-        (type (;1;) (list 0))
-        (type (;2;) (func (result 1)))
-        (export (;0;) "get-environment" (func (type 2)))
-        (type (;3;) (list string))
-        (type (;4;) (func (result 3)))
-        (export (;1;) "get-arguments" (func (type 4)))
-      )
-    )
-    (import (interface "wasi:cli-base/environment") (instance (;0;) (type 0)))
-    (type (;1;)
-      (instance)
-    )
-    (import "other1" (instance (;1;) (type 1)))
-    (type (;2;)
-      (instance)
-    )
-    (import "other2" (instance (;2;) (type 2)))
-    (core module (;0;)
-      (type (;0;) (func (param i32)))
-      (type (;1;) (func (param i32 i32 i32 i32) (result i32)))
-      (import "wasi:cli-base/environment" "get-environment" (func (;0;) (type 0)))
-      (import "wasi:cli-base/environment" "get-arguments" (func (;1;) (type 0)))
-      (func (;2;) (type 1) (param i32 i32 i32 i32) (result i32)
-        unreachable
-      )
-      (memory (;0;) 0)
-      (export "memory" (memory 0))
-      (export "cabi_realloc" (func 2))
-    )
-    (core module (;1;)
-      (type (;0;) (func (param i32)))
-      (func $indirect-wasi:cli-base/environment-get-environment (;0;) (type 0) (param i32)
-        local.get 0
-        i32.const 0
-        call_indirect (type 0)
-      )
-      (func $indirect-wasi:cli-base/environment-get-arguments (;1;) (type 0) (param i32)
-        local.get 0
-        i32.const 1
-        call_indirect (type 0)
-      )
-      (table (;0;) 2 2 funcref)
-      (export "0" (func $indirect-wasi:cli-base/environment-get-environment))
-      (export "1" (func $indirect-wasi:cli-base/environment-get-arguments))
-      (export "$imports" (table 0))
-    )
-    (core module (;2;)
-      (type (;0;) (func (param i32)))
-      (import "" "0" (func (;0;) (type 0)))
-      (import "" "1" (func (;1;) (type 0)))
-      (import "" "$imports" (table (;0;) 2 2 funcref))
-      (elem (;0;) (i32.const 0) func 0 1)
-    )
-    (core instance (;0;) (instantiate 1))
-    (alias core export 0 "0" (core func (;0;)))
-    (alias core export 0 "1" (core func (;1;)))
-    (core instance (;1;)
-      (export "get-environment" (func 0))
-      (export "get-arguments" (func 1))
-    )
-    (core instance (;2;) (instantiate 0
-        (with "wasi:cli-base/environment" (instance 1))
-      )
-    )
-    (alias core export 2 "memory" (core memory (;0;)))
-    (alias core export 2 "cabi_realloc" (core func (;2;)))
-    (alias core export 0 "$imports" (core table (;0;)))
-    (alias export 0 "get-environment" (func (;0;)))
-    (core func (;3;) (canon lower (func 0) (memory 0) (realloc 2) string-encoding=utf8))
-    (alias export 0 "get-arguments" (func (;1;)))
-    (core func (;4;) (canon lower (func 1) (memory 0) (realloc 2) string-encoding=utf8))
-    (core instance (;3;)
-      (export "$imports" (table 0))
-      (export "0" (func 3))
-      (export "1" (func 4))
-    )
-    (core instance (;4;) (instantiate 2
-        (with "" (instance 3))
-      )
-    )
-  )
-  (component (;1;)
-    (core module (;0;)
-      (type (;0;) (func))
-      (type (;1;) (func (result i32)))
-      (type (;2;) (func (param i32)))
-      (type (;3;) (func (param i32 i32) (result i32)))
-      (type (;4;) (func (param i32 i32 i32)))
-      (type (;5;) (func (param i32 i32 i32 i32) (result i32)))
-      (type (;6;) (func (param i32) (result i32)))
-      (type (;7;) (func (param i32 i32)))
-      (type (;8;) (func (param i32 i32 i32) (result i32)))
-      (func $__wasm_call_ctors (;0;) (type 0))
-      (func $wasi:cli-base/environment#get-environment (;1;) (type 1) (result i32)
-        i32.const 0
-      )
-      (func $cabi_post_wasi:cli-base/environment#get-environment (;2;) (type 2) (param i32))
-      (func $wasi:cli-base/environment#get-arguments (;3;) (type 1) (result i32)
-        i32.const 0
-      )
-      (func $cabi_post_wasi:cli-base/environment#get-arguments (;4;) (type 2) (param i32))
-      (func $cabi_realloc (;5;) (type 5) (param i32 i32 i32 i32) (result i32)
-        i32.const 0
-      )
-      (table (;0;) 1 1 funcref)
-      (memory (;0;) 17)
-      (global $__stack_pointer (;0;) (mut i32) i32.const 1048576)
-      (export "memory" (memory 0))
-      (export "wasi:cli-base/environment#get-environment" (func $wasi:cli-base/environment#get-environment))
-      (export "cabi_post_wasi:cli-base/environment#get-environment" (func $cabi_post_wasi:cli-base/environment#get-environment))
-      (export "wasi:cli-base/environment#get-arguments" (func $wasi:cli-base/environment#get-arguments))
-      (export "cabi_post_wasi:cli-base/environment#get-arguments" (func $cabi_post_wasi:cli-base/environment#get-arguments))
-      (export "cabi_realloc" (func $cabi_realloc))
-    )
-    (core instance (;0;) (instantiate 0))
-    (alias core export 0 "memory" (core memory (;0;)))
-    (alias core export 0 "cabi_realloc" (core func (;0;)))
-    (type (;0;) (tuple string string))
-    (type (;1;) (list 0))
-    (type (;2;) (func (result 1)))
-    (alias core export 0 "wasi:cli-base/environment#get-environment" (core func (;1;)))
-    (alias core export 0 "cabi_post_wasi:cli-base/environment#get-environment" (core func (;2;)))
-    (func (;0;) (type 2) (canon lift (core func 1) (memory 0) string-encoding=utf8 (post-return 2)))
-    (type (;3;) (list string))
-    (type (;4;) (func (result 3)))
-    (alias core export 0 "wasi:cli-base/environment#get-arguments" (core func (;3;)))
-    (alias core export 0 "cabi_post_wasi:cli-base/environment#get-arguments" (core func (;4;)))
-    (func (;1;) (type 4) (canon lift (core func 3) (memory 0) string-encoding=utf8 (post-return 4)))
-    (component (;0;)
-      (type (;0;) (tuple string string))
-      (type (;1;) (list 0))
-      (type (;2;) (func (result 1)))
-      (import "import-func-get-environment" (func (;0;) (type 2)))
-      (type (;3;) (list string))
-      (type (;4;) (func (result 3)))
-      (import "import-func-get-arguments" (func (;1;) (type 4)))
-      (type (;5;) (tuple string string))
-      (type (;6;) (list 5))
-      (type (;7;) (func (result 6)))
-      (export (;2;) "get-environment" (func 0) (func (type 7)))
-      (type (;8;) (list string))
-      (type (;9;) (func (result 8)))
-      (export (;3;) "get-arguments" (func 1) (func (type 9)))
-    )
-    (instance (;0;) (instantiate 0
-        (with "import-func-get-environment" (func 0))
-        (with "import-func-get-arguments" (func 1))
-      )
-    )
-    (export (;1;) (interface "wasi:cli-base/environment") (instance 0))
-  )
-  (component (;2;)
-    (instance (;0;))
-    (export (;1;) "other1" (instance 0))
-    (export (;2;) "other2" (instance 0))
-  )
-  (instance (;0;) (instantiate 2))
-  (instance (;1;) (instantiate 1))
-  (alias export 1 "wasi:cli-base/environment" (instance (;2;)))
-  (alias export 0 "other1" (instance (;3;)))
-  (alias export 0 "other2" (instance (;4;)))
-  (instance (;5;) (instantiate 0
-      (with "wasi:cli-base/environment" (instance 2))
-      (with "other1" (instance 3))
-      (with "other2" (instance 4))
-    )
-  )
-)
diff --git a/crates/wasm-compose/tests/compositions/defs/config.yml b/crates/wasm-compose/tests/compositions/defs/config.yml
deleted file mode 100644
index f6633e02..00000000
--- a/crates/wasm-compose/tests/compositions/defs/config.yml
+++ /dev/null
@@ -1 +0,0 @@
-definitions: ['cli.wat', 'other.wat']
diff --git a/crates/wasm-compose/tests/compositions/defs/other.wat b/crates/wasm-compose/tests/compositions/defs/other.wat
deleted file mode 100644
index 6670a482..00000000
--- a/crates/wasm-compose/tests/compositions/defs/other.wat
+++ /dev/null
@@ -1,5 +0,0 @@
-(component
-  (instance)
-  (export "other1" (instance 0))
-  (export "other2" (instance 0))
-)
diff --git a/crates/wasm-compose/tests/compositions/defs/root.wat b/crates/wasm-compose/tests/compositions/defs/root.wat
deleted file mode 100644
index 59a6114d..00000000
--- a/crates/wasm-compose/tests/compositions/defs/root.wat
+++ /dev/null
@@ -1,91 +0,0 @@
-(component
-  (type (;0;)
-    (instance
-      (type (;0;) (tuple string string))
-      (type (;1;) (list 0))
-      (type (;2;) (func (result 1)))
-      (export (;0;) "get-environment" (func (type 2)))
-      (type (;3;) (list string))
-      (type (;4;) (func (result 3)))
-      (export (;1;) "get-arguments" (func (type 4)))
-    )
-  )
-  (import (interface "wasi:cli-base/environment") (instance (;0;) (type 0)))
-  (import "other1" (instance (;0;)))
-  (import "other2" (instance (;0;)))
-  (core module (;0;)
-    (type (;0;) (func (param i32)))
-    (type (;1;) (func (param i32 i32 i32 i32) (result i32)))
-    (import "wasi:cli-base/environment" "get-environment" (func (;0;) (type 0)))
-    (import "wasi:cli-base/environment" "get-arguments" (func (;1;) (type 0)))
-    (func (;2;) (type 1) (param i32 i32 i32 i32) (result i32)
-      unreachable
-    )
-    (memory (;0;) 0)
-    (export "memory" (memory 0))
-    (export "cabi_realloc" (func 2))
-    (@producers
-      (processed-by "wit-component" "0.11.0")
-    )
-  )
-  (core module (;1;)
-    (type (;0;) (func (param i32)))
-    (func $indirect-wasi:cli-base/environment-get-environment (;0;) (type 0) (param i32)
-      local.get 0
-      i32.const 0
-      call_indirect (type 0)
-    )
-    (func $indirect-wasi:cli-base/environment-get-arguments (;1;) (type 0) (param i32)
-      local.get 0
-      i32.const 1
-      call_indirect (type 0)
-    )
-    (table (;0;) 2 2 funcref)
-    (export "0" (func $indirect-wasi:cli-base/environment-get-environment))
-    (export "1" (func $indirect-wasi:cli-base/environment-get-arguments))
-    (export "$imports" (table 0))
-    (@producers
-      (processed-by "wit-component" "0.11.0")
-    )
-  )
-  (core module (;2;)
-    (type (;0;) (func (param i32)))
-    (import "" "0" (func (;0;) (type 0)))
-    (import "" "1" (func (;1;) (type 0)))
-    (import "" "$imports" (table (;0;) 2 2 funcref))
-    (elem (;0;) (i32.const 0) func 0 1)
-    (@producers
-      (processed-by "wit-component" "0.11.0")
-    )
-  )
-  (core instance (;0;) (instantiate 1))
-  (alias core export 0 "0" (core func (;0;)))
-  (alias core export 0 "1" (core func (;1;)))
-  (core instance (;1;)
-    (export "get-environment" (func 0))
-    (export "get-arguments" (func 1))
-  )
-  (core instance (;2;) (instantiate 0
-      (with "wasi:cli-base/environment" (instance 1))
-    )
-  )
-  (alias core export 2 "memory" (core memory (;0;)))
-  (alias core export 2 "cabi_realloc" (core func (;2;)))
-  (alias core export 0 "$imports" (core table (;0;)))
-  (alias export 0 "get-environment" (func (;0;)))
-  (core func (;3;) (canon lower (func 0) (memory 0) (realloc 2) string-encoding=utf8))
-  (alias export 0 "get-arguments" (func (;1;)))
-  (core func (;4;) (canon lower (func 1) (memory 0) (realloc 2) string-encoding=utf8))
-  (@producers
-    (processed-by "wit-component" "0.11.0")
-  )
-  (core instance (;3;)
-    (export "$imports" (table 0))
-    (export "0" (func 3))
-    (export "1" (func 4))
-  )
-  (core instance (;4;) (instantiate 2
-      (with "" (instance 3))
-    )
-  )
-)
\ No newline at end of file
diff --git a/crates/wasm-compose/tests/compositions/missing-explicit-dep/error.txt b/crates/wasm-compose/tests/compositions/missing-explicit-dep/error.txt
index ed7bb681..36521b69 100644
--- a/crates/wasm-compose/tests/compositions/missing-explicit-dep/error.txt
+++ b/crates/wasm-compose/tests/compositions/missing-explicit-dep/error.txt
@@ -1,5 +1,5 @@
 failed to parse component `tests/compositions/missing-explicit-dep/a.wat`
 
 Caused by:
-    0: failed to read from `tests/compositions/missing-explicit-dep/a.wat`
-    1: platform-specific error
+    0: failed to read from `tests/compositions/missing-explicit-dep/a.wat`: No such file or directory (os error 2)
+    1: No such file or directory (os error 2)
diff --git a/crates/wasm-compose/tests/compositions/missing-root/error.txt b/crates/wasm-compose/tests/compositions/missing-root/error.txt
index d3d92144..8778fc12 100644
--- a/crates/wasm-compose/tests/compositions/missing-root/error.txt
+++ b/crates/wasm-compose/tests/compositions/missing-root/error.txt
@@ -1,5 +1,5 @@
 failed to parse component `tests/compositions/missing-root/root.wat`
 
 Caused by:
-    0: failed to read from `tests/compositions/missing-root/root.wat`
-    1: platform-specific error
+    0: failed to read from `tests/compositions/missing-root/root.wat`: No such file or directory (os error 2)
+    1: No such file or directory (os error 2)
diff --git a/crates/wasm-compose/tests/compositions/url-mismatch/b.wat b/crates/wasm-compose/tests/compositions/url-mismatch/b.wat
new file mode 100644
index 00000000..9018fcc7
--- /dev/null
+++ b/crates/wasm-compose/tests/compositions/url-mismatch/b.wat
@@ -0,0 +1,3 @@
+(component
+  (import "a" "http://example.com/bar" (instance))
+)
diff --git a/crates/wasm-compose/tests/compositions/url-mismatch/error.txt b/crates/wasm-compose/tests/compositions/url-mismatch/error.txt
new file mode 100644
index 00000000..956919f9
--- /dev/null
+++ b/crates/wasm-compose/tests/compositions/url-mismatch/error.txt
@@ -0,0 +1 @@
+cannot import instance with name `a` because import URL `http://example.com/foo` conflicts with `http://example.com/bar`
diff --git a/crates/wasm-compose/tests/compositions/url-mismatch/root.wat b/crates/wasm-compose/tests/compositions/url-mismatch/root.wat
new file mode 100644
index 00000000..0c1f4c11
--- /dev/null
+++ b/crates/wasm-compose/tests/compositions/url-mismatch/root.wat
@@ -0,0 +1,4 @@
+(component
+  (import "a" "http://example.com/foo" (instance))
+  (import "b" (instance))
+)
diff --git a/crates/wasm-encoder/Cargo.toml b/crates/wasm-encoder/Cargo.toml
index 120cbc22..077d7fa3 100644
--- a/crates/wasm-encoder/Cargo.toml
+++ b/crates/wasm-encoder/Cargo.toml
@@ -1,6 +1,6 @@
 [package]
 name = "wasm-encoder"
-version = "0.30.0"
+version = "0.25.0"
 authors = ["Nick Fitzgerald <fitzgen@gmail.com>"]
 edition.workspace = true
 license = "Apache-2.0 WITH LLVM-exception"
diff --git a/crates/wasm-encoder/src/component.rs b/crates/wasm-encoder/src/component.rs
index 68ee1b64..5f92a91f 100644
--- a/crates/wasm-encoder/src/component.rs
+++ b/crates/wasm-encoder/src/component.rs
@@ -113,7 +113,7 @@ impl Component {
         // Magic
         0x00, 0x61, 0x73, 0x6D,
         // Version
-        0x0d, 0x00, 0x01, 0x00,
+        0x0c, 0x00, 0x01, 0x00,
     ];
 
     /// Begin writing a new `Component`.
diff --git a/crates/wasm-encoder/src/component/canonicals.rs b/crates/wasm-encoder/src/component/canonicals.rs
index 340d9ca6..e81819c4 100644
--- a/crates/wasm-encoder/src/component/canonicals.rs
+++ b/crates/wasm-encoder/src/component/canonicals.rs
@@ -118,32 +118,6 @@ impl CanonicalFunctionSection {
         self.num_added += 1;
         self
     }
-
-    /// Defines a function which will create an owned handle to the resource
-    /// specified by `ty_index`.
-    pub fn resource_new(&mut self, ty_index: u32) -> &mut Self {
-        self.bytes.push(0x02);
-        ty_index.encode(&mut self.bytes);
-        self.num_added += 1;
-        self
-    }
-
-    /// Defines a function which will drop the specified type of handle.
-    pub fn resource_drop(&mut self, ty_index: u32) -> &mut Self {
-        self.bytes.push(0x03);
-        ty_index.encode(&mut self.bytes);
-        self.num_added += 1;
-        self
-    }
-
-    /// Defines a function which will return the representation of the specified
-    /// resource type.
-    pub fn resource_rep(&mut self, ty_index: u32) -> &mut Self {
-        self.bytes.push(0x04);
-        ty_index.encode(&mut self.bytes);
-        self.num_added += 1;
-        self
-    }
 }
 
 impl Encode for CanonicalFunctionSection {
diff --git a/crates/wasm-encoder/src/component/exports.rs b/crates/wasm-encoder/src/component/exports.rs
index 09f9e251..9720d51b 100644
--- a/crates/wasm-encoder/src/component/exports.rs
+++ b/crates/wasm-encoder/src/component/exports.rs
@@ -2,10 +2,7 @@ use super::{
     COMPONENT_SORT, CORE_MODULE_SORT, CORE_SORT, FUNCTION_SORT, INSTANCE_SORT, TYPE_SORT,
     VALUE_SORT,
 };
-use crate::{
-    encode_section, AsComponentExternName, ComponentSection, ComponentSectionId, ComponentTypeRef,
-    Encode,
-};
+use crate::{encode_section, ComponentSection, ComponentSectionId, ComponentTypeRef, Encode};
 
 /// Represents the kind of an export from a WebAssembly component.
 #[derive(Clone, Copy, Debug, Eq, PartialEq)]
@@ -55,12 +52,11 @@ impl Encode for ComponentExportKind {
 /// # Example
 ///
 /// ```rust
-/// use wasm_encoder::{Component, ComponentExportSection, ComponentExportKind, ComponentExternName};
+/// use wasm_encoder::{Component, ComponentExportSection, ComponentExportKind};
 ///
 /// // This exports a function named "foo"
 /// let mut exports = ComponentExportSection::new();
-/// let name = ComponentExternName::Kebab("foo");
-/// exports.export(name, ComponentExportKind::Func, 0, None);
+/// exports.export("foo", "", ComponentExportKind::Func, 0, None);
 ///
 /// let mut component = Component::new();
 /// component.section(&exports);
@@ -92,12 +88,14 @@ impl ComponentExportSection {
     /// Define an export in the export section.
     pub fn export(
         &mut self,
-        name: impl AsComponentExternName,
+        name: &str,
+        url: &str,
         kind: ComponentExportKind,
         index: u32,
         ty: Option<ComponentTypeRef>,
     ) -> &mut Self {
-        name.as_component_extern_name().encode(&mut self.bytes);
+        name.encode(&mut self.bytes);
+        url.encode(&mut self.bytes);
         kind.encode(&mut self.bytes);
         index.encode(&mut self.bytes);
         match ty {
diff --git a/crates/wasm-encoder/src/component/imports.rs b/crates/wasm-encoder/src/component/imports.rs
index fe611a01..8d843407 100644
--- a/crates/wasm-encoder/src/component/imports.rs
+++ b/crates/wasm-encoder/src/component/imports.rs
@@ -6,20 +6,14 @@ use crate::{
 /// Represents the possible type bounds for type references.
 #[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
 pub enum TypeBounds {
-    /// The type is bounded by equality to the type index specified.
-    Eq(u32),
-    /// This type is a fresh resource type,
-    SubResource,
+    /// The type is bounded by equality.
+    Eq,
 }
 
 impl Encode for TypeBounds {
     fn encode(&self, sink: &mut Vec<u8>) {
         match self {
-            Self::Eq(i) => {
-                sink.push(0x00);
-                i.encode(sink);
-            }
-            Self::SubResource => sink.push(0x01),
+            Self::Eq => sink.push(0x00),
         }
     }
 }
@@ -38,7 +32,9 @@ pub enum ComponentTypeRef {
     /// The reference is to a value type.
     Value(ComponentValType),
     /// The reference is to a bounded type.
-    Type(TypeBounds),
+    ///
+    /// The index is expected to be a type index.
+    Type(TypeBounds, u32),
     /// The reference is to an instance type.
     ///
     /// The index is expected to be a type index to an instance type.
@@ -72,7 +68,10 @@ impl Encode for ComponentTypeRef {
                 idx.encode(sink);
             }
             Self::Value(ty) => ty.encode(sink),
-            Self::Type(bounds) => bounds.encode(sink),
+            Self::Type(bounds, idx) => {
+                bounds.encode(sink);
+                idx.encode(sink);
+            }
         }
     }
 }
@@ -82,7 +81,7 @@ impl Encode for ComponentTypeRef {
 /// # Example
 ///
 /// ```rust
-/// use wasm_encoder::{Component, ComponentTypeSection, PrimitiveValType, ComponentImportSection, ComponentTypeRef, ComponentExternName};
+/// use wasm_encoder::{Component, ComponentTypeSection, PrimitiveValType, ComponentImportSection, ComponentTypeRef};
 ///
 /// let mut types = ComponentTypeSection::new();
 ///
@@ -99,8 +98,7 @@ impl Encode for ComponentTypeRef {
 ///
 /// // This imports a function named `f` with the type defined above
 /// let mut imports = ComponentImportSection::new();
-/// let name = ComponentExternName::Kebab("f");
-/// imports.import(name, ComponentTypeRef::Func(0));
+/// imports.import("f", "", ComponentTypeRef::Func(0));
 ///
 /// let mut component = Component::new();
 /// component.section(&types);
@@ -131,8 +129,9 @@ impl ComponentImportSection {
     }
 
     /// Define an import in the component import section.
-    pub fn import(&mut self, name: impl AsComponentExternName, ty: ComponentTypeRef) -> &mut Self {
-        name.as_component_extern_name().encode(&mut self.bytes);
+    pub fn import(&mut self, name: &str, url: &str, ty: ComponentTypeRef) -> &mut Self {
+        name.encode(&mut self.bytes);
+        url.encode(&mut self.bytes);
         ty.encode(&mut self.bytes);
         self.num_added += 1;
         self
@@ -150,51 +149,3 @@ impl ComponentSection for ComponentImportSection {
         ComponentSectionId::Import.into()
     }
 }
-
-/// The different names that can be assigned to component imports
-#[derive(Debug, Copy, Clone)]
-pub enum ComponentExternName<'a> {
-    /// This is a "kebab name" along the lines of "a-foo-bar"
-    Kebab(&'a str),
-    /// This is an ID along the lines of "wasi:http/types@2.0"
-    Interface(&'a str),
-}
-
-impl Encode for ComponentExternName<'_> {
-    fn encode(&self, sink: &mut Vec<u8>) {
-        match self {
-            ComponentExternName::Kebab(name) => {
-                sink.push(0x00);
-                name.encode(sink);
-            }
-            ComponentExternName::Interface(name) => {
-                sink.push(0x01);
-                name.encode(sink);
-            }
-        }
-    }
-}
-
-/// Helper trait to convert into a `ComponentExternName` either from that type
-/// or from a string.
-pub trait AsComponentExternName {
-    /// Converts this receiver into a `ComponentExternName`.
-    fn as_component_extern_name(&self) -> ComponentExternName<'_>;
-}
-
-impl AsComponentExternName for ComponentExternName<'_> {
-    fn as_component_extern_name(&self) -> ComponentExternName<'_> {
-        *self
-    }
-}
-
-impl<S: AsRef<str>> AsComponentExternName for S {
-    fn as_component_extern_name(&self) -> ComponentExternName<'_> {
-        let s = self.as_ref();
-        if s.contains("/") {
-            ComponentExternName::Interface(s)
-        } else {
-            ComponentExternName::Kebab(s)
-        }
-    }
-}
diff --git a/crates/wasm-encoder/src/component/instances.rs b/crates/wasm-encoder/src/component/instances.rs
index d2a8e4e7..5f2c97de 100644
--- a/crates/wasm-encoder/src/component/instances.rs
+++ b/crates/wasm-encoder/src/component/instances.rs
@@ -1,7 +1,6 @@
 use super::CORE_INSTANCE_SORT;
 use crate::{
-    encode_section, ComponentExportKind, ComponentExternName, ComponentSection, ComponentSectionId,
-    Encode, ExportKind,
+    encode_section, ComponentExportKind, ComponentSection, ComponentSectionId, Encode, ExportKind,
 };
 
 /// Represents an argument to a module instantiation.
@@ -115,10 +114,10 @@ impl ComponentSection for InstanceSection {
 /// # Example
 ///
 /// ```rust
-/// use wasm_encoder::{Component, ComponentInstanceSection, ComponentExportKind, ComponentExternName};
+/// use wasm_encoder::{Component, ComponentInstanceSection, ComponentExportKind};
 ///
 /// let mut instances = ComponentInstanceSection::new();
-/// instances.export_items([(ComponentExternName::Kebab("foo"), ComponentExportKind::Func, 0)]);
+/// instances.export_items([("foo", ComponentExportKind::Func, 0)]);
 /// instances.instantiate(1, [("foo", ComponentExportKind::Instance, 0)]);
 ///
 /// let mut component = Component::new();
@@ -171,7 +170,7 @@ impl ComponentInstanceSection {
     /// Define an instance by exporting items.
     pub fn export_items<'a, E>(&mut self, exports: E) -> &mut Self
     where
-        E: IntoIterator<Item = (ComponentExternName<'a>, ComponentExportKind, u32)>,
+        E: IntoIterator<Item = (&'a str, ComponentExportKind, u32)>,
         E::IntoIter: ExactSizeIterator,
     {
         let exports = exports.into_iter();
diff --git a/crates/wasm-encoder/src/component/names.rs b/crates/wasm-encoder/src/component/names.rs
index 99db10bd..0e3b02dc 100644
--- a/crates/wasm-encoder/src/component/names.rs
+++ b/crates/wasm-encoder/src/component/names.rs
@@ -1,5 +1,3 @@
-use std::borrow::Cow;
-
 use super::*;
 use crate::{encoding_size, CustomSection, Encode, ExportKind, NameMap, SectionId};
 
@@ -130,8 +128,8 @@ impl ComponentNameSection {
     /// View the encoded section as a CustomSection.
     pub fn as_custom<'a>(&'a self) -> CustomSection<'a> {
         CustomSection {
-            name: "component-name".into(),
-            data: Cow::Borrowed(&self.bytes),
+            name: "component-name",
+            data: &self.bytes,
         }
     }
 }
diff --git a/crates/wasm-encoder/src/component/types.rs b/crates/wasm-encoder/src/component/types.rs
index 14e8a993..930467d5 100644
--- a/crates/wasm-encoder/src/component/types.rs
+++ b/crates/wasm-encoder/src/component/types.rs
@@ -1,7 +1,7 @@
 use super::CORE_TYPE_SORT;
 use crate::{
-    encode_section, Alias, AsComponentExternName, ComponentExportKind, ComponentOuterAliasKind,
-    ComponentSection, ComponentSectionId, ComponentTypeRef, Encode, EntityType, ValType,
+    encode_section, Alias, ComponentExportKind, ComponentOuterAliasKind, ComponentSection,
+    ComponentSectionId, ComponentTypeRef, Encode, EntityType, ValType,
 };
 
 /// Represents the type of a core module.
@@ -245,9 +245,10 @@ impl ComponentType {
     }
 
     /// Defines an import in this component type.
-    pub fn import(&mut self, name: impl AsComponentExternName, ty: ComponentTypeRef) -> &mut Self {
+    pub fn import(&mut self, name: &str, url: &str, ty: ComponentTypeRef) -> &mut Self {
         self.bytes.push(0x03);
-        name.as_component_extern_name().encode(&mut self.bytes);
+        name.encode(&mut self.bytes);
+        url.encode(&mut self.bytes);
         ty.encode(&mut self.bytes);
         self.num_added += 1;
         match ty {
@@ -258,9 +259,10 @@ impl ComponentType {
     }
 
     /// Defines an export in this component type.
-    pub fn export(&mut self, name: impl AsComponentExternName, ty: ComponentTypeRef) -> &mut Self {
+    pub fn export(&mut self, name: &str, url: &str, ty: ComponentTypeRef) -> &mut Self {
         self.bytes.push(0x04);
-        name.as_component_extern_name().encode(&mut self.bytes);
+        name.encode(&mut self.bytes);
+        url.encode(&mut self.bytes);
         ty.encode(&mut self.bytes);
         self.num_added += 1;
         match ty {
@@ -322,8 +324,8 @@ impl InstanceType {
     }
 
     /// Defines an export in this instance type.
-    pub fn export(&mut self, name: impl AsComponentExternName, ty: ComponentTypeRef) -> &mut Self {
-        self.0.export(name, ty);
+    pub fn export(&mut self, name: &str, url: &str, ty: ComponentTypeRef) -> &mut Self {
+        self.0.export(name, url, ty);
         self
     }
 
@@ -440,19 +442,6 @@ impl<'a> ComponentTypeEncoder<'a> {
     pub fn defined_type(self) -> ComponentDefinedTypeEncoder<'a> {
         ComponentDefinedTypeEncoder(self.0)
     }
-
-    /// Define a resource type.
-    pub fn resource(self, rep: ValType, dtor: Option<u32>) {
-        self.0.push(0x3f);
-        rep.encode(self.0);
-        match dtor {
-            Some(i) => {
-                self.0.push(0x01);
-                i.encode(self.0);
-            }
-            None => self.0.push(0x00),
-        }
-    }
 }
 
 /// Represents a primitive component value type.
@@ -650,18 +639,6 @@ impl ComponentDefinedTypeEncoder<'_> {
         ok.encode(self.0);
         err.encode(self.0);
     }
-
-    /// Define a `own` handle type
-    pub fn own(self, idx: u32) {
-        self.0.push(0x69);
-        idx.encode(self.0);
-    }
-
-    /// Define a `borrow` handle type
-    pub fn borrow(self, idx: u32) {
-        self.0.push(0x68);
-        idx.encode(self.0);
-    }
 }
 
 /// An encoder for the type section of WebAssembly components.
@@ -744,12 +721,6 @@ impl ComponentTypeSection {
     pub fn defined_type(&mut self) -> ComponentDefinedTypeEncoder<'_> {
         self.ty().defined_type()
     }
-
-    /// Defines a new resource type.
-    pub fn resource(&mut self, rep: ValType, dtor: Option<u32>) -> &mut Self {
-        self.ty().resource(rep, dtor);
-        self
-    }
 }
 
 impl Encode for ComponentTypeSection {
diff --git a/crates/wasm-encoder/src/core.rs b/crates/wasm-encoder/src/core.rs
index feccfdef..dcf4d6fb 100644
--- a/crates/wasm-encoder/src/core.rs
+++ b/crates/wasm-encoder/src/core.rs
@@ -1,7 +1,6 @@
 mod code;
 mod custom;
 mod data;
-mod dump;
 mod elements;
 mod exports;
 mod functions;
@@ -19,7 +18,6 @@ mod types;
 pub use code::*;
 pub use custom::*;
 pub use data::*;
-pub use dump::*;
 pub use elements::*;
 pub use exports::*;
 pub use functions::*;
diff --git a/crates/wasm-encoder/src/core/code.rs b/crates/wasm-encoder/src/core/code.rs
index 391c7b3f..cf807c29 100644
--- a/crates/wasm-encoder/src/core/code.rs
+++ b/crates/wasm-encoder/src/core/code.rs
@@ -322,9 +322,9 @@ pub enum Instruction<'a> {
     BrOnNonNull(u32),
     Return,
     Call(u32),
-    CallRef(u32),
+    CallRef(HeapType),
     CallIndirect { ty: u32, table: u32 },
-    ReturnCallRef(u32),
+    ReturnCallRef(HeapType),
     ReturnCall(u32),
     ReturnCallIndirect { ty: u32, table: u32 },
     Throw(u32),
@@ -522,11 +522,6 @@ pub enum Instruction<'a> {
     RefFunc(u32),
     RefAsNonNull,
 
-    // GC types instructions.
-    I31New,
-    I31GetS,
-    I31GetU,
-
     // Bulk memory instructions.
     TableInit { elem_index: u32, table: u32 },
     ElemDrop(u32),
@@ -865,6 +860,14 @@ pub enum Instruction<'a> {
     I64AtomicRmw8CmpxchgU(MemArg),
     I64AtomicRmw16CmpxchgU(MemArg),
     I64AtomicRmw32CmpxchgU(MemArg),
+
+    // Typed continuations proposal
+    ContNew(u32),
+    ContBind(u32),
+    Suspend(u32),
+    Resume(Cow<'a, [(u32, u32)]>),
+    ResumeThrow(u32, Cow<'a, [(u32, u32)]>),
+    Barrier(BlockType),
 }
 
 impl Encode for Instruction<'_> {
@@ -1320,20 +1323,6 @@ impl Encode for Instruction<'_> {
             }
             Instruction::RefAsNonNull => sink.push(0xD3),
 
-            // GC instructions.
-            Instruction::I31New => {
-                sink.push(0xfb);
-                sink.push(0x20)
-            }
-            Instruction::I31GetS => {
-                sink.push(0xfb);
-                sink.push(0x21)
-            }
-            Instruction::I31GetU => {
-                sink.push(0xfb);
-                sink.push(0x22)
-            }
-
             // Bulk memory instructions.
             Instruction::TableInit { elem_index, table } => {
                 sink.push(0xfc);
@@ -2803,6 +2792,24 @@ impl Encode for Instruction<'_> {
                 sink.push(0x4E);
                 memarg.encode(sink);
             }
+            Instruction::ContNew(_type_index) => {
+                todo!()
+            }
+            Instruction::ContBind(_type_index) => {
+                todo!()
+            }
+            Instruction::Suspend(_tag_index) => {
+                todo!()
+            }
+            Instruction::Resume(ref _resumetable) => {
+                todo!()
+            }
+            Instruction::ResumeThrow(_tag_index, ref _resumetable) => {
+                todo!()
+            }
+            Instruction::Barrier(_blockty) => {
+                todo!()
+            }
         }
     }
 }
diff --git a/crates/wasm-encoder/src/core/custom.rs b/crates/wasm-encoder/src/core/custom.rs
index e05ce01d..47d78d45 100644
--- a/crates/wasm-encoder/src/core/custom.rs
+++ b/crates/wasm-encoder/src/core/custom.rs
@@ -1,14 +1,12 @@
-use std::borrow::Cow;
-
 use crate::{encoding_size, Encode, Section, SectionId};
 
 /// A custom section holding arbitrary data.
 #[derive(Clone, Debug)]
 pub struct CustomSection<'a> {
     /// The name of this custom section.
-    pub name: Cow<'a, str>,
+    pub name: &'a str,
     /// This custom section's data.
-    pub data: Cow<'a, [u8]>,
+    pub data: &'a [u8],
 }
 
 impl Encode for CustomSection<'_> {
@@ -16,7 +14,7 @@ impl Encode for CustomSection<'_> {
         let encoded_name_len = encoding_size(u32::try_from(self.name.len()).unwrap());
         (encoded_name_len + self.name.len() + self.data.len()).encode(sink);
         self.name.encode(sink);
-        sink.extend(&*self.data);
+        sink.extend(self.data);
     }
 }
 
@@ -33,8 +31,8 @@ mod tests {
     #[test]
     fn test_custom_section() {
         let custom = CustomSection {
-            name: "test".into(),
-            data: Cow::Borrowed(&[11, 22, 33, 44]),
+            name: "test",
+            data: &[11, 22, 33, 44],
         };
 
         let mut encoded = vec![];
diff --git a/crates/wasm-encoder/src/core/dump.rs b/crates/wasm-encoder/src/core/dump.rs
deleted file mode 100644
index ee3d2299..00000000
--- a/crates/wasm-encoder/src/core/dump.rs
+++ /dev/null
@@ -1,627 +0,0 @@
-use std::borrow::Cow;
-
-use crate::{CustomSection, Encode, Section};
-
-/// The "core" custom section for coredumps, as described in the
-/// [tool-conventions
-/// repository](https://github.com/WebAssembly/tool-conventions/blob/main/Coredump.md).
-///
-/// There are four sections that comprise a core dump:
-///     - "core", which contains the name of the core dump
-///     - "coremodules", a listing of modules
-///     - "coreinstances", a listing of module instances
-///     - "corestack", a listing of frames for a specific thread
-///
-/// # Example of how these could be constructed and encoded into a module:
-///
-/// ```
-/// use wasm_encoder::{
-///     CoreDumpInstancesSection, CoreDumpModulesSection, CoreDumpSection, CoreDumpStackSection,
-///     CoreDumpValue, Module,
-/// };
-/// let core = CoreDumpSection::new("MyModule.wasm");
-///
-/// let mut modules = CoreDumpModulesSection::new();
-/// modules.module("my_module");
-///
-/// let mut instances = CoreDumpInstancesSection::new();
-/// let module_idx = 0;
-/// let memories = vec![1];
-/// let globals = vec![2];
-/// instances.instance(module_idx, memories, globals);
-///
-/// let mut thread = CoreDumpStackSection::new("main");
-/// let instance_index = 0;
-/// let func_index = 42;
-/// let code_offset = 0x1234;
-/// let locals = vec![CoreDumpValue::I32(1)];
-/// let stack = vec![CoreDumpValue::I32(2)];
-/// thread.frame(instance_index, func_index, code_offset, locals, stack);
-///
-/// let mut module = Module::new();
-/// module.section(&core);
-/// module.section(&modules);
-/// module.section(&instances);
-/// module.section(&thread);
-/// ```
-#[derive(Clone, Debug, Default)]
-pub struct CoreDumpSection {
-    name: String,
-}
-
-impl CoreDumpSection {
-    /// Create a new core dump section encoder
-    pub fn new(name: impl Into<String>) -> Self {
-        let name = name.into();
-        CoreDumpSection { name }
-    }
-
-    /// View the encoded section as a CustomSection.
-    fn as_custom<'a>(&'a self) -> CustomSection<'a> {
-        let mut data = vec![0];
-        self.name.encode(&mut data);
-        CustomSection {
-            name: "core".into(),
-            data: Cow::Owned(data),
-        }
-    }
-}
-
-impl Encode for CoreDumpSection {
-    fn encode(&self, sink: &mut Vec<u8>) {
-        self.as_custom().encode(sink);
-    }
-}
-
-impl Section for CoreDumpSection {
-    fn id(&self) -> u8 {
-        crate::core::SectionId::Custom as u8
-    }
-}
-
-/// The "coremodules" custom section for coredumps which lists the names of the
-/// modules
-///
-/// # Example
-///
-/// ```
-/// use wasm_encoder::{CoreDumpModulesSection, Module};
-/// let mut modules_section = CoreDumpModulesSection::new();
-/// modules_section.module("my_module");
-/// let mut module = Module::new();
-/// module.section(&modules_section);
-/// ```
-#[derive(Debug)]
-pub struct CoreDumpModulesSection {
-    num_added: u32,
-    bytes: Vec<u8>,
-}
-
-impl CoreDumpModulesSection {
-    /// Create a new core dump modules section encoder.
-    pub fn new() -> Self {
-        CoreDumpModulesSection {
-            bytes: vec![],
-            num_added: 0,
-        }
-    }
-
-    /// View the encoded section as a CustomSection.
-    pub fn as_custom(&self) -> CustomSection<'_> {
-        let mut data = vec![];
-        self.num_added.encode(&mut data);
-        data.extend(self.bytes.iter().copied());
-        CustomSection {
-            name: "coremodules".into(),
-            data: Cow::Owned(data),
-        }
-    }
-
-    /// Encode a module name into the section's bytes.
-    pub fn module(&mut self, module_name: impl AsRef<str>) -> &mut Self {
-        self.bytes.push(0x0);
-        module_name.as_ref().encode(&mut self.bytes);
-        self.num_added += 1;
-        self
-    }
-
-    /// The number of modules that are encoded in the section.
-    pub fn len(&self) -> u32 {
-        self.num_added
-    }
-}
-
-impl Encode for CoreDumpModulesSection {
-    fn encode(&self, sink: &mut Vec<u8>) {
-        self.as_custom().encode(sink);
-    }
-}
-
-impl Section for CoreDumpModulesSection {
-    fn id(&self) -> u8 {
-        crate::core::SectionId::Custom as u8
-    }
-}
-
-/// The "coreinstances" section for the core dump
-#[derive(Debug)]
-pub struct CoreDumpInstancesSection {
-    num_added: u32,
-    bytes: Vec<u8>,
-}
-
-impl CoreDumpInstancesSection {
-    /// Create a new core dump instances section encoder.
-    pub fn new() -> Self {
-        CoreDumpInstancesSection {
-            bytes: vec![],
-            num_added: 0,
-        }
-    }
-
-    /// View the encoded section as a CustomSection.
-    pub fn as_custom(&self) -> CustomSection<'_> {
-        let mut data = vec![];
-        self.num_added.encode(&mut data);
-        data.extend(self.bytes.iter().copied());
-        CustomSection {
-            name: "coreinstances".into(),
-            data: Cow::Owned(data),
-        }
-    }
-
-    /// Encode an instance into the section's bytes.
-    pub fn instance<M, G>(&mut self, module_index: u32, memories: M, globals: G) -> &mut Self
-    where
-        M: IntoIterator<Item = u32>,
-        <M as IntoIterator>::IntoIter: ExactSizeIterator,
-        G: IntoIterator<Item = u32>,
-        <G as IntoIterator>::IntoIter: ExactSizeIterator,
-    {
-        self.bytes.push(0x0);
-        module_index.encode(&mut self.bytes);
-        crate::encode_vec(memories, &mut self.bytes);
-        crate::encode_vec(globals, &mut self.bytes);
-        self.num_added += 1;
-        self
-    }
-
-    /// The number of modules that are encoded in the section.
-    pub fn len(&self) -> u32 {
-        self.num_added
-    }
-}
-
-impl Encode for CoreDumpInstancesSection {
-    fn encode(&self, sink: &mut Vec<u8>) {
-        self.as_custom().encode(sink);
-    }
-}
-
-impl Section for CoreDumpInstancesSection {
-    fn id(&self) -> u8 {
-        crate::core::SectionId::Custom as u8
-    }
-}
-
-/// A "corestack" custom section as described in the [tool-conventions
-/// repository](https://github.com/WebAssembly/tool-conventions/blob/main/Coredump.md)
-///
-/// # Example
-///
-/// ```
-/// use wasm_encoder::{CoreDumpStackSection, Module, CoreDumpValue};
-/// let mut thread = CoreDumpStackSection::new("main");
-///
-/// let instance_index = 0;
-/// let func_index = 42;
-/// let code_offset = 0x1234;
-/// let locals = vec![CoreDumpValue::I32(1)];
-/// let stack = vec![CoreDumpValue::I32(2)];
-/// thread.frame(instance_index, func_index, code_offset, locals, stack);
-///
-/// let mut module = Module::new();
-/// module.section(&thread);
-/// ```
-#[derive(Clone, Debug, Default)]
-pub struct CoreDumpStackSection {
-    frame_bytes: Vec<u8>,
-    count: u32,
-    name: String,
-}
-
-impl CoreDumpStackSection {
-    /// Create a new core dump stack section encoder.
-    pub fn new(name: impl Into<String>) -> Self {
-        let name = name.into();
-        CoreDumpStackSection {
-            frame_bytes: Vec::new(),
-            count: 0,
-            name,
-        }
-    }
-
-    /// Add a stack frame to this coredump stack section.
-    pub fn frame<L, S>(
-        &mut self,
-        instanceidx: u32,
-        funcidx: u32,
-        codeoffset: u32,
-        locals: L,
-        stack: S,
-    ) -> &mut Self
-    where
-        L: IntoIterator<Item = CoreDumpValue>,
-        <L as IntoIterator>::IntoIter: ExactSizeIterator,
-        S: IntoIterator<Item = CoreDumpValue>,
-        <S as IntoIterator>::IntoIter: ExactSizeIterator,
-    {
-        self.count += 1;
-        self.frame_bytes.push(0);
-        instanceidx.encode(&mut self.frame_bytes);
-        funcidx.encode(&mut self.frame_bytes);
-        codeoffset.encode(&mut self.frame_bytes);
-        crate::encode_vec(locals, &mut self.frame_bytes);
-        crate::encode_vec(stack, &mut self.frame_bytes);
-        self
-    }
-
-    /// View the encoded section as a CustomSection.
-    pub fn as_custom<'a>(&'a self) -> CustomSection<'a> {
-        let mut data = vec![0];
-        self.name.encode(&mut data);
-        self.count.encode(&mut data);
-        data.extend(&self.frame_bytes);
-        CustomSection {
-            name: "corestack".into(),
-            data: Cow::Owned(data),
-        }
-    }
-}
-
-impl Encode for CoreDumpStackSection {
-    fn encode(&self, sink: &mut Vec<u8>) {
-        self.as_custom().encode(sink);
-    }
-}
-
-impl Section for CoreDumpStackSection {
-    fn id(&self) -> u8 {
-        crate::core::SectionId::Custom as u8
-    }
-}
-
-/// Local and stack values are encoded using one byte for the type (similar to
-/// Wasm's Number Types) followed by bytes representing the actual value
-/// See the tool-conventions repo for more details.
-#[derive(Clone, Debug)]
-pub enum CoreDumpValue {
-    /// a missing value (usually missing because it was optimized out)
-    Missing,
-    /// An i32 value
-    I32(i32),
-    /// An i64 value
-    I64(i64),
-    /// An f32 value
-    F32(f32),
-    /// An f64 value
-    F64(f64),
-}
-
-impl Encode for CoreDumpValue {
-    fn encode(&self, sink: &mut Vec<u8>) {
-        match self {
-            CoreDumpValue::Missing => sink.push(0x01),
-            CoreDumpValue::I32(x) => {
-                sink.push(0x7F);
-                x.encode(sink);
-            }
-            CoreDumpValue::I64(x) => {
-                sink.push(0x7E);
-                x.encode(sink);
-            }
-            CoreDumpValue::F32(x) => {
-                sink.push(0x7D);
-                x.encode(sink);
-            }
-            CoreDumpValue::F64(x) => {
-                sink.push(0x7C);
-                x.encode(sink);
-            }
-        }
-    }
-}
-
-#[cfg(test)]
-mod tests {
-    use super::*;
-    use crate::Module;
-    use wasmparser::{BinaryReader, FromReader, Parser, Payload};
-
-    // Create new core dump section and test whether it is properly encoded and
-    // parsed back out by wasmparser
-    #[test]
-    fn test_roundtrip_core() {
-        let core = CoreDumpSection::new("test.wasm");
-        let mut module = Module::new();
-        module.section(&core);
-
-        let wasm_bytes = module.finish();
-
-        let mut parser = Parser::new(0).parse_all(&wasm_bytes);
-        match parser.next() {
-            Some(Ok(Payload::Version { .. })) => {}
-            _ => panic!(""),
-        }
-
-        let payload = parser
-            .next()
-            .expect("parser is not empty")
-            .expect("element is a payload");
-        match payload {
-            Payload::CustomSection(section) => {
-                assert_eq!(section.name(), "core");
-                let core = wasmparser::CoreDumpSection::from_reader(&mut BinaryReader::new(
-                    section.data(),
-                ))
-                .expect("data is readable into a core dump section");
-                assert_eq!(core.name, "test.wasm");
-            }
-            _ => panic!("unexpected payload"),
-        }
-    }
-
-    #[test]
-    fn test_roundtrip_coremodules() {
-        let mut coremodules = CoreDumpModulesSection::new();
-        coremodules.module("test_module");
-
-        let mut module = crate::Module::new();
-        module.section(&coremodules);
-
-        let wasm_bytes = module.finish();
-
-        let mut parser = Parser::new(0).parse_all(&wasm_bytes);
-        match parser.next() {
-            Some(Ok(Payload::Version { .. })) => {}
-            _ => panic!(""),
-        }
-
-        let payload = parser
-            .next()
-            .expect("parser is not empty")
-            .expect("element is a payload");
-        match payload {
-            Payload::CustomSection(section) => {
-                assert_eq!(section.name(), "coremodules");
-                let modules = wasmparser::CoreDumpModulesSection::from_reader(
-                    &mut BinaryReader::new(section.data()),
-                )
-                .expect("data is readable into a core dump modules section");
-                assert_eq!(modules.modules[0], "test_module");
-            }
-            _ => panic!("unexpected payload"),
-        }
-    }
-
-    #[test]
-    fn test_roundtrip_coreinstances() {
-        let mut coreinstances = CoreDumpInstancesSection::new();
-        let module_index = 0;
-        let memories = vec![42];
-        let globals = vec![17];
-        coreinstances.instance(module_index, memories, globals);
-
-        let mut module = Module::new();
-        module.section(&coreinstances);
-        let wasm_bytes = module.finish();
-
-        let mut parser = Parser::new(0).parse_all(&wasm_bytes);
-        match parser.next() {
-            Some(Ok(Payload::Version { .. })) => {}
-            _ => panic!(""),
-        }
-
-        let payload = parser
-            .next()
-            .expect("parser is not empty")
-            .expect("element is a payload");
-        match payload {
-            Payload::CustomSection(section) => {
-                assert_eq!(section.name(), "coreinstances");
-                let coreinstances = wasmparser::CoreDumpInstancesSection::from_reader(
-                    &mut BinaryReader::new(section.data()),
-                )
-                .expect("data is readable into a core dump instances section");
-                assert_eq!(coreinstances.instances.len(), 1);
-                let instance = coreinstances
-                    .instances
-                    .first()
-                    .expect("instance is encoded");
-                assert_eq!(instance.module_index, 0);
-                assert_eq!(instance.memories.len(), 1);
-                assert_eq!(instance.globals.len(), 1);
-            }
-            _ => panic!("unexpected payload"),
-        }
-    }
-
-    // Create new corestack section and test whether it is properly encoded and
-    // parsed back out by wasmparser
-    #[test]
-    fn test_roundtrip_corestack() {
-        let mut corestack = CoreDumpStackSection::new("main");
-        corestack.frame(
-            0,
-            12,
-            0,
-            vec![CoreDumpValue::I32(10)],
-            vec![CoreDumpValue::I32(42)],
-        );
-        let mut module = Module::new();
-        module.section(&corestack);
-        let wasm_bytes = module.finish();
-
-        let mut parser = Parser::new(0).parse_all(&wasm_bytes);
-        match parser.next() {
-            Some(Ok(Payload::Version { .. })) => {}
-            _ => panic!(""),
-        }
-
-        let payload = parser
-            .next()
-            .expect("parser is not empty")
-            .expect("element is a payload");
-        match payload {
-            Payload::CustomSection(section) => {
-                assert_eq!(section.name(), "corestack");
-                let corestack = wasmparser::CoreDumpStackSection::from_reader(
-                    &mut BinaryReader::new(section.data()),
-                )
-                .expect("data is readable into a core dump stack section");
-                assert_eq!(corestack.name, "main");
-                assert_eq!(corestack.frames.len(), 1);
-                let frame = corestack
-                    .frames
-                    .first()
-                    .expect("frame is encoded in corestack");
-                assert_eq!(frame.instanceidx, 0);
-                assert_eq!(frame.funcidx, 12);
-                assert_eq!(frame.codeoffset, 0);
-                assert_eq!(frame.locals.len(), 1);
-                match frame.locals.first().expect("frame contains a local") {
-                    &wasmparser::CoreDumpValue::I32(val) => assert_eq!(val, 10),
-                    _ => panic!("unexpected local value"),
-                }
-                assert_eq!(frame.stack.len(), 1);
-                match frame.stack.first().expect("stack contains a value") {
-                    &wasmparser::CoreDumpValue::I32(val) => assert_eq!(val, 42),
-                    _ => panic!("unexpected stack value"),
-                }
-            }
-            _ => panic!("unexpected payload"),
-        }
-    }
-
-    #[test]
-    fn test_encode_coredump_section() {
-        let core = CoreDumpSection::new("test");
-
-        let mut encoded = vec![];
-        core.encode(&mut encoded);
-
-        #[rustfmt::skip]
-        assert_eq!(encoded, vec![
-            // section length
-            11,
-            // name length
-            4,
-            // section name (core)
-            b'c',b'o',b'r',b'e',
-            // process-info (0, data length, data)
-            0, 4, b't', b'e', b's', b't',
-        ]);
-    }
-
-    #[test]
-    fn test_encode_coremodules_section() {
-        let mut modules = CoreDumpModulesSection::new();
-        modules.module("mod1");
-        modules.module("mod2");
-
-        let mut encoded = vec![];
-        modules.encode(&mut encoded);
-
-        #[rustfmt::skip]
-        assert_eq!(encoded, vec![
-            // section length
-            25,
-            // name length
-            11,
-            // section name (coremodules)
-            b'c',b'o',b'r',b'e',b'm',b'o',b'd',b'u',b'l',b'e',b's',
-            // module count
-            2,
-            // 0x0, name-length, module name (mod1)
-            0x0, 4, b'm',b'o',b'd',b'1',
-            // 0x0, name-length, module name (mod2)
-            0x0, 4, b'm',b'o',b'd',b'2'
-        ]);
-    }
-
-    #[test]
-    fn test_encode_coreinstances_section() {
-        let mut instances = CoreDumpInstancesSection::new();
-        instances.instance(0, vec![42], vec![17]);
-
-        let mut encoded = vec![];
-        instances.encode(&mut encoded);
-
-        #[rustfmt::skip]
-        assert_eq!(encoded, vec![
-            // section length
-            21,
-            // name length
-            13,
-            // section name (coreinstances)
-            b'c',b'o',b'r',b'e',b'i',b'n',b's',b't',b'a',b'n',b'c',b'e',b's',
-            // instance count
-            1,
-            // 0x0, module_idx
-            0x0, 0,
-            // memories count, memories
-            1, 42, 
-            // globals count, globals
-            1, 17
-        ]);
-    }
-
-    #[test]
-    fn test_encode_corestack_section() {
-        let mut thread = CoreDumpStackSection::new("main");
-        thread.frame(
-            0,
-            42,
-            51,
-            vec![CoreDumpValue::I32(1)],
-            vec![CoreDumpValue::I32(2)],
-        );
-
-        let mut encoded = vec![];
-        thread.encode(&mut encoded);
-
-        #[rustfmt::skip]
-        assert_eq!(
-            encoded,
-            vec![
-                // section length
-                27, 
-                // length of name.
-                9,
-                // section name (corestack)
-                b'c',b'o',b'r',b'e',b's',b't',b'a',b'c',b'k',
-                // 0x0, thread name length
-                0, 4,
-                // thread name (main)
-                b'm',b'a',b'i',b'n',
-                // frame count
-                1,
-                // 0x0, instanceidx, funcidx, codeoffset
-                0, 0, 42, 51,
-                // local count
-                1,
-                // local value type
-                0x7F,
-                // local value
-                1,
-                // stack count
-                1,
-                // stack value type
-                0x7F,
-                // stack value
-                2
-
-            ]
-        );
-    }
-}
diff --git a/crates/wasm-encoder/src/core/elements.rs b/crates/wasm-encoder/src/core/elements.rs
index 43a85874..3325c3d4 100644
--- a/crates/wasm-encoder/src/core/elements.rs
+++ b/crates/wasm-encoder/src/core/elements.rs
@@ -111,7 +111,7 @@ impl ElementSection {
             ElementMode::Active {
                 table: None,
                 offset,
-            } if segment.element_type == RefType::FUNCREF => {
+            } => {
                 (/* 0x00 | */expr_bit).encode(&mut self.bytes);
                 offset.encode(&mut self.bytes);
             }
@@ -123,9 +123,12 @@ impl ElementSection {
                     segment.element_type.encode(&mut self.bytes);
                 }
             }
-            ElementMode::Active { table, offset } => {
+            ElementMode::Active {
+                table: Some(i),
+                offset,
+            } => {
                 (0x02 | expr_bit).encode(&mut self.bytes);
-                table.unwrap_or(0).encode(&mut self.bytes);
+                i.encode(&mut self.bytes);
                 offset.encode(&mut self.bytes);
                 if expr_bit == 0 {
                     self.bytes.push(0x00); // elemkind == funcref
diff --git a/crates/wasm-encoder/src/core/linking.rs b/crates/wasm-encoder/src/core/linking.rs
index 9a299572..3309277b 100644
--- a/crates/wasm-encoder/src/core/linking.rs
+++ b/crates/wasm-encoder/src/core/linking.rs
@@ -1,5 +1,3 @@
-use std::borrow::Cow;
-
 use crate::{encode_section, CustomSection, Encode, Section, SectionId};
 
 const VERSION: u32 = 2;
@@ -74,8 +72,8 @@ impl Default for LinkingSection {
 impl Encode for LinkingSection {
     fn encode(&self, sink: &mut Vec<u8>) {
         CustomSection {
-            name: "linking".into(),
-            data: Cow::Borrowed(&self.bytes),
+            name: "linking",
+            data: &self.bytes,
         }
         .encode(sink);
     }
diff --git a/crates/wasm-encoder/src/core/names.rs b/crates/wasm-encoder/src/core/names.rs
index 7cb01cfa..a1c31506 100644
--- a/crates/wasm-encoder/src/core/names.rs
+++ b/crates/wasm-encoder/src/core/names.rs
@@ -1,5 +1,3 @@
-use std::borrow::Cow;
-
 use crate::{encoding_size, CustomSection, Encode, Section, SectionId};
 
 /// An encoder for the custom `name` section.
@@ -155,8 +153,8 @@ impl NameSection {
     /// View the encoded section as a CustomSection.
     pub fn as_custom<'a>(&'a self) -> CustomSection<'a> {
         CustomSection {
-            name: "name".into(),
-            data: Cow::Borrowed(&self.bytes),
+            name: "name",
+            data: &self.bytes,
         }
     }
 }
diff --git a/crates/wasm-encoder/src/core/producers.rs b/crates/wasm-encoder/src/core/producers.rs
index af03ecbb..ace908a7 100644
--- a/crates/wasm-encoder/src/core/producers.rs
+++ b/crates/wasm-encoder/src/core/producers.rs
@@ -1,5 +1,3 @@
-use std::borrow::Cow;
-
 use crate::{CustomSection, Encode, Section, SectionId};
 
 /// An encoder for the [producers custom
@@ -63,8 +61,8 @@ impl Encode for ProducersSection {
         data.extend(&self.bytes);
 
         CustomSection {
-            name: "producers".into(),
-            data: Cow::Borrowed(&data),
+            name: "producers",
+            data: &data,
         }
         .encode(sink);
     }
diff --git a/crates/wasm-encoder/src/core/types.rs b/crates/wasm-encoder/src/core/types.rs
index 5c931f6c..d21dbbc9 100644
--- a/crates/wasm-encoder/src/core/types.rs
+++ b/crates/wasm-encoder/src/core/types.rs
@@ -1,67 +1,5 @@
 use crate::{encode_section, Encode, Section, SectionId};
 
-/// Represents a subtype of possible other types in a WebAssembly module.
-#[derive(Debug, Clone)]
-pub struct SubType {
-    /// Is the subtype final.
-    pub is_final: bool,
-    /// The list of supertype indexes. As of GC MVP, there can be at most one supertype.
-    pub supertype_idx: Option<u32>,
-    /// The structural type of the subtype.
-    pub structural_type: StructuralType,
-}
-
-/// Represents a structural type in a WebAssembly module.
-#[derive(Debug, Clone)]
-pub enum StructuralType {
-    /// The type is for a function.
-    Func(FuncType),
-    /// The type is for an array.
-    Array(ArrayType),
-    /// The type is for a struct.
-    Struct(StructType),
-}
-
-/// Represents a type of a function in a WebAssembly module.
-#[derive(Debug, Clone, Eq, PartialEq, Hash)]
-pub struct FuncType {
-    /// The combined parameters and result types.
-    params_results: Box<[ValType]>,
-    /// The number of parameter types.
-    len_params: usize,
-}
-
-/// Represents a type of an array in a WebAssembly module.
-#[derive(Debug, Clone, Eq, PartialEq, Hash)]
-pub struct ArrayType(pub FieldType);
-
-/// Represents a type of a struct in a WebAssembly module.
-#[derive(Debug, Clone, Eq, PartialEq, Hash)]
-pub struct StructType {
-    /// Struct fields.
-    pub fields: Box<[FieldType]>,
-}
-
-/// Field type in structural types (structs, arrays).
-#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, Ord, PartialOrd)]
-pub struct FieldType {
-    /// Storage type of the field.
-    pub element_type: StorageType,
-    /// Is the field mutable.
-    pub mutable: bool,
-}
-
-/// Storage type for structural type fields.
-#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, Ord, PartialOrd)]
-pub enum StorageType {
-    /// The `i8` type.
-    I8,
-    /// The `i16` type.
-    I16,
-    /// A value type.
-    Val(ValType),
-}
-
 /// The type of a core WebAssembly value.
 #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, Ord, PartialOrd)]
 pub enum ValType {
@@ -85,35 +23,6 @@ pub enum ValType {
     Ref(RefType),
 }
 
-impl FuncType {
-    /// Creates a new [`FuncType`] from the given `params` and `results`.
-    pub fn new<P, R>(params: P, results: R) -> Self
-    where
-        P: IntoIterator<Item = ValType>,
-        R: IntoIterator<Item = ValType>,
-    {
-        let mut buffer = params.into_iter().collect::<Vec<_>>();
-        let len_params = buffer.len();
-        buffer.extend(results);
-        Self {
-            params_results: buffer.into(),
-            len_params,
-        }
-    }
-
-    /// Returns a shared slice to the parameter types of the [`FuncType`].
-    #[inline]
-    pub fn params(&self) -> &[ValType] {
-        &self.params_results[..self.len_params]
-    }
-
-    /// Returns a shared slice to the result types of the [`FuncType`].
-    #[inline]
-    pub fn results(&self) -> &[ValType] {
-        &self.params_results[self.len_params..]
-    }
-}
-
 impl ValType {
     /// Alias for the `funcref` type in WebAssembly
     pub const FUNCREF: ValType = ValType::Ref(RefType::FUNCREF);
@@ -121,16 +30,6 @@ impl ValType {
     pub const EXTERNREF: ValType = ValType::Ref(RefType::EXTERNREF);
 }
 
-impl Encode for StorageType {
-    fn encode(&self, sink: &mut Vec<u8>) {
-        match self {
-            StorageType::I8 => sink.push(0x7A),
-            StorageType::I16 => sink.push(0x79),
-            StorageType::Val(vt) => vt.encode(sink),
-        }
-    }
-}
-
 impl Encode for ValType {
     fn encode(&self, sink: &mut Vec<u8>) {
         match self {
@@ -200,29 +99,12 @@ impl From<RefType> for ValType {
 /// Part of the function references proposal.
 #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, Ord, PartialOrd)]
 pub enum HeapType {
-    /// Untyped (any) function.
+    /// A function reference. When nullable, equivalent to `funcref`
     Func,
-    /// External heap type.
+    /// An extern reference. When nullable, equivalent to `externref`
     Extern,
-    /// The `any` heap type. The common supertype (a.k.a. top) of all internal types.
-    Any,
-    /// The `none` heap type. The common subtype (a.k.a. bottom) of all internal types.
-    None,
-    /// The `noextern` heap type. The common subtype (a.k.a. bottom) of all external types.
-    NoExtern,
-    /// The `nofunc` heap type. The common subtype (a.k.a. bottom) of all function types.
-    NoFunc,
-    /// The `eq` heap type. The common supertype of all referenceable types on which comparison
-    /// (ref.eq) is allowed.
-    Eq,
-    /// The `struct` heap type. The common supertype of all struct types.
-    Struct,
-    /// The `array` heap type. The common supertype of all array types.
-    Array,
-    /// The i31 heap type.
-    I31,
-    /// User defined type at the given index.
-    Indexed(u32),
+    /// A reference to a particular index in a table.
+    TypedFunc(u32),
 }
 
 impl Encode for HeapType {
@@ -230,17 +112,9 @@ impl Encode for HeapType {
         match self {
             HeapType::Func => sink.push(0x70),
             HeapType::Extern => sink.push(0x6F),
-            HeapType::Any => sink.push(0x6E),
-            HeapType::None => sink.push(0x65),
-            HeapType::NoExtern => sink.push(0x69),
-            HeapType::NoFunc => sink.push(0x68),
-            HeapType::Eq => sink.push(0x6D),
-            HeapType::Struct => sink.push(0x67),
-            HeapType::Array => sink.push(0x66),
-            HeapType::I31 => sink.push(0x6A),
             // Note that this is encoded as a signed type rather than unsigned
             // as it's decoded as an s33
-            HeapType::Indexed(i) => i64::from(*i).encode(sink),
+            HeapType::TypedFunc(i) => i64::from(*i).encode(sink),
         }
     }
 }
@@ -302,61 +176,6 @@ impl TypeSection {
         self.num_added += 1;
         self
     }
-
-    /// Define an array type in this type section.
-    pub fn array(&mut self, ty: &StorageType, mutable: bool) -> &mut Self {
-        self.bytes.push(0x5e);
-        self.field(ty, mutable);
-        self.num_added += 1;
-        self
-    }
-
-    fn field(&mut self, ty: &StorageType, mutable: bool) -> &mut Self {
-        ty.encode(&mut self.bytes);
-        self.bytes.push(mutable as u8);
-        self
-    }
-
-    /// Define a struct type in this type section.
-    pub fn struct_(&mut self, fields: Vec<FieldType>) -> &mut Self {
-        self.bytes.push(0x5f);
-        fields.len().encode(&mut self.bytes);
-        for f in fields.iter() {
-            self.field(&f.element_type, f.mutable);
-        }
-        self.num_added += 1;
-        self
-    }
-
-    /// Define an explicit subtype in this type section.
-    pub fn subtype(&mut self, ty: &SubType) -> &mut Self {
-        // In the GC spec, supertypes is a vector, not an option.
-        let st = match ty.supertype_idx {
-            Some(idx) => vec![idx],
-            None => vec![],
-        };
-        if ty.is_final {
-            self.bytes.push(0x4e);
-            st.encode(&mut self.bytes);
-        } else if !st.is_empty() {
-            self.bytes.push(0x50);
-            st.encode(&mut self.bytes);
-        }
-
-        match &ty.structural_type {
-            StructuralType::Func(ty) => {
-                self.function(ty.params().iter().copied(), ty.results().iter().copied());
-            }
-            StructuralType::Array(ArrayType(ty)) => {
-                self.array(&ty.element_type, ty.mutable);
-            }
-            StructuralType::Struct(ty) => {
-                self.struct_(ty.fields.to_vec());
-            }
-        }
-
-        self
-    }
 }
 
 impl Encode for TypeSection {
diff --git a/crates/wasm-encoder/src/lib.rs b/crates/wasm-encoder/src/lib.rs
index 930c63ec..3f365625 100644
--- a/crates/wasm-encoder/src/lib.rs
+++ b/crates/wasm-encoder/src/lib.rs
@@ -144,33 +144,6 @@ impl Encode for i64 {
     }
 }
 
-impl Encode for f32 {
-    fn encode(&self, sink: &mut Vec<u8>) {
-        let bits = self.to_bits();
-        sink.extend(bits.to_le_bytes())
-    }
-}
-
-impl Encode for f64 {
-    fn encode(&self, sink: &mut Vec<u8>) {
-        let bits = self.to_bits();
-        sink.extend(bits.to_le_bytes())
-    }
-}
-
-fn encode_vec<T, V>(elements: V, sink: &mut Vec<u8>)
-where
-    T: Encode,
-    V: IntoIterator<Item = T>,
-    V::IntoIter: ExactSizeIterator,
-{
-    let elements = elements.into_iter();
-    u32::try_from(elements.len()).unwrap().encode(sink);
-    for x in elements {
-        x.encode(sink);
-    }
-}
-
 impl<T> Encode for Option<T>
 where
     T: Encode,
@@ -210,6 +183,6 @@ mod test {
     #[test]
     fn it_encodes_an_empty_component() {
         let bytes = Component::new().finish();
-        assert_eq!(bytes, [0x00, b'a', b's', b'm', 0x0d, 0x00, 0x01, 0x00]);
+        assert_eq!(bytes, [0x00, b'a', b's', b'm', 0x0c, 0x00, 0x01, 0x00]);
     }
 }
diff --git a/crates/wasm-metadata/Cargo.toml b/crates/wasm-metadata/Cargo.toml
index d515a0ae..65a1e99e 100644
--- a/crates/wasm-metadata/Cargo.toml
+++ b/crates/wasm-metadata/Cargo.toml
@@ -1,6 +1,6 @@
 [package]
 name = "wasm-metadata"
-version = "0.9.0"
+version = "0.3.1"
 edition.workspace = true
 license = "Apache-2.0 WITH LLVM-exception"
 repository = "https://github.com/bytecodealliance/wasm-tools/tree/main/crates/wasm-metadata"
@@ -13,8 +13,6 @@ wasmparser = { workspace = true }
 wasm-encoder = { workspace = true }
 indexmap = { workspace = true, features = ["serde"] }
 serde = { workspace = true }
-serde_json = { version = "1" }
-spdx = "0.10.1"
 
 [dev-dependencies]
 wat = { workspace = true }
diff --git a/crates/wasm-metadata/src/lib.rs b/crates/wasm-metadata/src/lib.rs
index 44b79f6f..749554ca 100644
--- a/crates/wasm-metadata/src/lib.rs
+++ b/crates/wasm-metadata/src/lib.rs
@@ -1,10 +1,7 @@
 use anyhow::Result;
 use indexmap::{map::Entry, IndexMap};
-use serde::{Deserialize, Serialize};
-use spdx::Expression;
-use std::borrow::Cow;
+use serde::Serialize;
 use std::fmt;
-use std::fmt::Display;
 use std::mem;
 use std::ops::Range;
 use wasm_encoder::{ComponentSection as _, ComponentSectionId, Encode, Section};
@@ -17,7 +14,7 @@ use wasmparser::{
 /// Spec: https://github.com/WebAssembly/tool-conventions/blob/main/ProducersSection.md
 #[derive(Debug, Serialize)]
 pub struct Producers(
-    #[serde(serialize_with = "indexmap::map::serde_seq::serialize")]
+    #[serde(serialize_with = "indexmap::serde_seq::serialize")]
     IndexMap<String, IndexMap<String, String>>,
 );
 
@@ -144,7 +141,7 @@ impl Producers {
     /// Merge into an existing wasm module. Rewrites the module with this producers section
     /// merged into its existing one, or adds this producers section if none is present.
     pub fn add_to_wasm(&self, input: &[u8]) -> Result<Vec<u8>> {
-        rewrite_wasm(&None, self, None, input)
+        rewrite_wasm(&None, self, input)
     }
 
     fn display(&self, f: &mut fmt::Formatter, indent: usize) -> fmt::Result {
@@ -205,10 +202,6 @@ pub struct AddMetadata {
     /// Add an SDK and its version to the producers section
     #[cfg_attr(feature="clap", clap(long, value_parser = parse_key_value, value_name="NAME=VERSION"))]
     pub sdk: Vec<(String, String)>,
-
-    /// Add an registry metadata to the registry-metadata section
-    #[cfg_attr(feature="clap", clap(long, value_parser = parse_registry_metadata_value, value_name="PATH"))]
-    pub registry_metadata: Option<RegistryMetadata>,
 }
 
 #[cfg(feature = "clap")]
@@ -218,33 +211,18 @@ fn parse_key_value(s: &str) -> Result<(String, String)> {
         .ok_or_else(|| anyhow::anyhow!("expected KEY=VALUE"))
 }
 
-#[cfg(feature = "clap")]
-fn parse_registry_metadata_value(s: &str) -> Result<RegistryMetadata> {
-    let contents = std::fs::read(s)?;
-
-    let registry_metadata = RegistryMetadata::from_bytes(&contents, 0)?;
-
-    Ok(registry_metadata)
-}
-
 impl AddMetadata {
     /// Process a WebAssembly binary. Supports both core WebAssembly modules, and WebAssembly
     /// components. The module and component will have, at very least, an empty name and producers
     /// section created.
     pub fn to_wasm(&self, input: &[u8]) -> Result<Vec<u8>> {
-        rewrite_wasm(
-            &self.name,
-            &Producers::from_meta(self),
-            self.registry_metadata.as_ref(),
-            input,
-        )
+        rewrite_wasm(&self.name, &Producers::from_meta(self), input)
     }
 }
 
 fn rewrite_wasm(
     add_name: &Option<String>,
     add_producers: &Producers,
-    add_registry_metadata: Option<&RegistryMetadata>,
     input: &[u8],
 ) -> Result<Vec<u8>> {
     let mut producers_found = false;
@@ -313,19 +291,6 @@ fn rewrite_wasm(
                 names.section()?.as_custom().append_to(&mut output);
             }
 
-            CustomSection(c) if c.name() == "registry-metadata" && stack.len() == 0 => {
-                // Pass section through if a new registry metadata isn't provided, otherwise ignore and overwrite with new
-                if add_registry_metadata.is_none() {
-                    let registry: RegistryMetadata = RegistryMetadata::from_bytes(&c.data(), 0)?;
-
-                    let registry_metadata = wasm_encoder::CustomSection {
-                        name: Cow::Borrowed("registry-metadata"),
-                        data: Cow::Owned(serde_json::to_vec(&registry)?),
-                    };
-                    registry_metadata.append_to(&mut output);
-                }
-            }
-
             // All other sections get passed through unmodified:
             _ => {
                 if let Some((id, range)) = payload.as_section() {
@@ -354,13 +319,6 @@ fn rewrite_wasm(
         // Encode into output:
         producers.section().append_to(&mut output);
     }
-    if add_registry_metadata.is_some() {
-        let registry_metadata = wasm_encoder::CustomSection {
-            name: Cow::Borrowed("registry-metadata"),
-            data: Cow::Owned(serde_json::to_vec(&add_registry_metadata)?),
-        };
-        registry_metadata.append_to(&mut output);
-    }
     Ok(output)
 }
 
@@ -374,8 +332,6 @@ pub enum Metadata {
         name: Option<String>,
         /// The component's producers section, if any.
         producers: Option<Producers>,
-        /// The component's registry metadata section, if any.
-        registry_metadata: Option<RegistryMetadata>,
         /// All child modules and components inside the component.
         children: Vec<Box<Metadata>>,
         /// Byte range of the module in the parent binary
@@ -387,8 +343,6 @@ pub enum Metadata {
         name: Option<String>,
         /// The module's producers section, if any.
         producers: Option<Producers>,
-        /// The module's registry metadata section, if any.
-        registry_metadata: Option<RegistryMetadata>,
         /// Byte range of the module in the parent binary
         range: Range<usize>,
     },
@@ -452,13 +406,6 @@ impl Metadata {
                         .expect("non-empty metadata stack")
                         .set_producers(producers);
                 }
-                CustomSection(c) if c.name() == "registry-metadata" => {
-                    let registry: RegistryMetadata = RegistryMetadata::from_bytes(&c.data(), 0)?;
-                    metadata
-                        .last_mut()
-                        .expect("non-empty metadata stack")
-                        .set_registry_metadata(registry);
-                }
 
                 _ => {}
             }
@@ -472,7 +419,6 @@ impl Metadata {
         Metadata::Component {
             name: None,
             producers: None,
-            registry_metadata: None,
             children: Vec::new(),
             range,
         }
@@ -482,7 +428,6 @@ impl Metadata {
         Metadata::Module {
             name: None,
             producers: None,
-            registry_metadata: None,
             range,
         }
     }
@@ -498,16 +443,6 @@ impl Metadata {
             Metadata::Component { producers, .. } => *producers = Some(p),
         }
     }
-    fn set_registry_metadata(&mut self, r: RegistryMetadata) {
-        match self {
-            Metadata::Module {
-                registry_metadata, ..
-            } => *registry_metadata = Some(r),
-            Metadata::Component {
-                registry_metadata, ..
-            } => *registry_metadata = Some(r),
-        }
-    }
     fn push_child(&mut self, child: Self) {
         match self {
             Metadata::Module { .. } => panic!("module shouldnt have children"),
@@ -519,10 +454,7 @@ impl Metadata {
         let spaces = std::iter::repeat(" ").take(indent).collect::<String>();
         match self {
             Metadata::Module {
-                name,
-                producers,
-                registry_metadata,
-                ..
+                name, producers, ..
             } => {
                 if let Some(name) = name {
                     writeln!(f, "{spaces}module {name}:")?;
@@ -532,15 +464,11 @@ impl Metadata {
                 if let Some(producers) = producers {
                     producers.display(f, indent + 4)?;
                 }
-                if let Some(registry_metadata) = registry_metadata {
-                    registry_metadata.display(f, indent + 4)?;
-                }
                 Ok(())
             }
             Metadata::Component {
                 name,
                 producers,
-                registry_metadata,
                 children,
                 ..
             } => {
@@ -552,9 +480,6 @@ impl Metadata {
                 if let Some(producers) = producers {
                     producers.display(f, indent + 4)?;
                 }
-                if let Some(registry_metadata) = registry_metadata {
-                    registry_metadata.display(f, indent + 4)?;
-                }
                 for c in children {
                     c.display(f, indent + 4)?;
                 }
@@ -747,344 +672,8 @@ fn indirect_name_map(
     Ok(out)
 }
 
-#[derive(Debug, Deserialize, Serialize, Clone, Default, PartialEq)]
-pub struct RegistryMetadata {
-    /// List of authors who has created this package.
-    #[serde(skip_serializing_if = "Option::is_none")]
-    authors: Option<Vec<String>>,
-
-    /// Package description in markdown format.
-    #[serde(skip_serializing_if = "Option::is_none")]
-    description: Option<String>,
-
-    /// SPDX License Expression
-    /// https://spdx.github.io/spdx-spec/v2.3/SPDX-license-expressions/
-    /// SPDX License List: https://spdx.org/licenses/
-    #[serde(skip_serializing_if = "Option::is_none")]
-    license: Option<String>,
-
-    /// A list of custom licenses that should be referenced to from the license expression.
-    /// https://spdx.github.io/spdx-spec/v2.3/other-licensing-information-detected/
-    #[serde(skip_serializing_if = "Option::is_none")]
-    custom_licenses: Option<Vec<CustomLicense>>,
-
-    /// A list of links that can contain predefined link types or custom links for use with tooling or registries.
-    #[serde(skip_serializing_if = "Option::is_none")]
-    links: Option<Vec<Link>>,
-
-    /// A list of categories that a package should be listed under when uploaded to a registry.
-    #[serde(skip_serializing_if = "Option::is_none")]
-    categories: Option<Vec<String>>,
-}
-
-const LICENSE_REF: &str = "LicenseRef-";
-
-impl RegistryMetadata {
-    /// Merge into an existing wasm module. Rewrites the module with this registry-metadata section
-    /// overwriting its existing one, or adds this registry-metadata section if none is present.
-    pub fn add_to_wasm(&self, input: &[u8]) -> Result<Vec<u8>> {
-        rewrite_wasm(&None, &Producers::empty(), Some(&self), input)
-    }
-
-    pub fn from_wasm(bytes: &[u8]) -> Result<Option<Self>> {
-        let mut depth = 0;
-        for payload in Parser::new(0).parse_all(bytes) {
-            let payload = payload?;
-            use wasmparser::Payload::*;
-            match payload {
-                ModuleSection { .. } | ComponentSection { .. } => depth += 1,
-                End { .. } => depth -= 1,
-                CustomSection(c) if c.name() == "registry-metadata" && depth == 0 => {
-                    let registry = RegistryMetadata::from_bytes(&c.data(), 0)?;
-                    return Ok(Some(registry));
-                }
-                _ => {}
-            }
-        }
-        Ok(None)
-    }
-
-    /// Gets the registry-matadata from a slice of bytes
-    pub fn from_bytes(bytes: &[u8], offset: usize) -> Result<Self> {
-        let registry: RegistryMetadata = serde_json::from_slice(&bytes[offset..])?;
-        return Ok(registry);
-    }
-
-    pub fn validate(&self) -> Result<()> {
-        fn validate_expression(expression: &str) -> Result<Vec<String>> {
-            let expression = Expression::parse(expression)?;
-
-            let mut licenses = Vec::new();
-
-            for license in expression.iter() {
-                match license {
-                    spdx::expression::ExprNode::Op(_) => continue,
-                    spdx::expression::ExprNode::Req(req) => {
-                        if let spdx::LicenseItem::Spdx { .. } = req.req.license {
-                            // Continue if it's a license that exists on the Spdx license list
-                            continue;
-                        }
-
-                        let license_id = req.req.to_string();
-
-                        if license_id.starts_with(LICENSE_REF) {
-                            // Strip "LicenseRef-", convert to lowercase and then append
-                            licenses.push(license_id[LICENSE_REF.len()..].to_lowercase());
-                        }
-                    }
-                }
-            }
-
-            Ok(licenses)
-        }
-
-        match (&self.license, &self.custom_licenses) {
-            (None, Some(custom_licenses)) => {
-                let ids = custom_licenses
-                    .iter()
-                    .map(|license| license.id.clone())
-                    .collect::<Vec<String>>()
-                    .join(", ");
-
-                return Err(anyhow::anyhow!(
-                    "{ids} are defined but nevered referenced in license expression"
-                ));
-            }
-            (Some(license), Some(custom_licenses)) => {
-                let licenses = validate_expression(license.as_str())?;
-
-                if !licenses.is_empty() {
-                    for license in &licenses {
-                        let mut match_found = false;
-                        for custom_license in custom_licenses {
-                            // Ignore license id casing
-                            if custom_license.id.to_lowercase() == *license {
-                                match_found = true;
-                            }
-                        }
-
-                        if !match_found {
-                            return Err(anyhow::anyhow!(
-                                "No matching reference for license '{license}' was defined"
-                            ));
-                        }
-                    }
-                }
-            }
-            (Some(license), None) => {
-                let licenses = validate_expression(license.as_str())?;
-
-                if !licenses.is_empty() {
-                    return Err(anyhow::anyhow!(
-                        "Reference to custom license exists but no custom license was given"
-                    ));
-                }
-            }
-            (None, None) => {}
-        }
-
-        Ok(())
-    }
-
-    /// Get authors
-    pub fn get_authors(&self) -> Option<&Vec<String>> {
-        self.authors.as_ref()
-    }
-
-    /// Set authors
-    pub fn set_authors(&mut self, authors: Option<Vec<String>>) {
-        self.authors = authors;
-    }
-
-    /// Get description
-    pub fn get_description(&self) -> Option<&String> {
-        self.description.as_ref()
-    }
-
-    /// Set description
-    pub fn set_description(&mut self, description: Option<String>) {
-        self.description = description;
-    }
-
-    /// Get license
-    pub fn get_license(&self) -> Option<&String> {
-        self.license.as_ref()
-    }
-
-    /// Set license
-    pub fn set_license(&mut self, license: Option<String>) {
-        self.license = license;
-    }
-
-    /// Get custom_licenses
-    pub fn get_custom_licenses(&self) -> Option<&Vec<CustomLicense>> {
-        self.custom_licenses.as_ref()
-    }
-
-    /// Set custom_licenses
-    pub fn set_custom_licenses(&mut self, custom_licenses: Option<Vec<CustomLicense>>) {
-        self.custom_licenses = custom_licenses;
-    }
-
-    /// Get links
-    pub fn get_links(&self) -> Option<&Vec<Link>> {
-        self.links.as_ref()
-    }
-
-    /// Set links
-    pub fn set_links(&mut self, links: Option<Vec<Link>>) {
-        self.links = links;
-    }
-
-    /// Get categories
-    pub fn get_categories(&self) -> Option<&Vec<String>> {
-        self.categories.as_ref()
-    }
-
-    /// Set categories
-    pub fn set_categories(&mut self, categories: Option<Vec<String>>) {
-        self.categories = categories;
-    }
-
-    fn display(&self, f: &mut fmt::Formatter, indent: usize) -> fmt::Result {
-        let spaces = std::iter::repeat(" ").take(indent).collect::<String>();
-
-        if let Some(authors) = &self.authors {
-            writeln!(f, "{spaces}authors:")?;
-            for author in authors {
-                writeln!(f, "{spaces}    {author}")?;
-            }
-        }
-
-        if let Some(license) = &self.license {
-            writeln!(f, "{spaces}license:")?;
-            writeln!(f, "{spaces}    {license}")?;
-        }
-
-        if let Some(links) = &self.links {
-            writeln!(f, "{spaces}links:")?;
-            for link in links {
-                writeln!(f, "{spaces}    {link}")?;
-            }
-        }
-
-        if let Some(categories) = &self.categories {
-            writeln!(f, "{spaces}categories:")?;
-            for category in categories {
-                writeln!(f, "{spaces}    {category}")?;
-            }
-        }
-
-        if let Some(description) = &self.description {
-            writeln!(f, "{spaces}description:")?;
-            writeln!(f, "{spaces}    {description}")?;
-        }
-
-        if let Some(custom_licenses) = &self.custom_licenses {
-            writeln!(f, "{spaces}custom_licenses:")?;
-            for license in custom_licenses {
-                license.display(f, indent + 4)?;
-            }
-        }
-
-        Ok(())
-    }
-}
-
-impl Display for RegistryMetadata {
-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
-        self.display(f, 0)
-    }
-}
-
-#[derive(Debug, Deserialize, Serialize, Clone, PartialEq)]
-pub struct Link {
-    pub ty: LinkType,
-    pub value: String,
-}
-
-impl Display for Link {
-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
-        write!(f, "{}: {}", self.ty, self.value)
-    }
-}
-
-#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)]
-pub enum LinkType {
-    Documentation,
-    Homepage,
-    Repository,
-    Funding,
-    #[serde(untagged)]
-    Custom(String),
-}
-
-impl Display for LinkType {
-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
-        let s = match self {
-            LinkType::Documentation => "Documentation",
-            LinkType::Homepage => "Homepage",
-            LinkType::Repository => "Repository",
-            LinkType::Funding => "Funding",
-            LinkType::Custom(s) => s.as_str(),
-        };
-
-        write!(f, "{s}")
-    }
-}
-
-#[derive(Debug, Deserialize, Serialize, Default, Clone, PartialEq)]
-pub struct CustomLicense {
-    /// License Identifier
-    /// Provides a locally unique identifier to refer to licenses that are not found on the SPDX License List.
-    /// https://spdx.github.io/spdx-spec/v2.3/other-licensing-information-detected/#101-license-identifier-field
-    pub id: String,
-
-    /// License Name
-    /// Provide a common name of the license that is not on the SPDX list.
-    /// https://spdx.github.io/spdx-spec/v2.3/other-licensing-information-detected/#103-license-name-field
-    pub name: String,
-
-    /// Extracted Text
-    /// Provides a copy of the actual text of the license reference extracted from the package or file that is associated with the License Identifier to aid in future analysis.
-    /// https://spdx.github.io/spdx-spec/v2.3/other-licensing-information-detected/#102-extracted-text-field
-    pub text: String,
-
-    /// License Cross Reference
-    /// Provides a pointer to the official source of a license that is not included in the SPDX License List, that is referenced by the License Identifier.
-    /// https://spdx.github.io/spdx-spec/v2.3/other-licensing-information-detected/#104-license-cross-reference-field
-    #[serde(skip_serializing_if = "Option::is_none")]
-    pub reference: Option<String>,
-}
-
-impl CustomLicense {
-    fn display(&self, f: &mut fmt::Formatter, indent: usize) -> fmt::Result {
-        let spaces = std::iter::repeat(" ").take(indent).collect::<String>();
-
-        writeln!(f, "{spaces}{}:", self.id)?;
-        writeln!(f, "{spaces}    name: {}", self.name)?;
-
-        if let Some(reference) = &self.reference {
-            writeln!(f, "{spaces}    reference: {reference}")?;
-        }
-
-        writeln!(f, "{spaces}    text:")?;
-        writeln!(f, "{spaces}        {}", self.text)?;
-
-        Ok(())
-    }
-}
-
-impl Display for CustomLicense {
-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
-        self.display(f, 0)
-    }
-}
-
 #[cfg(test)]
 mod test {
-    use std::vec;
-
     use super::*;
     #[test]
     fn add_to_empty_module() {
@@ -1095,28 +684,6 @@ mod test {
             language: vec!["bar".to_owned()],
             processed_by: vec![("baz".to_owned(), "1.0".to_owned())],
             sdk: vec![],
-            registry_metadata: Some(RegistryMetadata {
-                authors: Some(vec!["foo".to_owned()]),
-                description: Some("foo bar baz".to_owned()),
-                license: Some("MIT OR LicenseRef-FOO".to_owned()),
-                custom_licenses: Some(vec![CustomLicense {
-                    id: "FOO".to_owned(),
-                    name: "Foo".to_owned(),
-                    text: "Foo License".to_owned(),
-                    reference: Some("https://exaple.com/license/foo".to_owned()),
-                }]),
-                links: Some(vec![
-                    Link {
-                        ty: LinkType::Custom("CustomFoo".to_owned()),
-                        value: "https://example.com/custom".to_owned(),
-                    },
-                    Link {
-                        ty: LinkType::Homepage,
-                        value: "https://example.com".to_owned(),
-                    },
-                ]),
-                categories: Some(vec!["Tools".to_owned()]),
-            }),
         };
         let module = add.to_wasm(&module).unwrap();
 
@@ -1125,7 +692,6 @@ mod test {
             Metadata::Module {
                 name,
                 producers,
-                registry_metadata,
                 range,
             } => {
                 assert_eq!(name, Some("foo".to_owned()));
@@ -1135,50 +701,8 @@ mod test {
                     producers.get("processed-by").unwrap().get("baz").unwrap(),
                     "1.0"
                 );
-
-                let registry_metadata = registry_metadata.unwrap();
-
-                assert!(registry_metadata.validate().is_ok());
-
-                assert_eq!(registry_metadata.authors.unwrap(), vec!["foo".to_owned()]);
-                assert_eq!(
-                    registry_metadata.description.unwrap(),
-                    "foo bar baz".to_owned()
-                );
-
-                assert_eq!(
-                    registry_metadata.license.unwrap(),
-                    "MIT OR LicenseRef-FOO".to_owned()
-                );
-                assert_eq!(
-                    registry_metadata.custom_licenses.unwrap(),
-                    vec![CustomLicense {
-                        id: "FOO".to_owned(),
-                        name: "Foo".to_owned(),
-                        text: "Foo License".to_owned(),
-                        reference: Some("https://exaple.com/license/foo".to_owned()),
-                    }]
-                );
-                assert_eq!(
-                    registry_metadata.links.unwrap(),
-                    vec![
-                        Link {
-                            ty: LinkType::Custom("CustomFoo".to_owned()),
-                            value: "https://example.com/custom".to_owned(),
-                        },
-                        Link {
-                            ty: LinkType::Homepage,
-                            value: "https://example.com".to_owned(),
-                        },
-                    ]
-                );
-                assert_eq!(
-                    registry_metadata.categories.unwrap(),
-                    vec!["Tools".to_owned()]
-                );
-
                 assert_eq!(range.start, 0);
-                assert_eq!(range.end, 422);
+                assert_eq!(range.end, 71);
             }
             _ => panic!("metadata should be module"),
         }
@@ -1193,28 +717,6 @@ mod test {
             language: vec!["bar".to_owned()],
             processed_by: vec![("baz".to_owned(), "1.0".to_owned())],
             sdk: vec![],
-            registry_metadata: Some(RegistryMetadata {
-                authors: Some(vec!["foo".to_owned()]),
-                description: Some("foo bar baz".to_owned()),
-                license: Some("MIT OR LicenseRef-FOO".to_owned()),
-                custom_licenses: Some(vec![CustomLicense {
-                    id: "FOO".to_owned(),
-                    name: "Foo".to_owned(),
-                    text: "Foo License".to_owned(),
-                    reference: Some("https://exaple.com/license/foo".to_owned()),
-                }]),
-                links: Some(vec![
-                    Link {
-                        ty: LinkType::Custom("CustomFoo".to_owned()),
-                        value: "https://example.com/custom".to_owned(),
-                    },
-                    Link {
-                        ty: LinkType::Homepage,
-                        value: "https://example.com".to_owned(),
-                    },
-                ]),
-                categories: Some(vec!["Tools".to_owned()]),
-            }),
         };
         let component = add.to_wasm(&component).unwrap();
 
@@ -1223,7 +725,6 @@ mod test {
             Metadata::Component {
                 name,
                 producers,
-                registry_metadata,
                 children,
                 range,
             } => {
@@ -1235,50 +736,8 @@ mod test {
                     producers.get("processed-by").unwrap().get("baz").unwrap(),
                     "1.0"
                 );
-
-                let registry_metadata = registry_metadata.unwrap();
-
-                assert!(registry_metadata.validate().is_ok());
-
-                assert_eq!(registry_metadata.authors.unwrap(), vec!["foo".to_owned()]);
-                assert_eq!(
-                    registry_metadata.description.unwrap(),
-                    "foo bar baz".to_owned()
-                );
-
-                assert_eq!(
-                    registry_metadata.license.unwrap(),
-                    "MIT OR LicenseRef-FOO".to_owned()
-                );
-                assert_eq!(
-                    registry_metadata.custom_licenses.unwrap(),
-                    vec![CustomLicense {
-                        id: "FOO".to_owned(),
-                        name: "Foo".to_owned(),
-                        text: "Foo License".to_owned(),
-                        reference: Some("https://exaple.com/license/foo".to_owned()),
-                    }]
-                );
-                assert_eq!(
-                    registry_metadata.links.unwrap(),
-                    vec![
-                        Link {
-                            ty: LinkType::Custom("CustomFoo".to_owned()),
-                            value: "https://example.com/custom".to_owned(),
-                        },
-                        Link {
-                            ty: LinkType::Homepage,
-                            value: "https://example.com".to_owned(),
-                        },
-                    ]
-                );
-                assert_eq!(
-                    registry_metadata.categories.unwrap(),
-                    vec!["Tools".to_owned()]
-                );
-
                 assert_eq!(range.start, 0);
-                assert_eq!(range.end, 432);
+                assert_eq!(range.end, 81);
             }
             _ => panic!("metadata should be component"),
         }
@@ -1294,10 +753,6 @@ mod test {
             language: vec!["bar".to_owned()],
             processed_by: vec![("baz".to_owned(), "1.0".to_owned())],
             sdk: vec![],
-            registry_metadata: Some(RegistryMetadata {
-                authors: Some(vec!["Foo".to_owned()]),
-                ..Default::default()
-            }),
         };
         let module = add.to_wasm(&module).unwrap();
 
@@ -1339,7 +794,6 @@ mod test {
                     Metadata::Module {
                         name,
                         producers,
-                        registry_metadata,
                         range,
                     } => {
                         assert_eq!(name, &Some("foo".to_owned()));
@@ -1349,15 +803,8 @@ mod test {
                             producers.get("processed-by").unwrap().get("baz").unwrap(),
                             "1.0"
                         );
-
-                        let registry_metadata = registry_metadata.as_ref().unwrap();
-                        assert_eq!(
-                            registry_metadata.authors.as_ref().unwrap(),
-                            &["Foo".to_owned()]
-                        );
-
                         assert_eq!(range.start, 10);
-                        assert_eq!(range.end, 120);
+                        assert_eq!(range.end, 81);
                     }
                     _ => panic!("child is a module"),
                 }
@@ -1448,32 +895,4 @@ mod test {
             _ => panic!("metadata should be module"),
         }
     }
-
-    #[test]
-    fn overwrite_registry_metadata() {
-        let wat = "(module)";
-        let module = wat::parse_str(wat).unwrap();
-        let registry_metadata = RegistryMetadata {
-            authors: Some(vec!["Foo".to_owned()]),
-            ..Default::default()
-        };
-        let module = registry_metadata.add_to_wasm(&module).unwrap();
-
-        let registry_metadata = RegistryMetadata {
-            authors: Some(vec!["Bar".to_owned()]),
-            ..Default::default()
-        };
-        let module = registry_metadata.add_to_wasm(&module).unwrap();
-
-        let metadata = Metadata::from_binary(&module).unwrap();
-        match metadata {
-            Metadata::Module {
-                registry_metadata, ..
-            } => {
-                let registry_metadata = registry_metadata.expect("some registry_metadata");
-                assert_eq!(registry_metadata.authors.unwrap(), vec!["Bar".to_owned()]);
-            }
-            _ => panic!("metadata should be module"),
-        }
-    }
 }
diff --git a/crates/wasm-mutate/Cargo.toml b/crates/wasm-mutate/Cargo.toml
index 6cbdc781..034a873c 100644
--- a/crates/wasm-mutate/Cargo.toml
+++ b/crates/wasm-mutate/Cargo.toml
@@ -1,6 +1,6 @@
 [package]
 name = "wasm-mutate"
-version = "0.2.28"
+version = "0.2.22"
 edition.workspace = true
 license = "Apache-2.0 WITH LLVM-exception"
 repository = "https://github.com/bytecodealliance/wasm-tools/tree/main/crates/wasm-mutate"
diff --git a/crates/wasm-mutate/src/info.rs b/crates/wasm-mutate/src/info.rs
index 54b0f646..16cec493 100644
--- a/crates/wasm-mutate/src/info.rs
+++ b/crates/wasm-mutate/src/info.rs
@@ -1,6 +1,6 @@
 use crate::{
     module::{PrimitiveTypeInfo, TypeInfo},
-    Error, Result,
+    Result,
 };
 use std::collections::HashSet;
 use std::convert::TryFrom;
@@ -93,13 +93,8 @@ impl<'a> ModuleInfo<'a> {
 
                     // Save function types
                     for ty in reader {
-                        if let Ok(st) = ty {
-                            if st.is_final || st.supertype_idx.is_some() {
-                                return Err(Error::unsupported("GC types not supported yet"));
-                            }
-                            let typeinfo = TypeInfo::try_from(st.structural_type).unwrap();
-                            info.types_map.push(typeinfo);
-                        }
+                        let typeinfo = TypeInfo::try_from(ty?).unwrap();
+                        info.types_map.push(typeinfo);
                     }
                 }
                 Payload::ImportSection(reader) => {
diff --git a/crates/wasm-mutate/src/module.rs b/crates/wasm-mutate/src/module.rs
index 4b997df2..603f0784 100644
--- a/crates/wasm-mutate/src/module.rs
+++ b/crates/wasm-mutate/src/module.rs
@@ -49,12 +49,12 @@ impl From<wasmparser::RefType> for PrimitiveTypeInfo {
     }
 }
 
-impl TryFrom<wasmparser::StructuralType> for TypeInfo {
+impl TryFrom<wasmparser::Type> for TypeInfo {
     type Error = Error;
 
-    fn try_from(value: wasmparser::StructuralType) -> Result<Self> {
+    fn try_from(value: wasmparser::Type) -> Result<Self> {
         match value {
-            wasmparser::StructuralType::Func(ft) => Ok(TypeInfo::Func(FuncInfo {
+            wasmparser::Type::Func(ft) => Ok(TypeInfo::Func(FuncInfo {
                 params: ft
                     .params()
                     .iter()
@@ -66,12 +66,7 @@ impl TryFrom<wasmparser::StructuralType> for TypeInfo {
                     .map(|&t| PrimitiveTypeInfo::from(t))
                     .collect(),
             })),
-            wasmparser::StructuralType::Array(_) => {
-                Err(Error::unsupported("Array types are not supported yet."))
-            }
-            wasmparser::StructuralType::Struct(_) => {
-                Err(Error::unsupported("Struct types are not supported yet."))
-            }
+            wasmparser::Type::Cont(_) => unimplemented!(),
         }
     }
 }
@@ -87,21 +82,13 @@ pub fn map_type(tpe: wasmparser::ValType) -> Result<ValType> {
     }
 }
 
-pub fn map_ref_type(ref_ty: wasmparser::RefType) -> Result<RefType> {
+pub fn map_ref_type(tpe: wasmparser::RefType) -> Result<RefType> {
     Ok(RefType {
-        nullable: ref_ty.is_nullable(),
-        heap_type: match ref_ty.heap_type() {
+        nullable: tpe.nullable,
+        heap_type: match tpe.heap_type {
             wasmparser::HeapType::Func => HeapType::Func,
             wasmparser::HeapType::Extern => HeapType::Extern,
-            wasmparser::HeapType::Any => HeapType::Any,
-            wasmparser::HeapType::None => HeapType::None,
-            wasmparser::HeapType::NoExtern => HeapType::NoExtern,
-            wasmparser::HeapType::NoFunc => HeapType::NoFunc,
-            wasmparser::HeapType::Eq => HeapType::Eq,
-            wasmparser::HeapType::Struct => HeapType::Struct,
-            wasmparser::HeapType::Array => HeapType::Array,
-            wasmparser::HeapType::I31 => HeapType::I31,
-            wasmparser::HeapType::Indexed(i) => HeapType::Indexed(i.into()),
+            wasmparser::HeapType::TypedFunc(i) => HeapType::TypedFunc(i.into()),
         },
     })
 }
diff --git a/crates/wasm-mutate/src/mutators.rs b/crates/wasm-mutate/src/mutators.rs
index 23e5e2c1..4c96c87b 100644
--- a/crates/wasm-mutate/src/mutators.rs
+++ b/crates/wasm-mutate/src/mutators.rs
@@ -136,7 +136,7 @@ impl WasmMutate<'_> {
 
         assert!(can_mutate);
 
-        let attempts = 2000;
+        let attempts = 100;
         let mut last_mutation = None;
 
         for _ in 0..attempts {
diff --git a/crates/wasm-mutate/src/mutators/add_type.rs b/crates/wasm-mutate/src/mutators/add_type.rs
index 6de1719e..41786c7d 100644
--- a/crates/wasm-mutate/src/mutators/add_type.rs
+++ b/crates/wasm-mutate/src/mutators/add_type.rs
@@ -2,7 +2,7 @@
 
 use super::Mutator;
 use crate::module::map_type;
-use crate::{Error, Result};
+use crate::Result;
 use rand::Rng;
 use std::iter;
 
@@ -56,8 +56,8 @@ impl Mutator for AddTypeMutator {
             // Copy the existing types section over into the encoder.
             let reader = wasmparser::TypeSectionReader::new(old_types.data, 0)?;
             for ty in reader {
-                match ty?.structural_type {
-                    wasmparser::StructuralType::Func(ty) => {
+                match ty? {
+                    wasmparser::Type::Func(ty) => {
                         let params = ty
                             .params()
                             .iter()
@@ -72,12 +72,7 @@ impl Mutator for AddTypeMutator {
                             .collect::<Result<Vec<_>, _>>()?;
                         types.function(params, results);
                     }
-                    wasmparser::StructuralType::Array(_) => {
-                        return Err(Error::unsupported("Array types are not supported yet."));
-                    }
-                    wasmparser::StructuralType::Struct(_) => {
-                        return Err(Error::unsupported("Struct types are not supported yet."));
-                    }
+                    wasmparser::Type::Cont(_) => unimplemented!(),
                 }
             }
             // And then add our new type.
diff --git a/crates/wasm-mutate/src/mutators/custom.rs b/crates/wasm-mutate/src/mutators/custom.rs
index 6991c4de..d3dac799 100644
--- a/crates/wasm-mutate/src/mutators/custom.rs
+++ b/crates/wasm-mutate/src/mutators/custom.rs
@@ -1,7 +1,5 @@
 //! Mutate custom sections.
 
-use std::borrow::Cow;
-
 use super::Mutator;
 use rand::{seq::SliceRandom, Rng};
 
@@ -69,10 +67,7 @@ impl Mutator for CustomSectionMutator {
             .info()
             .replace_section(
                 custom_section_index,
-                &wasm_encoder::CustomSection {
-                    name: name.into(),
-                    data: Cow::Borrowed(data),
-                },
+                &wasm_encoder::CustomSection { name, data },
             )))))
     }
 }
@@ -103,8 +98,8 @@ impl Mutator for AddCustomSectionMutator {
         Ok(Box::new(std::iter::once(Ok(config.info().insert_section(
             new_custom_section_idx,
             &wasm_encoder::CustomSection {
-                name: name.into(),
-                data: Cow::Borrowed(&data),
+                name: &name,
+                data: &data,
             },
         )))))
     }
diff --git a/crates/wasm-mutate/src/mutators/peephole.rs b/crates/wasm-mutate/src/mutators/peephole.rs
index 9110da9a..41ef663d 100644
--- a/crates/wasm-mutate/src/mutators/peephole.rs
+++ b/crates/wasm-mutate/src/mutators/peephole.rs
@@ -569,7 +569,6 @@ mod tests {
 
     /// Condition to apply the unfold operator
     /// check that the var is a constant
-    #[allow(dead_code)]
     fn is_const(vari: &'static str) -> impl Fn(&mut EG, Id, &Subst) -> bool {
         move |egraph: &mut EG, _, subst| {
             let var = vari.parse();
@@ -609,11 +608,7 @@ mod tests {
         }
     }
 
-    // Random numbers vary by pointer-width presumably due to `usize` at some
-    // point factoring in, and this test is only known to pass within a
-    // reasonable amount of time on 64-bit platforms.
     #[test]
-    #[cfg(target_pointer_width = "64")]
     fn test_peep_unfold2() {
         let rules: &[Rewrite<super::Lang, PeepholeMutationAnalysis>] = &[
             rewrite!("unfold-2";  "?x" => "(i32.unfold ?x)" if is_const("?x") if is_type("?x", PrimitiveTypeInfo::I32)),
@@ -1593,7 +1588,7 @@ mod tests {
         seed: u64,
     ) {
         let mut config = WasmMutate::default();
-        config.fuel(10000);
+        config.fuel(300);
         config.seed(seed);
 
         let mutator = PeepholeMutator::new_with_rules(3, rules.to_vec());
diff --git a/crates/wasm-mutate/src/mutators/peephole/rules.rs b/crates/wasm-mutate/src/mutators/peephole/rules.rs
index c735f3a9..e9d48f33 100644
--- a/crates/wasm-mutate/src/mutators/peephole/rules.rs
+++ b/crates/wasm-mutate/src/mutators/peephole/rules.rs
@@ -621,7 +621,7 @@ impl PeepholeMutator {
         rhs: &str,
         cond: &[Condition],
     ) {
-        self.add_rewrite(rules, name, lhs, rhs, cond);
+        self.add_rewrite(rules, name, lhs, rhs, cond.clone());
         self.add_rewrite(rules, &format!("{name}-rev"), rhs, lhs, cond);
     }
 
diff --git a/crates/wasm-mutate/src/mutators/remove_item.rs b/crates/wasm-mutate/src/mutators/remove_item.rs
index d29bb07a..2e54c0fe 100644
--- a/crates/wasm-mutate/src/mutators/remove_item.rs
+++ b/crates/wasm-mutate/src/mutators/remove_item.rs
@@ -136,7 +136,7 @@ impl RemoveItem {
                         0,
                         TypeSectionReader::new(section.data, 0)?,
                         Item::Type,
-                        |me, ty, section| me.translate_type_def(ty.structural_type, section),
+                        |me, ty, section| me.translate_type_def(ty, section),
                     )?;
                 },
 
@@ -427,8 +427,11 @@ impl Translator for RemoveItem {
             }
         }
 
-        if item != self.item || idx < self.idx {
-            // Different kind of item or a later item was removed, index doesn't change
+        if item != self.item {
+            // Different kind of item, no change
+            Ok(idx)
+        } else if idx < self.idx {
+            // A later item was removed, so this index doesn't change
             Ok(idx)
         } else if idx == self.idx {
             // If we're removing a referenced item then that means that this
diff --git a/crates/wasm-mutate/src/mutators/translate.rs b/crates/wasm-mutate/src/mutators/translate.rs
index 3adf47e1..d7f53688 100644
--- a/crates/wasm-mutate/src/mutators/translate.rs
+++ b/crates/wasm-mutate/src/mutators/translate.rs
@@ -1,6 +1,6 @@
 use crate::{Error, Result};
 use wasm_encoder::*;
-use wasmparser::{DataKind, ElementKind, FunctionBody, Global, Operator, StructuralType};
+use wasmparser::{DataKind, ElementKind, FunctionBody, Global, Operator, Type};
 
 #[derive(Debug, Hash, Eq, PartialEq, Copy, Clone)]
 pub enum Item {
@@ -26,7 +26,7 @@ pub enum ConstExprKind {
 pub trait Translator {
     fn as_obj(&mut self) -> &mut dyn Translator;
 
-    fn translate_type_def(&mut self, ty: StructuralType, s: &mut TypeSection) -> Result<()> {
+    fn translate_type_def(&mut self, ty: Type, s: &mut TypeSection) -> Result<()> {
         type_def(self.as_obj(), ty, s)
     }
 
@@ -109,7 +109,7 @@ pub trait Translator {
     }
 
     fn remap(&mut self, item: Item, idx: u32) -> Result<u32> {
-        let _ = item;
+        drop(item);
         Ok(idx)
     }
 }
@@ -122,9 +122,9 @@ impl Translator for DefaultTranslator {
     }
 }
 
-pub fn type_def(t: &mut dyn Translator, ty: StructuralType, s: &mut TypeSection) -> Result<()> {
+pub fn type_def(t: &mut dyn Translator, ty: Type, s: &mut TypeSection) -> Result<()> {
     match ty {
-        StructuralType::Func(f) => {
+        Type::Func(f) => {
             s.function(
                 f.params()
                     .iter()
@@ -137,8 +137,7 @@ pub fn type_def(t: &mut dyn Translator, ty: StructuralType, s: &mut TypeSection)
             );
             Ok(())
         }
-        StructuralType::Array(_) => Err(Error::unsupported("Array types are not supported yet.")),
-        StructuralType::Struct(_) => Err(Error::unsupported("Struct types are not supported yet.")),
+        Type::Cont(_) => unimplemented!(),
     }
 }
 
@@ -195,8 +194,8 @@ pub fn ty(t: &mut dyn Translator, ty: &wasmparser::ValType) -> Result<ValType> {
 
 pub fn refty(t: &mut dyn Translator, ty: &wasmparser::RefType) -> Result<RefType> {
     Ok(RefType {
-        nullable: ty.is_nullable(),
-        heap_type: t.translate_heapty(&ty.heap_type())?,
+        nullable: ty.nullable,
+        heap_type: t.translate_heapty(&ty.heap_type)?,
     })
 }
 
@@ -204,16 +203,8 @@ pub fn heapty(t: &mut dyn Translator, ty: &wasmparser::HeapType) -> Result<HeapT
     match ty {
         wasmparser::HeapType::Func => Ok(HeapType::Func),
         wasmparser::HeapType::Extern => Ok(HeapType::Extern),
-        wasmparser::HeapType::Any => Ok(HeapType::Any),
-        wasmparser::HeapType::None => Ok(HeapType::None),
-        wasmparser::HeapType::NoExtern => Ok(HeapType::NoExtern),
-        wasmparser::HeapType::NoFunc => Ok(HeapType::NoFunc),
-        wasmparser::HeapType::Eq => Ok(HeapType::Eq),
-        wasmparser::HeapType::Struct => Ok(HeapType::Struct),
-        wasmparser::HeapType::Array => Ok(HeapType::Array),
-        wasmparser::HeapType::I31 => Ok(HeapType::I31),
-        wasmparser::HeapType::Indexed(i) => {
-            Ok(HeapType::Indexed(t.remap(Item::Type, (*i).into())?))
+        wasmparser::HeapType::TypedFunc(i) => {
+            Ok(HeapType::TypedFunc(t.remap(Item::Type, (*i).into())?))
         }
     }
 }
@@ -272,10 +263,8 @@ pub fn element(
                 &wasmparser::ValType::I32,
                 ConstExprKind::ElementOffset,
             )?;
-            let table_index = table_index.unwrap_or(0);
-            let table = t.remap(Item::Table, table_index)?;
             ElementMode::Active {
-                table: if table == 0 { None } else { Some(table) },
+                table: Some(t.remap(Item::Table, *table_index)?),
                 offset: &offset,
             }
         }
@@ -369,12 +358,20 @@ pub fn op(t: &mut dyn Translator, op: &Operator<'_>) -> Result<Instruction<'stat
         (map $arg:ident value) => ($arg);
         (map $arg:ident lane) => (*$arg);
         (map $arg:ident lanes) => (*$arg);
+        (map $arg:ident resumetable) => (
+            $arg
+                .targets()
+                .collect::<Result<Vec<_>, wasmparser::BinaryReaderError>>()?
+                .into()
+        );
 
         // This case takes the arguments of a wasmparser instruction and creates
         // a wasm-encoder instruction. There are a few special cases for where
         // the structure of a wasmparser instruction differs from that of
         // wasm-encoder.
         (build $op:ident) => (I::$op);
+        (build Resume $arg:ident) => (I::Resume($arg));
+        (build ResumeThrow $tag_index:ident $resumetable:ident) => (I::ResumeThrow($tag_index, $resumetable));
         (build BrTable $arg:ident) => (I::BrTable($arg.0, $arg.1));
         (build I32Const $arg:ident) => (I::I32Const(*$arg));
         (build I64Const $arg:ident) => (I::I64Const(*$arg));
diff --git a/crates/wasm-shrink/Cargo.toml b/crates/wasm-shrink/Cargo.toml
index 9eb706d4..990043fa 100644
--- a/crates/wasm-shrink/Cargo.toml
+++ b/crates/wasm-shrink/Cargo.toml
@@ -8,7 +8,7 @@ license = "Apache-2.0 WITH LLVM-exception"
 readme = "./README.md"
 repository = "https://github.com/bytecodealliance/wasm-tools/tree/main/crates/wasm-shrink"
 name = "wasm-shrink"
-version = "0.1.29"
+version = "0.1.23"
 
 [dependencies]
 anyhow = { workspace = true }
diff --git a/crates/wasm-shrink/src/lib.rs b/crates/wasm-shrink/src/lib.rs
index 9ff2ae80..65ea60ac 100755
--- a/crates/wasm-shrink/src/lib.rs
+++ b/crates/wasm-shrink/src/lib.rs
@@ -234,7 +234,7 @@ impl ShrinkRun {
             sign_extension: true,
             component_model: false,
             function_references: false,
-            gc: false,
+            typed_continuations: false,
 
             floats: true,
             memory_control: true,
diff --git a/crates/wasm-smith/Cargo.toml b/crates/wasm-smith/Cargo.toml
index 243425e6..5ae74f0a 100644
--- a/crates/wasm-smith/Cargo.toml
+++ b/crates/wasm-smith/Cargo.toml
@@ -8,7 +8,7 @@ license = "Apache-2.0 WITH LLVM-exception"
 name = "wasm-smith"
 readme = "./README.md"
 repository = "https://github.com/bytecodealliance/wasm-tools/tree/main/crates/wasm-smith"
-version = "0.12.11"
+version = "0.12.5"
 exclude = ["/benches/corpus"]
 
 [[bench]]
@@ -26,12 +26,10 @@ wasmparser = { workspace = true }
 
 [dev-dependencies]
 criterion = { workspace = true }
+libfuzzer-sys = { workspace = true }
 rand = { workspace = true }
 wasmprinter = { path = "../wasmprinter" }
 wat = { path = "../wat" }
 
-[target.'cfg(not(target_family = "wasm"))'.dev-dependencies]
-libfuzzer-sys = { workspace = true }
-
 [features]
 _internal_cli = ["serde", "flagset/serde"]
diff --git a/crates/wasm-smith/src/component.rs b/crates/wasm-smith/src/component.rs
index abce0b1c..d0573002 100644
--- a/crates/wasm-smith/src/component.rs
+++ b/crates/wasm-smith/src/component.rs
@@ -13,7 +13,7 @@ use std::{
     rc::Rc,
 };
 use wasm_encoder::{ComponentTypeRef, ComponentValType, PrimitiveValType, TypeBounds, ValType};
-use wasmparser::names::KebabString;
+use wasmparser::types::KebabString;
 
 mod encode;
 
@@ -637,9 +637,12 @@ impl ComponentBuilder {
             && (for_type_def || scope.types.len() < self.config.max_types())
         {
             choices.push(|me, u| {
-                Ok(ComponentTypeRef::Type(TypeBounds::Eq(u.int_in_range(
-                    0..=u32::try_from(me.current_type_scope().types.len() - 1).unwrap(),
-                )?)))
+                Ok(ComponentTypeRef::Type(
+                    TypeBounds::Eq,
+                    u.int_in_range(
+                        0..=u32::try_from(me.current_type_scope().types.len() - 1).unwrap(),
+                    )?,
+                ))
             });
         }
 
@@ -1112,7 +1115,7 @@ impl ComponentBuilder {
         if self.current_type_scope().can_ref_type() {
             choices.push(|me, exports, export_urls, u, _type_fuel| {
                 let ty = me.arbitrary_type_ref(u, false, true)?.unwrap();
-                if let ComponentTypeRef::Type(TypeBounds::Eq(idx)) = ty {
+                if let ComponentTypeRef::Type(_, idx) = ty {
                     let ty = me.current_type_scope().get(idx).clone();
                     me.current_type_scope_mut().push(ty);
                 }
@@ -1552,13 +1555,10 @@ impl ComponentBuilder {
                 self.total_values += 1;
                 self.component_mut().values.push(ty);
             }
-            ComponentTypeRef::Type(TypeBounds::Eq(ty_index)) => {
+            ComponentTypeRef::Type(TypeBounds::Eq, ty_index) => {
                 let ty = self.current_type_scope().get(ty_index).clone();
                 self.current_type_scope_mut().push(ty);
             }
-            ComponentTypeRef::Type(TypeBounds::SubResource) => {
-                unimplemented!()
-            }
             ComponentTypeRef::Instance(ty_index) => {
                 let instance_ty = match self.current_type_scope().get(ty_index).as_ref() {
                     Type::Instance(ty) => ty.clone(),
@@ -1870,7 +1870,7 @@ fn inverse_scalar_canonical_abi_for(
         ValType::F64 => Ok(ComponentValType::Primitive(PrimitiveValType::Float64)),
         ValType::V128 | ValType::Ref(_) => {
             unreachable!("not used in canonical ABI")
-        }
+        },
     };
 
     let mut names = HashSet::default();
diff --git a/crates/wasm-smith/src/component/encode.rs b/crates/wasm-smith/src/component/encode.rs
index c5b65712..f2bfe734 100644
--- a/crates/wasm-smith/src/component/encode.rs
+++ b/crates/wasm-smith/src/component/encode.rs
@@ -1,8 +1,6 @@
-use std::borrow::Cow;
-
 use super::*;
 use wasm_encoder::{ComponentExportKind, ComponentOuterAliasKind, ExportKind};
-use wasmparser::names::KebabStr;
+use wasmparser::types::KebabStr;
 
 impl Component {
     /// Encode this Wasm component into bytes.
@@ -53,8 +51,8 @@ impl Section {
 impl CustomSection {
     fn encode(&self, component: &mut wasm_encoder::Component) {
         component.section(&wasm_encoder::CustomSection {
-            name: (&self.name).into(),
-            data: Cow::Borrowed(&self.data),
+            name: &self.name,
+            data: &self.data,
         });
     }
 }
@@ -73,7 +71,7 @@ impl ImportSection {
     fn encode(&self, component: &mut wasm_encoder::Component) {
         let mut sec = wasm_encoder::ComponentImportSection::new();
         for imp in &self.imports {
-            sec.import(wasm_encoder::ComponentExternName::Kebab(&imp.name), imp.ty);
+            sec.import(&imp.name, imp.url.as_deref().unwrap_or(""), imp.ty);
         }
         component.section(&sec);
     }
@@ -180,10 +178,7 @@ impl Type {
                 for def in &comp_ty.defs {
                     match def {
                         ComponentTypeDef::Import(imp) => {
-                            enc_comp_ty.import(
-                                wasm_encoder::ComponentExternName::Kebab(&imp.name),
-                                imp.ty,
-                            );
+                            enc_comp_ty.import(&imp.name, imp.url.as_deref().unwrap_or(""), imp.ty);
                         }
                         ComponentTypeDef::CoreType(ty) => {
                             ty.encode(enc_comp_ty.core_type());
@@ -191,8 +186,8 @@ impl Type {
                         ComponentTypeDef::Type(ty) => {
                             ty.encode(enc_comp_ty.ty());
                         }
-                        ComponentTypeDef::Export { name, url: _, ty } => {
-                            enc_comp_ty.export(wasm_encoder::ComponentExternName::Kebab(name), *ty);
+                        ComponentTypeDef::Export { name, url, ty } => {
+                            enc_comp_ty.export(name, url.as_deref().unwrap_or(""), *ty);
                         }
                         ComponentTypeDef::Alias(a) => {
                             enc_comp_ty.alias(translate_alias(a));
@@ -211,8 +206,8 @@ impl Type {
                         InstanceTypeDecl::Type(ty) => {
                             ty.encode(enc_inst_ty.ty());
                         }
-                        InstanceTypeDecl::Export { name, url: _, ty } => {
-                            enc_inst_ty.export(wasm_encoder::ComponentExternName::Kebab(name), *ty);
+                        InstanceTypeDecl::Export { name, url, ty } => {
+                            enc_inst_ty.export(name, url.as_deref().unwrap_or(""), *ty);
                         }
                         InstanceTypeDecl::Alias(a) => {
                             enc_inst_ty.alias(translate_alias(a));
diff --git a/crates/wasm-smith/src/config.rs b/crates/wasm-smith/src/config.rs
index 48471dc2..0d3b39ab 100644
--- a/crates/wasm-smith/src/config.rs
+++ b/crates/wasm-smith/src/config.rs
@@ -578,6 +578,7 @@ impl<'a> Arbitrary<'a> for SwarmConfig {
             min_uleb_size: u.int_in_range(0..=5)?,
             bulk_memory_enabled: reference_types_enabled || u.arbitrary()?,
             reference_types_enabled,
+            tail_call_enabled: u.arbitrary()?,
             simd_enabled: u.arbitrary()?,
             multi_value_enabled: u.arbitrary()?,
             max_aliases: u.int_in_range(0..=MAX_MAXIMUM)?,
@@ -627,7 +628,6 @@ impl<'a> Arbitrary<'a> for SwarmConfig {
             threads_enabled: false,
             export_everything: false,
             disallow_traps: false,
-            tail_call_enabled: false,
         })
     }
 }
diff --git a/crates/wasm-smith/src/core.rs b/crates/wasm-smith/src/core.rs
index e4468a8e..50289379 100644
--- a/crates/wasm-smith/src/core.rs
+++ b/crates/wasm-smith/src/core.rs
@@ -547,14 +547,14 @@ impl Module {
         // index in our newly generated module. Initially the option is `None` and will become a
         // `Some` when we encounter an import that uses this signature in the next portion of this
         // function. See also the `make_func_type` closure below.
-        let mut available_types = Vec::<(wasmparser::StructuralType, Option<u32>)>::new();
+        let mut available_types = Vec::<(wasmparser::Type, Option<u32>)>::new();
         let mut available_imports = Vec::<wasmparser::Import>::new();
         for payload in wasmparser::Parser::new(0).parse_all(&example_module) {
             match payload.expect("could not parse the available import payload") {
                 wasmparser::Payload::TypeSection(type_reader) => {
                     for ty in type_reader {
                         let ty = ty.expect("could not parse type section");
-                        available_types.push((ty.structural_type, None));
+                        available_types.push((ty, None));
                     }
                 }
                 wasmparser::Payload::ImportSection(import_reader) => {
@@ -587,7 +587,7 @@ impl Module {
             let serialized_sig_idx = match available_types.get_mut(parsed_sig_idx as usize) {
                 None => panic!("signature index refers to a type out of bounds"),
                 Some((_, Some(idx))) => *idx as usize,
-                Some((wasmparser::StructuralType::Func(func_type), index_store)) => {
+                Some((wasmparser::Type::Func(func_type), index_store)) => {
                     let multi_value_required = func_type.results().len() > 1;
                     let new_index = first_type_index + new_types.len();
                     if new_index >= max_types || (multi_value_required && !multi_value_enabled) {
@@ -609,12 +609,7 @@ impl Module {
                     new_types.push(Type::Func(Rc::clone(&func_type)));
                     new_index
                 }
-                Some((wasmparser::StructuralType::Array(_array_type), _index_store)) => {
-                    unimplemented!("Array types are not supported yet.");
-                }
-                Some((wasmparser::StructuralType::Struct(_struct_type), _index_store)) => {
-                    unimplemented!("Struct types are not supported yet.");
-                }
+                Some((wasmparser::Type::Cont(_), _)) => unimplemented!(),
             };
             match &new_types[serialized_sig_idx - first_type_index] {
                 Type::Func(f) => Some((serialized_sig_idx as u32, Rc::clone(f))),
@@ -1645,19 +1640,11 @@ fn convert_type(parsed_type: wasmparser::ValType) -> ValType {
 
 fn convert_reftype(ty: wasmparser::RefType) -> RefType {
     wasm_encoder::RefType {
-        nullable: ty.is_nullable(),
-        heap_type: match ty.heap_type() {
-            wasmparser::HeapType::Func => HeapType::Func,
-            wasmparser::HeapType::Extern => HeapType::Extern,
-            wasmparser::HeapType::Any => HeapType::Any,
-            wasmparser::HeapType::None => HeapType::None,
-            wasmparser::HeapType::NoExtern => HeapType::NoExtern,
-            wasmparser::HeapType::NoFunc => HeapType::NoFunc,
-            wasmparser::HeapType::Eq => HeapType::Eq,
-            wasmparser::HeapType::Struct => HeapType::Struct,
-            wasmparser::HeapType::Array => HeapType::Array,
-            wasmparser::HeapType::I31 => HeapType::I31,
-            wasmparser::HeapType::Indexed(i) => HeapType::Indexed(i.into()),
+        nullable: ty.nullable,
+        heap_type: match ty.heap_type {
+            wasmparser::HeapType::Func => wasm_encoder::HeapType::Func,
+            wasmparser::HeapType::Extern => wasm_encoder::HeapType::Extern,
+            wasmparser::HeapType::TypedFunc(i) => wasm_encoder::HeapType::TypedFunc(i.into()),
         },
     }
 }
diff --git a/crates/wasm-smith/src/lib.rs b/crates/wasm-smith/src/lib.rs
index 941843a3..63db1ad9 100644
--- a/crates/wasm-smith/src/lib.rs
+++ b/crates/wasm-smith/src/lib.rs
@@ -65,7 +65,7 @@ use arbitrary::{Result, Unstructured};
 pub use component::{Component, ConfiguredComponent};
 pub use config::{Config, DefaultConfig, SwarmConfig};
 use std::{collections::HashSet, fmt::Write, str};
-use wasmparser::names::{KebabStr, KebabString};
+use wasmparser::types::{KebabStr, KebabString};
 
 /// Do something an arbitrary number of times.
 ///
diff --git a/crates/wasm-smith/tests/component.rs b/crates/wasm-smith/tests/component.rs
index 7d5a4015..fe5d253f 100644
--- a/crates/wasm-smith/tests/component.rs
+++ b/crates/wasm-smith/tests/component.rs
@@ -3,7 +3,6 @@ use rand::{rngs::SmallRng, RngCore, SeedableRng};
 use wasm_smith::Component;
 
 #[test]
-#[ignore] // FIXME(#1000): need to update wasm-smith's support for components
 fn smoke_test_component() {
     const NUM_RUNS: usize = 4096;
 
diff --git a/crates/wasm-smith/tests/core.rs b/crates/wasm-smith/tests/core.rs
index 0e0115a8..2ec81354 100644
--- a/crates/wasm-smith/tests/core.rs
+++ b/crates/wasm-smith/tests/core.rs
@@ -130,14 +130,8 @@ fn smoke_test_imports_config() {
                 if let wasmparser::Payload::TypeSection(rdr) = payload {
                     // Gather the signature types to later check function types against.
                     for ty in rdr {
-                        match ty.unwrap().structural_type {
-                            wasmparser::StructuralType::Func(ft) => sig_types.push(ft),
-                            wasmparser::StructuralType::Array(_) => {
-                                unimplemented!("Array types are not supported yet.")
-                            }
-                            wasmparser::StructuralType::Struct(_) => {
-                                unimplemented!("Struct types are not supported yet.")
-                            }
+                        match ty.unwrap() {
+                            wasmparser::Type::Func(ft) => sig_types.push(ft),
                         }
                     }
                 } else if let wasmparser::Payload::ImportSection(rdr) = payload {
@@ -307,8 +301,8 @@ fn parser_features_from_config(config: &impl Config) -> WasmFeatures {
         extended_const: false,
         component_model: false,
         function_references: false,
+        typed_continuations: false,
         memory_control: false,
-        gc: false,
     }
 }
 
diff --git a/crates/wasmparser/Cargo.toml b/crates/wasmparser/Cargo.toml
index 520c22cb..5cb434c5 100644
--- a/crates/wasmparser/Cargo.toml
+++ b/crates/wasmparser/Cargo.toml
@@ -1,6 +1,6 @@
 [package]
 name = "wasmparser"
-version = "0.108.0"
+version = "0.102.0"
 authors = ["Yury Delendik <ydelendik@mozilla.com>"]
 license = "Apache-2.0 WITH LLVM-exception"
 repository = "https://github.com/bytecodealliance/wasm-tools/tree/main/crates/wasmparser"
@@ -14,7 +14,7 @@ exclude = ["benches/*.wasm"]
 
 [dependencies]
 indexmap = { workspace = true }
-semver = { workspace = true }
+url = { workspace = true }
 
 [dev-dependencies]
 anyhow = { workspace = true }
diff --git a/crates/wasmparser/benches/benchmark.rs b/crates/wasmparser/benches/benchmark.rs
index e706a9dd..5fb7b839 100644
--- a/crates/wasmparser/benches/benchmark.rs
+++ b/crates/wasmparser/benches/benchmark.rs
@@ -256,7 +256,6 @@ fn define_benchmarks(c: &mut Criterion) {
             sign_extension: true,
             function_references: true,
             memory_control: true,
-            gc: true,
         })
     }
 
diff --git a/crates/wasmparser/src/binary_reader.rs b/crates/wasmparser/src/binary_reader.rs
index 9fcfca89..153a8a8d 100644
--- a/crates/wasmparser/src/binary_reader.rs
+++ b/crates/wasmparser/src/binary_reader.rs
@@ -21,7 +21,7 @@ use std::marker;
 use std::ops::Range;
 use std::str;
 
-pub(crate) const WASM_MAGIC_NUMBER: &[u8; 4] = b"\0asm";
+const WASM_MAGIC_NUMBER: &[u8; 4] = b"\0asm";
 
 /// A binary reader for WebAssembly modules.
 #[derive(Debug, Clone)]
@@ -92,11 +92,6 @@ impl BinaryReaderError {
     pub fn offset(&self) -> usize {
         self.inner.offset
     }
-
-    pub(crate) fn add_context(&mut self, mut context: String) {
-        context.push_str("\n");
-        self.inner.message.insert_str(0, &context);
-    }
 }
 
 /// A binary reader of the WebAssembly structures and types.
@@ -293,6 +288,19 @@ impl<'a> BinaryReader<'a> {
         })
     }
 
+    fn read_resume_table(&mut self) -> Result<ResumeTable<'a>> {
+        let cnt = self.read_size(MAX_WASM_RESUME_TABLE_SIZE, "resume_table")?;
+        let start = self.position;
+        for _ in 0..(cnt * 2) {
+            self.read_var_u32()?;
+        }
+        let end = self.position;
+        Ok(ResumeTable {
+            reader: BinaryReader::new_with_offset(&self.buffer[start..end], start),
+            cnt: cnt as u32,
+        })
+    }
+
     /// Returns whether the `BinaryReader` has reached the end of the file.
     #[inline]
     pub fn eof(&self) -> bool {
@@ -982,30 +990,20 @@ impl<'a> BinaryReader<'a> {
             0xd4 => visitor.visit_br_on_null(self.read_var_u32()?),
             0xd6 => visitor.visit_br_on_non_null(self.read_var_u32()?),
 
-            0xfb => self.visit_0xfb_operator(pos, visitor)?,
             0xfc => self.visit_0xfc_operator(pos, visitor)?,
             0xfd => self.visit_0xfd_operator(pos, visitor)?,
             0xfe => self.visit_0xfe_operator(pos, visitor)?,
 
-            _ => bail!(pos, "illegal opcode: 0x{code:x}"),
-        })
-    }
+            // Typed continuations operators.
+            // TODO(dhil) fixme: merge into the above list.
+            0xe0 => visitor.visit_cont_new(self.read_var_u32()?),
+            0xe1 => visitor.visit_cont_bind(self.read_var_u32()?),
+            0xe2 => visitor.visit_suspend(self.read_var_u32()?),
+            0xe3 => visitor.visit_resume(self.read_resume_table()?),
+            0xe4 => visitor.visit_resume_throw(self.read_var_u32()?, self.read_resume_table()?),
+            0xe5 => visitor.visit_barrier(self.read_block_type()?),
 
-    fn visit_0xfb_operator<T>(
-        &mut self,
-        pos: usize,
-        visitor: &mut T,
-    ) -> Result<<T as VisitOperator<'a>>::Output>
-    where
-        T: VisitOperator<'a>,
-    {
-        let code = self.read_var_u32()?;
-        Ok(match code {
-            0x20 => visitor.visit_i31_new(),
-            0x21 => visitor.visit_i31_get_s(),
-            0x22 => visitor.visit_i31_get_u(),
-
-            _ => bail!(pos, "unknown 0xfb subopcode: 0x{code:x}"),
+            _ => bail!(pos, "illegal opcode: 0x{code:x}"),
         })
     }
 
@@ -1632,6 +1630,98 @@ impl fmt::Debug for BrTable<'_> {
     }
 }
 
+// Resume table
+impl<'a> ResumeTable<'a> {
+    /// Returns the number of `resume` entries.
+    pub fn len(&self) -> u32 {
+        self.cnt
+    }
+
+    /// Returns whether `ResumeTable` doesn't have any entries.
+    pub fn is_empty(&self) -> bool {
+        self.len() == 0
+    }
+
+    /// Returns the list of targets that this `resume` instruction will be
+    /// jumping to.
+    ///
+    /// This method will return an iterator which parses each target
+    /// of this `resume`. The returned iterator will yield
+    /// `self.len()` elements.
+    ///
+    /// # Examples
+    ///
+    /// ```rust
+    /// let buf = [0xe3, 0x01, 0x01, 0x02, 0x00];
+    /// let mut reader = wasmparser::BinaryReader::new(&buf);
+    /// let op = reader.read_operator().unwrap();
+    /// if let wasmparser::Operator::Resume { table } = op {
+    ///     let targets = table.targets().collect::<Result<Vec<(_,_)>, _>>().unwrap();
+    ///     assert_eq!(targets, [(1, 2)]);
+    /// }
+    /// ```
+    pub fn targets(&self) -> ResumeTableTargets {
+        ResumeTableTargets {
+            reader: self.reader.clone(),
+            remaining: self.cnt,
+        }
+    }
+}
+
+/// An iterator over the targets of a [`ResumeTable`].
+///
+/// # Note
+///
+/// This iterator parses each target of the underlying `resume`.  The
+/// iterator will yield exactly as many targets as the `resume` has.
+pub struct ResumeTableTargets<'a> {
+    reader: crate::BinaryReader<'a>,
+    remaining: u32,
+}
+
+impl<'a> Iterator for ResumeTableTargets<'a> {
+    type Item = Result<(u32, u32)>;
+
+    fn size_hint(&self) -> (usize, Option<usize>) {
+        let remaining = usize::try_from(self.remaining).unwrap_or_else(|error| {
+            panic!("could not convert remaining `u32` into `usize`: {}", error)
+        });
+        (remaining, Some(remaining))
+    }
+
+    fn next(&mut self) -> Option<Self::Item> {
+        if self.remaining == 0 {
+            if !self.reader.eof() {
+                return Some(Err(BinaryReaderError::new(
+                    "trailing data in resume",
+                    self.reader.original_position(),
+                )));
+            }
+            return None;
+        }
+        self.remaining -= 1;
+        let tag = self.reader.read_var_u32().ok()?;
+        let label = self.reader.read_var_u32().ok()?;
+        Some(Ok((tag, label)))
+    }
+}
+
+impl fmt::Debug for ResumeTable<'_> {
+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
+        let mut f = f.debug_struct("ResumeTable");
+        f.field("count", &self.cnt);
+        match self.targets().collect::<Result<Vec<(_, _)>>>() {
+            Ok(targets) => {
+                f.field("targets", &targets);
+            }
+            Err(_) => {
+                f.field("reader", &self.reader);
+            }
+        }
+        f.finish()
+    }
+}
+
 /// A factory to construct [`Operator`] instances via the [`VisitOperator`] trait.
 struct OperatorFactory<'a> {
     marker: core::marker::PhantomData<fn() -> &'a ()>,
diff --git a/crates/wasmparser/src/lib.rs b/crates/wasmparser/src/lib.rs
index 8f9565c2..aa0fccfa 100644
--- a/crates/wasmparser/src/lib.rs
+++ b/crates/wasmparser/src/lib.rs
@@ -49,7 +49,6 @@
 /// - `@threads`: [Wasm `threads` proposal]
 /// - `@simd`: [Wasm `simd` proposal]
 /// - `@relaxed_simd`: [Wasm `relaxed-simd` proposal]
-/// - `@gc`: [Wasm `gc` proposal]
 ///
 /// [Wasm `expection-handling` proposal]:
 /// https://github.com/WebAssembly/exception-handling
@@ -78,9 +77,6 @@
 /// [Wasm `relaxed-simd` proposal]:
 /// https://github.com/WebAssembly/relaxed-simd
 ///
-/// [Wasm `gc` proposal]:
-/// https://github.com/WebAssembly/gc
-///
 /// ```
 /// macro_rules! define_visit_operator {
 ///     // The outer layer of repetition represents how all operators are
@@ -310,13 +306,6 @@ macro_rules! for_each_operator {
             @sign_extension I64Extend16S => visit_i64_extend16_s
             @sign_extension I64Extend32S => visit_i64_extend32_s
 
-            // 0xFB prefixed operators
-            // Garbage Collection
-            // http://github.com/WebAssembly/gc
-            @gc I31New => visit_i31_new
-            @gc I31GetS => visit_i31_get_s
-            @gc I31GetU => visit_i31_get_u
-
             // 0xFC operators
             // Non-trapping Float-to-int Conversions
             // https://github.com/WebAssembly/nontrapping-float-to-int-conversions
@@ -690,11 +679,19 @@ macro_rules! for_each_operator {
             @relaxed_simd I32x4RelaxedDotI8x16I7x16AddS => visit_i32x4_relaxed_dot_i8x16_i7x16_add_s
 
             // Typed Function references
-            @function_references CallRef { type_index: u32 } => visit_call_ref
-            @function_references ReturnCallRef { type_index: u32 } => visit_return_call_ref
+            @function_references CallRef { hty: $crate::HeapType } => visit_call_ref
+            @function_references ReturnCallRef { hty: $crate::HeapType } => visit_return_call_ref
             @function_references RefAsNonNull => visit_ref_as_non_null
             @function_references BrOnNull { relative_depth: u32 } => visit_br_on_null
             @function_references BrOnNonNull { relative_depth: u32 } => visit_br_on_non_null
+
+            // Typed continuations
+            @typed_continuations ContNew { type_index: u32 } => visit_cont_new
+            @typed_continuations ContBind { type_index: u32 } => visit_cont_bind
+            @typed_continuations Suspend { tag_index: u32 } => visit_suspend
+            @typed_continuations Resume { resumetable: $crate::ResumeTable<'a> } => visit_resume
+            @typed_continuations ResumeThrow { tag_index: u32, resumetable: $crate::ResumeTable<'a> } => visit_resume_throw
+            @typed_continuations Barrier { blockty: $crate::BlockType } => visit_barrier
         }
     };
 }
diff --git a/crates/wasmparser/src/limits.rs b/crates/wasmparser/src/limits.rs
index 139dbae2..6909a2ed 100644
--- a/crates/wasmparser/src/limits.rs
+++ b/crates/wasmparser/src/limits.rs
@@ -16,7 +16,6 @@
 // The following limits are imposed by wasmparser on WebAssembly modules.
 // The limits are agreed upon with other engines for consistency.
 pub const MAX_WASM_TYPES: usize = 1_000_000;
-pub const MAX_WASM_SUPERTYPES: usize = 1;
 pub const MAX_WASM_FUNCTIONS: usize = 1_000_000;
 pub const MAX_WASM_EXPORTS: usize = 100_000;
 pub const MAX_WASM_GLOBALS: usize = 1_000_000;
@@ -35,7 +34,7 @@ pub const MAX_WASM_TABLES: usize = 100;
 pub const MAX_WASM_MEMORIES: usize = 100;
 pub const MAX_WASM_TAGS: usize = 1_000_000;
 pub const MAX_WASM_BR_TABLE_SIZE: usize = MAX_WASM_FUNCTION_SIZE;
-pub const MAX_WASM_STRUCT_FIELDS: usize = 10_000;
+pub const MAX_WASM_RESUME_TABLE_SIZE: usize = MAX_WASM_FUNCTION_SIZE;
 
 // Component-related limits
 pub const MAX_WASM_MODULE_SIZE: usize = 1024 * 1024 * 1024; //= 1 GiB
diff --git a/crates/wasmparser/src/parser.rs b/crates/wasmparser/src/parser.rs
index 87c47f23..227530ab 100644
--- a/crates/wasmparser/src/parser.rs
+++ b/crates/wasmparser/src/parser.rs
@@ -1,4 +1,3 @@
-use crate::binary_reader::WASM_MAGIC_NUMBER;
 use crate::CoreTypeSectionReader;
 use crate::{
     limits::MAX_WASM_MODULE_SIZE, BinaryReader, BinaryReaderError, ComponentCanonicalSectionReader,
@@ -19,14 +18,9 @@ pub(crate) const WASM_MODULE_VERSION: u16 = 0x1;
 // the component model is stabilized this will become 0x1. The changes here are:
 //
 // * [????-??-??] 0xa - original version
-// * [2023-01-05] 0xb - `export` introduces an alias
-// * [2023-02-06] 0xc - `export` has an optional type ascribed to it
-// * [2023-05-10] 0xd - imports/exports drop URLs, new discriminator byte which
-//                      allows for `(import (interface "...") ...)` syntax.
-pub(crate) const WASM_COMPONENT_VERSION: u16 = 0xd;
-
-const KIND_MODULE: u16 = 0x00;
-const KIND_COMPONENT: u16 = 0x01;
+// * [2022-01-05] 0xb - `export` introduces an alias
+// * [2022-02-06] 0xc - `export` has an optional type ascribed to it
+pub(crate) const WASM_COMPONENT_VERSION: u16 = 0xc;
 
 /// The supported encoding formats for the parser.
 #[derive(Debug, Clone, Copy, Eq, PartialEq)]
@@ -338,42 +332,6 @@ impl Parser {
         }
     }
 
-    /// Tests whether `bytes` looks like a core WebAssembly module.
-    ///
-    /// This will inspect the first 8 bytes of `bytes` and return `true` if it
-    /// starts with the standard core WebAssembly header.
-    pub fn is_core_wasm(bytes: &[u8]) -> bool {
-        const HEADER: [u8; 8] = [
-            WASM_MAGIC_NUMBER[0],
-            WASM_MAGIC_NUMBER[1],
-            WASM_MAGIC_NUMBER[2],
-            WASM_MAGIC_NUMBER[3],
-            WASM_MODULE_VERSION.to_le_bytes()[0],
-            WASM_MODULE_VERSION.to_le_bytes()[1],
-            KIND_MODULE.to_le_bytes()[0],
-            KIND_MODULE.to_le_bytes()[1],
-        ];
-        bytes.starts_with(&HEADER)
-    }
-
-    /// Tests whether `bytes` looks like a WebAssembly component.
-    ///
-    /// This will inspect the first 8 bytes of `bytes` and return `true` if it
-    /// starts with the standard WebAssembly component header.
-    pub fn is_component(bytes: &[u8]) -> bool {
-        const HEADER: [u8; 8] = [
-            WASM_MAGIC_NUMBER[0],
-            WASM_MAGIC_NUMBER[1],
-            WASM_MAGIC_NUMBER[2],
-            WASM_MAGIC_NUMBER[3],
-            WASM_COMPONENT_VERSION.to_le_bytes()[0],
-            WASM_COMPONENT_VERSION.to_le_bytes()[1],
-            KIND_COMPONENT.to_le_bytes()[0],
-            KIND_COMPONENT.to_le_bytes()[1],
-        ];
-        bytes.starts_with(&HEADER)
-    }
-
     /// Attempts to parse a chunk of data.
     ///
     /// This method will attempt to parse the next incremental portion of a
@@ -562,6 +520,9 @@ impl Parser {
 
         match self.state {
             State::Header => {
+                const KIND_MODULE: u16 = 0x00;
+                const KIND_COMPONENT: u16 = 0x01;
+
                 let start = reader.original_position();
                 let header_version = reader.read_header_version()?;
                 self.encoding = match (header_version >> 16) as u16 {
@@ -1206,7 +1167,7 @@ mod tests {
     fn parser_after_component_header() -> Parser {
         let mut p = Parser::default();
         assert_matches!(
-            p.parse(b"\0asm\x0d\0\x01\0", false),
+            p.parse(b"\0asm\x0c\0\x01\0", false),
             Ok(Chunk::Parsed {
                 consumed: 8,
                 payload: Payload::Version {
diff --git a/crates/wasmparser/src/readers/component/canonicals.rs b/crates/wasmparser/src/readers/component/canonicals.rs
index 3b8c64b7..e360d029 100644
--- a/crates/wasmparser/src/readers/component/canonicals.rs
+++ b/crates/wasmparser/src/readers/component/canonicals.rs
@@ -43,22 +43,6 @@ pub enum CanonicalFunction {
         /// The canonical options for the function.
         options: Box<[CanonicalOption]>,
     },
-    /// A function which creates a new owned handle to a resource.
-    ResourceNew {
-        /// The type index of the resource that's being created.
-        resource: u32,
-    },
-    /// A function which is used to drop resource handles of the specified type.
-    ResourceDrop {
-        /// The type index of the resource that's being dropped.
-        resource: u32,
-    },
-    /// A function which returns the underlying i32-based representation of the
-    /// specified resource.
-    ResourceRep {
-        /// The type index of the resource that's being accessed.
-        resource: u32,
-    },
 }
 
 /// A reader for the canonical section of a WebAssembly component.
@@ -91,15 +75,6 @@ impl<'a> FromReader<'a> for CanonicalFunction {
                 },
                 x => return reader.invalid_leading_byte(x, "canonical function lower"),
             },
-            0x02 => CanonicalFunction::ResourceNew {
-                resource: reader.read()?,
-            },
-            0x03 => CanonicalFunction::ResourceDrop {
-                resource: reader.read()?,
-            },
-            0x04 => CanonicalFunction::ResourceRep {
-                resource: reader.read()?,
-            },
             x => return reader.invalid_leading_byte(x, "canonical function"),
         })
     }
diff --git a/crates/wasmparser/src/readers/component/exports.rs b/crates/wasmparser/src/readers/component/exports.rs
index 35c54394..8ce5f43a 100644
--- a/crates/wasmparser/src/readers/component/exports.rs
+++ b/crates/wasmparser/src/readers/component/exports.rs
@@ -1,6 +1,4 @@
-use crate::{
-    BinaryReader, ComponentExternName, ComponentTypeRef, FromReader, Result, SectionLimited,
-};
+use crate::{BinaryReader, ComponentTypeRef, FromReader, Result, SectionLimited};
 
 /// Represents the kind of an external items of a WebAssembly component.
 #[derive(Clone, Copy, Debug, Eq, PartialEq)]
@@ -50,26 +48,15 @@ impl ComponentExternalKind {
             }
         })
     }
-
-    /// Returns a simple string description of this kind.
-    pub fn desc(&self) -> &'static str {
-        use ComponentExternalKind::*;
-        match self {
-            Module => "module",
-            Func => "func",
-            Value => "value",
-            Type => "type",
-            Instance => "instance",
-            Component => "component",
-        }
-    }
 }
 
 /// Represents an export in a WebAssembly component.
 #[derive(Debug, Clone)]
 pub struct ComponentExport<'a> {
     /// The name of the exported item.
-    pub name: ComponentExternName<'a>,
+    pub name: &'a str,
+    /// The optional URL of the exported item.
+    pub url: &'a str,
     /// The kind of the export.
     pub kind: ComponentExternalKind,
     /// The index of the exported item.
@@ -85,6 +72,7 @@ impl<'a> FromReader<'a> for ComponentExport<'a> {
     fn from_reader(reader: &mut BinaryReader<'a>) -> Result<Self> {
         Ok(ComponentExport {
             name: reader.read()?,
+            url: reader.read()?,
             kind: reader.read()?,
             index: reader.read()?,
             ty: match reader.read_u8()? {
diff --git a/crates/wasmparser/src/readers/component/imports.rs b/crates/wasmparser/src/readers/component/imports.rs
index d5e09cbc..c1313c11 100644
--- a/crates/wasmparser/src/readers/component/imports.rs
+++ b/crates/wasmparser/src/readers/component/imports.rs
@@ -6,16 +6,13 @@ use crate::{
 #[derive(Clone, Copy, Debug, Eq, PartialEq)]
 pub enum TypeBounds {
     /// The type is bounded by equality.
-    Eq(u32),
-    /// A fresh resource type,
-    SubResource,
+    Eq,
 }
 
 impl<'a> FromReader<'a> for TypeBounds {
     fn from_reader(reader: &mut BinaryReader<'a>) -> Result<Self> {
         Ok(match reader.read_u8()? {
-            0x00 => TypeBounds::Eq(reader.read()?),
-            0x01 => TypeBounds::SubResource,
+            0x00 => TypeBounds::Eq,
             x => return reader.invalid_leading_byte(x, "type bound"),
         })
     }
@@ -37,7 +34,7 @@ pub enum ComponentTypeRef {
     /// The reference is to a bounded type.
     ///
     /// The index is expected to be a type index.
-    Type(TypeBounds),
+    Type(TypeBounds, u32),
     /// The reference is to an instance type.
     ///
     /// The index is a type index to an instance type.
@@ -68,7 +65,7 @@ impl<'a> FromReader<'a> for ComponentTypeRef {
             ComponentExternalKind::Module => ComponentTypeRef::Module(reader.read()?),
             ComponentExternalKind::Func => ComponentTypeRef::Func(reader.read()?),
             ComponentExternalKind::Value => ComponentTypeRef::Value(reader.read()?),
-            ComponentExternalKind::Type => ComponentTypeRef::Type(reader.read()?),
+            ComponentExternalKind::Type => ComponentTypeRef::Type(reader.read()?, reader.read()?),
             ComponentExternalKind::Instance => ComponentTypeRef::Instance(reader.read()?),
             ComponentExternalKind::Component => ComponentTypeRef::Component(reader.read()?),
         })
@@ -79,7 +76,9 @@ impl<'a> FromReader<'a> for ComponentTypeRef {
 #[derive(Debug, Copy, Clone)]
 pub struct ComponentImport<'a> {
     /// The name of the imported item.
-    pub name: ComponentExternName<'a>,
+    pub name: &'a str,
+    /// The optional URL of the imported item.
+    pub url: &'a str,
     /// The type reference for the import.
     pub ty: ComponentTypeRef,
 }
@@ -88,6 +87,7 @@ impl<'a> FromReader<'a> for ComponentImport<'a> {
     fn from_reader(reader: &mut BinaryReader<'a>) -> Result<Self> {
         Ok(ComponentImport {
             name: reader.read()?,
+            url: reader.read()?,
             ty: reader.read()?,
         })
     }
@@ -99,7 +99,7 @@ impl<'a> FromReader<'a> for ComponentImport<'a> {
 ///
 /// ```
 /// use wasmparser::ComponentImportSectionReader;
-/// let data: &[u8] = &[0x01, 0x00, 0x01, 0x41, 0x01, 0x66];
+/// let data: &[u8] = &[0x01, 0x01, 0x41, 0x00, 0x01, 0x66];
 /// let reader = ComponentImportSectionReader::new(data, 0).unwrap();
 /// for import in reader {
 ///     let import = import.expect("import");
@@ -107,31 +107,3 @@ impl<'a> FromReader<'a> for ComponentImport<'a> {
 /// }
 /// ```
 pub type ComponentImportSectionReader<'a> = SectionLimited<'a, ComponentImport<'a>>;
-
-/// Represents the name of a component import.
-#[derive(Debug, Copy, Clone)]
-#[allow(missing_docs)]
-pub enum ComponentExternName<'a> {
-    Kebab(&'a str),
-    Interface(&'a str),
-}
-
-impl<'a> ComponentExternName<'a> {
-    /// Returns the underlying string representing this name.
-    pub fn as_str(&self) -> &'a str {
-        match self {
-            ComponentExternName::Kebab(name) => name,
-            ComponentExternName::Interface(name) => name,
-        }
-    }
-}
-
-impl<'a> FromReader<'a> for ComponentExternName<'a> {
-    fn from_reader(reader: &mut BinaryReader<'a>) -> Result<Self> {
-        Ok(match reader.read_u8()? {
-            0x00 => ComponentExternName::Kebab(reader.read()?),
-            0x01 => ComponentExternName::Interface(reader.read()?),
-            x => return reader.invalid_leading_byte(x, "import name"),
-        })
-    }
-}
diff --git a/crates/wasmparser/src/readers/component/instances.rs b/crates/wasmparser/src/readers/component/instances.rs
index a33762c4..8166395e 100644
--- a/crates/wasmparser/src/readers/component/instances.rs
+++ b/crates/wasmparser/src/readers/component/instances.rs
@@ -141,6 +141,7 @@ impl<'a> FromReader<'a> for ComponentInstance<'a> {
                     .map(|_| {
                         Ok(ComponentExport {
                             name: reader.read()?,
+                            url: "",
                             kind: reader.read()?,
                             index: reader.read()?,
                             ty: None,
diff --git a/crates/wasmparser/src/readers/component/types.rs b/crates/wasmparser/src/readers/component/types.rs
index c33feaa9..b0e9687a 100644
--- a/crates/wasmparser/src/readers/component/types.rs
+++ b/crates/wasmparser/src/readers/component/types.rs
@@ -1,9 +1,8 @@
 use crate::limits::*;
 use crate::{
-    BinaryReader, ComponentAlias, ComponentExternName, ComponentImport, ComponentTypeRef,
-    FromReader, FuncType, Import, Result, SectionLimited, SubType, TypeRef, ValType,
+    BinaryReader, ComponentAlias, ComponentImport, ComponentTypeRef, FromReader, FuncType, Import,
+    Result, SectionLimited, Type, TypeRef,
 };
-use std::fmt;
 
 /// Represents the kind of an outer core alias in a WebAssembly component.
 #[derive(Clone, Copy, Debug, Eq, PartialEq)]
@@ -39,7 +38,7 @@ impl<'a> FromReader<'a> for CoreType<'a> {
 #[derive(Debug, Clone)]
 pub enum ModuleTypeDeclaration<'a> {
     /// The module type definition is for a type.
-    Type(SubType),
+    Type(Type),
     /// The module type definition is for an export.
     Export {
         /// The name of the exported item.
@@ -202,28 +201,6 @@ impl PrimitiveValType {
     }
 }
 
-impl fmt::Display for PrimitiveValType {
-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
-        use PrimitiveValType::*;
-        let s = match self {
-            Bool => "bool",
-            S8 => "s8",
-            U8 => "u8",
-            S16 => "s16",
-            U16 => "u16",
-            S32 => "s32",
-            U32 => "u32",
-            S64 => "s64",
-            U64 => "u64",
-            Float32 => "float32",
-            Float64 => "float64",
-            Char => "char",
-            String => "string",
-        };
-        s.fmt(f)
-    }
-}
-
 /// Represents a type in a WebAssembly component.
 #[derive(Debug, Clone)]
 pub enum ComponentType<'a> {
@@ -235,27 +212,11 @@ pub enum ComponentType<'a> {
     Component(Box<[ComponentTypeDeclaration<'a>]>),
     /// The type is an instance type.
     Instance(Box<[InstanceTypeDeclaration<'a>]>),
-    /// The type is a fresh new resource type.
-    Resource {
-        /// The representation of this resource type in core WebAssembly.
-        rep: ValType,
-        /// An optionally-specified destructor to use for when this resource is
-        /// no longer needed.
-        dtor: Option<u32>,
-    },
 }
 
 impl<'a> FromReader<'a> for ComponentType<'a> {
     fn from_reader(reader: &mut BinaryReader<'a>) -> Result<Self> {
         Ok(match reader.read_u8()? {
-            0x3f => ComponentType::Resource {
-                rep: reader.read()?,
-                dtor: match reader.read_u8()? {
-                    0x00 => None,
-                    0x01 => Some(reader.read()?),
-                    b => return reader.invalid_leading_byte(b, "resource destructor"),
-                },
-            },
             0x40 => {
                 let params = reader
                     .read_iter(MAX_WASM_FUNCTION_PARAMS, "component function parameters")?
@@ -296,7 +257,9 @@ pub enum ComponentTypeDeclaration<'a> {
     /// The component type declaration is for an export.
     Export {
         /// The name of the export.
-        name: ComponentExternName<'a>,
+        name: &'a str,
+        /// The optional URL of the export.
+        url: &'a str,
         /// The type reference for the export.
         ty: ComponentTypeRef,
     },
@@ -318,8 +281,8 @@ impl<'a> FromReader<'a> for ComponentTypeDeclaration<'a> {
             InstanceTypeDeclaration::CoreType(t) => ComponentTypeDeclaration::CoreType(t),
             InstanceTypeDeclaration::Type(t) => ComponentTypeDeclaration::Type(t),
             InstanceTypeDeclaration::Alias(a) => ComponentTypeDeclaration::Alias(a),
-            InstanceTypeDeclaration::Export { name, ty } => {
-                ComponentTypeDeclaration::Export { name, ty }
+            InstanceTypeDeclaration::Export { name, url, ty } => {
+                ComponentTypeDeclaration::Export { name, url, ty }
             }
         })
     }
@@ -337,7 +300,9 @@ pub enum InstanceTypeDeclaration<'a> {
     /// The instance type declaration is for an export.
     Export {
         /// The name of the export.
-        name: ComponentExternName<'a>,
+        name: &'a str,
+        /// The URL for the export.
+        url: &'a str,
         /// The type reference for the export.
         ty: ComponentTypeRef,
     },
@@ -351,6 +316,7 @@ impl<'a> FromReader<'a> for InstanceTypeDeclaration<'a> {
             0x02 => InstanceTypeDeclaration::Alias(reader.read()?),
             0x04 => InstanceTypeDeclaration::Export {
                 name: reader.read()?,
+                url: reader.read()?,
                 ty: reader.read()?,
             },
             x => return reader.invalid_leading_byte(x, "component or instance type declaration"),
@@ -481,10 +447,6 @@ pub enum ComponentDefinedType<'a> {
         /// The type returned for failure.
         err: Option<ComponentValType>,
     },
-    /// An owned handle to a resource.
-    Own(u32),
-    /// A borrowed handle to a resource.
-    Borrow(u32),
 }
 
 impl<'a> ComponentDefinedType<'a> {
@@ -526,8 +488,6 @@ impl<'a> ComponentDefinedType<'a> {
                 ok: reader.read()?,
                 err: reader.read()?,
             },
-            0x69 => ComponentDefinedType::Own(reader.read()?),
-            0x68 => ComponentDefinedType::Borrow(reader.read()?),
             x => return reader.invalid_leading_byte(x, "component defined type"),
         })
     }
diff --git a/crates/wasmparser/src/readers/core.rs b/crates/wasmparser/src/readers/core.rs
index c558d180..c42bbf8d 100644
--- a/crates/wasmparser/src/readers/core.rs
+++ b/crates/wasmparser/src/readers/core.rs
@@ -1,5 +1,4 @@
 mod code;
-mod coredumps;
 mod custom;
 mod data;
 mod elements;
@@ -17,7 +16,6 @@ mod tags;
 mod types;
 
 pub use self::code::*;
-pub use self::coredumps::*;
 pub use self::custom::*;
 pub use self::data::*;
 pub use self::elements::*;
diff --git a/crates/wasmparser/src/readers/core/coredumps.rs b/crates/wasmparser/src/readers/core/coredumps.rs
deleted file mode 100644
index 3579fdce..00000000
--- a/crates/wasmparser/src/readers/core/coredumps.rs
+++ /dev/null
@@ -1,243 +0,0 @@
-use crate::{BinaryReader, FromReader, Result};
-
-/// The data portion of a custom section representing a core dump. Per the
-/// tool-conventions repo, this section just specifies the executable name that
-/// the core dump came from while the rest of the core dump information is
-/// contained in a corestack custom section
-///
-/// # Examples
-///
-/// ```
-/// use wasmparser::{ BinaryReader, CoreDumpSection, FromReader, Result };
-/// let data: &[u8] = &[0x00, 0x09, 0x74, 0x65, 0x73, 0x74, 0x2e, 0x77, 0x61,
-///      0x73, 0x6d];
-/// let mut reader = BinaryReader::new(data);
-/// let core = CoreDumpSection::from_reader(&mut reader).unwrap();
-/// assert!(core.name == "test.wasm")
-/// ```
-pub struct CoreDumpSection<'a> {
-    /// The name of the process that created the core dump
-    pub name: &'a str,
-}
-
-impl<'a> FromReader<'a> for CoreDumpSection<'a> {
-    fn from_reader(reader: &mut BinaryReader<'a>) -> Result<Self> {
-        let pos = reader.original_position();
-        if reader.read_u8()? != 0 {
-            bail!(pos, "invalid start byte for core dump name");
-        }
-        let name = reader.read_string()?;
-        Ok(CoreDumpSection { name })
-    }
-}
-
-/// The data portion of a "coremodules" custom section. This contains a vec of
-/// module names that will be referenced by index by other coredump sections.
-///
-/// # Example
-///
-/// ```
-/// use wasmparser::{ BinaryReader, CoreDumpModulesSection, FromReader, Result };
-/// let data: &[u8] = &[0x01, 0x00, 0x04, 0x74, 0x65, 0x73, 0x74];
-/// let mut reader = BinaryReader::new(data);
-/// let modules_section = CoreDumpModulesSection::from_reader(&mut reader).unwrap();
-/// assert!(modules_section.modules[0] == "test")
-/// ```
-#[derive(Debug)]
-pub struct CoreDumpModulesSection<'a> {
-    /// A list of module names, which may be URLs, file paths, or other
-    /// identifiers for the module.
-    pub modules: Vec<&'a str>,
-}
-
-impl<'a> FromReader<'a> for CoreDumpModulesSection<'a> {
-    fn from_reader(reader: &mut BinaryReader<'a>) -> Result<Self> {
-        let pos = reader.original_position();
-        let mut modules = vec![];
-        for _ in 0..reader.read_var_u32()? {
-            if reader.read_u8()? != 0 {
-                bail!(pos, "invalid start byte for coremodule");
-            }
-            modules.push(reader.read_string()?);
-        }
-        Ok(CoreDumpModulesSection { modules })
-    }
-}
-/// A custom section representing the instances involved in a given coredump
-pub struct CoreDumpInstancesSection {
-    /// The instances for the coredump
-    pub instances: Vec<CoreDumpInstance>,
-}
-
-impl<'a> FromReader<'a> for CoreDumpInstancesSection {
-    fn from_reader(reader: &mut BinaryReader<'a>) -> Result<Self> {
-        let mut instances = vec![];
-        for _ in 0..reader.read_var_u32()? {
-            instances.push(CoreDumpInstance::from_reader(reader)?);
-        }
-        Ok(CoreDumpInstancesSection { instances })
-    }
-}
-
-/// A single instance from a coredump instances section
-pub struct CoreDumpInstance {
-    /// The module that this is an instance of, as an index into a "coremodules"
-    /// section.
-    pub module_index: u32,
-
-    /// Which of the coredump's memories are this instance's memories, via
-    /// indexing into the memory index space.
-    pub memories: Vec<u32>,
-
-    /// Which of the coredump's globals are this instance's globals, via
-    /// indexing into the global index space.
-    pub globals: Vec<u32>,
-}
-
-impl<'a> FromReader<'a> for CoreDumpInstance {
-    fn from_reader(reader: &mut BinaryReader<'a>) -> Result<Self> {
-        let pos = reader.original_position();
-        if reader.read_u8()? != 0 {
-            bail!(pos, "invalid start byte for core dump instance");
-        }
-        let module_index = reader.read_var_u32()?;
-        let mut memories = vec![];
-        for _ in 0..reader.read_var_u32()? {
-            memories.push(reader.read_var_u32()?);
-        }
-        let mut globals = vec![];
-
-        for _ in 0..reader.read_var_u32()? {
-            globals.push(reader.read_var_u32()?);
-        }
-
-        Ok(CoreDumpInstance {
-            module_index,
-            memories,
-            globals,
-        })
-    }
-}
-
-/// The data portion of a custom section representing a core dump stack. The
-/// structure of this follows the coredump spec in the tool-conventions repo
-///
-/// # Examples
-///
-/// ```
-/// let data: &[u8] = &[0x00, 0x04, 0x6d, 0x61, 0x69, 0x6e, 0x01, 0x00, 0x04,
-///     0x2a, 0x33, 0x01, 0x7f, 0x01, 0x01, 0x7f, 0x02];
-/// use wasmparser::{ BinaryReader, CoreDumpStackSection, FromReader };
-/// let mut reader = BinaryReader::new(data);
-/// let corestack = CoreDumpStackSection::from_reader(&mut reader).unwrap();
-/// assert!(corestack.name == "main");
-/// assert!(corestack.frames.len() == 1);
-/// let frame = &corestack.frames[0];
-/// assert!(frame.instanceidx == 4);
-/// assert!(frame.funcidx == 42);
-/// assert!(frame.codeoffset == 51);
-/// assert!(frame.locals.len() == 1);
-/// assert!(frame.stack.len() == 1);
-/// ```
-pub struct CoreDumpStackSection<'a> {
-    /// The thread name
-    pub name: &'a str,
-    /// The stack frames for the core dump
-    pub frames: Vec<CoreDumpStackFrame>,
-}
-
-impl<'a> FromReader<'a> for CoreDumpStackSection<'a> {
-    fn from_reader(reader: &mut BinaryReader<'a>) -> Result<Self> {
-        let pos = reader.original_position();
-        if reader.read_u8()? != 0 {
-            bail!(pos, "invalid start byte for core dump stack name");
-        }
-        let name = reader.read_string()?;
-        let mut frames = vec![];
-        for _ in 0..reader.read_var_u32()? {
-            frames.push(CoreDumpStackFrame::from_reader(reader)?);
-        }
-        Ok(CoreDumpStackSection {
-            name: name,
-            frames: frames,
-        })
-    }
-}
-
-/// A single stack frame from a core dump
-#[derive(Debug)]
-pub struct CoreDumpStackFrame {
-    /// The instance that this stack frame belongs to.
-    pub instanceidx: u32,
-    /// The function index in the module
-    pub funcidx: u32,
-    /// The instruction's offset relative to the function's start
-    pub codeoffset: u32,
-    /// The locals for this stack frame (including function parameters)
-    pub locals: Vec<CoreDumpValue>,
-    /// The values on the stack
-    pub stack: Vec<CoreDumpValue>,
-}
-
-impl<'a> FromReader<'a> for CoreDumpStackFrame {
-    fn from_reader(reader: &mut BinaryReader<'a>) -> Result<Self> {
-        let pos = reader.original_position();
-        if reader.read_u8()? != 0 {
-            bail!(pos, "invalid start byte for core dump stack frame");
-        }
-        let instanceidx = reader.read_var_u32()?;
-        let funcidx = reader.read_var_u32()?;
-        let codeoffset = reader.read_var_u32()?;
-        let mut locals = vec![];
-        for _ in 0..reader.read_var_u32()? {
-            locals.push(CoreDumpValue::from_reader(reader)?);
-        }
-        let mut stack = vec![];
-        for _ in 0..reader.read_var_u32()? {
-            stack.push(CoreDumpValue::from_reader(reader)?);
-        }
-
-        Ok(CoreDumpStackFrame {
-            instanceidx,
-            funcidx,
-            codeoffset,
-            locals,
-            stack,
-        })
-    }
-}
-
-/// Local and stack values are encoded using one byte for the type (similar to
-/// Wasm's Number Types) followed by bytes representing the actual value
-/// See the tool-conventions repo for more details.
-#[derive(Clone, Debug)]
-pub enum CoreDumpValue {
-    /// A missing value (usually missing because it was optimized out)
-    Missing,
-    /// An i32 value
-    I32(i32),
-    /// An i64 value
-    I64(i64),
-    /// An f32 value
-    F32(f32),
-    /// An f64 value
-    F64(f64),
-}
-
-impl<'a> FromReader<'a> for CoreDumpValue {
-    fn from_reader(reader: &mut BinaryReader<'a>) -> Result<Self> {
-        let pos = reader.original_position();
-        match reader.read_u8()? {
-            0x01 => Ok(CoreDumpValue::Missing),
-            0x7F => Ok(CoreDumpValue::I32(reader.read_var_i32()?)),
-            0x7E => Ok(CoreDumpValue::I64(reader.read_var_i64()?)),
-            0x7D => Ok(CoreDumpValue::F32(f32::from_bits(
-                reader.read_f32()?.bits(),
-            ))),
-            0x7C => Ok(CoreDumpValue::F64(f64::from_bits(
-                reader.read_f64()?.bits(),
-            ))),
-            _ => bail!(pos, "invalid CoreDumpValue type"),
-        }
-    }
-}
diff --git a/crates/wasmparser/src/readers/core/elements.rs b/crates/wasmparser/src/readers/core/elements.rs
index 314be452..7e37e7d7 100644
--- a/crates/wasmparser/src/readers/core/elements.rs
+++ b/crates/wasmparser/src/readers/core/elements.rs
@@ -40,7 +40,7 @@ pub enum ElementKind<'a> {
     /// The element segment is active.
     Active {
         /// The index of the table being initialized.
-        table_index: Option<u32>,
+        table_index: u32,
         /// The initial expression of the element segment.
         offset_expr: ConstExpr<'a>,
     },
@@ -91,9 +91,9 @@ impl<'a> FromReader<'a> for Element<'a> {
             }
         } else {
             let table_index = if flags & 0b010 == 0 {
-                None
+                0
             } else {
-                Some(reader.read_var_u32()?)
+                reader.read_var_u32()?
             };
             let offset_expr = reader.read()?;
             ElementKind::Active {
diff --git a/crates/wasmparser/src/readers/core/operators.rs b/crates/wasmparser/src/readers/core/operators.rs
index d1312c25..c643d4df 100644
--- a/crates/wasmparser/src/readers/core/operators.rs
+++ b/crates/wasmparser/src/readers/core/operators.rs
@@ -62,6 +62,13 @@ pub struct BrTable<'a> {
     pub(crate) default: u32,
 }
 
+/// A resume entries representation.
+#[derive(Clone)]
+pub struct ResumeTable<'a> {
+    pub(crate) reader: crate::BinaryReader<'a>,
+    pub(crate) cnt: u32,
+}
+
 /// An IEEE binary32 immediate floating point value, represented as a u32
 /// containing the bit pattern.
 ///
diff --git a/crates/wasmparser/src/readers/core/producers.rs b/crates/wasmparser/src/readers/core/producers.rs
index 050cb496..07785ed7 100644
--- a/crates/wasmparser/src/readers/core/producers.rs
+++ b/crates/wasmparser/src/readers/core/producers.rs
@@ -44,12 +44,7 @@ pub struct ProducersField<'a> {
 
 impl<'a> FromReader<'a> for ProducersField<'a> {
     fn from_reader(reader: &mut BinaryReader<'a>) -> Result<Self> {
-        let offset = reader.original_position();
         let name = reader.read_string()?;
-        match name {
-            "language" | "sdk" | "processed-by" => {}
-            _ => bail!(offset, "invalid producers field name: `{name}`"),
-        }
         let values = reader.skip(|reader| {
             // FIXME(#188) ideally shouldn't need to skip here
             for _ in 0..reader.read_var_u32()? {
diff --git a/crates/wasmparser/src/readers/core/types.rs b/crates/wasmparser/src/readers/core/types.rs
index 6d89c3ec..bce77de7 100644
--- a/crates/wasmparser/src/readers/core/types.rs
+++ b/crates/wasmparser/src/readers/core/types.rs
@@ -13,12 +13,9 @@
  * limitations under the License.
  */
 
-use crate::limits::{
-    MAX_WASM_FUNCTION_PARAMS, MAX_WASM_FUNCTION_RETURNS, MAX_WASM_STRUCT_FIELDS,
-    MAX_WASM_SUPERTYPES,
-};
-use crate::{BinaryReader, BinaryReaderError, FromReader, Result, SectionLimited};
-use std::fmt::{self, Debug, Write};
+use crate::limits::{MAX_WASM_FUNCTION_PARAMS, MAX_WASM_FUNCTION_RETURNS};
+use crate::{BinaryReader, FromReader, Result, SectionLimited};
+use std::fmt::Debug;
 
 /// Represents the types of values in a WebAssembly module.
 #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
@@ -33,30 +30,36 @@ pub enum ValType {
     F64,
     /// The value type is v128.
     V128,
-    /// The value type is a reference.
+    /// The value type is a reference. Which type of reference is decided by
+    /// RefType. This is a change in syntax from the function references proposal,
+    /// which now provides FuncRef and ExternRef as sugar for the generic ref
+    /// construct.
     Ref(RefType),
 }
 
-/// Represents storage types introduced in the GC spec for array and struct fields.
+/// A reference type. When the function references feature is disabled, this
+/// only represents funcref and externref, using the following format:
+/// RefType { nullable: true, heap_type: Func | Extern })
 #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
-pub enum StorageType {
-    /// The storage type is i8.
-    I8,
-    /// The storage type is i16.
-    I16,
-    /// The storage type is a value type.
-    Val(ValType),
+#[repr(packed)]
+pub struct RefType {
+    /// Whether it's nullable
+    pub nullable: bool,
+    /// The relevant heap type
+    pub heap_type: HeapType,
 }
 
-// The size of `ValType` is performance sensitive.
-const _: () = {
-    assert!(std::mem::size_of::<ValType>() == 4);
-};
-
-pub(crate) trait Inherits {
-    fn inherits<'a, F>(&self, other: &Self, type_at: &F) -> bool
-    where
-        F: Fn(u32) -> &'a SubType;
+impl RefType {
+    /// Alias for the wasm `funcref` type.
+    pub const FUNCREF: RefType = RefType {
+        nullable: true,
+        heap_type: HeapType::Func,
+    };
+    /// Alias for the wasm `externref` type.
+    pub const EXTERNREF: RefType = RefType {
+        nullable: true,
+        heap_type: HeapType::Extern,
+    };
 }
 
 impl From<RefType> for ValType {
@@ -65,10 +68,44 @@ impl From<RefType> for ValType {
     }
 }
 
+/// Used as a performance optimization in HeapType. Call `.into()` to get the u32
+// A u16 forces 2-byte alignment, which forces HeapType to be 4 bytes,
+// which forces ValType to 5 bytes. This newtype is annotated as unaligned to
+// store the necessary bits compactly
+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
+#[repr(packed)]
+pub struct PackedIndex(u16);
+
+impl TryFrom<u32> for PackedIndex {
+    type Error = ();
+
+    fn try_from(idx: u32) -> Result<PackedIndex, ()> {
+        idx.try_into().map(PackedIndex).map_err(|_| ())
+    }
+}
+
+impl From<PackedIndex> for u32 {
+    fn from(x: PackedIndex) -> u32 {
+        x.0 as u32
+    }
+}
+
+/// A heap type from function references. When the proposal is disabled, Index
+/// is an invalid type.
+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
+pub enum HeapType {
+    /// Function type index
+    /// Note: [PackedIndex] may need to be unpacked
+    TypedFunc(PackedIndex),
+    /// From reference types
+    Func,
+    /// From reference types
+    Extern,
+}
+
 impl ValType {
     /// Alias for the wasm `funcref` type.
     pub const FUNCREF: ValType = ValType::Ref(RefType::FUNCREF);
-
     /// Alias for the wasm `externref` type.
     pub const EXTERNREF: ValType = ValType::Ref(RefType::EXTERNREF);
 
@@ -79,56 +116,26 @@ impl ValType {
     pub fn is_reference_type(&self) -> bool {
         matches!(self, ValType::Ref(_))
     }
-
-    /// Whether the type is defaultable, i.e. it is not a non-nullable reference
-    /// type.
+    /// Whether the type is defaultable according to function references
+    /// spec. This amounts to whether it's a non-nullable ref
     pub fn is_defaultable(&self) -> bool {
-        match *self {
-            Self::I32 | Self::I64 | Self::F32 | Self::F64 | Self::V128 => true,
-            Self::Ref(rt) => rt.is_nullable(),
-        }
+        !matches!(
+            self,
+            ValType::Ref(RefType {
+                nullable: false,
+                ..
+            })
+        )
     }
 
     pub(crate) fn is_valtype_byte(byte: u8) -> bool {
         match byte {
-            0x7F | 0x7E | 0x7D | 0x7C | 0x7B | 0x70 | 0x6F | 0x6B | 0x6C | 0x6E | 0x65 | 0x69
-            | 0x68 | 0x6D | 0x67 | 0x66 | 0x6A => true,
+            0x7F | 0x7E | 0x7D | 0x7C | 0x7B | 0x70 | 0x6F | 0x6B | 0x6C => true,
             _ => false,
         }
     }
 }
 
-impl Inherits for ValType {
-    fn inherits<'a, F>(&self, other: &Self, type_at: &F) -> bool
-    where
-        F: Fn(u32) -> &'a SubType,
-    {
-        match (self, other) {
-            (Self::Ref(r1), Self::Ref(r2)) => r1.inherits(r2, type_at),
-            (
-                s @ (Self::I32 | Self::I64 | Self::F32 | Self::F64 | Self::V128 | Self::Ref(_)),
-                o,
-            ) => s == o,
-        }
-    }
-}
-
-impl<'a> FromReader<'a> for StorageType {
-    fn from_reader(reader: &mut BinaryReader<'a>) -> Result<Self> {
-        match reader.peek()? {
-            0x7A => {
-                reader.position += 1;
-                Ok(StorageType::I8)
-            }
-            0x79 => {
-                reader.position += 1;
-                Ok(StorageType::I16)
-            }
-            _ => Ok(StorageType::Val(reader.read()?)),
-        }
-    }
-}
-
 impl<'a> FromReader<'a> for ValType {
     fn from_reader(reader: &mut BinaryReader<'a>) -> Result<Self> {
         match reader.peek()? {
@@ -152,547 +159,26 @@ impl<'a> FromReader<'a> for ValType {
                 reader.position += 1;
                 Ok(ValType::V128)
             }
-            0x70 | 0x6F | 0x6B | 0x6C | 0x6E | 0x65 | 0x69 | 0x68 | 0x6D | 0x67 | 0x66 | 0x6A => {
-                Ok(ValType::Ref(reader.read()?))
-            }
+            0x70 | 0x6F | 0x6B | 0x6C => Ok(ValType::Ref(reader.read()?)),
             _ => bail!(reader.original_position(), "invalid value type"),
         }
     }
 }
 
-impl fmt::Display for ValType {
-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
-        let s = match self {
-            ValType::I32 => "i32",
-            ValType::I64 => "i64",
-            ValType::F32 => "f32",
-            ValType::F64 => "f64",
-            ValType::V128 => "v128",
-            ValType::Ref(r) => return fmt::Display::fmt(r, f),
-        };
-        f.write_str(s)
-    }
-}
-
-/// A reference type.
-///
-/// The reference types proposal first introduced `externref` and `funcref`.
-///
-/// The function references proposal introduced typed function references.
-///
-/// The GC proposal introduces heap types: any, eq, i31, struct, array, nofunc, noextern, none.
-//
-// RefType is a bit-packed enum that fits in a `u24` aka `[u8; 3]`.
-// Note that its content is opaque (and subject to change), but its API is stable.
-// It has the following internal structure:
-// ```
-// [nullable:u1] [indexed==1:u1] [kind:u2] [index:u20]
-// [nullable:u1] [indexed==0:u1] [type:u4] [(unused):u18]
-// ```
-// , where
-// - `nullable` determines nullability of the ref
-// - `indexed` determines if the ref is of a dynamically defined type with an index (encoded in a following bit-packing section) or of a known fixed type
-// - `kind` determines what kind of indexed type the index is pointing to:
-//   ```
-//   10 = struct
-//   11 = array
-//   01 = function
-//   ```
-// - `index` is the type index
-// - `type` is an enumeration of known types:
-//   ```
-//   1111 = any
-//
-//   1101 = eq
-//   1000 = i31
-//   1001 = struct
-//   1100 = array
-//
-//   0101 = func
-//   0100 = nofunc
-//
-//   0011 = extern
-//   0010 = noextern
-//
-//   0000 = none
-//   ```
-// - `(unused)` is unused sequence of bits
-#[derive(Copy, Clone, PartialEq, Eq, Hash)]
-pub struct RefType([u8; 3]);
-
-impl Debug for RefType {
-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
-        match (self.is_nullable(), self.heap_type()) {
-            (true, HeapType::Any) => write!(f, "anyref"),
-            (false, HeapType::Any) => write!(f, "(ref any)"),
-            (true, HeapType::None) => write!(f, "nullref"),
-            (false, HeapType::None) => write!(f, "(ref none)"),
-            (true, HeapType::NoExtern) => write!(f, "nullexternref"),
-            (false, HeapType::NoExtern) => write!(f, "(ref noextern)"),
-            (true, HeapType::NoFunc) => write!(f, "nullfuncref"),
-            (false, HeapType::NoFunc) => write!(f, "(ref nofunc)"),
-            (true, HeapType::Eq) => write!(f, "eqref"),
-            (false, HeapType::Eq) => write!(f, "(ref eq)"),
-            (true, HeapType::Struct) => write!(f, "structref"),
-            (false, HeapType::Struct) => write!(f, "(ref struct)"),
-            (true, HeapType::Array) => write!(f, "arrayref"),
-            (false, HeapType::Array) => write!(f, "(ref array)"),
-            (true, HeapType::I31) => write!(f, "i31ref"),
-            (false, HeapType::I31) => write!(f, "(ref i31)"),
-            (true, HeapType::Extern) => write!(f, "externref"),
-            (false, HeapType::Extern) => write!(f, "(ref extern)"),
-            (true, HeapType::Func) => write!(f, "funcref"),
-            (false, HeapType::Func) => write!(f, "(ref func)"),
-            (true, HeapType::Indexed(idx)) => write!(f, "(ref null {idx})"),
-            (false, HeapType::Indexed(idx)) => write!(f, "(ref {idx})"),
-        }
-    }
-}
-
-// Static assert that we can fit indices up to `MAX_WASM_TYPES` inside `RefType`.
-const _: () = {
-    const fn can_roundtrip_index(index: u32) -> bool {
-        assert!(RefType::can_represent_type_index(index));
-        let rt = match RefType::indexed_func(true, index) {
-            Some(rt) => rt,
-            None => panic!(),
-        };
-        assert!(rt.is_nullable());
-        let actual_index = match rt.type_index() {
-            Some(i) => i,
-            None => panic!(),
-        };
-        actual_index == index
-    }
-
-    assert!(can_roundtrip_index(crate::limits::MAX_WASM_TYPES as u32));
-    assert!(can_roundtrip_index(0b00000000_00001111_00000000_00000000));
-    assert!(can_roundtrip_index(0b00000000_00000000_11111111_00000000));
-    assert!(can_roundtrip_index(0b00000000_00000000_00000000_11111111));
-    assert!(can_roundtrip_index(0));
-};
-
-impl RefType {
-    const NULLABLE_BIT: u32 = 1 << 23; // bit #23
-    const INDEXED_BIT: u32 = 1 << 22; // bit #22
-
-    const TYPE_MASK: u32 = 0b1111 << 18; // 4 bits #21-#18 (if `indexed == 0`)
-    const ANY_TYPE: u32 = 0b1111 << 18;
-    const EQ_TYPE: u32 = 0b1101 << 18;
-    const I31_TYPE: u32 = 0b1000 << 18;
-    const STRUCT_TYPE: u32 = 0b1001 << 18;
-    const ARRAY_TYPE: u32 = 0b1100 << 18;
-    const FUNC_TYPE: u32 = 0b0101 << 18;
-    const NOFUNC_TYPE: u32 = 0b0100 << 18;
-    const EXTERN_TYPE: u32 = 0b0011 << 18;
-    const NOEXTERN_TYPE: u32 = 0b0010 << 18;
-    const NONE_TYPE: u32 = 0b0000 << 18;
-
-    const KIND_MASK: u32 = 0b11 << 20; // 2 bits #21-#20 (if `indexed == 1`)
-    const STRUCT_KIND: u32 = 0b10 << 20;
-    const ARRAY_KIND: u32 = 0b11 << 20;
-    const FUNC_KIND: u32 = 0b01 << 20;
-
-    const INDEX_MASK: u32 = (1 << 20) - 1; // 20 bits #19-#0 (if `indexed == 1`)
-
-    /// A nullable untyped function reference aka `(ref null func)` aka
-    /// `funcref` aka `anyfunc`.
-    pub const FUNCREF: Self = RefType::FUNC.nullable();
-
-    /// A nullable reference to an extern object aka `(ref null extern)` aka
-    /// `externref`.
-    pub const EXTERNREF: Self = RefType::EXTERN.nullable();
-
-    /// A non-nullable untyped function reference aka `(ref func)`.
-    pub const FUNC: Self = RefType::from_u32(Self::FUNC_TYPE);
-
-    /// A non-nullable reference to an extern object aka `(ref extern)`.
-    pub const EXTERN: Self = RefType::from_u32(Self::EXTERN_TYPE);
-
-    /// A non-nullable reference to any object aka `(ref any)`.
-    pub const ANY: Self = RefType::from_u32(Self::ANY_TYPE);
-
-    /// A non-nullable reference to no object aka `(ref none)`.
-    pub const NONE: Self = RefType::from_u32(Self::NONE_TYPE);
-
-    /// A non-nullable reference to a noextern object aka `(ref noextern)`.
-    pub const NOEXTERN: Self = RefType::from_u32(Self::NOEXTERN_TYPE);
-
-    /// A non-nullable reference to a nofunc object aka `(ref nofunc)`.
-    pub const NOFUNC: Self = RefType::from_u32(Self::NOFUNC_TYPE);
-
-    /// A non-nullable reference to an eq object aka `(ref eq)`.
-    pub const EQ: Self = RefType::from_u32(Self::EQ_TYPE);
-
-    /// A non-nullable reference to a struct aka `(ref struct)`.
-    pub const STRUCT: Self = RefType::from_u32(Self::STRUCT_TYPE);
-
-    /// A non-nullable reference to an array aka `(ref array)`.
-    pub const ARRAY: Self = RefType::from_u32(Self::ARRAY_TYPE);
-
-    /// A non-nullable reference to an i31 object aka `(ref i31)`.
-    pub const I31: Self = RefType::from_u32(Self::I31_TYPE);
-
-    const fn can_represent_type_index(index: u32) -> bool {
-        index & Self::INDEX_MASK == index
-    }
-
-    const fn u24_to_u32(bytes: [u8; 3]) -> u32 {
-        let expanded_bytes = [bytes[0], bytes[1], bytes[2], 0];
-        u32::from_le_bytes(expanded_bytes)
-    }
-
-    const fn u32_to_u24(x: u32) -> [u8; 3] {
-        let bytes = x.to_le_bytes();
-        debug_assert!(bytes[3] == 0);
-        [bytes[0], bytes[1], bytes[2]]
-    }
-
-    #[inline]
-    const fn as_u32(&self) -> u32 {
-        Self::u24_to_u32(self.0)
-    }
-
-    #[inline]
-    const fn from_u32(x: u32) -> Self {
-        debug_assert!(x & (0b11111111 << 24) == 0);
-
-        // if not indexed, type must be any/eq/i31/struct/array/func/extern/nofunc/noextern/none
-        debug_assert!(
-            x & Self::INDEXED_BIT != 0
-                || matches!(
-                    x & Self::TYPE_MASK,
-                    Self::ANY_TYPE
-                        | Self::EQ_TYPE
-                        | Self::I31_TYPE
-                        | Self::STRUCT_TYPE
-                        | Self::ARRAY_TYPE
-                        | Self::FUNC_TYPE
-                        | Self::NOFUNC_TYPE
-                        | Self::EXTERN_TYPE
-                        | Self::NOEXTERN_TYPE
-                        | Self::NONE_TYPE
-                )
-        );
-        RefType(Self::u32_to_u24(x))
-    }
-
-    /// Create a reference to a typed function with the type at the given index.
-    ///
-    /// Returns `None` when the type index is beyond this crate's implementation
-    /// limits and therefore is not representable.
-    pub const fn indexed_func(nullable: bool, index: u32) -> Option<Self> {
-        Self::indexed(nullable, Self::FUNC_KIND, index)
-    }
-
-    /// Create a reference to an array with the type at the given index.
-    ///
-    /// Returns `None` when the type index is beyond this crate's implementation
-    /// limits and therefore is not representable.
-    pub const fn indexed_array(nullable: bool, index: u32) -> Option<Self> {
-        Self::indexed(nullable, Self::ARRAY_KIND, index)
-    }
-
-    /// Create a reference to a struct with the type at the given index.
-    ///
-    /// Returns `None` when the type index is beyond this crate's implementation
-    /// limits and therefore is not representable.
-    pub const fn indexed_struct(nullable: bool, index: u32) -> Option<Self> {
-        Self::indexed(nullable, Self::STRUCT_KIND, index)
-    }
-
-    /// Create a reference to a user defined type at the given index.
-    ///
-    /// Returns `None` when the type index is beyond this crate's implementation
-    /// limits and therefore is not representable, or when the heap type is not
-    /// a typed array, struct or function.
-    const fn indexed(nullable: bool, kind: u32, index: u32) -> Option<Self> {
-        if Self::can_represent_type_index(index) {
-            let nullable32 = Self::NULLABLE_BIT * nullable as u32;
-            Some(RefType::from_u32(
-                nullable32 | Self::INDEXED_BIT | kind | index,
-            ))
-        } else {
-            None
-        }
-    }
-
-    /// Create a new `RefType`.
-    ///
-    /// Returns `None` when the heap type's type index (if any) is beyond this
-    /// crate's implementation limits and therfore is not representable.
-    pub const fn new(nullable: bool, heap_type: HeapType) -> Option<Self> {
-        let nullable32 = Self::NULLABLE_BIT * nullable as u32;
-        match heap_type {
-            HeapType::Indexed(index) => RefType::indexed(nullable, 0, index), // 0 bc we don't know the kind
-            HeapType::Func => Some(Self::from_u32(nullable32 | Self::FUNC_TYPE)),
-            HeapType::Extern => Some(Self::from_u32(nullable32 | Self::EXTERN_TYPE)),
-            HeapType::Any => Some(Self::from_u32(nullable32 | Self::ANY_TYPE)),
-            HeapType::None => Some(Self::from_u32(nullable32 | Self::NONE_TYPE)),
-            HeapType::NoExtern => Some(Self::from_u32(nullable32 | Self::NOEXTERN_TYPE)),
-            HeapType::NoFunc => Some(Self::from_u32(nullable32 | Self::NOFUNC_TYPE)),
-            HeapType::Eq => Some(Self::from_u32(nullable32 | Self::EQ_TYPE)),
-            HeapType::Struct => Some(Self::from_u32(nullable32 | Self::STRUCT_TYPE)),
-            HeapType::Array => Some(Self::from_u32(nullable32 | Self::ARRAY_TYPE)),
-            HeapType::I31 => Some(Self::from_u32(nullable32 | Self::I31_TYPE)),
-        }
-    }
-
-    /// Is this a reference to a typed function?
-    pub const fn is_typed_func_ref(&self) -> bool {
-        self.is_indexed_type_ref() && self.as_u32() & Self::KIND_MASK == Self::FUNC_KIND
-    }
-
-    /// Is this a reference to an indexed type?
-    pub const fn is_indexed_type_ref(&self) -> bool {
-        self.as_u32() & Self::INDEXED_BIT != 0
-    }
-
-    /// If this is a reference to a typed function, get its type index.
-    pub const fn type_index(&self) -> Option<u32> {
-        if self.is_indexed_type_ref() {
-            Some(self.as_u32() & Self::INDEX_MASK)
-        } else {
-            None
-        }
-    }
-
-    /// Is this an untyped function reference aka `(ref null func)` aka `funcref` aka `anyfunc`?
-    pub const fn is_func_ref(&self) -> bool {
-        !self.is_indexed_type_ref() && self.as_u32() & Self::TYPE_MASK == Self::FUNC_TYPE
-    }
-
-    /// Is this a `(ref null extern)` aka `externref`?
-    pub const fn is_extern_ref(&self) -> bool {
-        !self.is_indexed_type_ref() && self.as_u32() & Self::TYPE_MASK == Self::EXTERN_TYPE
-    }
-
-    /// Is this ref type nullable?
-    pub const fn is_nullable(&self) -> bool {
-        self.as_u32() & Self::NULLABLE_BIT != 0
-    }
-
-    /// Get the non-nullable version of this ref type.
-    pub const fn as_non_null(&self) -> Self {
-        Self::from_u32(self.as_u32() & !Self::NULLABLE_BIT)
-    }
-
-    /// Get the non-nullable version of this ref type.
-    pub const fn nullable(&self) -> Self {
-        Self::from_u32(self.as_u32() | Self::NULLABLE_BIT)
-    }
-
-    /// Get the heap type that this is a reference to.
-    pub fn heap_type(&self) -> HeapType {
-        let s = self.as_u32();
-        if self.is_indexed_type_ref() {
-            HeapType::Indexed(self.type_index().unwrap())
-        } else {
-            match s & Self::TYPE_MASK {
-                Self::FUNC_TYPE => HeapType::Func,
-                Self::EXTERN_TYPE => HeapType::Extern,
-                Self::ANY_TYPE => HeapType::Any,
-                Self::NONE_TYPE => HeapType::None,
-                Self::NOEXTERN_TYPE => HeapType::NoExtern,
-                Self::NOFUNC_TYPE => HeapType::NoFunc,
-                Self::EQ_TYPE => HeapType::Eq,
-                Self::STRUCT_TYPE => HeapType::Struct,
-                Self::ARRAY_TYPE => HeapType::Array,
-                Self::I31_TYPE => HeapType::I31,
-                _ => unreachable!(),
-            }
-        }
-    }
-
-    // Note that this is similar to `Display for RefType` except that it has
-    // the indexes stubbed out.
-    pub(crate) fn wat(&self) -> &'static str {
-        match (self.is_nullable(), self.heap_type()) {
-            (true, HeapType::Func) => "funcref",
-            (true, HeapType::Extern) => "externref",
-            (true, HeapType::Indexed(_)) => "(ref null $type)",
-            (true, HeapType::Any) => "anyref",
-            (true, HeapType::None) => "nullref",
-            (true, HeapType::NoExtern) => "nullexternref",
-            (true, HeapType::NoFunc) => "nullfuncref",
-            (true, HeapType::Eq) => "eqref",
-            (true, HeapType::Struct) => "structref",
-            (true, HeapType::Array) => "arrayref",
-            (true, HeapType::I31) => "i31ref",
-            (false, HeapType::Func) => "(ref func)",
-            (false, HeapType::Extern) => "(ref extern)",
-            (false, HeapType::Indexed(_)) => "(ref $type)",
-            (false, HeapType::Any) => "(ref any)",
-            (false, HeapType::None) => "(ref none)",
-            (false, HeapType::NoExtern) => "(ref noextern)",
-            (false, HeapType::NoFunc) => "(ref nofunc)",
-            (false, HeapType::Eq) => "(ref eq)",
-            (false, HeapType::Struct) => "(ref struct)",
-            (false, HeapType::Array) => "(ref array)",
-            (false, HeapType::I31) => "(ref i31)",
-        }
-    }
-}
-
-impl Inherits for RefType {
-    fn inherits<'a, F>(&self, other: &Self, type_at: &F) -> bool
-    where
-        F: Fn(u32) -> &'a SubType,
-    {
-        self == other
-            || ((other.is_nullable() || !self.is_nullable())
-                && self.heap_type().inherits(&other.heap_type(), type_at))
-    }
-}
-
 impl<'a> FromReader<'a> for RefType {
     fn from_reader(reader: &mut BinaryReader<'a>) -> Result<Self> {
         match reader.read()? {
-            0x70 => Ok(RefType::FUNC.nullable()),
-            0x6F => Ok(RefType::EXTERN.nullable()),
-            0x6E => Ok(RefType::ANY.nullable()),
-            0x65 => Ok(RefType::NONE.nullable()),
-            0x69 => Ok(RefType::NOEXTERN.nullable()),
-            0x68 => Ok(RefType::NOFUNC.nullable()),
-            0x6D => Ok(RefType::EQ.nullable()),
-            0x67 => Ok(RefType::STRUCT.nullable()),
-            0x66 => Ok(RefType::ARRAY.nullable()),
-            0x6A => Ok(RefType::I31.nullable()),
-            byte @ (0x6B | 0x6C) => {
-                let nullable = byte == 0x6C;
-                let pos = reader.original_position();
-                RefType::new(nullable, reader.read()?)
-                    .ok_or_else(|| crate::BinaryReaderError::new("type index too large", pos))
-            }
+            0x70 => Ok(RefType::FUNCREF),
+            0x6F => Ok(RefType::EXTERNREF),
+            byte @ (0x6B | 0x6C) => Ok(RefType {
+                nullable: byte == 0x6C,
+                heap_type: reader.read()?,
+            }),
             _ => bail!(reader.original_position(), "malformed reference type"),
         }
     }
 }
 
-impl fmt::Display for RefType {
-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
-        // Note that this is similar to `RefType::wat` except that it has the
-        // indexes filled out.
-        let s = match (self.is_nullable(), self.heap_type()) {
-            (true, HeapType::Func) => "funcref",
-            (true, HeapType::Extern) => "externref",
-            (true, HeapType::Indexed(i)) => return write!(f, "(ref null {i})"),
-            (true, HeapType::Any) => "anyref",
-            (true, HeapType::None) => "nullref",
-            (true, HeapType::NoExtern) => "nullexternref",
-            (true, HeapType::NoFunc) => "nullfuncref",
-            (true, HeapType::Eq) => "eqref",
-            (true, HeapType::Struct) => "structref",
-            (true, HeapType::Array) => "arrayref",
-            (true, HeapType::I31) => "i31ref",
-            (false, HeapType::Func) => "(ref func)",
-            (false, HeapType::Extern) => "(ref extern)",
-            (false, HeapType::Indexed(i)) => return write!(f, "(ref {i})"),
-            (false, HeapType::Any) => "(ref any)",
-            (false, HeapType::None) => "(ref none)",
-            (false, HeapType::NoExtern) => "(ref noextern)",
-            (false, HeapType::NoFunc) => "(ref nofunc)",
-            (false, HeapType::Eq) => "(ref eq)",
-            (false, HeapType::Struct) => "(ref struct)",
-            (false, HeapType::Array) => "(ref array)",
-            (false, HeapType::I31) => "(ref i31)",
-        };
-        f.write_str(s)
-    }
-}
-
-/// A heap type from function references. When the proposal is disabled, Index
-/// is an invalid type.
-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
-pub enum HeapType {
-    /// User defined type at the given index.
-    Indexed(u32),
-    /// Untyped (any) function.
-    Func,
-    /// External heap type.
-    Extern,
-    /// The `any` heap type. The common supertype (a.k.a. top) of all internal types.
-    Any,
-    /// The `none` heap type. The common subtype (a.k.a. bottom) of all internal types.
-    None,
-    /// The `noextern` heap type. The common subtype (a.k.a. bottom) of all external types.
-    NoExtern,
-    /// The `nofunc` heap type. The common subtype (a.k.a. bottom) of all function types.
-    NoFunc,
-    /// The `eq` heap type. The common supertype of all referenceable types on which comparison
-    /// (ref.eq) is allowed.
-    Eq,
-    /// The `struct` heap type. The common supertype of all struct types.
-    Struct,
-    /// The `array` heap type. The common supertype of all array types.
-    Array,
-    /// The i31 heap type.
-    I31,
-}
-
-impl Inherits for HeapType {
-    fn inherits<'a, F>(&self, other: &Self, type_at: &F) -> bool
-    where
-        F: Fn(u32) -> &'a SubType,
-    {
-        match (self, other) {
-            (HeapType::Indexed(a), HeapType::Indexed(b)) => {
-                a == b || type_at(*a).inherits(type_at(*b), type_at)
-            }
-            (HeapType::Indexed(a), HeapType::Func) => match type_at(*a).structural_type {
-                StructuralType::Func(_) => true,
-                _ => false,
-            },
-            (HeapType::Indexed(a), HeapType::Array) => match type_at(*a).structural_type {
-                StructuralType::Array(_) => true,
-                _ => false,
-            },
-            (HeapType::Indexed(a), HeapType::Struct) => match type_at(*a).structural_type {
-                StructuralType::Struct(_) => true,
-                _ => false,
-            },
-            (HeapType::Indexed(a), HeapType::Eq | HeapType::Any) => {
-                match type_at(*a).structural_type {
-                    StructuralType::Array(_) | StructuralType::Struct(_) => true,
-                    _ => false,
-                }
-            }
-            (HeapType::Eq, HeapType::Any) => true,
-            (HeapType::I31 | HeapType::Array | HeapType::Struct, HeapType::Eq | HeapType::Any) => {
-                true
-            }
-            (HeapType::None, HeapType::Indexed(a)) => match type_at(*a).structural_type {
-                StructuralType::Array(_) | StructuralType::Struct(_) => true,
-                _ => false,
-            },
-            (
-                HeapType::None,
-                HeapType::I31 | HeapType::Eq | HeapType::Any | HeapType::Array | HeapType::Struct,
-            ) => true,
-            (HeapType::NoExtern, HeapType::Extern) => true,
-            (HeapType::NoFunc, HeapType::Func) => true,
-            (HeapType::NoFunc, HeapType::Indexed(a)) => match type_at(*a).structural_type {
-                StructuralType::Func(_) => true,
-                _ => false,
-            },
-            (
-                a @ (HeapType::Func
-                | HeapType::Extern
-                | HeapType::Any
-                | HeapType::Indexed(_)
-                | HeapType::None
-                | HeapType::NoExtern
-                | HeapType::NoFunc
-                | HeapType::Eq
-                | HeapType::Struct
-                | HeapType::Array
-                | HeapType::I31),
-                b,
-            ) => a == b,
-        }
-    }
-}
-
 impl<'a> FromReader<'a> for HeapType {
     fn from_reader(reader: &mut BinaryReader<'a>) -> Result<Self> {
         match reader.peek()? {
@@ -704,83 +190,31 @@ impl<'a> FromReader<'a> for HeapType {
                 reader.position += 1;
                 Ok(HeapType::Extern)
             }
-            0x6E => {
-                reader.position += 1;
-                Ok(HeapType::Any)
-            }
-            0x65 => {
-                reader.position += 1;
-                Ok(HeapType::None)
-            }
-            0x69 => {
-                reader.position += 1;
-                Ok(HeapType::NoExtern)
-            }
-            0x68 => {
-                reader.position += 1;
-                Ok(HeapType::NoFunc)
-            }
-            0x6D => {
-                reader.position += 1;
-                Ok(HeapType::Eq)
-            }
-            0x67 => {
-                reader.position += 1;
-                Ok(HeapType::Struct)
-            }
-            0x66 => {
-                reader.position += 1;
-                Ok(HeapType::Array)
-            }
-            0x6A => {
-                reader.position += 1;
-                Ok(HeapType::I31)
-            }
             _ => {
                 let idx = match u32::try_from(reader.read_var_s33()?) {
                     Ok(idx) => idx,
                     Err(_) => {
-                        bail!(reader.original_position(), "invalid indexed ref heap type");
+                        bail!(reader.original_position(), "invalid function heap type",);
                     }
                 };
-                Ok(HeapType::Indexed(idx))
+                match idx.try_into() {
+                    Ok(packed) => Ok(HeapType::TypedFunc(packed)),
+                    Err(_) => {
+                        bail!(reader.original_position(), "function index too large");
+                    }
+                }
             }
         }
     }
 }
 
-/// Represents a structural type in a WebAssembly module.
+/// Represents a type in a WebAssembly module.
 #[derive(Debug, Clone)]
-pub enum StructuralType {
+pub enum Type {
     /// The type is for a function.
     Func(FuncType),
-    /// The type is for an array.
-    Array(ArrayType),
-    /// The type is for a struct.
-    Struct(StructType),
-}
-
-/// Represents a subtype of possible other types in a WebAssembly module.
-#[derive(Debug, Clone)]
-pub struct SubType {
-    /// Is the subtype final.
-    pub is_final: bool,
-    /// The list of supertype indexes. As of GC MVP, there can be at most one supertype.
-    pub supertype_idx: Option<u32>,
-    /// The structural type of the subtype.
-    pub structural_type: StructuralType,
-}
-
-impl Inherits for SubType {
-    fn inherits<'a, F>(&self, other: &Self, type_at: &F) -> bool
-    where
-        F: Fn(u32) -> &'a SubType,
-    {
-        !other.is_final
-            && self
-                .structural_type
-                .inherits(&other.structural_type, type_at)
-    }
+    /// The type is for a continuation.
+    Cont(u32),
 }
 
 /// Represents a type of a function in a WebAssembly module.
@@ -792,42 +226,6 @@ pub struct FuncType {
     len_params: usize,
 }
 
-/// Represents a type of an array in a WebAssembly module.
-#[derive(Debug, Clone, Eq, PartialEq, Hash)]
-pub struct ArrayType(pub FieldType);
-
-/// Represents a field type of an array or a struct.
-#[derive(Debug, Clone, Eq, PartialEq, Hash)]
-pub struct FieldType {
-    /// Array element type.
-    pub element_type: StorageType,
-    /// Are elements mutable.
-    pub mutable: bool,
-}
-
-/// Represents a type of a struct in a WebAssembly module.
-#[derive(Debug, Clone, Eq, PartialEq, Hash)]
-pub struct StructType {
-    /// Struct fields.
-    pub fields: Box<[FieldType]>,
-}
-
-impl Inherits for StructuralType {
-    fn inherits<'a, F>(&self, other: &Self, type_at: &F) -> bool
-    where
-        F: Fn(u32) -> &'a SubType,
-    {
-        match (self, other) {
-            (StructuralType::Func(a), StructuralType::Func(b)) => a.inherits(b, type_at),
-            (StructuralType::Array(a), StructuralType::Array(b)) => a.inherits(b, type_at),
-            (StructuralType::Struct(a), StructuralType::Struct(b)) => a.inherits(b, type_at),
-            (StructuralType::Func(_), _) => false,
-            (StructuralType::Array(_), _) => false,
-            (StructuralType::Struct(_), _) => false,
-        }
-    }
-}
-
 impl Debug for FuncType {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         f.debug_struct("FuncType")
@@ -877,93 +275,6 @@ impl FuncType {
     pub fn results(&self) -> &[ValType] {
         &self.params_results[self.len_params..]
     }
-
-    pub(crate) fn desc(&self) -> String {
-        let mut s = String::new();
-        s.push_str("[");
-        for (i, param) in self.params().iter().enumerate() {
-            if i > 0 {
-                s.push_str(" ");
-            }
-            write!(s, "{param}").unwrap();
-        }
-        s.push_str("] -> [");
-        for (i, result) in self.results().iter().enumerate() {
-            if i > 0 {
-                s.push_str(" ");
-            }
-            write!(s, "{result}").unwrap();
-        }
-        s.push_str("]");
-        s
-    }
-}
-
-impl Inherits for FuncType {
-    fn inherits<'a, F>(&self, other: &Self, type_at: &F) -> bool
-    where
-        F: Fn(u32) -> &'a SubType,
-    {
-        self.params().len() == other.params().len()
-            && self.results().len() == other.results().len()
-            // Note: per GC spec, function subtypes are contravariant in their parameter types.
-            // Also see https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)
-            && self
-                .params()
-                .iter()
-                .zip(other.params())
-                .fold(true, |r, (a, b)| r && b.inherits(a, type_at))
-            && self
-                .results()
-                .iter()
-                .zip(other.results())
-                .fold(true, |r, (a, b)| r && a.inherits(b, type_at))
-    }
-}
-
-impl Inherits for ArrayType {
-    fn inherits<'a, F>(&self, other: &Self, type_at: &F) -> bool
-    where
-        F: Fn(u32) -> &'a SubType,
-    {
-        self.0.inherits(&other.0, type_at)
-    }
-}
-
-impl Inherits for FieldType {
-    fn inherits<'a, F>(&self, other: &Self, type_at: &F) -> bool
-    where
-        F: Fn(u32) -> &'a SubType,
-    {
-        (other.mutable || !self.mutable) && self.element_type.inherits(&other.element_type, type_at)
-    }
-}
-
-impl Inherits for StorageType {
-    fn inherits<'a, F>(&self, other: &Self, type_at: &F) -> bool
-    where
-        F: Fn(u32) -> &'a SubType,
-    {
-        match (self, other) {
-            (Self::Val(a), Self::Val(b)) => a.inherits(b, type_at),
-            (a @ (Self::I8 | Self::I16 | Self::Val(_)), b) => a == b,
-        }
-    }
-}
-
-impl Inherits for StructType {
-    fn inherits<'a, F>(&self, other: &Self, type_at: &F) -> bool
-    where
-        F: Fn(u32) -> &'a SubType,
-    {
-        // Note: Structure types support width and depth subtyping.
-        self.fields.len() >= other.fields.len()
-            && self
-                .fields
-                .iter()
-                .zip(other.fields.iter())
-                .fold(true, |r, (a, b)| r && a.inherits(b, type_at))
-    }
 }
 
 /// Represents a table's type.
@@ -1044,50 +355,14 @@ pub struct TagType {
 }
 
 /// A reader for the type section of a WebAssembly module.
-pub type TypeSectionReader<'a> = SectionLimited<'a, SubType>;
+pub type TypeSectionReader<'a> = SectionLimited<'a, Type>;
 
-impl<'a> FromReader<'a> for StructuralType {
+impl<'a> FromReader<'a> for Type {
     fn from_reader(reader: &mut BinaryReader<'a>) -> Result<Self> {
-        read_structural_type(reader.read_u8()?, reader)
-    }
-}
-
-fn read_structural_type(
-    opcode: u8,
-    reader: &mut BinaryReader,
-) -> Result<StructuralType, BinaryReaderError> {
-    Ok(match opcode {
-        0x60 => StructuralType::Func(reader.read()?),
-        0x5e => StructuralType::Array(reader.read()?),
-        0x5f => StructuralType::Struct(reader.read()?),
-        x => return reader.invalid_leading_byte(x, "type"),
-    })
-}
-
-impl<'a> FromReader<'a> for SubType {
-    fn from_reader(reader: &mut BinaryReader<'a>) -> Result<Self> {
-        let pos = reader.original_position();
         Ok(match reader.read_u8()? {
-            opcode @ (0x4e | 0x50) => {
-                let idx_iter = reader.read_iter(MAX_WASM_SUPERTYPES, "supertype idxs")?;
-                let idxs = idx_iter.collect::<Result<Vec<u32>>>()?;
-                if idxs.len() > 1 {
-                    return Err(BinaryReaderError::new(
-                        "multiple supertypes not supported",
-                        pos,
-                    ));
-                }
-                SubType {
-                    is_final: opcode == 0x4e,
-                    supertype_idx: idxs.first().copied(),
-                    structural_type: read_structural_type(reader.read_u8()?, reader)?,
-                }
-            }
-            opcode => SubType {
-                is_final: false,
-                supertype_idx: None,
-                structural_type: read_structural_type(opcode, reader)?,
-            },
+            0x60 => Type::Func(reader.read()?),
+            0x5d => Type::Cont(reader.read()?),
+            x => return reader.invalid_leading_byte(x, "type"),
         })
     }
 }
@@ -1106,36 +381,3 @@ impl<'a> FromReader<'a> for FuncType {
         Ok(FuncType::from_raw_parts(params_results.into(), len_params))
     }
 }
-
-impl<'a> FromReader<'a> for FieldType {
-    fn from_reader(reader: &mut BinaryReader<'a>) -> Result<Self> {
-        let element_type = reader.read()?;
-        let mutable = reader.read_u8()?;
-        Ok(FieldType {
-            element_type,
-            mutable: match mutable {
-                0 => false,
-                1 => true,
-                _ => bail!(
-                    reader.original_position(),
-                    "invalid mutability byte for array type"
-                ),
-            },
-        })
-    }
-}
-
-impl<'a> FromReader<'a> for ArrayType {
-    fn from_reader(reader: &mut BinaryReader<'a>) -> Result<Self> {
-        Ok(ArrayType(FieldType::from_reader(reader)?))
-    }
-}
-
-impl<'a> FromReader<'a> for StructType {
-    fn from_reader(reader: &mut BinaryReader<'a>) -> Result<Self> {
-        let fields = reader.read_iter(MAX_WASM_STRUCT_FIELDS, "struct fields")?;
-        Ok(StructType {
-            fields: fields.collect::<Result<_>>()?,
-        })
-    }
-}
diff --git a/crates/wasmparser/src/resources.rs b/crates/wasmparser/src/resources.rs
index be4fa4ae..84447e66 100644
--- a/crates/wasmparser/src/resources.rs
+++ b/crates/wasmparser/src/resources.rs
@@ -216,6 +216,8 @@ pub trait WasmModuleResources {
     fn type_index_of_function(&self, func_idx: u32) -> Option<u32>;
     /// Returns the `FuncType` associated with the given function index.
     fn type_of_function(&self, func_idx: u32) -> Option<&Self::FuncType>;
+    /// Return the `Cont` type associated with the given type index.
+    fn cont_type_at(&self, at: u32) -> Option<u32>;
     /// Returns the element type at the given index.
     fn element_type_at(&self, at: u32) -> Option<RefType>;
     /// Under the function references proposal, returns whether t1 <=
@@ -240,14 +242,11 @@ pub trait WasmModuleResources {
         // Delegate to the generic value type validation which will have the
         // same validity checks.
         self.check_value_type(
-            RefType::new(true, heap_type)
-                .ok_or_else(|| {
-                    BinaryReaderError::new(
-                        "heap type index beyond this crate's implementation limits",
-                        offset,
-                    )
-                })?
-                .into(),
+            RefType {
+                nullable: true,
+                heap_type,
+            }
+            .into(),
             features,
             offset,
         )
@@ -289,6 +288,9 @@ where
     fn type_of_function(&self, func_idx: u32) -> Option<&Self::FuncType> {
         T::type_of_function(self, func_idx)
     }
+    fn cont_type_at(&self, at: u32) -> Option<u32> {
+        T::cont_type_at(self, at)
+    }
     fn check_value_type(
         &self,
         t: ValType,
@@ -349,6 +351,10 @@ where
         T::type_of_function(self, func_idx)
     }
 
+    fn cont_type_at(&self, at: u32) -> Option<u32> {
+        T::cont_type_at(self, at)
+    }
+
     fn check_value_type(
         &self,
         t: ValType,
diff --git a/crates/wasmparser/src/validator.rs b/crates/wasmparser/src/validator.rs
index 6d964d47..e6b03044 100644
--- a/crates/wasmparser/src/validator.rs
+++ b/crates/wasmparser/src/validator.rs
@@ -48,7 +48,6 @@ fn test_validate() {
 mod component;
 mod core;
 mod func;
-pub mod names;
 mod operators;
 pub mod types;
 
@@ -243,10 +242,10 @@ pub struct WasmFeatures {
     pub component_model: bool,
     /// The WebAssembly typed function references proposal
     pub function_references: bool,
+    /// The typed continuations proposals
+    pub typed_continuations: bool,
     /// The WebAssembly memory control proposal
     pub memory_control: bool,
-    /// The WebAssembly gc proposal
-    pub gc: bool,
 }
 
 impl WasmFeatures {
@@ -265,50 +264,22 @@ impl WasmFeatures {
                 }
             }
             ValType::Ref(r) => {
-                if !self.reference_types {
-                    return Err("reference types support is not enabled");
-                }
-                match (r.heap_type(), r.is_nullable()) {
-                    // funcref/externref only require `reference-types`
-                    (HeapType::Func, true) | (HeapType::Extern, true) => Ok(()),
-
-                    // non-nullable func/extern references requires the
-                    // `function-references` proposal
-                    (HeapType::Func | HeapType::Extern, false) => {
-                        if self.function_references {
-                            Ok(())
-                        } else {
-                            Err("function references required for non-nullable types")
-                        }
-                    }
-                    // indexed types require at least the function-references
-                    // proposal
-                    (HeapType::Indexed(_), _) => {
-                        if self.function_references {
-                            Ok(())
-                        } else {
-                            Err("function references required for index reference types")
-                        }
-                    }
-
-                    // types added in the gc proposal
-                    (
-                        HeapType::Any
-                        | HeapType::None
-                        | HeapType::Eq
-                        | HeapType::Struct
-                        | HeapType::Array
-                        | HeapType::I31
-                        | HeapType::NoExtern
-                        | HeapType::NoFunc,
-                        _,
-                    ) => {
-                        if self.gc {
-                            Ok(())
-                        } else {
-                            Err("heap types not supported without the gc feature")
+                if self.reference_types {
+                    if !self.function_references {
+                        match (r.heap_type, r.nullable) {
+                            (_, false) => {
+                                Err("function references required for non-nullable types")
+                            }
+                            (HeapType::TypedFunc(_), _) => {
+                                Err("function references required for index reference types")
+                            }
+                            _ => Ok(()),
                         }
+                    } else {
+                        Ok(())
                     }
+                } else {
+                    Err("reference types support is not enabled")
                 }
             }
             ValType::V128 => {
@@ -334,8 +305,8 @@ impl Default for WasmFeatures {
             extended_const: false,
             component_model: false,
             function_references: false,
+            typed_continuations: false,
             memory_control: false,
-            gc: false,
 
             // On-by-default features (phase 4 or greater).
             mutable_global: true,
@@ -572,8 +543,7 @@ impl Validator {
                     );
                 }
                 if num == WASM_COMPONENT_VERSION {
-                    self.components
-                        .push(ComponentState::new(ComponentKind::Component));
+                    self.components.push(ComponentState::default());
                     State::Component
                 } else if num < WASM_COMPONENT_VERSION {
                     bail!(range.start, "unsupported component version: {num:#x}");
@@ -1153,15 +1123,6 @@ impl Validator {
                         func_index,
                         options,
                     } => current.lower_function(func_index, options.into_vec(), types, offset),
-                    crate::CanonicalFunction::ResourceNew { resource } => {
-                        current.resource_new(resource, types, offset)
-                    }
-                    crate::CanonicalFunction::ResourceDrop { resource } => {
-                        current.resource_drop(resource, types, offset)
-                    }
-                    crate::CanonicalFunction::ResourceRep { resource } => {
-                        current.resource_rep(resource, types, offset)
-                    }
                 }
             },
         )
@@ -1177,6 +1138,16 @@ impl Validator {
     ) -> Result<()> {
         self.state.ensure_component("start", range.start)?;
 
+        // let mut section = section.clone();
+        // let f = section.read()?;
+
+        // if !section.eof() {
+        //     return Err(BinaryReaderError::new(
+        //         "trailing data at the end of the start section",
+        //         section.original_position(),
+        //     ));
+        // }
+
         self.components.last_mut().unwrap().add_start(
             f.func_index,
             &f.arguments,
@@ -1219,13 +1190,13 @@ impl Validator {
             |components, _, count, offset| {
                 let current = components.last_mut().unwrap();
                 check_max(
-                    current.exports.len(),
+                    current.externs.len(),
                     count,
                     MAX_WASM_EXPORTS,
-                    "exports",
+                    "imports and exports",
                     offset,
                 )?;
-                current.exports.reserve(count as usize);
+                current.externs.reserve(count as usize);
                 Ok(())
             },
             |components, types, _, export, offset| {
@@ -1233,8 +1204,8 @@ impl Validator {
                 let ty = current.export_to_entity_type(&export, types, offset)?;
                 current.add_export(
                     export.name,
+                    export.url,
                     ty,
-                    types,
                     offset,
                     false, /* checked above */
                 )
@@ -1283,18 +1254,16 @@ impl Validator {
 
                 // Validate that all values were used for the component
                 if let Some(index) = component.values.iter().position(|(_, used)| !*used) {
-                    bail!(
-                        offset,
-                        "value index {index} was not used as part of an \
-                         instantiation, start function, or export"
+                    return Err(
+                        format_err!(offset,"value index {index} was not used as part of an instantiation, start function, or export"
+                            )
                     );
                 }
 
                 // If there's a parent component, pop the stack, add it to the parent,
                 // and continue to validate the component
-                let ty = component.finish(&mut self.types, offset)?;
                 if let Some(parent) = self.components.last_mut() {
-                    parent.add_component(ty, &mut self.types)?;
+                    parent.add_component(&mut component, &mut self.types);
                     self.state = State::Component;
                 }
 
@@ -1441,52 +1410,66 @@ mod tests {
         assert_eq!(types.instance_count(), 0);
         assert_eq!(types.value_count(), 0);
 
-        let ty = types[types.core_type_at(0)].unwrap_func();
-        assert_eq!(ty.params(), [ValType::I32, ValType::I64]);
-        assert_eq!(ty.results(), [ValType::I32]);
+        match types.func_type_at(0) {
+            Some(ty) => {
+                assert_eq!(ty.params(), [ValType::I32, ValType::I64]);
+                assert_eq!(ty.results(), [ValType::I32]);
+            }
+            _ => unreachable!(),
+        }
 
-        let ty = types[types.core_type_at(1)].unwrap_func();
-        assert_eq!(ty.params(), [ValType::I64, ValType::I32]);
-        assert_eq!(ty.results(), []);
+        match types.func_type_at(1) {
+            Some(ty) => {
+                assert_eq!(ty.params(), [ValType::I64, ValType::I32]);
+                assert_eq!(ty.results(), []);
+            }
+            _ => unreachable!(),
+        }
 
         assert_eq!(
             types.memory_at(0),
-            MemoryType {
+            Some(MemoryType {
                 memory64: false,
                 shared: false,
                 initial: 1,
                 maximum: Some(5)
-            }
+            })
         );
 
         assert_eq!(
             types.table_at(0),
-            TableType {
+            Some(TableType {
                 initial: 10,
                 maximum: None,
                 element_type: RefType::FUNCREF,
-            }
+            })
         );
 
         assert_eq!(
             types.global_at(0),
-            GlobalType {
+            Some(GlobalType {
                 content_type: ValType::I32,
                 mutable: true
-            }
+            })
         );
 
-        let id = types.function_at(0);
-        let ty = types[id].unwrap_func();
-        assert_eq!(ty.params(), [ValType::I32, ValType::I64]);
-        assert_eq!(ty.results(), [ValType::I32]);
+        match types.function_at(0) {
+            Some(ty) => {
+                assert_eq!(ty.params(), [ValType::I32, ValType::I64]);
+                assert_eq!(ty.results(), [ValType::I32]);
+            }
+            _ => unreachable!(),
+        }
 
-        let ty = types.tag_at(0);
-        let ty = types[ty].unwrap_func();
-        assert_eq!(ty.params(), [ValType::I64, ValType::I32]);
-        assert_eq!(ty.results(), []);
+        match types.tag_at(0) {
+            Some(ty) => {
+                assert_eq!(ty.params(), [ValType::I64, ValType::I32]);
+                assert_eq!(ty.results(), []);
+            }
+            _ => unreachable!(),
+        }
 
-        assert_eq!(types.element_at(0), RefType::FUNCREF);
+        assert_eq!(types.element_at(0), Some(RefType::FUNCREF));
 
         Ok(())
     }
@@ -1510,54 +1493,30 @@ mod tests {
 
         let types = validator.validate_all(&bytes)?;
 
-        let t_id = types.component_type_at(0);
-        let a1_id = types.component_type_at(1);
-        let a2_id = types.component_type_at(2);
-
-        // The ids should all be the same
-        assert!(t_id == a1_id);
-        assert!(t_id == a2_id);
-        assert!(a1_id == a2_id);
+        let t_id = types.id_from_type_index(0, false).unwrap();
+        let a1_id = types.id_from_type_index(1, false).unwrap();
+        let a2_id = types.id_from_type_index(2, false).unwrap();
 
-        // However, they should all point to the same type
-        assert!(std::ptr::eq(&types[t_id], &types[a1_id],));
-        assert!(std::ptr::eq(&types[t_id], &types[a2_id],));
-
-        Ok(())
-    }
-
-    #[test]
-    fn test_type_id_exports() -> Result<()> {
-        let bytes = wat::parse_str(
-            r#"
-            (component
-              (type $T (list string))
-              (export $A1 "A1" (type $T))
-              (export $A2 "A2" (type $T))
-            )
-        "#,
-        )?;
-
-        let mut validator = Validator::new_with_features(WasmFeatures {
-            component_model: true,
-            ..Default::default()
-        });
-
-        let types = validator.validate_all(&bytes)?;
-
-        let t_id = types.component_type_at(0);
-        let a1_id = types.component_type_at(1);
-        let a2_id = types.component_type_at(2);
-
-        // The ids should all be the same
+        // The ids should all be different
         assert!(t_id != a1_id);
         assert!(t_id != a2_id);
         assert!(a1_id != a2_id);
 
         // However, they should all point to the same type
-        assert!(std::ptr::eq(&types[t_id], &types[a1_id],));
-        assert!(std::ptr::eq(&types[t_id], &types[a2_id],));
+        assert!(std::ptr::eq(
+            types.type_from_id(t_id).unwrap(),
+            types.type_from_id(a1_id).unwrap()
+        ));
+        assert!(std::ptr::eq(
+            types.type_from_id(t_id).unwrap(),
+            types.type_from_id(a2_id).unwrap()
+        ));
 
         Ok(())
     }
+
+    #[test]
+    fn valtype_is_small() {
+        assert_eq!(std::mem::size_of::<ValType>(), 4);
+    }
 }
diff --git a/crates/wasmparser/src/validator/component.rs b/crates/wasmparser/src/validator/component.rs
index da415a90..641b18a2 100644
--- a/crates/wasmparser/src/validator/component.rs
+++ b/crates/wasmparser/src/validator/component.rs
@@ -4,26 +4,24 @@ use super::{
     check_max, combine_type_sizes,
     core::Module,
     types::{
-        ComponentFuncType, ComponentInstanceType, ComponentType, ComponentValType, EntityType,
-        InstanceType, ModuleType, RecordType, Remapping, ResourceId, Type, TypeAlloc, TypeId,
-        TypeList, VariantCase,
+        ComponentFuncType, ComponentInstanceType, ComponentInstanceTypeKind, ComponentType,
+        ComponentValType, EntityType, InstanceType, KebabString, ModuleType, RecordType, Type,
+        TypeAlloc, TypeId, TypeList, VariantCase,
     },
 };
-use crate::validator::names::{KebabName, KebabNameKind, KebabStr, KebabString};
 use crate::{
     limits::*,
     types::{
-        ComponentDefinedType, ComponentEntityType, Context, InstanceTypeKind, LoweringInfo, Remap,
-        SubtypeCx, TupleType, UnionType, VariantType,
+        ComponentDefinedType, ComponentEntityType, InstanceTypeKind, KebabStr, LoweringInfo,
+        TupleType, UnionType, VariantType,
     },
-    BinaryReaderError, CanonicalOption, ComponentExternName, ComponentExternalKind,
-    ComponentOuterAliasKind, ComponentTypeRef, ExternalKind, FuncType, GlobalType,
-    InstantiationArgKind, MemoryType, Result, StructuralType, SubType, TableType, TypeBounds,
-    ValType, WasmFeatures,
+    BinaryReaderError, CanonicalOption, ComponentExternalKind, ComponentOuterAliasKind,
+    ComponentTypeRef, ExternalKind, FuncType, GlobalType, InstantiationArgKind, MemoryType, Result,
+    TableType, TypeBounds, ValType, WasmFeatures,
 };
 use indexmap::{map::Entry, IndexMap, IndexSet};
-use std::collections::{HashMap, HashSet};
-use std::mem;
+use std::{collections::HashSet, mem};
+use url::Url;
 
 fn to_kebab_str<'a>(s: &'a str, desc: &str, offset: usize) -> Result<&'a KebabStr> {
     match KebabStr::new(s) {
@@ -38,11 +36,17 @@ fn to_kebab_str<'a>(s: &'a str, desc: &str, offset: usize) -> Result<&'a KebabSt
     }
 }
 
-pub(crate) struct ComponentState {
-    /// Whether this state is a concrete component, an instance type, or a
-    /// component type.
-    kind: ComponentKind,
+fn parse_url(url: &str, offset: usize) -> Result<Option<Url>> {
+    if url.is_empty() {
+        return Ok(None);
+    }
+
+    Url::parse(url)
+        .map(Some)
+        .map_err(|e| BinaryReaderError::new(e.to_string(), offset))
+}
 
+pub(crate) struct ComponentState {
     // Core index spaces
     pub core_types: Vec<TypeId>,
     pub core_modules: Vec<TypeId>,
@@ -60,144 +64,25 @@ pub(crate) struct ComponentState {
     pub instances: Vec<TypeId>,
     pub components: Vec<TypeId>,
 
-    pub imports: IndexMap<String, ComponentEntityType>,
-    pub exports: IndexMap<String, ComponentEntityType>,
-    pub kebab_named_externs: IndexSet<KebabName>,
+    /// A set of all imports and exports since they share the same namespace.
+    pub externs: IndexMap<KebabString, (Option<Url>, ComponentEntityType, ExternKind)>,
+
+    // Note: URL validation requires unique URLs by byte comparison, so
+    // strings are used here and the URLs are not normalized.
+    import_urls: HashSet<String>,
+    export_urls: HashSet<String>,
 
     has_start: bool,
     type_size: u32,
-
-    /// A mapping of imported resources in this component.
-    ///
-    /// This mapping represents all "type variables" imported into the
-    /// component, or resources. This could be resources imported directly as
-    /// a top-level type import or additionally transitively through other
-    /// imported instances.
-    ///
-    /// The mapping element here is a "path" which is a list of indexes into
-    /// the import map that will be generated for this component. Each index
-    /// is an index into an `IndexMap`, and each list is guaranteed to have at
-    /// least one element.
-    ///
-    /// An example of this map is:
-    ///
-    /// ```wasm
-    /// (component
-    ///     ;; [0] - the first import
-    ///     (import "r" (type (sub resource)))
-    ///
-    ///     ;; [1] - the second import
-    ///     (import "r2" (type (sub resource)))
-    ///
-    ///     (import "i" (instance
-    ///         ;; [2, 0] - the third import, and the first export the instance
-    ///         (export "r3" (type (sub resource)))
-    ///         ;; [2, 1] - the third import, and the second export the instance
-    ///         (export "r4" (type (sub resource)))
-    ///     ))
-    ///
-    ///     ;; ...
-    /// )
-    /// ```
-    ///
-    /// The `Vec<usize>` here can be thought of as `Vec<String>` but a
-    /// (hopefully) more efficient representation.
-    ///
-    /// Finally note that this map is listed as an "append only" map because all
-    /// insertions into it should always succeed. Any insertion which overlaps
-    /// with a previous entry indicates a bug in the validator which needs to be
-    /// corrected via other means.
-    //
-    // TODO: make these `SkolemResourceId` and then go fix all the compile
-    // errors, don't add skolem things into the type area
-    imported_resources: IndexMapAppendOnly<ResourceId, Vec<usize>>,
-
-    /// A mapping of "defined" resources in this component, or those which
-    /// are defined within the instantiation of this component.
-    ///
-    /// Defined resources, as the name implies, can sort of be thought of as
-    /// "these are defined within the component". Note though that the means by
-    /// which a local definition can occur are not simply those defined in the
-    /// component but also in its transitively instantiated components
-    /// internally. This means that this set closes over many transitive
-    /// internal items in addition to those defined immediately in the component
-    /// itself.
-    ///
-    /// The `Option<ValType>` in this mapping is whether or not the underlying
-    /// reprsentation of the resource is known to this component. Immediately
-    /// defined resources, for example, will have `Some(I32)` here. Resources
-    /// that come from transitively defined components, for example, will have
-    /// `None`. In the type context all entries here are `None`.
-    ///
-    /// Note that like `imported_resources` all insertions into this map are
-    /// expected to succeed to it's declared as append-only.
-    defined_resources: IndexMapAppendOnly<ResourceId, Option<ValType>>,
-
-    /// A mapping of explicitly exported resources from this component in
-    /// addition to the path that they're exported at.
-    ///
-    /// For more information on the path here see the documentation for
-    /// `imported_resources`. Note that the indexes here index into the
-    /// list of exports of this component.
-    explicit_resources: IndexMap<ResourceId, Vec<usize>>,
-
-    /// The set of types which are considered "exported" from this component.
-    ///
-    /// This is added to whenever a type export is found, or an instance export
-    /// which itself contains a type export. This additionally includes all
-    /// imported types since those are suitable for export as well.
-    ///
-    /// This set is consulted whenever an exported item is added since all
-    /// referenced types must be members of this set.
-    exported_types: HashSet<TypeId>,
-
-    /// Same as `exported_types`, but for imports.
-    imported_types: HashSet<TypeId>,
-
-    /// The set of top-level resource exports and their names.
-    ///
-    /// This context is used to validate method names such as `[method]foo.bar`
-    /// to ensure that `foo` is an exported resource and that the type mentioned
-    /// in a function type is actually named `foo`.
-    ///
-    /// Note that imports/exports have disjoint contexts to ensure that they're
-    /// validated correctly. Namely you can't retroactively attach methods to an
-    /// import, for example.
-    toplevel_exported_resources: KebabNameContext,
-
-    /// Same as `toplevel_exported_resources`, but for imports.
-    toplevel_imported_resources: KebabNameContext,
-}
-
-#[derive(Copy, Clone, Debug, PartialEq, Eq)]
-pub enum ComponentKind {
-    Component,
-    InstanceType,
-    ComponentType,
-}
-
-/// Helper context used to track information about resource names for method
-/// name validation.
-#[derive(Default)]
-struct KebabNameContext {
-    /// A map from a resource type id to an index in the `all_resource_names`
-    /// set for the name of that resource.
-    resource_name_map: HashMap<TypeId, usize>,
-
-    /// All known resource names in this context, used to validate static method
-    /// names to by ensuring that static methods' resource names are somewhere
-    /// in this set.
-    all_resource_names: IndexSet<String>,
 }
 
-#[derive(Debug, Copy, Clone)]
 pub enum ExternKind {
     Import,
     Export,
 }
 
 impl ExternKind {
-    pub fn desc(&self) -> &'static str {
+    fn desc(&self) -> &'static str {
         match self {
             ExternKind::Import => "import",
             ExternKind::Export => "export",
@@ -206,37 +91,6 @@ impl ExternKind {
 }
 
 impl ComponentState {
-    pub fn new(kind: ComponentKind) -> Self {
-        Self {
-            kind,
-            core_types: Default::default(),
-            core_modules: Default::default(),
-            core_instances: Default::default(),
-            core_funcs: Default::default(),
-            core_memories: Default::default(),
-            core_tables: Default::default(),
-            core_globals: Default::default(),
-            core_tags: Default::default(),
-            types: Default::default(),
-            funcs: Default::default(),
-            values: Default::default(),
-            instances: Default::default(),
-            components: Default::default(),
-            imports: Default::default(),
-            exports: Default::default(),
-            kebab_named_externs: Default::default(),
-            has_start: Default::default(),
-            type_size: 1,
-            imported_resources: Default::default(),
-            defined_resources: Default::default(),
-            explicit_resources: Default::default(),
-            exported_types: Default::default(),
-            imported_types: Default::default(),
-            toplevel_exported_resources: Default::default(),
-            toplevel_imported_resources: Default::default(),
-        }
-    }
-
     pub fn type_count(&self) -> usize {
         self.core_types.len() + self.types.len()
     }
@@ -258,18 +112,14 @@ impl ComponentState {
         check_limit: bool,
     ) -> Result<()> {
         let ty = match ty {
-            crate::CoreType::Func(ty) => Type::Sub(SubType {
-                is_final: false,
-                supertype_idx: None,
-                structural_type: StructuralType::Func(ty),
-            }),
-            crate::CoreType::Module(decls) => Type::Module(Box::new(Self::create_module_type(
+            crate::CoreType::Func(ty) => Type::Func(ty),
+            crate::CoreType::Module(decls) => Type::Module(Self::create_module_type(
                 components,
                 decls.into_vec(),
                 features,
                 types,
                 offset,
-            )?)),
+            )?),
         };
 
         let current = components.last_mut().unwrap();
@@ -278,7 +128,7 @@ impl ComponentState {
             check_max(current.type_count(), 1, MAX_WASM_TYPES, "types", offset)?;
         }
 
-        let id = types.push_ty(ty);
+        let id = types.push_defined(ty);
         current.core_types.push(id);
 
         Ok(())
@@ -295,13 +145,13 @@ impl ComponentState {
         // We have to clone the module's imports and exports here
         // because we cannot take the data out of the `MaybeOwned`
         // as it might be shared with a function validator.
-        let ty = Type::Module(Box::new(ModuleType {
+        let ty = Type::Module(ModuleType {
             type_size: module.type_size,
             imports,
             exports: module.exports.clone(),
-        }));
+        });
 
-        let id = types.push_ty(ty);
+        let id = types.push_anon(ty);
         self.core_modules.push(id);
 
         Ok(())
@@ -349,51 +199,16 @@ impl ComponentState {
                     .unwrap()
                     .create_function_type(ty, types, offset)?,
             ),
-            crate::ComponentType::Component(decls) => Type::Component(Box::new(
-                Self::create_component_type(components, decls.into_vec(), features, types, offset)?,
-            )),
-            crate::ComponentType::Instance(decls) => Type::ComponentInstance(Box::new(
+            crate::ComponentType::Component(decls) => Type::Component(Self::create_component_type(
+                components,
+                decls.into_vec(),
+                features,
+                types,
+                offset,
+            )?),
+            crate::ComponentType::Instance(decls) => Type::ComponentInstance(
                 Self::create_instance_type(components, decls.into_vec(), features, types, offset)?,
-            )),
-            crate::ComponentType::Resource { rep, dtor } => {
-                let component = components.last_mut().unwrap();
-
-                // Resource types cannot be declared in a type context, only
-                // within a component context.
-                if component.kind != ComponentKind::Component {
-                    bail!(
-                        offset,
-                        "resources can only be defined within a concrete component"
-                    );
-                }
-
-                // Current MVP restriction of the component model.
-                if rep != ValType::I32 {
-                    bail!(offset, "resources can only be represented by `i32`");
-                }
-
-                // If specified validate that the destructor is both a valid
-                // function and has the correct signature.
-                if let Some(dtor) = dtor {
-                    let ty = component.core_function_at(dtor, offset)?;
-                    let ty = types[ty].unwrap_func();
-                    if ty.params() != [rep] || ty.results() != [] {
-                        bail!(
-                            offset,
-                            "core function {dtor} has wrong signature for a destructor"
-                        );
-                    }
-                }
-
-                // As this is the introduction of a resource create a fresh new
-                // identifier for the resource. This is then added into the
-                // list of defined resources for this component, notably with a
-                // rep listed to enable getting access to various intrinsics
-                // such as `resource.rep`.
-                let id = types.alloc_resource_id();
-                component.defined_resources.insert(id, Some(rep));
-                Type::Resource(id)
-            }
+            ),
         };
 
         let current = components.last_mut().unwrap();
@@ -401,7 +216,7 @@ impl ComponentState {
             check_max(current.type_count(), 1, MAX_WASM_TYPES, "types", offset)?;
         }
 
-        let id = types.push_ty(ty);
+        let id = types.push_defined(ty);
         current.types.push(id);
 
         Ok(())
@@ -413,484 +228,116 @@ impl ComponentState {
         types: &mut TypeAlloc,
         offset: usize,
     ) -> Result<()> {
-        let mut entity = self.check_type_ref(&import.ty, types, offset)?;
-        self.add_entity(
-            &mut entity,
-            Some((import.name.as_str(), ExternKind::Import)),
-            types,
-            offset,
-        )?;
-        self.toplevel_imported_resources.validate_extern(
-            import.name,
-            "import",
-            &entity,
-            types,
-            offset,
-            &mut self.kebab_named_externs,
-            &mut self.imports,
-            &mut self.type_size,
-        )?;
+        let entity = self.check_type_ref(&import.ty, types, offset)?;
+        self.add_entity(entity, false, offset)?;
+        let name = to_kebab_str(import.name, "import", offset)?;
+
+        match self.externs.entry(name.to_owned()) {
+            Entry::Occupied(e) => {
+                bail!(
+                    offset,
+                    "import name `{name}` conflicts with previous {desc} name `{prev}`",
+                    name = import.name,
+                    prev = e.key(),
+                    desc = e.get().2.desc(),
+                );
+            }
+            Entry::Vacant(e) => {
+                let url = parse_url(import.url, offset)?;
+                if let Some(url) = url.as_ref() {
+                    if !self.import_urls.insert(url.to_string()) {
+                        bail!(offset, "duplicate import URL `{url}`");
+                    }
+                }
+
+                self.type_size = combine_type_sizes(self.type_size, entity.type_size(), offset)?;
+                e.insert((url, entity, ExternKind::Import));
+            }
+        }
+
         Ok(())
     }
 
     fn add_entity(
         &mut self,
-        ty: &mut ComponentEntityType,
-        name_and_kind: Option<(&str, ExternKind)>,
-        types: &mut TypeAlloc,
+        ty: ComponentEntityType,
+        value_used: bool,
         offset: usize,
     ) -> Result<()> {
-        let kind = name_and_kind.map(|(_, k)| k);
         let (len, max, desc) = match ty {
             ComponentEntityType::Module(id) => {
-                self.core_modules.push(*id);
+                self.core_modules.push(id);
                 (self.core_modules.len(), MAX_WASM_MODULES, "modules")
             }
             ComponentEntityType::Component(id) => {
-                self.components.push(*id);
+                self.components.push(id);
                 (self.components.len(), MAX_WASM_COMPONENTS, "components")
             }
             ComponentEntityType::Instance(id) => {
-                match kind {
-                    Some(ExternKind::Import) => self.prepare_instance_import(id, types),
-                    Some(ExternKind::Export) => self.prepare_instance_export(id, types),
-                    None => {}
-                }
-                self.instances.push(*id);
+                self.instances.push(id);
                 (self.instance_count(), MAX_WASM_INSTANCES, "instances")
             }
             ComponentEntityType::Func(id) => {
-                self.funcs.push(*id);
+                self.funcs.push(id);
                 (self.function_count(), MAX_WASM_FUNCTIONS, "functions")
             }
             ComponentEntityType::Value(ty) => {
-                let value_used = match kind {
-                    Some(ExternKind::Import) | None => false,
-                    Some(ExternKind::Export) => true,
-                };
-                self.values.push((*ty, value_used));
+                self.values.push((ty, value_used));
                 (self.values.len(), MAX_WASM_VALUES, "values")
             }
-            ComponentEntityType::Type {
-                created,
-                referenced,
-            } => {
-                self.types.push(*created);
-
-                // Extra logic here for resources being imported and exported.
-                // Note that if `created` is the same as `referenced` then this
-                // is the original introduction of the resource which is where
-                // `self.{imported,defined}_resources` are updated.
-                if let Type::Resource(id) = types[*created] {
-                    match kind {
-                        Some(ExternKind::Import) => {
-                            // A fresh new resource is being imported into a
-                            // component. This arises from the import section of
-                            // a component or from the import declaration in a
-                            // component type. In both cases a new imported
-                            // resource is injected with a fresh new identifier
-                            // into our state.
-                            if created == referenced {
-                                self.imported_resources.insert(id, vec![self.imports.len()]);
-                            }
-                        }
-
-                        Some(ExternKind::Export) => {
-                            // A fresh resource is being exported from this
-                            // component. This arises as part of the
-                            // declaration of a component type, for example. In
-                            // this situation brand new resource identifier is
-                            // allocated and a definition is added, unlike the
-                            // import case where an imported resource is added.
-                            // Notably the representation of this new resource
-                            // is unknown so it's listed as `None`.
-                            if created == referenced {
-                                self.defined_resources.insert(id, None);
-                            }
-
-                            // If this is a type export of a resource type then
-                            // update the `explicit_resources` list. A new
-                            // export path is about to be created for this
-                            // resource and this keeps track of that.
-                            self.explicit_resources.insert(id, vec![self.exports.len()]);
-                        }
-
-                        None => {}
-                    }
-                }
+            ComponentEntityType::Type { created, .. } => {
+                self.types.push(created);
                 (self.types.len(), MAX_WASM_TYPES, "types")
             }
         };
 
         check_max(len, 0, max, desc, offset)?;
-
-        // Before returning perform the final validation of the type of the item
-        // being imported/exported. This will ensure that everything is
-        // appropriately named with respect to type definitions, resources, etc.
-        if let Some((name, kind)) = name_and_kind {
-            if !self.validate_and_register_named_types(Some(name), kind, ty, types) {
-                bail!(
-                    offset,
-                    "{} not valid to be used as {}",
-                    ty.desc(),
-                    kind.desc()
-                );
-            }
-        }
         Ok(())
     }
 
-    /// Validates that the `ty` referenced only refers to named types internally
-    /// and then inserts anything necessary, if applicable, to the defined sets
-    /// within this component.
-    ///
-    /// This function will validate that `ty` only refers to named types. For
-    /// example if it's a record then all of its fields must refer to named
-    /// types. This consults either `self.imported_types` or
-    /// `self.exported_types` as specified by `kind`. Note that this is not
-    /// inherently recursive itself but it ends up being recursive since if
-    /// recursive members were named then all their components must also be
-    /// named. Consequently this check stops at the "one layer deep" position,
-    /// or more accurately the position where types must be named (e.g. tuples
-    /// aren't required to be named).
-    fn validate_and_register_named_types(
+    pub fn add_export(
         &mut self,
-        toplevel_name: Option<&str>,
-        kind: ExternKind,
-        ty: &ComponentEntityType,
-        types: &TypeAlloc,
-    ) -> bool {
-        if let ComponentEntityType::Type { created, .. } = ty {
-            // If this is a top-level resource then register it in the
-            // appropriate context so later validation of method-like-names
-            // works out.
-            if let Some(name) = toplevel_name {
-                if let Type::Resource(_) = types[*created] {
-                    let cx = match kind {
-                        ExternKind::Import => &mut self.toplevel_imported_resources,
-                        ExternKind::Export => &mut self.toplevel_exported_resources,
-                    };
-                    cx.register(name, *created);
-                }
-            }
-        }
-
-        match self.kind {
-            ComponentKind::Component | ComponentKind::ComponentType => {}
-            ComponentKind::InstanceType => return true,
+        name: &str,
+        url: &str,
+        ty: ComponentEntityType,
+        offset: usize,
+        check_limit: bool,
+    ) -> Result<()> {
+        if check_limit {
+            check_max(
+                self.externs.len(),
+                1,
+                MAX_WASM_EXPORTS,
+                "imports and exports",
+                offset,
+            )?;
         }
-        let set = match kind {
-            ExternKind::Import => &self.imported_types,
-            ExternKind::Export => &self.exported_types,
-        };
-        match ty {
-            // When a type is imported or exported than any recursive type
-            // referred to by that import/export must additionally be exported
-            // or imported. Here this walks the "first layer" of the type which
-            // delegates to `TypeAlloc::type_named_type_id` to determine whether
-            // the components of the type being named here are indeed all they
-            // themselves named.
-            ComponentEntityType::Type {
-                created,
-                referenced,
-            } => {
-                if !self.all_valtypes_named(types, *referenced, set) {
-                    return false;
-                }
-                match kind {
-                    // Imported types are both valid for import and valid for
-                    // export.
-                    ExternKind::Import => {
-                        self.imported_types.insert(*created);
-                        self.exported_types.insert(*created);
-                    }
-                    ExternKind::Export => {
-                        self.exported_types.insert(*created);
-                    }
-                }
+        self.add_entity(ty, true, offset)?;
 
-                true
-            }
+        let name = to_kebab_str(name, "export", offset)?;
 
-            // Instances are slightly nuanced here. The general idea is that if
-            // an instance is imported, then any type exported by the instance
-            // is then also exported. Additionally for exports. To get this to
-            // work out this arm will recursively call
-            // `validate_and_register_named_types` which means that types are
-            // inserted into `self.{imported,exported}_types` as-we-go rather
-            // than all at once.
-            //
-            // This then recursively validates that all items in the instance
-            // itself are valid to import/export, recursive instances are
-            // captured, and everything is appropriately added to the right
-            // imported/exported set.
-            ComponentEntityType::Instance(i) => {
-                let ty = types[*i].unwrap_component_instance();
-                ty.exports
-                    .values()
-                    .all(|ty| self.validate_and_register_named_types(None, kind, ty, types))
+        match self.externs.entry(name.to_owned()) {
+            Entry::Occupied(e) => {
+                bail!(
+                    offset,
+                    "export name `{name}` conflicts with previous {desc} name `{prev}`",
+                    prev = e.key(),
+                    desc = e.get().2.desc(),
+                );
             }
-
-            // All types referred to by a function must be named.
-            ComponentEntityType::Func(id) => self.all_valtypes_named(types, *id, set),
-
-            ComponentEntityType::Value(ty) => types.type_named_valtype(ty, set),
-
-            // Components/modules are always "closed" or "standalone" and don't
-            // need validation with respect to their named types.
-            ComponentEntityType::Component(_) | ComponentEntityType::Module(_) => true,
-        }
-    }
-    fn all_valtypes_named(&self, types: &TypeAlloc, id: TypeId, set: &HashSet<TypeId>) -> bool {
-        match &types[id] {
-            Type::Defined(i) => match i {
-                // These types do not contain anything which must be
-                // named.
-                ComponentDefinedType::Primitive(_)
-                | ComponentDefinedType::Flags(_)
-                | ComponentDefinedType::Enum(_) => true,
-
-                // Referenced types of all these aggregates must all be
-                // named.
-                ComponentDefinedType::Record(r) => {
-                    r.fields.values().all(|t| types.type_named_valtype(t, set))
-                }
-                ComponentDefinedType::Tuple(r) => {
-                    r.types.iter().all(|t| types.type_named_valtype(t, set))
-                }
-                ComponentDefinedType::Union(r) => {
-                    r.types.iter().all(|t| types.type_named_valtype(t, set))
-                }
-                ComponentDefinedType::Variant(r) => r
-                    .cases
-                    .values()
-                    .filter_map(|t| t.ty.as_ref())
-                    .all(|t| types.type_named_valtype(t, set)),
-                ComponentDefinedType::Result { ok, err } => {
-                    ok.as_ref()
-                        .map(|t| types.type_named_valtype(t, set))
-                        .unwrap_or(true)
-                        && err
-                            .as_ref()
-                            .map(|t| types.type_named_valtype(t, set))
-                            .unwrap_or(true)
-                }
-                ComponentDefinedType::List(ty) | ComponentDefinedType::Option(ty) => {
-                    types.type_named_valtype(ty, set)
-                }
-
-                // The resource referred to by own/borrow must be named.
-                ComponentDefinedType::Own(id) | ComponentDefinedType::Borrow(id) => {
-                    set.contains(id)
+            Entry::Vacant(e) => {
+                let url = parse_url(url, offset)?;
+                if let Some(url) = url.as_ref() {
+                    if !self.export_urls.insert(url.to_string()) {
+                        bail!(offset, "duplicate export URL `{url}`");
+                    }
                 }
-            },
-
-            // Core wasm constructs are always valid with respect to
-            // exported types, since they have none.
-            Type::Module(_) | Type::Instance(_) | Type::Sub(_) => true,
-
-            // Resource types, in isolation, are always valid to import
-            // or export since they're either attached to an import or
-            // being exported.
-            //
-            // Note that further validation of this happens in `finish`,
-            // too.
-            Type::Resource(_) => true,
-
-            // Component types are validated as they are constructed,
-            // so all component types are valid to export if they've
-            // already been constructed.
-            Type::Component(_) => true,
-
-            // Function types must have all their parameters/results named.
-            Type::ComponentFunc(ty) => ty
-                .params
-                .iter()
-                .map(|(_, ty)| ty)
-                .chain(ty.results.iter().map(|(_, ty)| ty))
-                .all(|ty| types.type_named_valtype(ty, set)),
-
-            // Instances must recursively have all referenced types named.
-            Type::ComponentInstance(ty) => ty.exports.values().all(|ty| {
-                let id = match ty {
-                    ComponentEntityType::Module(id)
-                    | ComponentEntityType::Func(id)
-                    | ComponentEntityType::Value(ComponentValType::Type(id))
-                    | ComponentEntityType::Type { created: id, .. }
-                    | ComponentEntityType::Instance(id)
-                    | ComponentEntityType::Component(id) => *id,
-                    ComponentEntityType::Value(ComponentValType::Primitive(_)) => return true,
-                };
-                self.all_valtypes_named(types, id, set)
-            }),
-        }
-    }
-
-    /// Updates the type `id` specified, an identifier for a component instance
-    /// type, to be imported into this component.
-    ///
-    /// Importing an instance type into a component specially handles the
-    /// defined resources registered in the instance type. Notably all
-    /// defined resources are "freshened" into brand new type variables and
-    /// these new variables are substituted within the type. This is what
-    /// creates a new `TypeId` and may update the `id` specified.
-    ///
-    /// One side effect of this operation, for example, is that if an instance
-    /// type is used twice to import two different instances then the instances
-    /// do not share resource types despite sharing the same original instance
-    /// type.
-    fn prepare_instance_import(&mut self, id: &mut TypeId, types: &mut TypeAlloc) {
-        let ty = types[*id].unwrap_component_instance();
-
-        // No special treatment for imports of instances which themselves have
-        // no defined resources
-        if ty.defined_resources.is_empty() {
-            return;
-        }
-
-        let mut new_ty = ComponentInstanceType {
-            // Copied from the input verbatim
-            type_size: ty.type_size,
-
-            // Copied over as temporary storage for now, and both of these are
-            // filled out and expanded below.
-            exports: ty.exports.clone(),
-            explicit_resources: ty.explicit_resources.clone(),
 
-            // Explicitly discard this field since the
-            // defined resources are lifted into `self`
-            defined_resources: Default::default(),
-        };
-
-        // Create brand new resources for all defined ones in the instance.
-        let resources = (0..ty.defined_resources.len())
-            .map(|_| types.alloc_resource_id())
-            .collect::<IndexSet<_>>();
-
-        // Build a map from the defined resources in `ty` to those in `new_ty`.
-        //
-        // As part of this same loop the new resources, which were previously
-        // defined in `ty`, now become imported variables in `self`. Their
-        // path for where they're imported is updated as well with
-        // `self.next_import_index` as the import-to-be soon.
-        let mut mapping = Remapping::default();
-        let ty = types[*id].unwrap_component_instance();
-        for (old, new) in ty.defined_resources.iter().zip(&resources) {
-            let prev = mapping.resources.insert(*old, *new);
-            assert!(prev.is_none());
-
-            let mut base = vec![self.imports.len()];
-            base.extend(ty.explicit_resources[old].iter().copied());
-            self.imported_resources.insert(*new, base);
-        }
-
-        // Using the old-to-new resource mapping perform a substitution on
-        // the `exports` and `explicit_resources` fields of `new_ty`
-        for ty in new_ty.exports.values_mut() {
-            types.remap_component_entity(ty, &mut mapping);
-        }
-        for (id, path) in mem::take(&mut new_ty.explicit_resources) {
-            let id = *mapping.resources.get(&id).unwrap_or(&id);
-            new_ty.explicit_resources.insert(id, path);
-        }
-
-        // Now that `new_ty` is complete finish its registration and then
-        // update `id` on the way out.
-        *id = types.push_ty(Type::ComponentInstance(Box::new(new_ty)));
-    }
-
-    /// Prepares an instance type, pointed to `id`, for being exported as a
-    /// concrete instance from `self`.
-    ///
-    /// This will internally perform any resource "freshening" as required and
-    /// then additionally update metadata within `self` about resources being
-    /// exported or defined.
-    fn prepare_instance_export(&mut self, id: &mut TypeId, types: &mut TypeAlloc) {
-        // Exports of an instance mean that the enclosing context
-        // is inheriting the resources that the instance
-        // encapsulates. This means that the instance type
-        // recorded for this export will itself have no
-        // defined resources.
-        let ty = types[*id].unwrap_component_instance();
-
-        // Check to see if `defined_resources` is non-empty, and if so then
-        // "freshen" all the resources and inherit them to our own defined
-        // resources, updating `id` in the process.
-        //
-        // Note though that this specifically is not rewriting the resources of
-        // exported instances. The `defined_resources` set on instance types is
-        // a little subtle (see its documentation for more info), but the
-        // general idea is that for a concrete instance it's always empty. Only
-        // for instance type definitions does it ever have elements in it.
-        //
-        // That means that if this set is non-empty then what's happening is
-        // that we're in a type context an exporting an instance of a previously
-        // specified type. In this case all resources are required to be
-        // "freshened" to ensure that multiple exports of the same type all
-        // export different types of resources.
-        //
-        // And finally note that this operation empties out the
-        // `defined_resources` set of the type that is registered for the
-        // instance, as this export is modeled as producing a concrete instance.
-        if !ty.defined_resources.is_empty() {
-            let mut new_ty = ty.clone();
-            let mut mapping = Remapping::default();
-            for old in mem::take(&mut new_ty.defined_resources) {
-                let new = types.alloc_resource_id();
-                mapping.resources.insert(old, new);
-                self.defined_resources.insert(new, None);
-            }
-            for ty in new_ty.exports.values_mut() {
-                types.remap_component_entity(ty, &mut mapping);
-            }
-            for (id, path) in mem::take(&mut new_ty.explicit_resources) {
-                let id = mapping.resources.get(&id).copied().unwrap_or(id);
-                new_ty.explicit_resources.insert(id, path);
-            }
-            *id = types.push_ty(Type::ComponentInstance(Box::new(new_ty)));
-        }
-
-        // Any explicit resources in the instance are now additionally explicit
-        // in this component since it's exported.
-        //
-        // The path to each explicit resources gets one element prepended which
-        // is `self.next_export_index`, the index of the export about to be
-        // generated.
-        let ty = types[*id].unwrap_component_instance();
-        for (id, path) in ty.explicit_resources.iter() {
-            let mut new_path = vec![self.exports.len()];
-            new_path.extend(path);
-            self.explicit_resources.insert(*id, new_path);
+                self.type_size = combine_type_sizes(self.type_size, ty.type_size(), offset)?;
+                e.insert((url, ty, ExternKind::Export));
+            }
         }
-    }
 
-    pub fn add_export(
-        &mut self,
-        name: ComponentExternName<'_>,
-        mut ty: ComponentEntityType,
-        types: &mut TypeAlloc,
-        offset: usize,
-        check_limit: bool,
-    ) -> Result<()> {
-        if check_limit {
-            check_max(self.exports.len(), 1, MAX_WASM_EXPORTS, "exports", offset)?;
-        }
-        self.add_entity(
-            &mut ty,
-            Some((name.as_str(), ExternKind::Export)),
-            types,
-            offset,
-        )?;
-        self.toplevel_exported_resources.validate_extern(
-            name.into(),
-            "export",
-            &ty,
-            types,
-            offset,
-            &mut self.kebab_named_externs,
-            &mut self.exports,
-            &mut self.type_size,
-        )?;
         Ok(())
     }
 
@@ -903,7 +350,9 @@ impl ComponentState {
         offset: usize,
     ) -> Result<()> {
         let ty = self.function_type_at(type_index, types, offset)?;
-        let core_ty = types[self.core_function_at(core_func_index, offset)?].unwrap_func();
+        let core_ty = types[self.core_function_at(core_func_index, offset)?]
+            .as_func_type()
+            .unwrap();
 
         // Lifting a function is for an export, so match the expected canonical ABI
         // export signature
@@ -942,7 +391,9 @@ impl ComponentState {
         types: &mut TypeAlloc,
         offset: usize,
     ) -> Result<()> {
-        let ty = types[self.function_at(func_index, offset)?].unwrap_component_func();
+        let ty = types[self.function_at(func_index, offset)?]
+            .as_component_func_type()
+            .unwrap();
 
         // Lowering a function is for an import, so use a function type that matches
         // the expected canonical ABI import signature.
@@ -950,88 +401,18 @@ impl ComponentState {
 
         self.check_options(None, &info, &options, types, offset)?;
 
-        let lowered_ty = Type::Sub(SubType {
-            is_final: false,
-            supertype_idx: None,
-            structural_type: StructuralType::Func(info.into_func_type()),
-        });
+        let lowered_ty = Type::Func(info.into_func_type());
 
-        let id = types.push_ty(lowered_ty);
+        let id = types.push_anon(lowered_ty);
         self.core_funcs.push(id);
 
         Ok(())
     }
 
-    pub fn resource_new(
-        &mut self,
-        resource: u32,
-        types: &mut TypeAlloc,
-        offset: usize,
-    ) -> Result<()> {
-        let rep = self.check_local_resource(resource, types, offset)?;
-        let core_ty = Type::Sub(SubType {
-            is_final: false,
-            supertype_idx: None,
-            structural_type: StructuralType::Func(FuncType::new([rep], [ValType::I32])),
-        });
-        self.core_funcs.push(types.push_ty(core_ty));
-        Ok(())
-    }
-
-    pub fn resource_drop(
-        &mut self,
-        resource: u32,
-        types: &mut TypeAlloc,
-        offset: usize,
-    ) -> Result<()> {
-        self.resource_at(resource, types, offset)?;
-        let core_ty = Type::Sub(SubType {
-            is_final: false,
-            supertype_idx: None,
-            structural_type: StructuralType::Func(FuncType::new([ValType::I32], [])),
-        });
-        self.core_funcs.push(types.push_ty(core_ty));
-        Ok(())
-    }
-
-    pub fn resource_rep(
-        &mut self,
-        resource: u32,
-        types: &mut TypeAlloc,
-        offset: usize,
-    ) -> Result<()> {
-        let rep = self.check_local_resource(resource, types, offset)?;
-        let core_ty = Type::Sub(SubType {
-            is_final: false,
-            supertype_idx: None,
-            structural_type: StructuralType::Func(FuncType::new([ValType::I32], [rep])),
-        });
-        self.core_funcs.push(types.push_ty(core_ty));
-        Ok(())
-    }
-
-    fn check_local_resource(&self, idx: u32, types: &TypeList, offset: usize) -> Result<ValType> {
-        let id = self.resource_at(idx, types, offset)?;
-        let resource = types[id].unwrap_resource();
-        match self.defined_resources.get(&resource).and_then(|rep| *rep) {
-            Some(ty) => Ok(ty),
-            None => bail!(offset, "type {idx} is not a local resource"),
-        }
-    }
-
-    fn resource_at<'a>(&self, idx: u32, types: &'a TypeList, offset: usize) -> Result<TypeId> {
-        let id = self.type_at(idx, false, offset)?;
-        match &types[id] {
-            Type::Resource(_) => Ok(id),
-            _ => bail!(offset, "type index {} is not a resource type", idx),
-        }
-    }
-
-    pub fn add_component(&mut self, component: ComponentType, types: &mut TypeAlloc) -> Result<()> {
-        let ty = Type::Component(Box::new(component));
-        let id = types.push_ty(ty);
+    pub fn add_component(&mut self, component: &mut Self, types: &mut TypeAlloc) {
+        let ty = Type::Component(component.take_component_type());
+        let id = types.push_anon(ty);
         self.components.push(id);
-        Ok(())
     }
 
     pub fn add_instance(
@@ -1089,7 +470,7 @@ impl ComponentState {
                     Self::alias_module(components, count, index, offset)
                 }
                 ComponentOuterAliasKind::CoreType => {
-                    Self::alias_core_type(components, count, index, offset)
+                    Self::alias_core_type(components, count, index, types, offset)
                 }
                 ComponentOuterAliasKind::Type => {
                     Self::alias_type(components, count, index, types, offset)
@@ -1116,7 +497,9 @@ impl ComponentState {
             ));
         }
 
-        let ft = types[self.function_at(func_index, offset)?].unwrap_component_func();
+        let ft = types[self.function_at(func_index, offset)?]
+            .as_component_func_type()
+            .unwrap();
 
         if ft.params.len() != args.len() {
             bail!(
@@ -1136,13 +519,19 @@ impl ComponentState {
             );
         }
 
-        let cx = SubtypeCx::new(types, types);
         for (i, ((_, ty), arg)) in ft.params.iter().zip(args).enumerate() {
             // Ensure the value's type is a subtype of the parameter type
-            cx.component_val_type(self.value_at(*arg, offset)?, ty, offset)
-                .with_context(|| {
-                    format!("value type mismatch for component start function argument {i}")
-                })?;
+            if !ComponentValType::internal_is_subtype_of(
+                self.value_at(*arg, offset)?,
+                types,
+                ty,
+                types,
+            ) {
+                bail!(
+                    offset,
+                    "value type mismatch for component start function argument {i}"
+                );
+            }
         }
 
         for (_, ty) in ft.results.iter() {
@@ -1210,7 +599,9 @@ impl ComponentState {
                 CanonicalOption::Realloc(idx) => {
                     realloc = match realloc {
                         None => {
-                            let ty = types[self.core_function_at(*idx, offset)?].unwrap_func();
+                            let ty = types[self.core_function_at(*idx, offset)?]
+                                .as_func_type()
+                                .unwrap();
                             if ty.params()
                                 != [ValType::I32, ValType::I32, ValType::I32, ValType::I32]
                                 || ty.results() != [ValType::I32]
@@ -1240,7 +631,9 @@ impl ComponentState {
                                 )
                             })?;
 
-                            let ty = types[self.core_function_at(*idx, offset)?].unwrap_func();
+                            let ty = types[self.core_function_at(*idx, offset)?]
+                                .as_func_type()
+                                .unwrap();
 
                             if ty.params() != core_ty.results() || !ty.results().is_empty() {
                                 return Err(BinaryReaderError::new(
@@ -1279,7 +672,7 @@ impl ComponentState {
     }
 
     fn check_type_ref(
-        &mut self,
+        &self,
         ty: &ComponentTypeRef,
         types: &mut TypeAlloc,
         offset: usize,
@@ -1287,18 +680,16 @@ impl ComponentState {
         Ok(match ty {
             ComponentTypeRef::Module(index) => {
                 let id = self.type_at(*index, true, offset)?;
-                match &types[id] {
-                    Type::Module(_) => {}
-                    _ => bail!(offset, "core type index {index} is not a module type"),
-                }
+                types[id].as_module_type().ok_or_else(|| {
+                    format_err!(offset, "core type index {index} is not a module type")
+                })?;
                 ComponentEntityType::Module(id)
             }
             ComponentTypeRef::Func(index) => {
                 let id = self.type_at(*index, false, offset)?;
-                match &types[id] {
-                    Type::ComponentFunc(_) => {}
-                    _ => bail!(offset, "type index {index} is not a function type"),
-                }
+                types[id].as_component_func_type().ok_or_else(|| {
+                    format_err!(offset, "type index {index} is not a function type")
+                })?;
                 ComponentEntityType::Func(id)
             }
             ComponentTypeRef::Value(ty) => {
@@ -1310,7 +701,7 @@ impl ComponentState {
                 };
                 ComponentEntityType::Value(ty)
             }
-            ComponentTypeRef::Type(TypeBounds::Eq(index)) => {
+            ComponentTypeRef::Type(TypeBounds::Eq, index) => {
                 let referenced = self.type_at(*index, false, offset)?;
                 let created = types.with_unique(referenced);
                 ComponentEntityType::Type {
@@ -1318,28 +709,18 @@ impl ComponentState {
                     created,
                 }
             }
-            ComponentTypeRef::Type(TypeBounds::SubResource) => {
-                let id = types.alloc_resource_id();
-                let id = types.push_ty(Type::Resource(id));
-                ComponentEntityType::Type {
-                    referenced: id,
-                    created: id,
-                }
-            }
             ComponentTypeRef::Instance(index) => {
                 let id = self.type_at(*index, false, offset)?;
-                match &types[id] {
-                    Type::ComponentInstance(_) => {}
-                    _ => bail!(offset, "type index {index} is not an instance type"),
-                }
+                types[id].as_component_instance_type().ok_or_else(|| {
+                    format_err!(offset, "type index {index} is not an instance type")
+                })?;
                 ComponentEntityType::Instance(id)
             }
             ComponentTypeRef::Component(index) => {
                 let id = self.type_at(*index, false, offset)?;
-                match &types[id] {
-                    Type::Component(_) => {}
-                    _ => bail!(offset, "type index {index} is not a component type"),
-                }
+                types[id].as_component_type().ok_or_else(|| {
+                    format_err!(offset, "type index {index} is not a component type")
+                })?;
                 ComponentEntityType::Component(id)
             }
         })
@@ -1382,9 +763,12 @@ impl ComponentState {
             None => return Ok(actual),
         };
 
-        SubtypeCx::new(types, types)
-            .component_entity_type(&actual, &ascribed, offset)
-            .with_context(|| "ascribed type of export is not compatible with item's type")?;
+        if !ComponentEntityType::internal_is_subtype_of(&actual, types, &ascribed, types) {
+            bail!(
+                offset,
+                "ascribed type of export is not compatible with item's type"
+            );
+        }
 
         Ok(ascribed)
     }
@@ -1418,7 +802,7 @@ impl ComponentState {
                         crate::OuterAliasKind::Type => {
                             let ty = if count == 0 {
                                 // Local alias, check the local module state
-                                state.type_id_at(index, offset)?
+                                state.type_at(index, offset)?
                             } else {
                                 // Otherwise, check the enclosing component state
                                 let component =
@@ -1454,7 +838,7 @@ impl ComponentState {
         types: &mut TypeAlloc,
         offset: usize,
     ) -> Result<ComponentType> {
-        components.push(ComponentState::new(ComponentKind::ComponentType));
+        components.push(ComponentState::default());
 
         for decl in decls {
             match decl {
@@ -1464,10 +848,10 @@ impl ComponentState {
                 crate::ComponentTypeDeclaration::Type(ty) => {
                     Self::add_type(components, ty, features, types, offset, true)?;
                 }
-                crate::ComponentTypeDeclaration::Export { name, ty } => {
+                crate::ComponentTypeDeclaration::Export { name, url, ty } => {
                     let current = components.last_mut().unwrap();
                     let ty = current.check_type_ref(&ty, types, offset)?;
-                    current.add_export(name, ty, types, offset, true)?;
+                    current.add_export(name, url, ty, offset, true)?;
                 }
                 crate::ComponentTypeDeclaration::Import(import) => {
                     components
@@ -1481,7 +865,9 @@ impl ComponentState {
             };
         }
 
-        components.pop().unwrap().finish(types, offset)
+        let mut state = components.pop().unwrap();
+
+        Ok(state.take_component_type())
     }
 
     fn create_instance_type(
@@ -1491,7 +877,7 @@ impl ComponentState {
         types: &mut TypeAlloc,
         offset: usize,
     ) -> Result<ComponentInstanceType> {
-        components.push(ComponentState::new(ComponentKind::InstanceType));
+        components.push(ComponentState::default());
 
         for decl in decls {
             match decl {
@@ -1501,10 +887,10 @@ impl ComponentState {
                 crate::InstanceTypeDeclaration::Type(ty) => {
                     Self::add_type(components, ty, features, types, offset, true)?;
                 }
-                crate::InstanceTypeDeclaration::Export { name, ty } => {
+                crate::InstanceTypeDeclaration::Export { name, url, ty } => {
                     let current = components.last_mut().unwrap();
                     let ty = current.check_type_ref(&ty, types, offset)?;
-                    current.add_export(name, ty, types, offset, true)?;
+                    current.add_export(name, url, ty, offset, true)?;
                 }
                 crate::InstanceTypeDeclaration::Alias(alias) => {
                     Self::add_alias(components, alias, types, offset)?;
@@ -1512,35 +898,20 @@ impl ComponentState {
             };
         }
 
-        let mut state = components.pop().unwrap();
-
-        assert!(state.imported_resources.is_empty());
+        let state = components.pop().unwrap();
 
         Ok(ComponentInstanceType {
             type_size: state.type_size,
-
-            // The defined resources for this instance type are those listed on
-            // the component state. The path to each defined resource is
-            // guaranteed to live within the `explicit_resources` map since,
-            // when in the type context, the introduction of any defined
-            // resource must have been done with `(export "x" (type (sub
-            // resource)))` which, in a sense, "fuses" the introduction of the
-            // variable with the export. This means that all defined resources,
-            // if any, should be guaranteed to have an `explicit_resources` path
-            // listed.
-            defined_resources: mem::take(&mut state.defined_resources)
-                .into_iter()
-                .map(|(id, rep)| {
-                    assert!(rep.is_none());
-                    id
-                })
-                .collect(),
-
-            // The map of what resources are explicitly exported and where
-            // they're exported is plumbed through as-is.
-            explicit_resources: mem::take(&mut state.explicit_resources),
-
-            exports: mem::take(&mut state.exports),
+            kind: ComponentInstanceTypeKind::Defined(
+                state
+                    .externs
+                    .into_iter()
+                    .filter_map(|(name, (url, ty, kind))| match kind {
+                        ExternKind::Export => Some((name, (url, ty))),
+                        ExternKind::Import => None,
+                    })
+                    .collect(),
+            ),
         })
     }
 
@@ -1638,16 +1009,16 @@ impl ComponentState {
         for module_arg in module_args {
             match module_arg.kind {
                 InstantiationArgKind::Instance => {
-                    let instance_type =
-                        types[self.core_instance_at(module_arg.index, offset)?].unwrap_instance();
+                    let instance_type = types[self.core_instance_at(module_arg.index, offset)?]
+                        .as_instance_type()
+                        .unwrap();
                     insert_arg(module_arg.name, instance_type, &mut args, offset)?;
                 }
             }
         }
 
         // Validate the arguments
-        let module_type = types[module_type_id].unwrap_module();
-        let cx = SubtypeCx::new(types, types);
+        let module_type = types[module_type_id].as_module_type().unwrap();
         for ((module, name), expected) in module_type.imports.iter() {
             let instance = args.get(module.as_str()).ok_or_else(|| {
                 format_err!(
@@ -1667,23 +1038,41 @@ impl ComponentState {
                     )
                 })?;
 
-            cx.entity_type(arg, expected, offset).with_context(|| {
-                format!(
-                    "type mismatch for export `{name}` of module \
-                         instantiation argument `{module}`"
-                )
-            })?;
+            match (arg, expected) {
+                (EntityType::Func(_), EntityType::Func(_))
+                | (EntityType::Table(_), EntityType::Table(_))
+                | (EntityType::Memory(_), EntityType::Memory(_))
+                | (EntityType::Global(_), EntityType::Global(_))
+                | (EntityType::Tag(_), EntityType::Tag(_)) => {}
+                _ => {
+                    bail!(
+                        offset,
+                        "module instantiation argument `{module}` exports \
+                         an item named `{name}` but it is not a {}",
+                        expected.desc()
+                    )
+                }
+            }
+
+            if !EntityType::internal_is_subtype_of(arg, types, expected, types) {
+                bail!(
+                    offset,
+                    "{} type mismatch for export `{name}` of module \
+                     instantiation argument `{module}`",
+                    expected.desc(),
+                );
+            }
         }
 
-        let ty = Type::Instance(Box::new(InstanceType {
+        let ty = Type::Instance(InstanceType {
             type_size: module_type
                 .exports
                 .iter()
                 .fold(1, |acc, (_, ty)| acc + ty.type_size()),
             kind: InstanceTypeKind::Instantiated(module_type_id),
-        }));
+        });
 
-        Ok(types.push_ty(ty))
+        Ok(types.push_anon(ty))
     }
 
     fn instantiate_component(
@@ -1693,265 +1082,140 @@ impl ComponentState {
         types: &mut TypeAlloc,
         offset: usize,
     ) -> Result<TypeId> {
-        let component_type_id = self.component_at(component_index, offset)?;
-        let mut args = IndexMap::new();
-
-        // Populate the arguments
-        for component_arg in component_args {
-            let ty = match component_arg.kind {
-                ComponentExternalKind::Module => {
-                    ComponentEntityType::Module(self.module_at(component_arg.index, offset)?)
-                }
+        fn insert_arg<'a>(
+            name: &'a str,
+            arg: ComponentEntityType,
+            args: &mut IndexMap<&'a KebabStr, ComponentEntityType>,
+            offset: usize,
+        ) -> Result<()> {
+            let name = to_kebab_str(name, "instantiation argument", offset)?;
+            match args.entry(name) {
+                Entry::Occupied(e) => {
+                    bail!(
+                        offset,
+                        "instantiation argument `{name}` conflicts with previous argument `{prev}`",
+                        prev = e.key()
+                    );
+                }
+                Entry::Vacant(e) => {
+                    e.insert(arg);
+                }
+            }
+
+            Ok(())
+        }
+
+        let component_type_id = self.component_at(component_index, offset)?;
+        let mut args = IndexMap::new();
+
+        // Populate the arguments
+        for component_arg in component_args {
+            match component_arg.kind {
+                ComponentExternalKind::Module => {
+                    insert_arg(
+                        component_arg.name,
+                        ComponentEntityType::Module(self.module_at(component_arg.index, offset)?),
+                        &mut args,
+                        offset,
+                    )?;
+                }
                 ComponentExternalKind::Component => {
-                    ComponentEntityType::Component(self.component_at(component_arg.index, offset)?)
+                    insert_arg(
+                        component_arg.name,
+                        ComponentEntityType::Component(
+                            self.component_at(component_arg.index, offset)?,
+                        ),
+                        &mut args,
+                        offset,
+                    )?;
                 }
                 ComponentExternalKind::Instance => {
-                    ComponentEntityType::Instance(self.instance_at(component_arg.index, offset)?)
+                    insert_arg(
+                        component_arg.name,
+                        ComponentEntityType::Instance(
+                            self.instance_at(component_arg.index, offset)?,
+                        ),
+                        &mut args,
+                        offset,
+                    )?;
                 }
                 ComponentExternalKind::Func => {
-                    ComponentEntityType::Func(self.function_at(component_arg.index, offset)?)
+                    insert_arg(
+                        component_arg.name,
+                        ComponentEntityType::Func(self.function_at(component_arg.index, offset)?),
+                        &mut args,
+                        offset,
+                    )?;
                 }
                 ComponentExternalKind::Value => {
-                    ComponentEntityType::Value(*self.value_at(component_arg.index, offset)?)
+                    insert_arg(
+                        component_arg.name,
+                        ComponentEntityType::Value(*self.value_at(component_arg.index, offset)?),
+                        &mut args,
+                        offset,
+                    )?;
                 }
                 ComponentExternalKind::Type => {
                     let ty = self.type_at(component_arg.index, false, offset)?;
-                    ComponentEntityType::Type {
-                        referenced: ty,
-                        created: ty,
-                    }
-                }
-            };
-            match args.entry(component_arg.name.to_string()) {
-                Entry::Occupied(e) => {
-                    bail!(
+                    insert_arg(
+                        component_arg.name,
+                        ComponentEntityType::Type {
+                            referenced: ty,
+                            created: ty,
+                        },
+                        &mut args,
                         offset,
-                        "instantiation argument `{name}` conflicts with previous argument `{prev}`",
-                        prev = e.key(),
-                        name = component_arg.name
-                    );
-                }
-                Entry::Vacant(e) => {
-                    e.insert(ty);
+                    )?;
                 }
             }
         }
 
-        // Here comes the fun part of the component model, we're instantiating
-        // the component with type `component_type_id` with the `args`
-        // specified. Easy enough!
-        //
-        // This operation, however, is one of the lynchpins of safety in the
-        // component model. Additionally what this ends up implementing ranges
-        // from "well just check the types are equal" to "let's have a
-        // full-blown ML-style module type system in the component model". There
-        // are primarily two major tricky pieces to the component model which
-        // make this operation, instantiating components, hard:
-        //
-        // 1. Components can import and exports other components. This means
-        //    that arguments to instantiation are along the lines of functions
-        //    being passed to functions or similar. Effectively this means that
-        //    the term "variance" comes into play with either contravariance
-        //    or covariance depending on where you are in typechecking. This is
-        //    one of the main rationales, however, that this check below is a
-        //    check for subtyping as opposed to exact type equivalence. For
-        //    example an instance that exports something is a subtype of an
-        //    instance that exports nothing. Components get a bit trick since
-        //    they both have imports and exports. My way of thinking about it
-        //    is "who's asking for what". If you're asking for imports then
-        //    I need to at least supply those imports, but I can possibly
-        //    supply more. If you're asking for a thing which you'll give a set
-        //    of imports, then I can give you something which takes less imports
-        //    because what you give still suffices. (things like that). The
-        //    real complication with components, however, comes with...
-        //
-        // 2. Resources. Resources in the component model are akin to "abstract
-        //    types". They're not abstract in the sense that they have no
-        //    representation, they're always backed by a 32-bit integer right
-        //    now. Instead they're abstract in the sense that some components
-        //    aren't allowed to understand the representation of a resource.
-        //    For example if you import a resource you can't get the underlying
-        //    internals of it. Furthermore the resource is strictly tracked
-        //    within the component with `own` and `borrow` runtime semantics.
-        //    The hardest part about resources, though, is handling them as
-        //    part of instantiation and subtyping.
-        //
-        //    For example one major aspect of resources is that if a component
-        //    exports a resource then each instantiation of the component
-        //    produces a fresh resource type. This means that the type recorded
-        //    for the instantiation here can't simply be "I instantiated
-        //    component X" since in such a situation the type of all
-        //    instantiations would be the same, which they aren't.
-        //
-        //    This sort of subtelty comes up quite frequently for resources.
-        //    This file contains references to `imported_resources` and
-        //    `defined_resources` for example which refer to the formal
-        //    nature of components and their abstract variables. Specifically
-        //    for instantiation though we're eventually faced with the problem
-        //    of subtype checks where resource subtyping is defined as "does
-        //    your id equal mine". Naively implemented that means anything with
-        //    resources isn't subtypes of anything else since resource ids are
-        //    unique between components. Instead what actually needs to happen
-        //    is types need to be substituted.
-        //
-        // Much of the complexity here is not actually apparent here in this
-        // literal one function. Instead it's spread out across validation
-        // in this file and type-checking in the `types.rs` module. Note that
-        // the "spread out" nature isn't because we're bad maintainers
-        // (hopefully), but rather it's quite infectious how many parts need
-        // to handle resources and account for defined/imported variables.
-        //
-        // For example only one subtyping method is called here where `args` is
-        // passed in. This method is quite recursive in its nature though and
-        // will internally touch all the fields that this file maintains to
-        // end up putting into various bits and pieces of type information.
-        //
-        // Unfortunately there's probably not really a succinct way to read
-        // this method and understand everything. If you've written ML module
-        // type systems this will probably look quite familiar, but otherwise
-        // the whole system is not really easily approachable at this time. It's
-        // hoped in the future that there's a formalism to refer to which will
-        // make things more clear as the code would be able to reference this
-        // hypothetical formalism. Until that's the case, though, these
-        // comments are hopefully enough when augmented with communication with
-        // the authors.
-
-        let component_type = types[component_type_id].unwrap_component();
-        let mut exports = component_type.exports.clone();
-        let type_size = component_type
-            .exports
-            .iter()
-            .fold(1, |acc, (_, ty)| acc + ty.type_size());
-
-        // Perform the subtype check that `args` matches the imports of
-        // `component_type_id`. The result of this subtype check is the
-        // production of a mapping of resource types from the imports to the
-        // arguments provided. This is a substitution map which is then used
-        // below to perform a substitution into the exports of the instance
-        // since the types of the exports are now in terms of whatever was
-        // supplied as imports.
-        let mut mapping = SubtypeCx::new(types, types).open_instance_type(
-            &args,
-            component_type_id,
-            ExternKind::Import,
-            offset,
-        )?;
-
-        // Part of the instantiation of a component is that all of its
-        // defined resources become "fresh" on each instantiation. This
-        // means that each instantiation of a component gets brand new type
-        // variables representing its defined resources, modeling that each
-        // instantiation produces distinct types. The freshening is performed
-        // here by allocating new ids and inserting them into `mapping`.
-        //
-        // Note that technically the `mapping` from subtyping should be applied
-        // first and then the mapping for freshening should be applied
-        // afterwards. The keys of the map from subtyping are the imported
-        // resources from this component which are disjoint from its defined
-        // resources. That means it should be possible to place everything
-        // into one large map which maps from:
-        //
-        // * the component's imported resources go to whatever was explicitly
-        //   supplied in the import map
-        // * the component's defined resources go to fresh new resources
-        //
-        // These two remapping operations can then get folded into one by
-        // placing everything in the same `mapping` and using that for a remap
-        // only once.
-        let fresh_defined_resources = (0..component_type.defined_resources.len())
-            .map(|_| types.alloc_resource_id())
-            .collect::<IndexSet<_>>();
-        let component_type = types[component_type_id].unwrap_component();
-        for ((old, _path), new) in component_type
-            .defined_resources
-            .iter()
-            .zip(&fresh_defined_resources)
-        {
-            let prev = mapping.resources.insert(*old, *new);
-            assert!(prev.is_none());
-        }
+        // Validate the arguments
+        let component_type = types[component_type_id].as_component_type().unwrap();
+        for (name, (_, expected)) in component_type.imports.iter() {
+            match args.get(&name.as_kebab_str()) {
+                Some(arg) => {
+                    match (arg, expected) {
+                        (ComponentEntityType::Module(_), ComponentEntityType::Module(_))
+                        | (ComponentEntityType::Component(_), ComponentEntityType::Component(_))
+                        | (ComponentEntityType::Instance(_), ComponentEntityType::Instance(_))
+                        | (ComponentEntityType::Func(_), ComponentEntityType::Func(_))
+                        | (ComponentEntityType::Value(_), ComponentEntityType::Value(_))
+                        | (ComponentEntityType::Type { .. }, ComponentEntityType::Type { .. }) => {}
+                        _ => {
+                            bail!(
+                                offset,
+                                "expected component instantiation argument `{name}` to be a {desc}",
+                                desc = expected.desc()
+                            )
+                        }
+                    };
 
-        // Perform the remapping operation over all the exports that will be
-        // listed for the final instance type. Note that this is performed
-        // both for all the export types in addition to the explicitly exported
-        // resources list.
-        //
-        // Note that this is a crucial step of the instantiation process which
-        // is intentionally transforming the type of a component based on the
-        // variables provided by imports and additionally ensuring that all
-        // references to the component's defined resources are rebound to the
-        // fresh ones introduced just above.
-        for entity in exports.values_mut() {
-            types.remap_component_entity(entity, &mut mapping);
-        }
-        let component_type = types[component_type_id].unwrap_component();
-        let explicit_resources = component_type
-            .explicit_resources
-            .iter()
-            .map(|(id, path)| {
-                (
-                    mapping.resources.get(id).copied().unwrap_or(*id),
-                    path.clone(),
-                )
-            })
-            .collect::<IndexMap<_, _>>();
-
-        // Technically in the last formalism that was consulted in writing this
-        // implementation there are two further steps that are part of the
-        // instantiation process:
-        //
-        // 1. The set of defined resources from the instance created, which are
-        //    added to the outer component, is the subset of the instance's
-        //    original defined resources and the free variables of the exports.
-        //
-        // 2. Each element of this subset is required to be "explicit in" the
-        //    instance, or otherwise explicitly exported somewhere within the
-        //    instance.
-        //
-        // With the syntactic structure of the component model, however, neither
-        // of these conditions should be necessary. The main reason for this is
-        // that this function is specifically dealing with instantiation of
-        // components which should already have these properties validated
-        // about them. Subsequently we shouldn't have to re-check them.
-        //
-        // In debug mode, however, do a sanity check.
-        if cfg!(debug_assertions) {
-            let mut free = IndexSet::new();
-            for ty in exports.values() {
-                types.free_variables_component_entity(ty, &mut free);
-            }
-            assert!(fresh_defined_resources.is_subset(&free));
-            for resource in fresh_defined_resources.iter() {
-                assert!(explicit_resources.contains_key(resource));
+                    if !ComponentEntityType::internal_is_subtype_of(arg, types, expected, types) {
+                        bail!(
+                            offset,
+                            "type mismatch for component instantiation argument `{name}`"
+                        );
+                    }
+                }
+                None => {
+                    bail!(
+                        offset,
+                        "missing component instantiation argument named `{name}`"
+                    );
+                }
             }
         }
 
-        // And as the final step of the instantiation process all of the
-        // new defined resources from this component instantiation are moved
-        // onto `self`. Note that concrete instances never have defined
-        // resources (see more comments in `instantiate_exports`) so the
-        // `defined_resources` listing in the final type is always empty. This
-        // represents how by having a concrete instance the definitions
-        // referred to in that instance are now problems for the outer
-        // component rather than the inner instance since the instance is bound
-        // to the component.
-        //
-        // All defined resources here have no known representation, so they're
-        // all listed with `None`. Also note that none of the resources were
-        // exported yet so `self.explicit_resources` is not updated yet. If
-        // this instance is exported, however, it'll consult the type's
-        // `explicit_resources` array and use that appropriately.
-        for resource in fresh_defined_resources {
-            self.defined_resources.insert(resource, None);
-        }
+        let ty = Type::ComponentInstance(ComponentInstanceType {
+            type_size: component_type
+                .exports
+                .iter()
+                .fold(1, |acc, (_, (_, ty))| acc + ty.type_size()),
+            kind: ComponentInstanceTypeKind::Instantiated(component_type_id),
+        });
 
-        let ty = Type::ComponentInstance(Box::new(ComponentInstanceType {
-            type_size,
-            defined_resources: Default::default(),
-            explicit_resources,
-            exports,
-        }));
-        Ok(types.push_ty(ty))
+        Ok(types.push_anon(ty))
     }
 
     fn instantiate_exports(
@@ -1960,121 +1224,106 @@ impl ComponentState {
         types: &mut TypeAlloc,
         offset: usize,
     ) -> Result<TypeId> {
-        let mut type_size = 1;
-        let mut inst_exports = IndexMap::new();
-        let mut explicit_resources = IndexMap::new();
-        let mut kebab_names = IndexSet::new();
+        fn insert_export(
+            name: &str,
+            export: ComponentEntityType,
+            exports: &mut IndexMap<KebabString, (Option<Url>, ComponentEntityType)>,
+            type_size: &mut u32,
+            offset: usize,
+        ) -> Result<()> {
+            let name = to_kebab_str(name, "instance export", offset)?;
+            match exports.entry(name.to_owned()) {
+                Entry::Occupied(e) => bail!(
+                    offset,
+                    "instance export name `{name}` conflicts with previous export name `{prev}`",
+                    prev = e.key()
+                ),
+                Entry::Vacant(e) => {
+                    *type_size = combine_type_sizes(*type_size, export.type_size(), offset)?;
+                    e.insert((None, export));
+                }
+            }
 
-        // NB: It's intentional that this context is empty since no indices are
-        // introduced in the bag-of-exports construct which means there's no
-        // way syntactically to register something inside of this.
-        let names = KebabNameContext::default();
+            Ok(())
+        }
 
+        let mut type_size = 1;
+        let mut inst_exports = IndexMap::new();
         for export in exports {
             assert!(export.ty.is_none());
-            let ty = match export.kind {
+            match export.kind {
                 ComponentExternalKind::Module => {
-                    ComponentEntityType::Module(self.module_at(export.index, offset)?)
+                    insert_export(
+                        export.name,
+                        ComponentEntityType::Module(self.module_at(export.index, offset)?),
+                        &mut inst_exports,
+                        &mut type_size,
+                        offset,
+                    )?;
                 }
                 ComponentExternalKind::Component => {
-                    ComponentEntityType::Component(self.component_at(export.index, offset)?)
+                    insert_export(
+                        export.name,
+                        ComponentEntityType::Component(self.component_at(export.index, offset)?),
+                        &mut inst_exports,
+                        &mut type_size,
+                        offset,
+                    )?;
                 }
                 ComponentExternalKind::Instance => {
-                    let ty = self.instance_at(export.index, offset)?;
-
-                    // When an instance is exported from an instance then
-                    // all explicitly exported resources on the sub-instance are
-                    // now also listed as exported resources on the outer
-                    // instance, just with one more element in their path.
-                    explicit_resources.extend(
-                        types[ty]
-                            .unwrap_component_instance()
-                            .explicit_resources
-                            .iter()
-                            .map(|(id, path)| {
-                                let mut new_path = vec![inst_exports.len()];
-                                new_path.extend(path);
-                                (*id, new_path)
-                            }),
-                    );
-                    ComponentEntityType::Instance(ty)
+                    insert_export(
+                        export.name,
+                        ComponentEntityType::Instance(self.instance_at(export.index, offset)?),
+                        &mut inst_exports,
+                        &mut type_size,
+                        offset,
+                    )?;
                 }
                 ComponentExternalKind::Func => {
-                    ComponentEntityType::Func(self.function_at(export.index, offset)?)
+                    insert_export(
+                        export.name,
+                        ComponentEntityType::Func(self.function_at(export.index, offset)?),
+                        &mut inst_exports,
+                        &mut type_size,
+                        offset,
+                    )?;
                 }
                 ComponentExternalKind::Value => {
-                    ComponentEntityType::Value(*self.value_at(export.index, offset)?)
+                    insert_export(
+                        export.name,
+                        ComponentEntityType::Value(*self.value_at(export.index, offset)?),
+                        &mut inst_exports,
+                        &mut type_size,
+                        offset,
+                    )?;
                 }
                 ComponentExternalKind::Type => {
                     let ty = self.type_at(export.index, false, offset)?;
-                    // If this is an export of a resource type be sure to
-                    // record that in the explicit list with the appropriate
-                    // path because if this instance ends up getting used
-                    // it'll count towards the "explicit in" check.
-                    if let Type::Resource(id) = &types[ty] {
-                        explicit_resources.insert(*id, vec![inst_exports.len()]);
-                    }
-                    ComponentEntityType::Type {
-                        referenced: ty,
-                        // The created type index here isn't used anywhere
-                        // in index spaces because a "bag of exports"
-                        // doesn't build up its own index spaces. Just fill
-                        // in the same index here in this case as what's
-                        // referenced.
-                        created: ty,
-                    }
+                    insert_export(
+                        export.name,
+                        ComponentEntityType::Type {
+                            referenced: ty,
+                            // The created type index here isn't used anywhere
+                            // in index spaces because a "bag of exports"
+                            // doesn't build up its own index spaces. Just fill
+                            // in the same index here in this case as what's
+                            // referenced.
+                            created: ty,
+                        },
+                        &mut inst_exports,
+                        &mut type_size,
+                        offset,
+                    )?;
                 }
-            };
-
-            names.validate_extern(
-                export.name.into(),
-                "instance export",
-                &ty,
-                types,
-                offset,
-                &mut kebab_names,
-                &mut inst_exports,
-                &mut type_size,
-            )?;
+            }
         }
 
-        let ty = Type::ComponentInstance(Box::new(ComponentInstanceType {
+        let ty = Type::ComponentInstance(ComponentInstanceType {
             type_size,
-            explicit_resources,
-            exports: inst_exports,
-
-            // NB: the list of defined resources for this instance itself
-            // is always empty. Even if this instance exports resources,
-            // it's empty.
-            //
-            // The reason for this is a bit subtle. The general idea, though, is
-            // that the defined resources list here is only used for instance
-            // types that are sort of "floating around" and haven't actually
-            // been attached to something yet. For example when an instance type
-            // is simply declared it can have defined resources introduced
-            // through `(export "name" (type (sub resource)))`. These
-            // definitions, however, are local to the instance itself and aren't
-            // defined elsewhere.
-            //
-            // Here, though, no new definitions were introduced. The instance
-            // created here is a "bag of exports" which could only refer to
-            // preexisting items. This means that inherently no new resources
-            // were created so there's nothing to put in this list. Any
-            // resources referenced by the instance must be bound by the outer
-            // component context or further above.
-            //
-            // Furthermore, however, actual instances of instances, which this
-            // is, aren't allowed to have defined resources. Instead the
-            // resources would have to be injected into the outer component
-            // enclosing the instance. That means that even if bag-of-exports
-            // could declare a new resource then the resource would be moved
-            // from here to `self.defined_resources`. This doesn't exist at this
-            // time, though, so this still remains empty and
-            // `self.defined_resources` remains unperturbed.
-            defined_resources: Default::default(),
-        }));
-
-        Ok(types.push_ty(ty))
+            kind: ComponentInstanceTypeKind::Exports(inst_exports),
+        });
+
+        Ok(types.push_anon(ty))
     }
 
     fn instantiate_core_exports(
@@ -2148,12 +1397,12 @@ impl ComponentState {
             }
         }
 
-        let ty = Type::Instance(Box::new(InstanceType {
+        let ty = Type::Instance(InstanceType {
             type_size,
             kind: InstanceTypeKind::Exports(inst_exports),
-        }));
+        });
 
-        Ok(types.push_ty(ty))
+        Ok(types.push_anon(ty))
     }
 
     fn alias_core_instance_export(
@@ -2232,42 +1481,97 @@ impl ComponentState {
         types: &mut TypeAlloc,
         offset: usize,
     ) -> Result<()> {
-        let mut ty = match types[self.instance_at(instance_index, offset)?]
-            .unwrap_component_instance()
-            .exports
-            .get(name)
-        {
-            Some(ty) => *ty,
-            None => bail!(
-                offset,
-                "instance {instance_index} has no export named `{name}`"
-            ),
-        };
+        let name = to_kebab_str(name, "alias export", offset)?;
 
-        let ok = match (&ty, kind) {
-            (ComponentEntityType::Module(_), ComponentExternalKind::Module) => true,
-            (ComponentEntityType::Module(_), _) => false,
-            (ComponentEntityType::Component(_), ComponentExternalKind::Component) => true,
-            (ComponentEntityType::Component(_), _) => false,
-            (ComponentEntityType::Func(_), ComponentExternalKind::Func) => true,
-            (ComponentEntityType::Func(_), _) => false,
-            (ComponentEntityType::Instance(_), ComponentExternalKind::Instance) => true,
-            (ComponentEntityType::Instance(_), _) => false,
-            (ComponentEntityType::Value(_), ComponentExternalKind::Value) => true,
-            (ComponentEntityType::Value(_), _) => false,
-            (ComponentEntityType::Type { .. }, ComponentExternalKind::Type) => true,
-            (ComponentEntityType::Type { .. }, _) => false,
-        };
-        if !ok {
-            bail!(
-                offset,
-                "export `{name}` for instance {instance_index} is not a {}",
-                kind.desc(),
-            );
+        macro_rules! push_component_export {
+            ($expected:path, $collection:ident, $ty:literal) => {{
+                match self.instance_export(instance_index, name, types, offset)? {
+                    $expected(ty) => {
+                        self.$collection.push(*ty);
+                        Ok(())
+                    }
+                    _ => {
+                        bail!(
+                            offset,
+                            "export `{name}` for instance {instance_index} is not a {}",
+                            $ty
+                        )
+                    }
+                }
+            }};
         }
 
-        self.add_entity(&mut ty, None, types, offset)?;
-        Ok(())
+        match kind {
+            ComponentExternalKind::Module => {
+                check_max(
+                    self.core_modules.len(),
+                    1,
+                    MAX_WASM_MODULES,
+                    "modules",
+                    offset,
+                )?;
+                push_component_export!(ComponentEntityType::Module, core_modules, "module")
+            }
+            ComponentExternalKind::Component => {
+                check_max(
+                    self.components.len(),
+                    1,
+                    MAX_WASM_COMPONENTS,
+                    "components",
+                    offset,
+                )?;
+                push_component_export!(ComponentEntityType::Component, components, "component")
+            }
+            ComponentExternalKind::Instance => {
+                check_max(
+                    self.instance_count(),
+                    1,
+                    MAX_WASM_INSTANCES,
+                    "instances",
+                    offset,
+                )?;
+                push_component_export!(ComponentEntityType::Instance, instances, "instance")
+            }
+            ComponentExternalKind::Func => {
+                check_max(
+                    self.function_count(),
+                    1,
+                    MAX_WASM_FUNCTIONS,
+                    "functions",
+                    offset,
+                )?;
+                push_component_export!(ComponentEntityType::Func, funcs, "function")
+            }
+            ComponentExternalKind::Value => {
+                check_max(self.values.len(), 1, MAX_WASM_VALUES, "values", offset)?;
+                match self.instance_export(instance_index, name, types, offset)? {
+                    ComponentEntityType::Value(ty) => {
+                        self.values.push((*ty, false));
+                        Ok(())
+                    }
+                    _ => bail!(
+                        offset,
+                        "export `{name}` for instance {instance_index} is not a value",
+                    ),
+                }
+            }
+            ComponentExternalKind::Type => {
+                check_max(self.type_count(), 1, MAX_WASM_TYPES, "types", offset)?;
+                match *self.instance_export(instance_index, name, types, offset)? {
+                    ComponentEntityType::Type { created, .. } => {
+                        let id = types.with_unique(created);
+                        self.types.push(id);
+                        Ok(())
+                    }
+                    _ => {
+                        bail!(
+                            offset,
+                            "export `{name}` for instance {instance_index} is not a type",
+                        )
+                    }
+                }
+            }
+        }
     }
 
     fn alias_module(components: &mut [Self], count: u32, index: u32, offset: usize) -> Result<()> {
@@ -2313,6 +1617,7 @@ impl ComponentState {
         components: &mut [Self],
         count: u32,
         index: u32,
+        types: &mut TypeAlloc,
         offset: usize,
     ) -> Result<()> {
         let component = Self::check_alias_count(components, count, offset)?;
@@ -2321,7 +1626,8 @@ impl ComponentState {
         let current = components.last_mut().unwrap();
         check_max(current.type_count(), 1, MAX_WASM_TYPES, "types", offset)?;
 
-        current.core_types.push(ty);
+        let id = types.with_unique(ty);
+        current.core_types.push(id);
 
         Ok(())
     }
@@ -2336,47 +1642,11 @@ impl ComponentState {
         let component = Self::check_alias_count(components, count, offset)?;
         let ty = component.type_at(index, false, offset)?;
 
-        // If `count` "crossed a component boundary", meaning that it went from
-        // one component to another, then this must additionally verify that
-        // `ty` has no free variables with respect to resources. This is
-        // intended to preserve the property for components where each component
-        // is an isolated unit that can theoretically be extracted from other
-        // components. If resources from other components were allowed to leak
-        // in then it would prevent that.
-        //
-        // This check is done by calculating the `pos` within `components` that
-        // our target `component` above was selected at. Once this is acquired
-        // the component to the "right" is checked, and if that's a component
-        // then it's considered as crossing a component boundary meaning the
-        // free variables check runs.
-        //
-        // The reason this works is that in the list of `ComponentState` types
-        // it's guaranteed that any `is_type` components are contiguous at the
-        // end of the array. This means that if state one level deeper than the
-        // target of this alias is a `!is_type` component, then the target must
-        // be a component as well. If the one-level deeper state `is_type` then
-        // the target is either a type or a component, both of which are valid
-        // (as aliases can reach the enclosing component and have as many free
-        // variables as they want).
-        let pos_after_component = components.len() - (count as usize);
-        if let Some(component) = components.get(pos_after_component) {
-            if component.kind == ComponentKind::Component {
-                let mut free = IndexSet::new();
-                types.free_variables_type_id(ty, &mut free);
-                if !free.is_empty() {
-                    bail!(
-                        offset,
-                        "cannot alias outer type which transitively refers \
-                         to resources not defined in the current component"
-                    );
-                }
-            }
-        }
-
         let current = components.last_mut().unwrap();
         check_max(current.type_count(), 1, MAX_WASM_TYPES, "types", offset)?;
 
-        current.types.push(ty);
+        let id = types.with_unique(ty);
+        current.types.push(id);
 
         Ok(())
     }
@@ -2430,12 +1700,6 @@ impl ComponentState {
                     .map(|ty| self.create_component_val_type(ty, types, offset))
                     .transpose()?,
             }),
-            crate::ComponentDefinedType::Own(idx) => Ok(ComponentDefinedType::Own(
-                self.resource_at(idx, types, offset)?,
-            )),
-            crate::ComponentDefinedType::Borrow(idx) => Ok(ComponentDefinedType::Borrow(
-                self.resource_at(idx, types, offset)?,
-            )),
         }
     }
 
@@ -2650,10 +1914,9 @@ impl ComponentState {
         types: &'a TypeList,
         offset: usize,
     ) -> Result<&'a ComponentFuncType> {
-        match &types[self.type_at(idx, false, offset)?] {
-            Type::ComponentFunc(f) => Ok(f),
-            _ => bail!(offset, "type index {idx} is not a function type"),
-        }
+        types[self.type_at(idx, false, offset)?]
+            .as_component_func_type()
+            .ok_or_else(|| format_err!(offset, "type index {idx} is not a function type"))
     }
 
     fn function_at(&self, idx: u32, offset: usize) -> Result<TypeId> {
@@ -2683,6 +1946,27 @@ impl ComponentState {
         })
     }
 
+    fn instance_export<'a>(
+        &self,
+        instance_index: u32,
+        name: &KebabStr,
+        types: &'a TypeList,
+        offset: usize,
+    ) -> Result<&'a ComponentEntityType> {
+        match types[self.instance_at(instance_index, offset)?]
+            .as_component_instance_type()
+            .unwrap()
+            .internal_exports(types)
+            .get(name)
+        {
+            Some((_, ty)) => Ok(ty),
+            None => bail!(
+                offset,
+                "instance {instance_index} has no export named `{name}`"
+            ),
+        }
+    }
+
     fn value_at(&mut self, idx: u32, offset: usize) -> Result<&ComponentValType> {
         match self.values.get_mut(idx as usize) {
             Some((ty, used)) if !*used => {
@@ -2737,7 +2021,8 @@ impl ComponentState {
         offset: usize,
     ) -> Result<&'a EntityType> {
         match types[self.core_instance_at(instance_index, offset)?]
-            .unwrap_instance()
+            .as_instance_type()
+            .unwrap()
             .internal_exports(types)
             .get(name)
         {
@@ -2770,316 +2055,47 @@ impl ComponentState {
         }
     }
 
-    /// Completes the translation of this component, performing final
-    /// validation of its structure.
-    ///
-    /// This method is required to be called for translating all components.
-    /// Internally this will convert local data structures into a
-    /// `ComponentType` which is suitable to use to describe the type of this
-    /// component.
-    pub fn finish(&mut self, types: &TypeAlloc, offset: usize) -> Result<ComponentType> {
+    fn take_component_type(&mut self) -> ComponentType {
         let mut ty = ComponentType {
-            // Inherit some fields based on translation of the component.
             type_size: self.type_size,
-            imports: self.imports.clone(),
-            exports: self.exports.clone(),
-
-            // This is filled in as a subset of `self.defined_resources`
-            // depending on what's actually used by the exports. See the
-            // bottom of this function.
-            defined_resources: Default::default(),
-
-            // These are inherited directly from what was calculated for this
-            // component.
-            imported_resources: mem::take(&mut self.imported_resources)
-                .into_iter()
-                .collect(),
-            explicit_resources: mem::take(&mut self.explicit_resources),
+            imports: Default::default(),
+            exports: Default::default(),
         };
 
-        // Collect all "free variables", or resources, from the imports of this
-        // component. None of the resources defined within this component can
-        // be used as part of the exports. This set is then used to reject any
-        // of `self.defined_resources` which show up.
-        let mut free = IndexSet::default();
-        for ty in ty.imports.values() {
-            types.free_variables_component_entity(ty, &mut free);
-        }
-        for (resource, _path) in self.defined_resources.iter() {
-            // FIXME: this error message is quite opaque and doesn't indicate
-            // more contextual information such as:
-            //
-            // * what was the exported resource found in the imports
-            // * which import was the resource found within
-            //
-            // These are possible to calculate here if necessary, however.
-            if free.contains(resource) {
-                bail!(offset, "local resource type found in imports");
-            }
-        }
-
-        // The next step in validation a component, with respect to resources,
-        // is to minimize the set of defined resources to only those that
-        // are actually used by the exports. This weeds out resources that are
-        // defined, used within a component, and never exported, for example.
-        //
-        // The free variables of all exports are inserted into the `free` set
-        // (which is reused from the imports after clearing it). The defined
-        // resources calculated for this component are then inserted into this
-        // type's list of defined resources if it's contained somewhere in
-        // the free variables.
-        //
-        // Note that at the same time all defined resources must be exported,
-        // somehow, transitively from this component. The `explicit_resources`
-        // map is consulted for this purpose which lists all explicitly
-        // exported resources in the component, regardless from whence they
-        // came. If not present in this map then it's not exported and an error
-        // is returned.
-        //
-        // NB: the "types are exported" check is probably sufficient nowadays
-        // that the check of the `explicit_resources` map is probably not
-        // necessary, but it's left here for completeness and out of an
-        // abundance of caution.
-        free.clear();
-        for ty in ty.exports.values() {
-            types.free_variables_component_entity(ty, &mut free);
-        }
-        for (id, _rep) in mem::take(&mut self.defined_resources) {
-            if !free.contains(&id) {
-                continue;
-            }
-
-            let path = match ty.explicit_resources.get(&id).cloned() {
-                Some(path) => path,
-                // FIXME: this error message is quite opaque and doesn't
-                // indicate more contextual information such as:
-                //
-                // * which resource wasn't found in an export
-                // * which export has a reference to the resource
-                //
-                // These are possible to calculate here if necessary, however.
-                None => bail!(
-                    offset,
-                    "local resource type found in export but not exported itself"
-                ),
+        for (name, (url, t, kind)) in mem::take(&mut self.externs) {
+            let map = match kind {
+                ExternKind::Import => &mut ty.imports,
+                ExternKind::Export => &mut ty.exports,
             };
-
-            ty.defined_resources.push((id, path));
-        }
-
-        Ok(ty)
-    }
-}
-
-impl KebabNameContext {
-    /// Registers that the resource `id` is named `name` within this context.
-    fn register(&mut self, name: &str, id: TypeId) {
-        let idx = self.all_resource_names.len();
-        let prev = self.resource_name_map.insert(id, idx);
-        assert!(prev.is_none());
-        self.all_resource_names.insert(name.to_string());
-    }
-
-    fn validate_extern(
-        &self,
-        name: ComponentExternName<'_>,
-        desc: &str,
-        ty: &ComponentEntityType,
-        types: &TypeAlloc,
-        offset: usize,
-        kebab_names: &mut IndexSet<KebabName>,
-        items: &mut IndexMap<String, ComponentEntityType>,
-        type_size: &mut u32,
-    ) -> Result<()> {
-        // First validate that `name` is even a valid kebab name, meaning it's
-        // in kebab-case, is an ID, etc.
-        let kebab = KebabName::new(name, offset).with_context(|| {
-            format!("{desc} name `{}` is not a valid extern name", name.as_str())
-        })?;
-
-        // Validate that the kebab name, if it has structure such as
-        // `[method]a.b`, is indeed valid with respect to known resources.
-        self.validate(&kebab, ty, types, offset)
-            .with_context(|| format!("{desc} name `{kebab}` is not valid"))?;
-
-        // Top-level kebab-names must all be unique, even between both imports
-        // and exports ot a component. For those names consult the `kebab_names`
-        // set.
-        if let ComponentExternName::Kebab(_) = name {
-            if let Some(prev) = kebab_names.replace(kebab.clone()) {
-                bail!(
-                    offset,
-                    "{desc} name `{kebab}` conflicts with previous name `{prev}`",
-                );
-            }
-        }
-
-        // Otherwise all strings must be unique, regardless of their name, so
-        // consult the `items` set to ensure that we're not for example
-        // importing the same interface ID twice.
-        match items.entry(kebab.into()) {
-            Entry::Occupied(e) => {
-                bail!(
-                    offset,
-                    "{desc} name `{name}` conflicts with previous name `{prev}`",
-                    name = name.as_str(),
-                    prev = e.key(),
-                );
-            }
-            Entry::Vacant(e) => {
-                e.insert(*ty);
-                *type_size = combine_type_sizes(*type_size, ty.type_size(), offset)?;
-            }
-        }
-        Ok(())
-    }
-
-    /// Validates that the `name` provided is allowed to have the type `ty`.
-    fn validate(
-        &self,
-        name: &KebabName,
-        ty: &ComponentEntityType,
-        types: &TypeAlloc,
-        offset: usize,
-    ) -> Result<()> {
-        let func = || {
-            let id = match ty {
-                ComponentEntityType::Func(id) => *id,
-                _ => bail!(offset, "item is not a func"),
-            };
-            Ok(types[id].unwrap_component_func())
-        };
-        match name.kind() {
-            // Normal kebab name or id? No validation necessary.
-            KebabNameKind::Normal(_) | KebabNameKind::Id { .. } => {}
-
-            // Constructors must return `(own $resource)` and the `$resource`
-            // must be named within this context to match `rname`
-            KebabNameKind::Constructor(rname) => {
-                let ty = func()?;
-                if ty.results.len() != 1 {
-                    bail!(offset, "function should return one value");
-                }
-                let ty = ty.results[0].1;
-                let resource = match ty {
-                    ComponentValType::Primitive(_) => None,
-                    ComponentValType::Type(ty) => match &types[ty] {
-                        Type::Defined(ComponentDefinedType::Own(id)) => Some(id),
-                        _ => None,
-                    },
-                };
-                let resource = match resource {
-                    Some(id) => id,
-                    None => bail!(offset, "function should return `(own $T)`"),
-                };
-                self.validate_resource_name(*resource, rname, offset)?;
-            }
-
-            // Methods must take `(param "self" (borrow $resource))` as the
-            // first argument where `$resources` matches the name `resource` as
-            // named in this context.
-            KebabNameKind::Method { resource, .. } => {
-                let ty = func()?;
-                if ty.params.len() == 0 {
-                    bail!(offset, "function should have at least one argument");
-                }
-                let (pname, pty) = &ty.params[0];
-                if pname.as_str() != "self" {
-                    bail!(
-                        offset,
-                        "function should have a first argument called `self`",
-                    );
-                }
-                let id = match pty {
-                    ComponentValType::Primitive(_) => None,
-                    ComponentValType::Type(ty) => match &types[*ty] {
-                        Type::Defined(ComponentDefinedType::Borrow(id)) => Some(id),
-                        _ => None,
-                    },
-                };
-                let id = match id {
-                    Some(id) => id,
-                    None => bail!(
-                        offset,
-                        "function should take a first argument of `(borrow $T)`"
-                    ),
-                };
-                self.validate_resource_name(*id, resource, offset)?;
-            }
-
-            // Static methods don't have much validation beyond that they must
-            // be a function and the resource name referred to must already be
-            // in this context.
-            KebabNameKind::Static { resource, .. } => {
-                func()?;
-                if !self.all_resource_names.contains(resource.as_str()) {
-                    bail!(offset, "static resource name is not known in this context");
-                }
-            }
-        }
-
-        Ok(())
-    }
-
-    fn validate_resource_name(&self, id: TypeId, name: &KebabStr, offset: usize) -> Result<()> {
-        let expected_name_idx = match self.resource_name_map.get(&id) {
-            Some(idx) => *idx,
-            None => {
-                bail!(
-                    offset,
-                    "resource used in function does not have a name in this context"
-                )
-            }
-        };
-        let expected_name = &self.all_resource_names[expected_name_idx];
-        if name.as_str() != expected_name {
-            bail!(
-                offset,
-                "function does not match expected \
-                         resource name `{expected_name}`"
-            );
-        }
-        Ok(())
-    }
-}
-
-use self::append_only::*;
-
-mod append_only {
-    use indexmap::IndexMap;
-    use std::hash::Hash;
-    use std::ops::Deref;
-
-    pub struct IndexMapAppendOnly<K, V>(IndexMap<K, V>);
-
-    impl<K, V> IndexMapAppendOnly<K, V>
-    where
-        K: Hash + Eq + PartialEq,
-    {
-        pub fn insert(&mut self, key: K, value: V) {
-            let prev = self.0.insert(key, value);
+            let prev = map.insert(name, (url, t));
             assert!(prev.is_none());
         }
-    }
 
-    impl<K, V> Deref for IndexMapAppendOnly<K, V> {
-        type Target = IndexMap<K, V>;
-        fn deref(&self) -> &IndexMap<K, V> {
-            &self.0
-        }
-    }
-
-    impl<K, V> Default for IndexMapAppendOnly<K, V> {
-        fn default() -> Self {
-            Self(Default::default())
-        }
+        ty
     }
+}
 
-    impl<K, V> IntoIterator for IndexMapAppendOnly<K, V> {
-        type IntoIter = <IndexMap<K, V> as IntoIterator>::IntoIter;
-        type Item = <IndexMap<K, V> as IntoIterator>::Item;
-        fn into_iter(self) -> Self::IntoIter {
-            self.0.into_iter()
+impl Default for ComponentState {
+    fn default() -> Self {
+        Self {
+            core_types: Default::default(),
+            core_modules: Default::default(),
+            core_instances: Default::default(),
+            core_funcs: Default::default(),
+            core_memories: Default::default(),
+            core_tables: Default::default(),
+            core_globals: Default::default(),
+            core_tags: Default::default(),
+            types: Default::default(),
+            funcs: Default::default(),
+            values: Default::default(),
+            instances: Default::default(),
+            components: Default::default(),
+            externs: Default::default(),
+            export_urls: Default::default(),
+            import_urls: Default::default(),
+            has_start: Default::default(),
+            type_size: 1,
         }
     }
 }
diff --git a/crates/wasmparser/src/validator/core.rs b/crates/wasmparser/src/validator/core.rs
index cf66807f..781834dc 100644
--- a/crates/wasmparser/src/validator/core.rs
+++ b/crates/wasmparser/src/validator/core.rs
@@ -6,13 +6,11 @@ use super::{
     types::{EntityType, Type, TypeAlloc, TypeId, TypeList},
 };
 use crate::limits::*;
-use crate::readers::Inherits;
 use crate::validator::core::arc::MaybeOwned;
 use crate::{
     BinaryReaderError, ConstExpr, Data, DataKind, Element, ElementKind, ExternalKind, FuncType,
-    Global, GlobalType, HeapType, MemoryType, RefType, Result, StorageType, StructuralType,
-    SubType, Table, TableInit, TableType, TagType, TypeRef, ValType, VisitOperator, WasmFeatures,
-    WasmModuleResources,
+    Global, GlobalType, HeapType, MemoryType, RefType, Result, Table, TableInit, TableType,
+    TagType, TypeRef, ValType, VisitOperator, WasmFeatures, WasmFuncType, WasmModuleResources,
 };
 use indexmap::IndexMap;
 use std::mem;
@@ -135,7 +133,7 @@ impl ModuleState {
         offset: usize,
     ) -> Result<()> {
         self.module
-            .check_global_type(&global.ty, features, offset)?;
+            .check_global_type(&global.ty, features, types, offset)?;
         self.check_const_expr(&global.init_expr, global.ty.content_type, features, types)?;
         self.module.assert_mut().globals.push(global.ty);
         Ok(())
@@ -148,11 +146,12 @@ impl ModuleState {
         types: &TypeList,
         offset: usize,
     ) -> Result<()> {
-        self.module.check_table_type(&table.ty, features, offset)?;
+        self.module
+            .check_table_type(&table.ty, features, types, offset)?;
 
         match &table.init {
             TableInit::RefNull => {
-                if !table.ty.element_type.is_nullable() {
+                if !table.ty.element_type.nullable {
                     bail!(offset, "type mismatch: non-defaultable element type");
                 }
             }
@@ -201,14 +200,14 @@ impl ModuleState {
         // don't check it here
         if e.ty != RefType::FUNCREF {
             self.module
-                .check_value_type(ValType::Ref(e.ty), features, offset)?;
+                .check_value_type(ValType::Ref(e.ty), features, types, offset)?;
         }
         match e.kind {
             ElementKind::Active {
                 table_index,
                 offset_expr,
             } => {
-                let table = self.module.table_at(table_index.unwrap_or(0), offset)?;
+                let table = self.module.table_at(table_index, offset)?;
                 if !self
                     .module
                     .matches(ValType::Ref(e.ty), ValType::Ref(table.element_type), types)
@@ -248,7 +247,7 @@ impl ModuleState {
         match e.items {
             crate::ElementItems::Functions(reader) => {
                 let count = reader.count();
-                if !e.ty.is_nullable() && count == 0 {
+                if !e.ty.nullable && count <= 0 {
                     return Err(BinaryReaderError::new(
                         "a non-nullable element must come with an initialization expression",
                         offset,
@@ -483,6 +482,7 @@ pub(crate) struct Module {
     pub data_count: Option<u32>,
     // Stores indexes into `types`.
     pub functions: Vec<u32>,
+    // Stores indexes into `types`.
     pub tags: Vec<TypeId>,
     pub function_references: HashSet<u32>,
     pub imports: IndexMap<(String, String), Vec<EntityType>>,
@@ -495,81 +495,16 @@ pub(crate) struct Module {
 impl Module {
     pub fn add_type(
         &mut self,
-        ty: SubType,
+        ty: crate::Type,
         features: &WasmFeatures,
         types: &mut TypeAlloc,
         offset: usize,
         check_limit: bool,
     ) -> Result<()> {
-        if check_limit {
-            check_max(self.types.len(), 1, MAX_WASM_TYPES, "types", offset)?;
-        }
-        let ty = self.check_subtype(ty, features, types, offset)?;
-
-        let id = types.push_ty(ty);
-        self.types.push(id);
-        Ok(())
-    }
-
-    fn check_subtype(
-        &mut self,
-        ty: SubType,
-        features: &WasmFeatures,
-        types: &mut TypeAlloc,
-        offset: usize,
-    ) -> Result<Type> {
-        if !features.gc && (ty.is_final || ty.supertype_idx.is_some()) {
-            return Err(BinaryReaderError::new(
-                "gc proposal must be enabled to use subtypes",
-                offset,
-            ));
-        }
-
-        self.check_structural_type(&ty.structural_type, features, offset)?;
-
-        if let Some(type_index) = ty.supertype_idx {
-            // Check the supertype exists, is not final, and the subtype matches it.
-            match self.type_at(types, type_index, offset)? {
-                Type::Sub(st) => {
-                    if !&ty.inherits(st, &|idx| self.subtype_at(types, idx, offset).unwrap()) {
-                        return Err(BinaryReaderError::new(
-                            "subtype must match supertype",
-                            offset,
-                        ));
-                    }
-                }
-                _ => {
-                    return Err(BinaryReaderError::new(
-                        "supertype must be a non-final subtype itself",
-                        offset,
-                    ));
-                }
-            };
-        }
-
-        Ok(Type::Sub(ty))
-    }
-
-    fn subtype_at<'a>(&self, types: &'a TypeList, idx: u32, offset: usize) -> Result<&'a SubType> {
-        match self.type_at(types, idx, offset)? {
-            Type::Sub(ty) => Ok(ty),
-            _ => bail!(
-                offset,
-                "subtype with index {idx} not found, offset: {offset}"
-            ),
-        }
-    }
-
-    fn check_structural_type(
-        &mut self,
-        ty: &StructuralType,
-        features: &WasmFeatures,
-        offset: usize,
-    ) -> Result<()> {
-        match ty {
-            StructuralType::Func(t) => {
+        let ty = match ty {
+            crate::Type::Func(t) => {
                 for ty in t.params().iter().chain(t.results()) {
-                    self.check_value_type(*ty, features, offset)?;
+                    self.check_value_type(*ty, features, types, offset)?;
                 }
                 if t.results().len() > 1 && !features.multi_value {
                     return Err(BinaryReaderError::new(
@@ -577,33 +512,24 @@ impl Module {
                         offset,
                     ));
                 }
+                Type::Func(t)
             }
-            StructuralType::Array(t) => {
-                if !features.gc {
-                    return Err(BinaryReaderError::new(
-                        "array indexed types not supported without the gc feature",
-                        offset,
-                    ));
-                }
-                match t.0.element_type {
-                    StorageType::I8 | StorageType::I16 => {}
-                    StorageType::Val(value_type) => {
-                        self.check_value_type(value_type, features, offset)?;
-                    }
-                };
-            }
-            StructuralType::Struct(t) => {
-                if !features.gc {
-                    return Err(BinaryReaderError::new(
-                        "struct indexed types not supported without the gc feature",
-                        offset,
-                    ));
-                }
-                for ty in t.fields.iter() {
-                    self.check_storage_type(ty.element_type, features, offset)?;
+            crate::Type::Cont(type_index) => {
+                if (type_index as usize) >= types.len() {
+                    return Err(BinaryReaderError::new("invalid type index", offset));
+                    // TODO(dhil): tidy up error message.
+                    // technically need to check that it points to a function type, and not just another continuation ref.
                 }
+                Type::Cont(type_index)
             }
+        };
+
+        if check_limit {
+            check_max(self.types.len(), 1, MAX_WASM_TYPES, "types", offset)?;
         }
+
+        let id = types.push_defined(ty);
+        self.types.push(id);
         Ok(())
     }
 
@@ -722,30 +648,22 @@ impl Module {
         Ok(())
     }
 
-    pub fn type_id_at(&self, idx: u32, offset: usize) -> Result<TypeId> {
+    pub fn type_at(&self, idx: u32, offset: usize) -> Result<TypeId> {
         self.types
             .get(idx as usize)
             .copied()
             .ok_or_else(|| format_err!(offset, "unknown type {idx}: type index out of bounds"))
     }
 
-    fn type_at<'a>(&self, types: &'a TypeList, idx: u32, offset: usize) -> Result<&'a Type> {
-        self.type_id_at(idx, offset).map(|type_id| &types[type_id])
-    }
-
     fn func_type_at<'a>(
         &self,
         type_index: u32,
         types: &'a TypeList,
         offset: usize,
     ) -> Result<&'a FuncType> {
-        match &types[self.type_id_at(type_index, offset)?] {
-            Type::Sub(SubType {
-                structural_type: StructuralType::Func(f),
-                ..
-            }) => Ok(f),
-            _ => bail!(offset, "type index {type_index} is not a function type"),
-        }
+        types[self.type_at(type_index, offset)?]
+            .as_func_type()
+            .ok_or_else(|| format_err!(offset, "type index {type_index} is not a function type"))
     }
 
     pub fn check_type_ref(
@@ -761,7 +679,7 @@ impl Module {
                 EntityType::Func(self.types[*type_index as usize])
             }
             TypeRef::Table(t) => {
-                self.check_table_type(t, features, offset)?;
+                self.check_table_type(t, features, types, offset)?;
                 EntityType::Table(*t)
             }
             TypeRef::Memory(t) => {
@@ -773,7 +691,7 @@ impl Module {
                 EntityType::Tag(self.types[t.func_type_idx as usize])
             }
             TypeRef::Global(t) => {
-                self.check_global_type(t, features, offset)?;
+                self.check_global_type(t, features, types, offset)?;
                 EntityType::Global(*t)
             }
         })
@@ -783,12 +701,13 @@ impl Module {
         &self,
         ty: &TableType,
         features: &WasmFeatures,
+        types: &TypeList,
         offset: usize,
     ) -> Result<()> {
         // the `funcref` value type is allowed all the way back to the MVP, so
         // don't check it here
         if ty.element_type != RefType::FUNCREF {
-            self.check_value_type(ValType::Ref(ty.element_type), features, offset)?
+            self.check_value_type(ValType::Ref(ty.element_type), features, types, offset)?
         }
 
         self.check_limits(ty.initial, ty.maximum, offset)?;
@@ -870,22 +789,13 @@ impl Module {
             .collect::<Result<_>>()
     }
 
-    fn check_storage_type(
+    fn check_value_type(
         &self,
-        ty: StorageType,
+        ty: ValType,
         features: &WasmFeatures,
+        types: &TypeList,
         offset: usize,
     ) -> Result<()> {
-        match ty {
-            StorageType::I8 | StorageType::I16 => {}
-            StorageType::Val(value_type) => {
-                self.check_value_type(value_type, features, offset)?;
-            }
-        }
-        Ok(())
-    }
-
-    fn check_value_type(&self, ty: ValType, features: &WasmFeatures, offset: usize) -> Result<()> {
         match features.check_value_type(ty) {
             Ok(()) => Ok(()),
             Err(e) => Err(BinaryReaderError::new(e, offset)),
@@ -894,39 +804,90 @@ impl Module {
         // We must check it if it's a reference.
         match ty {
             ValType::Ref(rt) => {
-                self.check_ref_type(rt, offset)?;
+                self.check_ref_type(rt, types, offset)?;
             }
             _ => (),
         }
         Ok(())
     }
 
-    fn check_ref_type(&self, ty: RefType, offset: usize) -> Result<()> {
+    fn check_ref_type(&self, ty: RefType, _types: &TypeList, offset: usize) -> Result<()> {
         // Check that the heap type is valid
-        match ty.heap_type() {
-            HeapType::Func
-            | HeapType::Extern
-            | HeapType::Any
-            | HeapType::None
-            | HeapType::NoExtern
-            | HeapType::NoFunc
-            | HeapType::Eq
-            | HeapType::Struct
-            | HeapType::Array
-            | HeapType::I31 => (),
-            HeapType::Indexed(type_index) => {
+        match ty.heap_type {
+            HeapType::Func | HeapType::Extern => (),
+            HeapType::TypedFunc(type_index) => {
                 // Just check that the index is valid
-                self.type_id_at(type_index, offset)?;
+                self.type_at(type_index.into(), offset)?; ()
             }
         }
         Ok(())
     }
 
-    /// Check that a value of type ty1 is assignable to a variable / table element of type ty2.
-    /// E.g. a non-nullable reference can be assigned to a nullable reference, but not vice versa.
-    /// Or an indexed func ref is assignable to a generic func ref, but not vice versa.
+    fn eq_defs(&self, t1: u32, t2: u32, types: &TypeList, offset: usize) -> bool {
+        if let Ok(x) = self.type_at(t1, offset) {
+            if let Ok(y) = self.type_at(t2, offset) {
+                return match (&types[x], &types[y]) {
+                    (Type::Func(f1), Type::Func(f2)) => self.eq_fns(&f1, &f2, types),
+                    (Type::Cont(c1), Type::Cont(c2)) => c1 == c2,
+                    (_, _) => false,
+                }
+            }
+        }
+        return false;
+    }
+
+    fn eq_valtypes(&self, ty1: ValType, ty2: ValType, types: &TypeList) -> bool {
+        match (ty1, ty2) {
+            (ValType::Ref(rt1), ValType::Ref(rt2)) => {
+                rt1.nullable == rt2.nullable
+                    && match (rt1.heap_type, rt2.heap_type) {
+                        (HeapType::Func, HeapType::Func) => true,
+                        (HeapType::Extern, HeapType::Extern) => true,
+                        (HeapType::TypedFunc(n1), HeapType::TypedFunc(n2)) => self.eq_defs(n1.into(), n2.into(), types, 0),
+                        (_, _) => false,
+                    }
+            }
+            _ => ty1 == ty2,
+        }
+    }
+    fn eq_fns(&self, f1: &impl WasmFuncType, f2: &impl WasmFuncType, types: &TypeList) -> bool {
+        f1.len_inputs() == f2.len_inputs()
+            && f2.len_outputs() == f2.len_outputs()
+            && f1
+                .inputs()
+                .zip(f2.inputs())
+                .all(|(t1, t2)| self.eq_valtypes(t1, t2, types))
+            && f1
+                .outputs()
+                .zip(f2.outputs())
+                .all(|(t1, t2)| self.eq_valtypes(t1, t2, types))
+    }
+
     pub(crate) fn matches(&self, ty1: ValType, ty2: ValType, types: &TypeList) -> bool {
-        ty1.inherits(&ty2, &|idx| self.subtype_at(types, idx, 0).unwrap())
+        fn matches_null(null1: bool, null2: bool) -> bool {
+            (null1 == null2) || null2
+        }
+
+        let matches_heap = |ty1: HeapType, ty2: HeapType, types: &TypeList| -> bool {
+            match (ty1, ty2) {
+                (HeapType::TypedFunc(n1), HeapType::TypedFunc(n2)) => {
+                    // Check whether the defined types are (structurally) equivalent.
+                    self.eq_defs(n1.into(), n2.into(), types, 0)
+                }
+                (HeapType::TypedFunc(_), HeapType::Func) => true,
+                (_, _) => ty1 == ty2,
+            }
+        };
+
+        let matches_ref = |ty1: RefType, ty2: RefType, types: &TypeList| -> bool {
+            matches_heap(ty1.heap_type, ty2.heap_type, types)
+                && matches_null(ty1.nullable, ty2.nullable)
+        };
+
+        match (ty1, ty2) {
+            (ValType::Ref(rt1), ValType::Ref(rt2)) => matches_ref(rt1, rt2, types),
+            (_, _) => ty1 == ty2,
+        }
     }
 
     fn check_tag_type(
@@ -943,7 +904,7 @@ impl Module {
             ));
         }
         let ty = self.func_type_at(ty.func_type_idx, types, offset)?;
-        if !ty.results().is_empty() {
+        if !ty.results().is_empty() && !features.typed_continuations {
             return Err(BinaryReaderError::new(
                 "invalid exception type: non-empty tag result type",
                 offset,
@@ -956,9 +917,10 @@ impl Module {
         &self,
         ty: &GlobalType,
         features: &WasmFeatures,
+        types: &TypeList,
         offset: usize,
     ) -> Result<()> {
-        self.check_value_type(ty.content_type, features, offset)
+        self.check_value_type(ty.content_type, features, types, offset)
     }
 
     fn check_limits<T>(&self, initial: T, maximum: Option<T>, offset: usize) -> Result<()>
@@ -1118,7 +1080,11 @@ impl WasmModuleResources for OperatorValidatorResources<'_> {
     }
 
     fn tag_at(&self, at: u32) -> Option<&Self::FuncType> {
-        Some(self.types[*self.module.tags.get(at as usize)?].unwrap_func())
+        Some(
+            self.types[*self.module.tags.get(at as usize)?]
+                .as_func_type()
+                .unwrap(),
+        )
     }
 
     fn global_at(&self, at: u32) -> Option<GlobalType> {
@@ -1126,7 +1092,11 @@ impl WasmModuleResources for OperatorValidatorResources<'_> {
     }
 
     fn func_type_at(&self, at: u32) -> Option<&Self::FuncType> {
-        Some(self.types[*self.module.types.get(at as usize)?].unwrap_func())
+        Some(
+            self.types[*self.module.types.get(at as usize)?]
+                .as_func_type()
+                .unwrap(),
+        )
     }
 
     fn type_index_of_function(&self, at: u32) -> Option<u32> {
@@ -1138,7 +1108,8 @@ impl WasmModuleResources for OperatorValidatorResources<'_> {
     }
 
     fn check_value_type(&self, t: ValType, features: &WasmFeatures, offset: usize) -> Result<()> {
-        self.module.check_value_type(t, features, offset)
+        self.module
+            .check_value_type(t, features, self.types, offset)
     }
 
     fn element_type_at(&self, at: u32) -> Option<RefType> {
@@ -1160,6 +1131,14 @@ impl WasmModuleResources for OperatorValidatorResources<'_> {
     fn is_function_referenced(&self, idx: u32) -> bool {
         self.module.function_references.contains(&idx)
     }
+
+    fn cont_type_at(&self, at: u32) -> Option<u32> {
+        Some(
+            self.types[*self.module.types.get(at as usize)?]
+                .as_cont_func_index()
+                .unwrap(),
+        )
+    }
 }
 
 /// The implementation of [`WasmModuleResources`] used by
@@ -1178,7 +1157,11 @@ impl WasmModuleResources for ValidatorResources {
     }
 
     fn tag_at(&self, at: u32) -> Option<&Self::FuncType> {
-        Some(self.0.snapshot.as_ref().unwrap()[*self.0.tags.get(at as usize)?].unwrap_func())
+        Some(
+            self.0.snapshot.as_ref().unwrap()[*self.0.tags.get(at as usize)?]
+                .as_func_type()
+                .unwrap(),
+        )
     }
 
     fn global_at(&self, at: u32) -> Option<GlobalType> {
@@ -1186,7 +1169,11 @@ impl WasmModuleResources for ValidatorResources {
     }
 
     fn func_type_at(&self, at: u32) -> Option<&Self::FuncType> {
-        Some(self.0.snapshot.as_ref().unwrap()[*self.0.types.get(at as usize)?].unwrap_func())
+        Some(
+            self.0.snapshot.as_ref().unwrap()[*self.0.types.get(at as usize)?]
+                .as_func_type()
+                .unwrap(),
+        )
     }
 
     fn type_index_of_function(&self, at: u32) -> Option<u32> {
@@ -1198,7 +1185,8 @@ impl WasmModuleResources for ValidatorResources {
     }
 
     fn check_value_type(&self, t: ValType, features: &WasmFeatures, offset: usize) -> Result<()> {
-        self.0.check_value_type(t, features, offset)
+        self.0
+            .check_value_type(t, features, self.0.snapshot.as_ref().unwrap(), offset)
     }
 
     fn element_type_at(&self, at: u32) -> Option<RefType> {
@@ -1220,6 +1208,15 @@ impl WasmModuleResources for ValidatorResources {
     fn is_function_referenced(&self, idx: u32) -> bool {
         self.0.function_references.contains(&idx)
     }
+
+    // Gives the index of the function
+    fn cont_type_at(&self, at: u32) -> Option<u32> {
+        Some(
+            self.0.snapshot.as_ref().unwrap()[*self.0.types.get(at as usize)?]
+                .as_cont_func_index()
+                .unwrap(),
+        )
+    }
 }
 
 const _: () = {
diff --git a/crates/wasmparser/src/validator/func.rs b/crates/wasmparser/src/validator/func.rs
index 4d405f96..c36aa59a 100644
--- a/crates/wasmparser/src/validator/func.rs
+++ b/crates/wasmparser/src/validator/func.rs
@@ -299,6 +299,9 @@ mod tests {
         fn is_function_referenced(&self, _idx: u32) -> bool {
             todo!()
         }
+        fn cont_type_at(&self, _at: u32) -> Option<u32> {
+            todo!()
+        }
     }
 
     struct EmptyFuncType;
diff --git a/crates/wasmparser/src/validator/names.rs b/crates/wasmparser/src/validator/names.rs
deleted file mode 100644
index 0c3263b3..00000000
--- a/crates/wasmparser/src/validator/names.rs
+++ /dev/null
@@ -1,606 +0,0 @@
-//! Definitions of name-related helpers and newtypes, primarily for the
-//! component model.
-
-use crate::{ComponentExternName, Result};
-use semver::Version;
-use std::borrow::Borrow;
-use std::fmt;
-use std::hash::{Hash, Hasher};
-use std::ops::Deref;
-
-/// Represents a kebab string slice used in validation.
-///
-/// This is a wrapper around `str` that ensures the slice is
-/// a valid kebab case string according to the component model
-/// specification.
-///
-/// It also provides an equality and hashing implementation
-/// that ignores ASCII case.
-#[derive(Debug, Eq)]
-#[repr(transparent)]
-pub struct KebabStr(str);
-
-impl KebabStr {
-    /// Creates a new kebab string slice.
-    ///
-    /// Returns `None` if the given string is not a valid kebab string.
-    pub fn new<'a>(s: impl AsRef<str> + 'a) -> Option<&'a Self> {
-        let s = Self::new_unchecked(s);
-        if s.is_kebab_case() {
-            Some(s)
-        } else {
-            None
-        }
-    }
-
-    pub(crate) fn new_unchecked<'a>(s: impl AsRef<str> + 'a) -> &'a Self {
-        // Safety: `KebabStr` is a transparent wrapper around `str`
-        // Therefore transmuting `&str` to `&KebabStr` is safe.
-        unsafe { std::mem::transmute::<_, &Self>(s.as_ref()) }
-    }
-
-    /// Gets the underlying string slice.
-    pub fn as_str(&self) -> &str {
-        &self.0
-    }
-
-    /// Converts the slice to an owned string.
-    pub fn to_kebab_string(&self) -> KebabString {
-        KebabString(self.to_string())
-    }
-
-    fn is_kebab_case(&self) -> bool {
-        let mut lower = false;
-        let mut upper = false;
-        for c in self.chars() {
-            match c {
-                'a'..='z' if !lower && !upper => lower = true,
-                'A'..='Z' if !lower && !upper => upper = true,
-                'a'..='z' if lower => {}
-                'A'..='Z' if upper => {}
-                '0'..='9' if lower || upper => {}
-                '-' if lower || upper => {
-                    lower = false;
-                    upper = false;
-                }
-                _ => return false,
-            }
-        }
-
-        !self.is_empty() && !self.ends_with('-')
-    }
-}
-
-impl Deref for KebabStr {
-    type Target = str;
-
-    fn deref(&self) -> &str {
-        self.as_str()
-    }
-}
-
-impl PartialEq for KebabStr {
-    fn eq(&self, other: &Self) -> bool {
-        if self.len() != other.len() {
-            return false;
-        }
-
-        self.chars()
-            .zip(other.chars())
-            .all(|(a, b)| a.to_ascii_lowercase() == b.to_ascii_lowercase())
-    }
-}
-
-impl PartialEq<KebabString> for KebabStr {
-    fn eq(&self, other: &KebabString) -> bool {
-        self.eq(other.as_kebab_str())
-    }
-}
-
-impl Hash for KebabStr {
-    fn hash<H: Hasher>(&self, state: &mut H) {
-        self.len().hash(state);
-
-        for b in self.chars() {
-            b.to_ascii_lowercase().hash(state);
-        }
-    }
-}
-
-impl fmt::Display for KebabStr {
-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
-        (self as &str).fmt(f)
-    }
-}
-
-impl ToOwned for KebabStr {
-    type Owned = KebabString;
-
-    fn to_owned(&self) -> Self::Owned {
-        self.to_kebab_string()
-    }
-}
-
-/// Represents an owned kebab string for validation.
-///
-/// This is a wrapper around `String` that ensures the string is
-/// a valid kebab case string according to the component model
-/// specification.
-///
-/// It also provides an equality and hashing implementation
-/// that ignores ASCII case.
-#[derive(Debug, Clone, Eq)]
-pub struct KebabString(String);
-
-impl KebabString {
-    /// Creates a new kebab string.
-    ///
-    /// Returns `None` if the given string is not a valid kebab string.
-    pub fn new(s: impl Into<String>) -> Option<Self> {
-        let s = s.into();
-        if KebabStr::new(&s).is_some() {
-            Some(Self(s))
-        } else {
-            None
-        }
-    }
-
-    /// Gets the underlying string.
-    pub fn as_str(&self) -> &str {
-        self.0.as_str()
-    }
-
-    /// Converts the kebab string to a kebab string slice.
-    pub fn as_kebab_str(&self) -> &KebabStr {
-        // Safety: internal string is always valid kebab-case
-        KebabStr::new_unchecked(self.as_str())
-    }
-}
-
-impl Deref for KebabString {
-    type Target = KebabStr;
-
-    fn deref(&self) -> &Self::Target {
-        self.as_kebab_str()
-    }
-}
-
-impl Borrow<KebabStr> for KebabString {
-    fn borrow(&self) -> &KebabStr {
-        self.as_kebab_str()
-    }
-}
-
-impl PartialEq for KebabString {
-    fn eq(&self, other: &Self) -> bool {
-        self.as_kebab_str().eq(other.as_kebab_str())
-    }
-}
-
-impl PartialEq<KebabStr> for KebabString {
-    fn eq(&self, other: &KebabStr) -> bool {
-        self.as_kebab_str().eq(other)
-    }
-}
-
-impl Hash for KebabString {
-    fn hash<H: Hasher>(&self, state: &mut H) {
-        self.as_kebab_str().hash(state)
-    }
-}
-
-impl fmt::Display for KebabString {
-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
-        self.as_kebab_str().fmt(f)
-    }
-}
-
-impl From<KebabString> for String {
-    fn from(s: KebabString) -> String {
-        s.0
-    }
-}
-
-/// A "kebab name" in the component model which is backed by `T`, which defaults
-/// to `String`.
-///
-/// This name can be either:
-///
-/// * a `KebabStr`: `a-b-c`
-/// * a method name : `[method]a-b.c-d`
-/// * a static method name : `[static]a-b.c-d`
-/// * a constructor: `[constructor]a-b`
-///
-/// # Equality and hashing
-///
-/// Note that this type the `Method` and `Static` variants are considered equal
-/// and hash to the same value. This enables disallowing clashes between the two
-/// where method name overlap cannot happen.
-#[derive(Clone)]
-pub struct KebabName {
-    raw: String,
-    parsed: ParsedKebabName,
-}
-
-#[derive(Copy, Clone)]
-enum ParsedKebabName {
-    Normal,
-    Constructor,
-    Method {
-        dot: u32,
-    },
-    Static {
-        dot: u32,
-    },
-    Id {
-        colon: u32,
-        slash: u32,
-        at: Option<u32>,
-    },
-}
-
-/// Created via [`KebabName::kind`] and classifies a name.
-#[derive(Debug, Clone)]
-pub enum KebabNameKind<'a> {
-    /// `a-b-c`
-    Normal(&'a KebabStr),
-    /// `[constructor]a-b`
-    Constructor(&'a KebabStr),
-    /// `[method]a-b.c-d`
-    #[allow(missing_docs)]
-    Method {
-        resource: &'a KebabStr,
-        name: &'a KebabStr,
-    },
-    /// `[static]a-b.c-d`
-    #[allow(missing_docs)]
-    Static {
-        resource: &'a KebabStr,
-        name: &'a KebabStr,
-    },
-    /// `wasi:http/types@2.0`
-    #[allow(missing_docs)]
-    Id {
-        namespace: &'a KebabStr,
-        package: &'a KebabStr,
-        interface: &'a KebabStr,
-        version: Option<Version>,
-    },
-}
-
-const CONSTRUCTOR: &str = "[constructor]";
-const METHOD: &str = "[method]";
-const STATIC: &str = "[static]";
-
-impl KebabName {
-    /// Attempts to parse `name` as a kebab name, returning `None` if it's not
-    /// valid.
-    pub fn new(name: ComponentExternName<'_>, offset: usize) -> Result<KebabName> {
-        let validate_kebab = |s: &str| {
-            if KebabStr::new(s).is_none() {
-                bail!(offset, "`{s}` is not in kebab case")
-            } else {
-                Ok(())
-            }
-        };
-        let find = |s: &str, c: char| match s.find(c) {
-            Some(i) => Ok(i),
-            None => bail!(offset, "failed to find `{c}` character"),
-        };
-        let parsed = match name {
-            ComponentExternName::Kebab(s) => {
-                if let Some(s) = s.strip_prefix(CONSTRUCTOR) {
-                    validate_kebab(s)?;
-                    ParsedKebabName::Constructor
-                } else if let Some(s) = s.strip_prefix(METHOD) {
-                    let dot = find(s, '.')?;
-                    validate_kebab(&s[..dot])?;
-                    validate_kebab(&s[dot + 1..])?;
-                    ParsedKebabName::Method { dot: dot as u32 }
-                } else if let Some(s) = s.strip_prefix(STATIC) {
-                    let dot = find(s, '.')?;
-                    validate_kebab(&s[..dot])?;
-                    validate_kebab(&s[dot + 1..])?;
-                    ParsedKebabName::Static { dot: dot as u32 }
-                } else {
-                    validate_kebab(s)?;
-                    ParsedKebabName::Normal
-                }
-            }
-            ComponentExternName::Interface(s) => {
-                let colon = find(s, ':')?;
-                validate_kebab(&s[..colon])?;
-                let slash = find(s, '/')?;
-                let at = s[slash..].find('@').map(|i| i + slash);
-                validate_kebab(&s[colon + 1..slash])?;
-                validate_kebab(&s[slash + 1..at.unwrap_or(s.len())])?;
-                if let Some(at) = at {
-                    let version = &s[at + 1..];
-                    if let Err(e) = version.parse::<Version>() {
-                        bail!(offset, "failed to parse version: {e}")
-                    }
-                }
-                ParsedKebabName::Id {
-                    colon: colon as u32,
-                    slash: slash as u32,
-                    at: at.map(|i| i as u32),
-                }
-            }
-        };
-        Ok(KebabName {
-            raw: name.as_str().to_string(),
-            parsed,
-        })
-    }
-
-    /// Returns the [`KebabNameKind`] corresponding to this name.
-    pub fn kind(&self) -> KebabNameKind<'_> {
-        match self.parsed {
-            ParsedKebabName::Normal => KebabNameKind::Normal(KebabStr::new_unchecked(&self.raw)),
-            ParsedKebabName::Constructor => {
-                let kebab = &self.raw[CONSTRUCTOR.len()..];
-                KebabNameKind::Constructor(KebabStr::new_unchecked(kebab))
-            }
-            ParsedKebabName::Method { dot } => {
-                let dotted = &self.raw[METHOD.len()..];
-                let resource = KebabStr::new_unchecked(&dotted[..dot as usize]);
-                let name = KebabStr::new_unchecked(&dotted[dot as usize + 1..]);
-                KebabNameKind::Method { resource, name }
-            }
-            ParsedKebabName::Static { dot } => {
-                let dotted = &self.raw[METHOD.len()..];
-                let resource = KebabStr::new_unchecked(&dotted[..dot as usize]);
-                let name = KebabStr::new_unchecked(&dotted[dot as usize + 1..]);
-                KebabNameKind::Static { resource, name }
-            }
-            ParsedKebabName::Id { colon, slash, at } => {
-                let colon = colon as usize;
-                let slash = slash as usize;
-                let at = at.map(|i| i as usize);
-                let namespace = KebabStr::new_unchecked(&self.raw[..colon]);
-                let package = KebabStr::new_unchecked(&self.raw[colon + 1..slash]);
-                let interface =
-                    KebabStr::new_unchecked(&self.raw[slash + 1..at.unwrap_or(self.raw.len())]);
-                let version = at.map(|i| Version::parse(&self.raw[i + 1..]).unwrap());
-                KebabNameKind::Id {
-                    namespace,
-                    package,
-                    interface,
-                    version,
-                }
-            }
-        }
-    }
-
-    /// Returns the raw underlying name as a string.
-    pub fn as_str(&self) -> &str {
-        &self.raw
-    }
-}
-
-impl From<KebabName> for String {
-    fn from(name: KebabName) -> String {
-        name.raw
-    }
-}
-
-impl Hash for KebabName {
-    fn hash<H: Hasher>(&self, hasher: &mut H) {
-        self.kind().hash(hasher)
-    }
-}
-
-impl PartialEq for KebabName {
-    fn eq(&self, other: &KebabName) -> bool {
-        self.kind().eq(&other.kind())
-    }
-}
-
-impl Eq for KebabName {}
-
-impl fmt::Display for KebabName {
-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
-        self.raw.fmt(f)
-    }
-}
-
-impl fmt::Debug for KebabName {
-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
-        self.raw.fmt(f)
-    }
-}
-
-impl Hash for KebabNameKind<'_> {
-    fn hash<H: Hasher>(&self, hasher: &mut H) {
-        match self {
-            KebabNameKind::Normal(name) => {
-                hasher.write_u8(0);
-                name.hash(hasher);
-            }
-            KebabNameKind::Constructor(name) => {
-                hasher.write_u8(1);
-                name.hash(hasher);
-            }
-            // for hashing method == static
-            KebabNameKind::Method { resource, name } | KebabNameKind::Static { resource, name } => {
-                hasher.write_u8(2);
-                resource.hash(hasher);
-                name.hash(hasher);
-            }
-            KebabNameKind::Id {
-                namespace,
-                package,
-                interface,
-                version,
-            } => {
-                hasher.write_u8(3);
-                namespace.hash(hasher);
-                package.hash(hasher);
-                interface.hash(hasher);
-                version.hash(hasher);
-            }
-        }
-    }
-}
-
-impl PartialEq for KebabNameKind<'_> {
-    fn eq(&self, other: &KebabNameKind<'_>) -> bool {
-        match (self, other) {
-            (KebabNameKind::Normal(a), KebabNameKind::Normal(b)) => a == b,
-            (KebabNameKind::Normal(_), _) => false,
-            (KebabNameKind::Constructor(a), KebabNameKind::Constructor(b)) => a == b,
-            (KebabNameKind::Constructor(_), _) => false,
-
-            // method == static for the purposes of hashing so equate them here
-            // as well.
-            (
-                KebabNameKind::Method {
-                    resource: ar,
-                    name: an,
-                },
-                KebabNameKind::Method {
-                    resource: br,
-                    name: bn,
-                },
-            )
-            | (
-                KebabNameKind::Static {
-                    resource: ar,
-                    name: an,
-                },
-                KebabNameKind::Static {
-                    resource: br,
-                    name: bn,
-                },
-            )
-            | (
-                KebabNameKind::Method {
-                    resource: ar,
-                    name: an,
-                },
-                KebabNameKind::Static {
-                    resource: br,
-                    name: bn,
-                },
-            )
-            | (
-                KebabNameKind::Static {
-                    resource: ar,
-                    name: an,
-                },
-                KebabNameKind::Method {
-                    resource: br,
-                    name: bn,
-                },
-            ) => ar == br && an == bn,
-
-            (KebabNameKind::Method { .. }, _) => false,
-            (KebabNameKind::Static { .. }, _) => false,
-
-            (
-                KebabNameKind::Id {
-                    namespace: an,
-                    package: ap,
-                    interface: ai,
-                    version: av,
-                },
-                KebabNameKind::Id {
-                    namespace: bn,
-                    package: bp,
-                    interface: bi,
-                    version: bv,
-                },
-            ) => an == bn && ap == bp && ai == bi && av == bv,
-            (KebabNameKind::Id { .. }, _) => false,
-        }
-    }
-}
-
-impl Eq for KebabNameKind<'_> {}
-
-#[cfg(test)]
-mod tests {
-    use super::*;
-    use std::collections::HashSet;
-
-    fn parse_kebab_name(s: &str) -> Option<KebabName> {
-        KebabName::new(ComponentExternName::Kebab(s), 0).ok()
-    }
-
-    #[test]
-    fn kebab_smoke() {
-        assert!(KebabStr::new("").is_none());
-        assert!(KebabStr::new("a").is_some());
-        assert!(KebabStr::new("aB").is_none());
-        assert!(KebabStr::new("a-B").is_some());
-        assert!(KebabStr::new("a-").is_none());
-        assert!(KebabStr::new("-").is_none());
-        assert!(KebabStr::new("").is_none());
-        assert!(KebabStr::new("0").is_none());
-        assert!(KebabStr::new("a0").is_some());
-        assert!(KebabStr::new("a-0").is_none());
-    }
-
-    #[test]
-    fn name_smoke() {
-        assert!(parse_kebab_name("a").is_some());
-        assert!(parse_kebab_name("[foo]a").is_none());
-        assert!(parse_kebab_name("[constructor]a").is_some());
-        assert!(parse_kebab_name("[method]a").is_none());
-        assert!(parse_kebab_name("[method]a.b").is_some());
-        assert!(parse_kebab_name("[method]a.b.c").is_none());
-        assert!(parse_kebab_name("[static]a.b").is_some());
-        assert!(parse_kebab_name("[static]a").is_none());
-    }
-
-    #[test]
-    fn name_equality() {
-        assert_eq!(parse_kebab_name("a"), parse_kebab_name("a"));
-        assert_ne!(parse_kebab_name("a"), parse_kebab_name("b"));
-        assert_eq!(
-            parse_kebab_name("[constructor]a"),
-            parse_kebab_name("[constructor]a")
-        );
-        assert_ne!(
-            parse_kebab_name("[constructor]a"),
-            parse_kebab_name("[constructor]b")
-        );
-        assert_eq!(
-            parse_kebab_name("[method]a.b"),
-            parse_kebab_name("[method]a.b")
-        );
-        assert_ne!(
-            parse_kebab_name("[method]a.b"),
-            parse_kebab_name("[method]b.b")
-        );
-        assert_eq!(
-            parse_kebab_name("[static]a.b"),
-            parse_kebab_name("[static]a.b")
-        );
-        assert_ne!(
-            parse_kebab_name("[static]a.b"),
-            parse_kebab_name("[static]b.b")
-        );
-
-        assert_eq!(
-            parse_kebab_name("[static]a.b"),
-            parse_kebab_name("[method]a.b")
-        );
-        assert_eq!(
-            parse_kebab_name("[method]a.b"),
-            parse_kebab_name("[static]a.b")
-        );
-
-        assert_ne!(
-            parse_kebab_name("[method]b.b"),
-            parse_kebab_name("[static]a.b")
-        );
-
-        let mut s = HashSet::new();
-        assert!(s.insert(parse_kebab_name("a")));
-        assert!(s.insert(parse_kebab_name("[constructor]a")));
-        assert!(s.insert(parse_kebab_name("[method]a.b")));
-        assert!(!s.insert(parse_kebab_name("[static]a.b")));
-        assert!(s.insert(parse_kebab_name("[static]b.b")));
-    }
-}
diff --git a/crates/wasmparser/src/validator/operators.rs b/crates/wasmparser/src/validator/operators.rs
index a0fa1a10..074799b3 100644
--- a/crates/wasmparser/src/validator/operators.rs
+++ b/crates/wasmparser/src/validator/operators.rs
@@ -24,7 +24,7 @@
 
 use crate::{
     limits::MAX_WASM_FUNCTION_LOCALS, BinaryReaderError, BlockType, BrTable, HeapType, Ieee32,
-    Ieee64, MemArg, RefType, Result, ValType, VisitOperator, WasmFeatures, WasmFuncType,
+    Ieee64, MemArg, RefType, Result, ResumeTable, ValType, VisitOperator, WasmFeatures, WasmFuncType,
     WasmModuleResources, V128,
 };
 use std::ops::{Deref, DerefMut};
@@ -130,6 +130,12 @@ pub enum FrameKind {
     ///
     /// This belongs to the Wasm exception handling proposal.
     CatchAll,
+    /// A Wasm `barrier` control block.
+    ///
+    /// # Note
+    ///
+    /// This belongs to the Wasm typed continuations proposal.
+    Barrier,
 }
 
 struct OperatorValidatorTemp<'validator, 'resources, T> {
@@ -173,13 +179,6 @@ impl From<ValType> for MaybeType {
     }
 }
 
-impl From<RefType> for MaybeType {
-    fn from(ty: RefType) -> MaybeType {
-        let ty: ValType = ty.into();
-        ty.into()
-    }
-}
-
 impl OperatorValidator {
     fn new(features: &WasmFeatures, allocs: OperatorValidatorAllocations) -> Self {
         let OperatorValidatorAllocations {
@@ -475,7 +474,7 @@ impl<'resources, R: WasmModuleResources> OperatorValidatorTemp<'_, 'resources, R
             if self.operands.len() == control.height {
                 let desc = match expected {
                     Some(ty) => ty_to_str(ty),
-                    None => "a type",
+                    None => "a type".into(),
                 };
                 bail!(
                     self.offset,
@@ -513,7 +512,7 @@ impl<'resources, R: WasmModuleResources> OperatorValidatorTemp<'_, 'resources, R
                 ) => {
                     bail!(
                         self.offset,
-                        "type mismatch: expected {}, found heap type",
+                        "type mismatche: expected {}, found heap type",
                         ty_to_str(expected)
                     )
                 }
@@ -692,9 +691,10 @@ impl<'resources, R: WasmModuleResources> OperatorValidatorTemp<'_, 'resources, R
     fn check_block_type(&self, ty: BlockType) -> Result<()> {
         match ty {
             BlockType::Empty => Ok(()),
-            BlockType::Type(t) => self
+            BlockType::Type(t) =>
+                self
                 .resources
-                .check_value_type(t, &self.features, self.offset),
+                    .check_value_type(t, &self.features, self.offset),
             BlockType::FuncType(idx) => {
                 if !self.features.multi_value {
                     bail!(
@@ -944,6 +944,15 @@ impl<'resources, R: WasmModuleResources> OperatorValidatorTemp<'_, 'resources, R
         Ok(())
     }
 
+    fn cont_type_at(&self, at: u32) -> Result<u32> {
+        self.resources.cont_type_at(at).ok_or_else(|| {
+            format_err!(
+                self.offset,
+                "unknown continuation type: type index out of bounds"
+            )
+        })
+    }
+
     fn func_type_at(&self, at: u32) -> Result<&'resources R::FuncType> {
         self.resources
             .func_type_at(at)
@@ -981,6 +990,86 @@ impl<'resources, R: WasmModuleResources> OperatorValidatorTemp<'_, 'resources, R
             _ => Either::B(self.results(ty)?),
         })
     }
+
+    /// Validates a resume table.
+    fn check_resume_table(
+        &mut self,
+        table: ResumeTable,            // The table to validate.
+        ctft: &'resources R::FuncType, // The type of the continuation applied to the resume, which `table` is attached to.
+    ) -> Result<()> {
+        // Resume table validation is somewhat involved as we have to
+        // check that the domain of each tag matches up with the
+        // expected type at its associated label. In addition, we also
+        // need to check that the continuation type matches the
+        // expectation at each label.
+        //
+        // Concretely, let's say the given continuation type has the
+        // form
+        //     ctft := ts1 -> ts2
+        // and that each tag type has the form
+        //     tagtype := ts1' -> ts2'
+        // and each label type has the form
+        //     labeltype := ts1'' (ref null? (cont $ft))
+        // then for each tag-label pair we have to check that domain
+        // (ts1') of the tag type matches the prefix of the label
+        // type, i.e.  ts1' <: ts1''
+        //
+        // Subsequently, we must check that the codomain of each
+        // tagtype matches the domain of the dynamic continuation type
+        // at its label. Moreover, we also need to check that the
+        // codomain of continuation type matches the overall return
+        // type of the context --- this type is given by the provided
+        // continuation $ctft. In essence, we need to check that
+        //     (ts2' -> ts2) <: $ft
+        for pair in table.targets() {
+            let (tag, relative_depth) = pair?;
+            // tagtype := ts1' -> ts2'
+            let tagtype = self.tag_at(tag)?;
+            let block = self.jump(relative_depth)?;
+
+            // label_types(offset, block.0, block.1) := ts1''* (ref null? (cont $ft))
+            if tagtype.inputs().len() != self.label_types(block.0, block.1)?.len() - 1 {
+                bail!(
+                    self.offset,
+                    "type mismatch between label type and tag type length"
+                ) // TODO(dhil): tidy up
+            }
+            let labeltys = self
+                .label_types(block.0, block.1)?
+                .take(tagtype.inputs().len());
+
+            // Next check that ts1' <: ts1''.
+            for (tagty, lblty) in labeltys.zip(tagtype.inputs()) {
+                if !self.resources.matches(tagty, lblty) {
+                    panic!("type mismatch between tag type and label type") // TODO(dhil): tidy up
+                }
+            }
+
+            // Retrieve the continuation reference type (i.e. (cont $ft)).
+            match self.label_types(block.0, block.1)?.last() {
+                Some(ValType::Ref(RefType { nullable: _, heap_type: HeapType::TypedFunc(z) })) => {
+                    let ctft2 = self.func_type_at(self.cont_type_at(z.into())?)?;
+                    // Now we must check that (ts2' -> ts2) <: $ft
+                    // This method should be exposed by resources to make this correct
+                    for (tagty, ct2ty) in tagtype.outputs().zip(ctft2.inputs()) {
+                        // Note: according to spec we should check for equality here
+                        if !self.resources.matches(ct2ty, tagty) {
+                            bail!(self.offset, "type mismatch in continuation type") // TODO(dhil): tidy up
+                        }
+                    }
+                    for (ctty, ct2ty) in ctft.outputs().zip(ctft2.outputs()) {
+                        // Note: according to spec we should check for equality here
+                        if !self.resources.matches(ctty, ct2ty) {
+                            bail!(self.offset, "type mismatch in continuation type") // TODO(dhil): tidy up
+                        }
+                    }
+                }
+                _ => bail!(self.offset,
+                    "type mismatch: instruction requires continuation reference type but label has none")
+            }
+        }
+        Ok(())
+    }
 }
 
 pub fn ty_to_str(ty: ValType) -> &'static str {
@@ -990,7 +1079,24 @@ pub fn ty_to_str(ty: ValType) -> &'static str {
         ValType::F32 => "f32",
         ValType::F64 => "f64",
         ValType::V128 => "v128",
-        ValType::Ref(r) => r.wat(),
+        ValType::FUNCREF => "funcref",
+        ValType::EXTERNREF => "externref",
+        ValType::Ref(RefType {
+            nullable: false,
+            heap_type: HeapType::Func,
+        }) => "(ref func)",
+        ValType::Ref(RefType {
+            nullable: false,
+            heap_type: HeapType::Extern,
+        }) => "(ref extern)",
+        ValType::Ref(RefType {
+            nullable: false,
+            heap_type: HeapType::TypedFunc(_),
+        }) => "(ref $type)",
+        ValType::Ref(RefType {
+            nullable: true,
+            heap_type: HeapType::TypedFunc(_),
+        }) => "(ref null $type)",
     }
 }
 
@@ -1040,8 +1146,8 @@ macro_rules! validate_proposal {
     (desc exceptions) => ("exceptions");
     (desc tail_call) => ("tail calls");
     (desc function_references) => ("function references");
+    (desc typed_continuations) => ("typed continuations");
     (desc memory_control) => ("memory control");
-    (desc gc) => ("gc");
 }
 
 impl<'a, T> VisitOperator<'a> for WasmProposalValidator<'_, '_, T>
@@ -1271,15 +1377,16 @@ where
         self.check_return()?;
         Ok(())
     }
-    fn visit_call_ref(&mut self, type_index: u32) -> Self::Output {
-        let hty = HeapType::Indexed(type_index);
+    fn visit_call_ref(&mut self, hty: HeapType) -> Self::Output {
         self.resources
             .check_heap_type(hty, &self.features, self.offset)?;
         // If `None` is popped then that means a "bottom" type was popped which
         // is always considered equivalent to the `hty` tag.
         if let Some(rt) = self.pop_ref()? {
-            let expected = RefType::indexed_func(true, type_index)
-                .expect("existing heap types should be within our limits");
+            let expected = RefType {
+                nullable: true,
+                heap_type: hty,
+            };
             if !self
                 .resources
                 .matches(ValType::Ref(rt), ValType::Ref(expected))
@@ -1290,10 +1397,17 @@ where
                 );
             }
         }
-        self.check_call_ty(type_index)
+        match hty {
+            HeapType::TypedFunc(type_index) => self.check_call_ty(type_index.into())?,
+            _ => bail!(
+                self.offset,
+                "type mismatch: instruction requires function reference type",
+            ),
+        }
+        Ok(())
     }
-    fn visit_return_call_ref(&mut self, type_index: u32) -> Self::Output {
-        self.visit_call_ref(type_index)?;
+    fn visit_return_call_ref(&mut self, hty: HeapType) -> Self::Output {
+        self.visit_call_ref(hty)?;
         self.check_return()
     }
     fn visit_call_indirect(
@@ -2204,15 +2318,19 @@ where
     fn visit_ref_null(&mut self, heap_type: HeapType) -> Self::Output {
         self.resources
             .check_heap_type(heap_type, &self.features, self.offset)?;
-        self.push_operand(ValType::Ref(
-            RefType::new(true, heap_type).expect("existing heap types should be within our limits"),
-        ))?;
+        self.push_operand(ValType::Ref(RefType {
+            nullable: true,
+            heap_type,
+        }))?;
         Ok(())
     }
 
     fn visit_ref_as_non_null(&mut self) -> Self::Output {
         let ty = match self.pop_ref()? {
-            Some(ty) => MaybeType::Type(ValType::Ref(ty.as_non_null())),
+            Some(ty) => MaybeType::Type(ValType::Ref(RefType {
+                nullable: false,
+                heap_type: ty.heap_type,
+            })),
             None => MaybeType::HeapBot,
         };
         self.push_operand(ty)?;
@@ -2221,7 +2339,10 @@ where
     fn visit_br_on_null(&mut self, relative_depth: u32) -> Self::Output {
         let ty = match self.pop_ref()? {
             None => MaybeType::HeapBot,
-            Some(ty) => MaybeType::Type(ValType::Ref(ty.as_non_null())),
+            Some(ty) => MaybeType::Type(ValType::Ref(RefType {
+                nullable: false,
+                heap_type: ty.heap_type,
+            })),
         };
         let (ft, kind) = self.jump(relative_depth)?;
         for ty in self.label_types(ft, kind)?.rev() {
@@ -2247,7 +2368,10 @@ where
                 // Switch rt0, our popped type, to a non-nullable type and
                 // perform the match because if the branch is taken it's a
                 // non-null value.
-                let ty = rt0.as_non_null();
+                let ty = RefType {
+                    nullable: false,
+                    heap_type: rt0.heap_type,
+                };
                 if !self.resources.matches(ty.into(), rt1) {
                     bail!(
                         self.offset,
@@ -2291,10 +2415,16 @@ where
         // FIXME(#924) this should not be conditional based on enabled
         // proposals.
         if self.features.function_references {
-            self.push_operand(
-                RefType::indexed_func(false, type_index)
-                    .expect("our limits on number of types should fit into ref type"),
-            )?;
+            let heap_type = HeapType::TypedFunc(match type_index.try_into() {
+                Ok(packed) => packed,
+                Err(_) => {
+                    bail!(self.offset, "type index of `ref.func` target too large")
+                }
+            });
+            self.push_operand(ValType::Ref(RefType {
+                nullable: false,
+                heap_type,
+            }))?;
         } else {
             self.push_operand(ValType::FUNCREF)?;
         }
@@ -3335,27 +3465,174 @@ where
         self.pop_operand(Some(ValType::I32))?;
         Ok(())
     }
-    fn visit_i31_new(&mut self) -> Self::Output {
-        self.pop_operand(Some(ValType::I32))?;
-        self.push_operand(ValType::Ref(RefType::I31))
+
+    // Typed continuations operators.
+    // TODO(dhil) fixme: merge into the above list.
+    fn visit_cont_new(&mut self, type_index: u32) -> Self::Output {
+        let fidx = self.cont_type_at(type_index)?;
+        let rt = RefType {
+            nullable: false,
+            heap_type: HeapType::TypedFunc(fidx
+                                           .try_into()
+                                           .expect("function reference index larger than 2^16")),
+        };
+        self.pop_operand(Some(ValType::Ref(rt)))?;
+        let result = RefType {
+            nullable: false,
+            heap_type: HeapType::TypedFunc(type_index
+                                           .try_into()
+                                           .expect("function reference index larger than 2^16")),
+        };
+        self.push_operand(ValType::Ref(result))?;
+        Ok(())
     }
-    fn visit_i31_get_s(&mut self) -> Self::Output {
+    fn visit_cont_bind(&mut self, type_index: u32) -> Self::Output {
         match self.pop_ref()? {
-            Some(ref_type) => match ref_type.heap_type() {
-                HeapType::I31 => self.push_operand(ValType::I32),
-                _ => bail!(self.offset, "ref heap type mismatch: expected i31"),
-            },
-            _ => bail!(self.offset, "type mismatch: expected (ref null? i31)"),
+            None => self.push_operand(ValType::Ref(RefType {
+                nullable: false,
+                heap_type: HeapType::TypedFunc(type_index
+                                               .try_into()
+                                               .expect("function reference index larger than 2^16")),
+            }))?,
+            Some(rt) => {
+                match rt.heap_type {
+                    HeapType::TypedFunc(y) => {
+                        let ft1 = self.func_type_at(self.cont_type_at(y.into())?)?;
+                        let ft2 =
+                            self.func_type_at(self.cont_type_at(type_index.into())?)?;
+
+                        // Verify that ft1's domain is at least as
+                        // large as ft2's domain.
+                        if ft1.inputs().len() < ft2.inputs().len() {
+                            panic!("|ft1.inputs()| must be greater or equal to |ft2.inputs()|")
+                            // TODO(dhil): Tidy up
+                        }
+                        // Next check that prefix of ft1's domain agrees with the domain of ft2.
+                        let ft1ins1 = ft1.inputs().take(ft1.inputs().len() - ft2.inputs().len());
+                        let ft1ins2 = ft1.inputs().skip(ft1.inputs().len() - ft2.inputs().len());
+
+                        for (ty1, ty2) in ft1ins2.zip(ft2.inputs()) {
+                            if !self.resources.matches(ty1, ty2) {
+                                panic!("mismatch error") // TODO(dhil): tidy up
+                            }
+                        }
+
+                        // Next check their codomains agree.
+                        if ft1.outputs().len() != ft2.outputs().len() {
+                            panic!("The codomains of ft1 and ft2 must have the same size")
+                            // TODO(dhil): Tidy up
+                        }
+
+                        for (ty1, ty2) in ft1.outputs().zip(ft2.outputs()) {
+                            if !self.resources.matches(ty1, ty2) {
+                                panic!("mismatch error") // TODO(dhil): tidy up
+                            }
+                        }
+
+                        // Check that the bound ft1 inputs are available on the stack.
+                        for ty in ft1ins1.rev() {
+                            self.pop_operand(Some(ty))?;
+                        }
+
+                        // Push the continuation reference.
+                        self.push_operand(ValType::Ref(RefType {
+                            nullable: false,
+                            heap_type: HeapType::TypedFunc(type_index
+                                                           .try_into()
+                                                           .expect("function reference index larger than 2^16")),
+                        }))?;
+                    }
+                    _ => {
+                        bail!(self.offset,
+                              "type mismatch: instruction requires continuation reference type but stack has {}",
+                              ty_to_str(ValType::Ref(rt)))
+                    }
+                }
+            }
         }
+        Ok(())
     }
-    fn visit_i31_get_u(&mut self) -> Self::Output {
+    fn visit_suspend(&mut self, tag_index: u32) -> Self::Output {
+        let ft = self.tag_at(tag_index)?;
+        for ty in ft.inputs().rev() {
+            self.pop_operand(Some(ty))?;
+        }
+        for ty in ft.outputs() {
+            self.push_operand(ty)?;
+        }
+        Ok(())
+    }
+    fn visit_resume(&mut self, resumetable: ResumeTable) -> Self::Output {
         match self.pop_ref()? {
-            Some(ref_type) => match ref_type.heap_type() {
-                HeapType::I31 => self.push_operand(ValType::I32),
-                _ => bail!(self.offset, "ref heap type mismatch: expected i31"),
-            },
-            _ => bail!(self.offset, "type mismatch: expected (ref null? i31)"),
+            None => {},
+            Some(rt) =>
+                match rt.heap_type {
+                    HeapType::TypedFunc(y) => {
+                        // ft := ts1 -> ts2
+                        let ctft = self.func_type_at(self.cont_type_at(y.into())?)?;
+                        self.check_resume_table(resumetable, ctft)?;
+
+                        // Check that ts1 are available on the stack.
+                        for ty in ctft.inputs().rev() {
+                            self.pop_operand(Some(ty))?;
+                        }
+
+                        // Make ts2 available on the stack.
+                        for ty in ctft.outputs() {
+                            self.push_operand(ty)?;
+                        }
+                    }
+                    _ => {
+                        bail!(self.offset,
+                              "type mismatch: instruction requires continuation reference type but stack has {}",
+                              ty_to_str(ValType::Ref(rt)))
+                    }
+                }
+        }
+        Ok(())
+    }
+    fn visit_resume_throw(
+        &mut self,
+        tag_index: u32,
+        resumetable: ResumeTable,
+    ) -> Self::Output {
+        match self.pop_ref()? {
+            None => {},
+            Some(rt) => match rt.heap_type {
+                HeapType::TypedFunc(y) => {
+                    // ct := ts1 -> ts2
+                    let ct = self.func_type_at(self.cont_type_at(y.into())?)?;
+                    self.check_resume_table(resumetable, ct)?;
+
+                    // tagtype := ts1' -> []
+                    let tagtype = self.tag_at(tag_index)?;
+
+                    // Check that ts1' are available on the stack.
+                    for tagty in tagtype.inputs().rev() {
+                        self.pop_operand(Some(tagty))?;
+                    }
+
+                    // Make ts2 available on the stack
+                    for ty in ct.outputs() {
+                        self.push_operand(ty)?;
+                    }
+                }
+                _ => {
+                    bail!(self.offset,
+                          "type mismatch: instruction requires continuation reference type but stack has {}",
+                          ty_to_str(ValType::Ref(rt)))
+                }
+            }
         }
+        Ok(())
+    }
+    fn visit_barrier(&mut self, blockty: BlockType) -> Self::Output {
+        self.check_block_type(blockty)?;
+        for ty in self.params(blockty)?.rev() {
+            self.pop_operand(Some(ty))?;
+        }
+        self.push_ctrl(FrameKind::Barrier, blockty)?;
+        Ok(())
     }
 }
 
diff --git a/crates/wasmparser/src/validator/types.rs b/crates/wasmparser/src/validator/types.rs
index 222172f0..35adc89a 100644
--- a/crates/wasmparser/src/validator/types.rs
+++ b/crates/wasmparser/src/validator/types.rs
@@ -1,27 +1,21 @@
 //! Types relating to type information provided by validation.
 
-use super::{
-    component::{ComponentState, ExternKind},
-    core::Module,
-};
-use crate::validator::names::KebabString;
+use super::{component::ComponentState, core::Module};
 use crate::{
-    ArrayType, BinaryReaderError, Export, ExternalKind, FuncType, GlobalType, Import, MemoryType,
-    PrimitiveValType, RefType, Result, StructType, StructuralType, SubType, TableType, TypeRef,
-    ValType,
+    Export, ExternalKind, FuncType, GlobalType, Import, MemoryType, PrimitiveValType, RefType,
+    TableType, TypeRef, ValType,
 };
 use indexmap::{IndexMap, IndexSet};
 use std::collections::HashMap;
-use std::collections::HashSet;
-use std::ops::Index;
-use std::sync::atomic::{AtomicU64, Ordering};
 use std::{
     borrow::Borrow,
+    fmt,
     hash::{Hash, Hasher},
     mem,
     ops::{Deref, DerefMut},
     sync::Arc,
 };
+use url::Url;
 
 /// The maximum number of parameters in the canonical ABI that can be passed by value.
 ///
@@ -37,6 +31,199 @@ const MAX_FLAT_FUNC_RESULTS: usize = 1;
 /// The maximum lowered types, including a possible type for a return pointer parameter.
 const MAX_LOWERED_TYPES: usize = MAX_FLAT_FUNC_PARAMS + 1;
 
+/// Represents a kebab string slice used in validation.
+///
+/// This is a wrapper around `str` that ensures the slice is
+/// a valid kebab case string according to the component model
+/// specification.
+///
+/// It also provides an equality and hashing implementation
+/// that ignores ASCII case.
+#[derive(Debug, Eq)]
+#[repr(transparent)]
+pub struct KebabStr(str);
+
+impl KebabStr {
+    /// Creates a new kebab string slice.
+    ///
+    /// Returns `None` if the given string is not a valid kebab string.
+    pub fn new<'a>(s: impl AsRef<str> + 'a) -> Option<&'a Self> {
+        let s = Self::new_unchecked(s);
+        if s.is_kebab_case() {
+            Some(s)
+        } else {
+            None
+        }
+    }
+
+    pub(crate) fn new_unchecked<'a>(s: impl AsRef<str> + 'a) -> &'a Self {
+        // Safety: `KebabStr` is a transparent wrapper around `str`
+        // Therefore transmuting `&str` to `&KebabStr` is safe.
+        unsafe { std::mem::transmute::<_, &Self>(s.as_ref()) }
+    }
+
+    /// Gets the underlying string slice.
+    pub fn as_str(&self) -> &str {
+        &self.0
+    }
+
+    /// Converts the slice to an owned string.
+    pub fn to_kebab_string(&self) -> KebabString {
+        KebabString(self.to_string())
+    }
+
+    fn is_kebab_case(&self) -> bool {
+        let mut lower = false;
+        let mut upper = false;
+        for c in self.chars() {
+            match c {
+                'a'..='z' if !lower && !upper => lower = true,
+                'A'..='Z' if !lower && !upper => upper = true,
+                'a'..='z' if lower => {}
+                'A'..='Z' if upper => {}
+                '0'..='9' if lower || upper => {}
+                '-' if lower || upper => {
+                    lower = false;
+                    upper = false;
+                }
+                _ => return false,
+            }
+        }
+
+        !self.is_empty() && !self.ends_with('-')
+    }
+}
+
+impl Deref for KebabStr {
+    type Target = str;
+
+    fn deref(&self) -> &str {
+        self.as_str()
+    }
+}
+
+impl PartialEq for KebabStr {
+    fn eq(&self, other: &Self) -> bool {
+        if self.len() != other.len() {
+            return false;
+        }
+
+        self.chars()
+            .zip(other.chars())
+            .all(|(a, b)| a.to_ascii_lowercase() == b.to_ascii_lowercase())
+    }
+}
+
+impl PartialEq<KebabString> for KebabStr {
+    fn eq(&self, other: &KebabString) -> bool {
+        self.eq(other.as_kebab_str())
+    }
+}
+
+impl Hash for KebabStr {
+    fn hash<H: Hasher>(&self, state: &mut H) {
+        self.len().hash(state);
+
+        for b in self.chars() {
+            b.to_ascii_lowercase().hash(state);
+        }
+    }
+}
+
+impl fmt::Display for KebabStr {
+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
+        (self as &str).fmt(f)
+    }
+}
+
+impl ToOwned for KebabStr {
+    type Owned = KebabString;
+
+    fn to_owned(&self) -> Self::Owned {
+        self.to_kebab_string()
+    }
+}
+
+/// Represents an owned kebab string for validation.
+///
+/// This is a wrapper around `String` that ensures the string is
+/// a valid kebab case string according to the component model
+/// specification.
+///
+/// It also provides an equality and hashing implementation
+/// that ignores ASCII case.
+#[derive(Debug, Clone, Eq)]
+pub struct KebabString(String);
+
+impl KebabString {
+    /// Creates a new kebab string.
+    ///
+    /// Returns `None` if the given string is not a valid kebab string.
+    pub fn new(s: impl Into<String>) -> Option<Self> {
+        let s = s.into();
+        if KebabStr::new(&s).is_some() {
+            Some(Self(s))
+        } else {
+            None
+        }
+    }
+
+    /// Gets the underlying string.
+    pub fn as_str(&self) -> &str {
+        self.0.as_str()
+    }
+
+    /// Converts the kebab string to a kebab string slice.
+    pub fn as_kebab_str(&self) -> &KebabStr {
+        // Safety: internal string is always valid kebab-case
+        KebabStr::new_unchecked(self.as_str())
+    }
+}
+
+impl Deref for KebabString {
+    type Target = KebabStr;
+
+    fn deref(&self) -> &Self::Target {
+        self.as_kebab_str()
+    }
+}
+
+impl Borrow<KebabStr> for KebabString {
+    fn borrow(&self) -> &KebabStr {
+        self.as_kebab_str()
+    }
+}
+
+impl PartialEq for KebabString {
+    fn eq(&self, other: &Self) -> bool {
+        self.as_kebab_str().eq(other.as_kebab_str())
+    }
+}
+
+impl PartialEq<KebabStr> for KebabString {
+    fn eq(&self, other: &KebabStr) -> bool {
+        self.as_kebab_str().eq(other)
+    }
+}
+
+impl Hash for KebabString {
+    fn hash<H: Hasher>(&self, state: &mut H) {
+        self.as_kebab_str().hash(state)
+    }
+}
+
+impl fmt::Display for KebabString {
+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
+        self.as_kebab_str().fmt(f)
+    }
+}
+
+impl From<KebabString> for String {
+    fn from(s: KebabString) -> String {
+        s.0
+    }
+}
+
 /// A simple alloc-free list of types used for calculating lowered function signatures.
 pub(crate) struct LoweredTypes {
     types: [ValType; MAX_LOWERED_TYPES],
@@ -142,7 +329,6 @@ fn push_primitive_wasm_types(ty: &PrimitiveValType, lowered_types: &mut LoweredT
 
 /// Represents a unique identifier for a type known to a [`crate::Validator`].
 #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
-#[repr(C)] // use fixed field layout to ensure minimal size
 pub struct TypeId {
     /// The index into the global list of types.
     pub(crate) index: usize,
@@ -169,24 +355,26 @@ const _: () = {
 /// A unified type definition for validating WebAssembly modules and components.
 #[derive(Debug)]
 pub enum Type {
-    /// The definition is for a sub type.
-    Sub(SubType),
+    /// The definition is for a core function type.
+    Func(FuncType),
+    /// The definition is for a continuation type.
+    Cont(u32),
     /// The definition is for a core module type.
     ///
     /// This variant is only supported when parsing a component.
-    Module(Box<ModuleType>),
+    Module(ModuleType),
     /// The definition is for a core module instance type.
     ///
     /// This variant is only supported when parsing a component.
-    Instance(Box<InstanceType>),
+    Instance(InstanceType),
     /// The definition is for a component type.
     ///
     /// This variant is only supported when parsing a component.
-    Component(Box<ComponentType>),
+    Component(ComponentType),
     /// The definition is for a component instance type.
     ///
     /// This variant is only supported when parsing a component.
-    ComponentInstance(Box<ComponentInstanceType>),
+    ComponentInstance(ComponentInstanceType),
     /// The definition is for a component function type.
     ///
     /// This variant is only supported when parsing a component.
@@ -195,119 +383,84 @@ pub enum Type {
     ///
     /// This variant is only supported when parsing a component.
     Defined(ComponentDefinedType),
-    /// This definition is for a resource type in the component model.
-    ///
-    /// Each resource is identified by a unique identifier specified here.
-    Resource(ResourceId),
 }
 
 impl Type {
     /// Converts the type to a core function type.
-    pub fn unwrap_func(&self) -> &FuncType {
-        match self {
-            Type::Sub(SubType {
-                structural_type: StructuralType::Func(ft),
-                ..
-            }) => ft,
-            _ => panic!("not a function type"),
-        }
-    }
-
-    /// Converts the type to an array type.
-    pub fn unwrap_array(&self) -> &ArrayType {
+    pub fn as_func_type(&self) -> Option<&FuncType> {
         match self {
-            Self::Sub(SubType {
-                structural_type: StructuralType::Array(ty),
-                ..
-            }) => ty,
-            _ => panic!("not an array type"),
+            Self::Func(ty) => Some(ty),
+            _ => None,
         }
     }
 
-    /// Converts the type to a struct type.
-    pub fn unwrap_struct(&self) -> &StructType {
+    /// If the given type is a continuation type, give the index of its
+    /// corresponding function type
+    pub fn as_cont_func_index(&self) -> Option<u32> {
         match self {
-            Self::Sub(SubType {
-                structural_type: StructuralType::Struct(ty),
-                ..
-            }) => ty,
-            _ => panic!("not a struct type"),
+            Self::Cont(fi) => Some(*fi),
+            _ => None,
         }
     }
 
     /// Converts the type to a core module type.
-    pub fn unwrap_module(&self) -> &ModuleType {
+    pub fn as_module_type(&self) -> Option<&ModuleType> {
         match self {
-            Self::Module(ty) => ty,
-            _ => panic!("not a module type"),
+            Self::Module(ty) => Some(ty),
+            _ => None,
         }
     }
 
     /// Converts the type to a core module instance type.
-    pub fn unwrap_instance(&self) -> &InstanceType {
+    pub fn as_instance_type(&self) -> Option<&InstanceType> {
         match self {
-            Self::Instance(ty) => ty,
-            _ => panic!("not an instance type"),
+            Self::Instance(ty) => Some(ty),
+            _ => None,
         }
     }
 
     /// Converts the type to a component type.
-    pub fn unwrap_component(&self) -> &ComponentType {
+    pub fn as_component_type(&self) -> Option<&ComponentType> {
         match self {
-            Self::Component(ty) => ty,
-            _ => panic!("not a component type"),
+            Self::Component(ty) => Some(ty),
+            _ => None,
         }
     }
 
     /// Converts the type to a component instance type.
-    pub fn unwrap_component_instance(&self) -> &ComponentInstanceType {
+    pub fn as_component_instance_type(&self) -> Option<&ComponentInstanceType> {
         match self {
-            Self::ComponentInstance(ty) => ty,
-            _ => panic!("not a component instance type"),
+            Self::ComponentInstance(ty) => Some(ty),
+            _ => None,
         }
     }
 
     /// Converts the type to a component function type.
-    pub fn unwrap_component_func(&self) -> &ComponentFuncType {
+    pub fn as_component_func_type(&self) -> Option<&ComponentFuncType> {
         match self {
-            Self::ComponentFunc(ty) => ty,
-            _ => panic!("not a component function type"),
+            Self::ComponentFunc(ty) => Some(ty),
+            _ => None,
         }
     }
 
     /// Converts the type to a component defined type.
-    pub fn unwrap_defined(&self) -> &ComponentDefinedType {
+    pub fn as_defined_type(&self) -> Option<&ComponentDefinedType> {
         match self {
-            Self::Defined(ty) => ty,
-            _ => panic!("not a defined type"),
-        }
-    }
-
-    /// Converts this type to a resource type, returning the corresponding id.
-    pub fn unwrap_resource(&self) -> ResourceId {
-        match self {
-            Self::Resource(id) => *id,
-            _ => panic!("not a resource type"),
+            Self::Defined(ty) => Some(ty),
+            _ => None,
         }
     }
 
     pub(crate) fn type_size(&self) -> u32 {
-        // TODO(#1036): calculate actual size for func, array, struct
         match self {
-            Self::Sub(ty) => {
-                1 + match ty.clone().structural_type {
-                    StructuralType::Func(ty) => 1 + (ty.params().len() + ty.results().len()) as u32,
-                    StructuralType::Array(_) => 2,
-                    StructuralType::Struct(ty) => 1 + 2 * ty.fields.len() as u32,
-                }
-            }
+            Self::Func(ty) => 1 + (ty.params().len() + ty.results().len()) as u32,
+            Self::Cont(_) => 1,
             Self::Module(ty) => ty.type_size,
             Self::Instance(ty) => ty.type_size,
             Self::Component(ty) => ty.type_size,
             Self::ComponentInstance(ty) => ty.type_size,
             Self::ComponentFunc(ty) => ty.type_size,
             Self::Defined(ty) => ty.type_size(),
-            Self::Resource(_) => 1,
         }
     }
 }
@@ -325,7 +478,43 @@ impl ComponentValType {
     pub(crate) fn requires_realloc(&self, types: &TypeList) -> bool {
         match self {
             ComponentValType::Primitive(ty) => ty.requires_realloc(),
-            ComponentValType::Type(ty) => types[*ty].unwrap_defined().requires_realloc(types),
+            ComponentValType::Type(ty) => types[*ty]
+                .as_defined_type()
+                .unwrap()
+                .requires_realloc(types),
+        }
+    }
+
+    /// Determines if component value type `a` is a subtype of `b`.
+    pub fn is_subtype_of(a: &Self, at: TypesRef, b: &Self, bt: TypesRef) -> bool {
+        Self::internal_is_subtype_of(a, at.list, b, bt.list)
+    }
+
+    pub(crate) fn internal_is_subtype_of(a: &Self, at: &TypeList, b: &Self, bt: &TypeList) -> bool {
+        match (a, b) {
+            (ComponentValType::Primitive(a), ComponentValType::Primitive(b)) => {
+                PrimitiveValType::is_subtype_of(*a, *b)
+            }
+            (ComponentValType::Type(a), ComponentValType::Type(b)) => {
+                ComponentDefinedType::internal_is_subtype_of(
+                    at[*a].as_defined_type().unwrap(),
+                    at,
+                    bt[*b].as_defined_type().unwrap(),
+                    bt,
+                )
+            }
+            (ComponentValType::Primitive(a), ComponentValType::Type(b)) => {
+                match bt[*b].as_defined_type().unwrap() {
+                    ComponentDefinedType::Primitive(b) => PrimitiveValType::is_subtype_of(*a, *b),
+                    _ => false,
+                }
+            }
+            (ComponentValType::Type(a), ComponentValType::Primitive(b)) => {
+                match at[*a].as_defined_type().unwrap() {
+                    ComponentDefinedType::Primitive(a) => PrimitiveValType::is_subtype_of(*a, *b),
+                    _ => false,
+                }
+            }
         }
     }
 
@@ -333,7 +522,8 @@ impl ComponentValType {
         match self {
             Self::Primitive(ty) => push_primitive_wasm_types(ty, lowered_types),
             Self::Type(id) => types[*id]
-                .unwrap_defined()
+                .as_defined_type()
+                .unwrap()
                 .push_wasm_types(types, lowered_types),
         }
     }
@@ -362,9 +552,48 @@ pub enum EntityType {
 }
 
 impl EntityType {
+    /// Determines if entity type `a` is a subtype of `b`.
+    pub fn is_subtype_of(a: &Self, at: TypesRef, b: &Self, bt: TypesRef) -> bool {
+        Self::internal_is_subtype_of(a, at.list, b, bt.list)
+    }
+
+    pub(crate) fn internal_is_subtype_of(a: &Self, at: &TypeList, b: &Self, bt: &TypeList) -> bool {
+        macro_rules! limits_match {
+            ($a:expr, $b:expr) => {{
+                let a = $a;
+                let b = $b;
+                a.initial >= b.initial
+                    && match b.maximum {
+                        Some(b_max) => match a.maximum {
+                            Some(a_max) => a_max <= b_max,
+                            None => false,
+                        },
+                        None => true,
+                    }
+            }};
+        }
+
+        match (a, b) {
+            (EntityType::Func(a), EntityType::Func(b)) => {
+                at[*a].as_func_type().unwrap() == bt[*b].as_func_type().unwrap()
+            }
+            (EntityType::Table(a), EntityType::Table(b)) => {
+                a.element_type == b.element_type && limits_match!(a, b)
+            }
+            (EntityType::Memory(a), EntityType::Memory(b)) => {
+                a.shared == b.shared && a.memory64 == b.memory64 && limits_match!(a, b)
+            }
+            (EntityType::Global(a), EntityType::Global(b)) => a == b,
+            (EntityType::Tag(a), EntityType::Tag(b)) => {
+                at[*a].as_func_type().unwrap() == bt[*b].as_func_type().unwrap()
+            }
+            _ => false,
+        }
+    }
+
     pub(crate) fn desc(&self) -> &'static str {
         match self {
-            Self::Func(_) => "func",
+            Self::Func(_) => "function",
             Self::Table(_) => "table",
             Self::Memory(_) => "memory",
             Self::Global(_) => "global",
@@ -444,6 +673,26 @@ impl ModuleType {
     pub fn lookup_import(&self, module: &str, name: &str) -> Option<&EntityType> {
         self.imports.get(&(module, name) as &dyn ModuleImportKey)
     }
+
+    /// Determines if module type `a` is a subtype of `b`.
+    pub fn is_subtype_of(a: &Self, at: TypesRef, b: &Self, bt: TypesRef) -> bool {
+        Self::internal_is_subtype_of(a, at.list, b, bt.list)
+    }
+
+    pub(crate) fn internal_is_subtype_of(a: &Self, at: &TypeList, b: &Self, bt: &TypeList) -> bool {
+        // For module type subtyping, all exports in the other module type
+        // must be present in this module type's exports (i.e. it can export
+        // *more* than what this module type needs).
+        // However, for imports, the check is reversed (i.e. it is okay
+        // to import *less* than what this module type needs).
+        a.imports.iter().all(|(k, a)| match b.imports.get(k) {
+            Some(b) => EntityType::internal_is_subtype_of(b, bt, a, at),
+            None => false,
+        }) && b.exports.iter().all(|(k, b)| match a.exports.get(k) {
+            Some(a) => EntityType::internal_is_subtype_of(a, at, b, bt),
+            None => false,
+        })
+    }
 }
 
 /// Represents the kind of module instance type.
@@ -475,7 +724,7 @@ impl InstanceType {
         types: &'a TypeList,
     ) -> &'a IndexMap<String, EntityType> {
         match &self.kind {
-            InstanceTypeKind::Instantiated(id) => &types[*id].unwrap_module().exports,
+            InstanceTypeKind::Instantiated(id) => &types[*id].as_module_type().unwrap().exports,
             InstanceTypeKind::Exports(exports) => exports,
         }
     }
@@ -512,15 +761,56 @@ pub enum ComponentEntityType {
 impl ComponentEntityType {
     /// Determines if component entity type `a` is a subtype of `b`.
     pub fn is_subtype_of(a: &Self, at: TypesRef, b: &Self, bt: TypesRef) -> bool {
-        SubtypeCx::new(at.list, bt.list)
-            .component_entity_type(a, b, 0)
-            .is_ok()
+        Self::internal_is_subtype_of(a, at.list, b, bt.list)
+    }
+
+    pub(crate) fn internal_is_subtype_of(a: &Self, at: &TypeList, b: &Self, bt: &TypeList) -> bool {
+        match (a, b) {
+            (Self::Module(a), Self::Module(b)) => ModuleType::internal_is_subtype_of(
+                at[*a].as_module_type().unwrap(),
+                at,
+                bt[*b].as_module_type().unwrap(),
+                bt,
+            ),
+            (Self::Func(a), Self::Func(b)) => ComponentFuncType::internal_is_subtype_of(
+                at[*a].as_component_func_type().unwrap(),
+                at,
+                bt[*b].as_component_func_type().unwrap(),
+                bt,
+            ),
+            (Self::Value(a), Self::Value(b)) => {
+                ComponentValType::internal_is_subtype_of(a, at, b, bt)
+            }
+            (Self::Type { referenced: a, .. }, Self::Type { referenced: b, .. }) => {
+                ComponentDefinedType::internal_is_subtype_of(
+                    at[*a].as_defined_type().unwrap(),
+                    at,
+                    bt[*b].as_defined_type().unwrap(),
+                    bt,
+                )
+            }
+            (Self::Instance(a), Self::Instance(b)) => {
+                ComponentInstanceType::internal_is_subtype_of(
+                    at[*a].as_component_instance_type().unwrap(),
+                    at,
+                    bt[*b].as_component_instance_type().unwrap(),
+                    bt,
+                )
+            }
+            (Self::Component(a), Self::Component(b)) => ComponentType::internal_is_subtype_of(
+                at[*a].as_component_type().unwrap(),
+                at,
+                bt[*b].as_component_type().unwrap(),
+                bt,
+            ),
+            _ => false,
+        }
     }
 
     pub(crate) fn desc(&self) -> &'static str {
         match self {
             Self::Module(_) => "module",
-            Self::Func(_) => "func",
+            Self::Func(_) => "function",
             Self::Value(_) => "value",
             Self::Type { .. } => "type",
             Self::Instance(_) => "instance",
@@ -545,55 +835,43 @@ impl ComponentEntityType {
 pub struct ComponentType {
     /// The effective type size for the component type.
     pub(crate) type_size: u32,
-
     /// The imports of the component type.
-    ///
-    /// Each import has its own kebab-name and an optional URL listed. Note that
-    /// the set of import names is disjoint with the set of export names.
-    pub imports: IndexMap<String, ComponentEntityType>,
-
+    pub imports: IndexMap<KebabString, (Option<Url>, ComponentEntityType)>,
     /// The exports of the component type.
-    ///
-    /// Each export has its own kebab-name and an optional URL listed. Note that
-    /// the set of export names is disjoint with the set of import names.
-    pub exports: IndexMap<String, ComponentEntityType>,
+    pub exports: IndexMap<KebabString, (Option<Url>, ComponentEntityType)>,
+}
 
-    /// Universally quantified resources required to be provided when
-    /// instantiating this component type.
-    ///
-    /// Each resource in this map is explicitly imported somewhere in the
-    /// `imports` map. The "path" to where it's imported is specified by the
-    /// `Vec<usize>` payload here. For more information about the indexes see
-    /// the documentation on `ComponentState::imported_resources`.
-    ///
-    /// This should technically be inferrable from the structure of `imports`,
-    /// but it's stored as an auxiliary set for subtype checking and
-    /// instantiation.
-    ///
-    /// Note that this is not a set of all resources referred to by the
-    /// `imports`. Instead it's only those created, relative to the internals of
-    /// this component, by the imports.
-    pub imported_resources: Vec<(ResourceId, Vec<usize>)>,
-
-    /// The dual of the `imported_resources`, or the set of defined
-    /// resources -- those created through the instantiation process which are
-    /// unique to this component.
-    ///
-    /// This set is similar to the `imported_resources` set but it's those
-    /// contained within the `exports`. Instantiating this component will
-    /// create fresh new versions of all of these resources. The path here is
-    /// within the `exports` array.
-    pub defined_resources: Vec<(ResourceId, Vec<usize>)>,
-
-    /// The set of all resources which are explicitly exported by this
-    /// component, and where they're exported.
-    ///
-    /// This mapping is stored separately from `defined_resources` to ensure
-    /// that it contains all exported resources, not just those which are
-    /// defined. That means that this can cover reexports of imported
-    /// resources, exports of local resources, or exports of closed-over
-    /// resources for example.
-    pub explicit_resources: IndexMap<ResourceId, Vec<usize>>,
+impl ComponentType {
+    /// Determines if component type `a` is a subtype of `b`.
+    pub fn is_subtype_of(a: &Self, at: TypesRef, b: &Self, bt: TypesRef) -> bool {
+        Self::internal_is_subtype_of(a, at.list, b, bt.list)
+    }
+
+    pub(crate) fn internal_is_subtype_of(a: &Self, at: &TypeList, b: &Self, bt: &TypeList) -> bool {
+        // For component type subtyping, all exports in the other component type
+        // must be present in this component type's exports (i.e. it can export
+        // *more* than what this component type needs).
+        // However, for imports, the check is reversed (i.e. it is okay
+        // to import *less* than what this component type needs).
+        a.imports.iter().all(|(k, (_, a))| match b.imports.get(k) {
+            Some((_, b)) => ComponentEntityType::internal_is_subtype_of(b, bt, a, at),
+            None => false,
+        }) && b.exports.iter().all(|(k, (_, b))| match a.exports.get(k) {
+            Some((_, a)) => ComponentEntityType::internal_is_subtype_of(a, at, b, bt),
+            None => false,
+        })
+    }
+}
+
+/// Represents the kind of a component instance.
+#[derive(Debug, Clone)]
+pub enum ComponentInstanceTypeKind {
+    /// The instance type is from a definition.
+    Defined(IndexMap<KebabString, (Option<Url>, ComponentEntityType)>),
+    /// The instance type is the result of instantiating a component type.
+    Instantiated(TypeId),
+    /// The instance type is the result of instantiating from exported items.
+    Exports(IndexMap<KebabString, (Option<Url>, ComponentEntityType)>),
 }
 
 /// Represents a type of a component instance.
@@ -601,49 +879,53 @@ pub struct ComponentType {
 pub struct ComponentInstanceType {
     /// The effective type size for the instance type.
     pub(crate) type_size: u32,
+    /// The kind of instance type.
+    pub kind: ComponentInstanceTypeKind,
+}
 
-    /// The list of exports, keyed by name, that this instance has.
-    ///
-    /// An optional URL and type of each export is provided as well.
-    pub exports: IndexMap<String, ComponentEntityType>,
+impl ComponentInstanceType {
+    /// Gets the exports of the instance type.
+    pub fn exports<'a>(
+        &'a self,
+        types: TypesRef<'a>,
+    ) -> impl ExactSizeIterator<Item = (&'a KebabStr, &'a Option<Url>, ComponentEntityType)> + Clone
+    {
+        self.internal_exports(types.list)
+            .iter()
+            .map(|(n, (u, t))| (n.as_kebab_str(), u, *t))
+    }
 
-    /// The list of "defined resources" or those which are closed over in
-    /// this instance type.
-    ///
-    /// This list is populated, for example, when the type of an instance is
-    /// declared and it contains its own resource type exports defined
-    /// internally. For example:
-    ///
-    /// ```wasm
-    /// (component
-    ///     (type (instance
-    ///         (export "x" (type sub resource)) ;; one `defined_resources` entry
-    ///     ))
-    /// )
-    /// ```
-    ///
-    /// This list is also a bit of an oddity, however, because the type of a
-    /// concrete instance will always have this as empty. For example:
-    ///
-    /// ```wasm
-    /// (component
-    ///     (type $t (instance (export "x" (type sub resource))))
-    ///
-    ///     ;; the type of this instance has no defined resources
-    ///     (import "i" (instance (type $t)))
-    /// )
-    /// ```
-    ///
-    /// This list ends up only being populated for instance types declared in a
-    /// module which aren't yet "attached" to anything. Once something is
-    /// instantiated, imported, exported, or otherwise refers to a concrete
-    /// instance then this list is always empty. For concrete instances
-    /// defined resources are tracked in the component state or component type.
-    pub defined_resources: Vec<ResourceId>,
+    pub(crate) fn internal_exports<'a>(
+        &'a self,
+        types: &'a TypeList,
+    ) -> &'a IndexMap<KebabString, (Option<Url>, ComponentEntityType)> {
+        match &self.kind {
+            ComponentInstanceTypeKind::Defined(exports)
+            | ComponentInstanceTypeKind::Exports(exports) => exports,
+            ComponentInstanceTypeKind::Instantiated(id) => {
+                &types[*id].as_component_type().unwrap().exports
+            }
+        }
+    }
+
+    /// Determines if component instance type `a` is a subtype of `b`.
+    pub fn is_subtype_of(a: &Self, at: TypesRef, b: &Self, bt: TypesRef) -> bool {
+        Self::internal_is_subtype_of(a, at.list, b, bt.list)
+    }
+
+    pub(crate) fn internal_is_subtype_of(a: &Self, at: &TypeList, b: &Self, bt: &TypeList) -> bool {
+        let exports = a.internal_exports(at);
 
-    /// The list of all resources that are explicitly exported from this
-    /// instance type along with the path they're exported at.
-    pub explicit_resources: IndexMap<ResourceId, Vec<usize>>,
+        // For instance type subtyping, all exports in the other instance type
+        // must be present in this instance type's exports (i.e. it can export
+        // *more* than what this instance type needs).
+        b.internal_exports(bt)
+            .iter()
+            .all(|(k, (_, b))| match exports.get(k) {
+                Some((_, a)) => ComponentEntityType::internal_is_subtype_of(a, at, b, bt),
+                None => false,
+            })
+    }
 }
 
 /// Represents a type of a component function.
@@ -658,6 +940,54 @@ pub struct ComponentFuncType {
 }
 
 impl ComponentFuncType {
+    /// Determines if component function type `a` is a subtype of `b`.
+    pub fn is_subtype_of(a: &Self, at: TypesRef, b: &Self, bt: TypesRef) -> bool {
+        Self::internal_is_subtype_of(a, at.list, b, bt.list)
+    }
+
+    pub(crate) fn internal_is_subtype_of(a: &Self, at: &TypeList, b: &Self, bt: &TypeList) -> bool {
+        // Note that this intentionally diverges from the upstream specification
+        // in terms of subtyping. This is a full type-equality check which
+        // ensures that the structure of `a` exactly matches the structure of
+        // `b`. The rationale for this is:
+        //
+        // * Primarily in Wasmtime subtyping based on function types is not
+        //   implemented. This includes both subtyping a host import and
+        //   additionally handling subtyping as functions cross component
+        //   boundaries. The host import subtyping (or component export
+        //   subtyping) is not clear how to handle at all at this time. The
+        //   subtyping of functions between components can more easily be
+        //   handled by extending the `fact` compiler, but that hasn't been done
+        //   yet.
+        //
+        // * The upstream specification is currently pretty intentionally vague
+        //   precisely what subtyping is allowed. Implementing a strict check
+        //   here is intended to be a conservative starting point for the
+        //   component model which can be extended in the future if necessary.
+        //
+        // * The interaction with subtyping on bindings generation, for example,
+        //   is a tricky problem that doesn't have a clear answer at this time.
+        //   Effectively this is more rationale for being conservative in the
+        //   first pass of the component model.
+        //
+        // So, in conclusion, the test here (and other places that reference
+        // this comment) is for exact type equality with no differences.
+        a.params.len() == b.params.len()
+            && a.results.len() == b.results.len()
+            && a.params
+                .iter()
+                .zip(b.params.iter())
+                .all(|((an, a), (bn, b))| {
+                    an == bn && ComponentValType::internal_is_subtype_of(a, at, b, bt)
+                })
+            && a.results
+                .iter()
+                .zip(b.results.iter())
+                .all(|((an, a), (bn, b))| {
+                    an == bn && ComponentValType::internal_is_subtype_of(a, at, b, bt)
+                })
+    }
+
     /// Lowers the component function type to core parameter and result types for the
     /// canonical ABI.
     pub(crate) fn lower(&self, types: &TypeList, import: bool) -> LoweringInfo {
@@ -788,10 +1118,6 @@ pub enum ComponentDefinedType {
         /// The `error` type.
         err: Option<ComponentValType>,
     },
-    /// The type is an owned handle to the specified resource.
-    Own(TypeId),
-    /// The type is a borrowed handle to the specified resource.
-    Borrow(TypeId),
 }
 
 impl ComponentDefinedType {
@@ -807,7 +1133,7 @@ impl ComponentDefinedType {
             Self::List(_) => true,
             Self::Tuple(t) => t.types.iter().any(|ty| ty.requires_realloc(types)),
             Self::Union(u) => u.types.iter().any(|ty| ty.requires_realloc(types)),
-            Self::Flags(_) | Self::Enum(_) | Self::Own(_) | Self::Borrow(_) => false,
+            Self::Flags(_) | Self::Enum(_) => false,
             Self::Option(ty) => ty.requires_realloc(types),
             Self::Result { ok, err } => {
                 ok.map(|ty| ty.requires_realloc(types)).unwrap_or(false)
@@ -816,13 +1142,78 @@ impl ComponentDefinedType {
         }
     }
 
+    /// Determines if component defined type `a` is a subtype of `b`.
+    pub fn is_subtype_of(a: &Self, at: TypesRef, b: &Self, bt: TypesRef) -> bool {
+        Self::internal_is_subtype_of(a, at.list, b, bt.list)
+    }
+
+    pub(crate) fn internal_is_subtype_of(a: &Self, at: &TypeList, b: &Self, bt: &TypeList) -> bool {
+        // Note that the implementation of subtyping here diverges from the
+        // upstream specification intentionally, see the documentation on
+        // function subtyping for more information.
+        match (a, b) {
+            (Self::Primitive(a), Self::Primitive(b)) => PrimitiveValType::is_subtype_of(*a, *b),
+            (Self::Record(a), Self::Record(b)) => {
+                a.fields.len() == b.fields.len()
+                    && a.fields
+                        .iter()
+                        .zip(b.fields.iter())
+                        .all(|((aname, a), (bname, b))| {
+                            aname == bname && ComponentValType::internal_is_subtype_of(a, at, b, bt)
+                        })
+            }
+            (Self::Variant(a), Self::Variant(b)) => {
+                a.cases.len() == b.cases.len()
+                    && a.cases
+                        .iter()
+                        .zip(b.cases.iter())
+                        .all(|((aname, a), (bname, b))| {
+                            aname == bname
+                                && match (&a.ty, &b.ty) {
+                                    (Some(a), Some(b)) => {
+                                        ComponentValType::internal_is_subtype_of(a, at, b, bt)
+                                    }
+                                    (None, None) => true,
+                                    _ => false,
+                                }
+                        })
+            }
+            (Self::List(a), Self::List(b)) | (Self::Option(a), Self::Option(b)) => {
+                ComponentValType::internal_is_subtype_of(a, at, b, bt)
+            }
+            (Self::Tuple(a), Self::Tuple(b)) => {
+                if a.types.len() != b.types.len() {
+                    return false;
+                }
+                a.types
+                    .iter()
+                    .zip(b.types.iter())
+                    .all(|(a, b)| ComponentValType::internal_is_subtype_of(a, at, b, bt))
+            }
+            (Self::Union(a), Self::Union(b)) => {
+                if a.types.len() != b.types.len() {
+                    return false;
+                }
+                a.types
+                    .iter()
+                    .zip(b.types.iter())
+                    .all(|(a, b)| ComponentValType::internal_is_subtype_of(a, at, b, bt))
+            }
+            (Self::Flags(a), Self::Flags(b)) | (Self::Enum(a), Self::Enum(b)) => {
+                a.len() == b.len() && a.iter().eq(b.iter())
+            }
+            (Self::Result { ok: ao, err: ae }, Self::Result { ok: bo, err: be }) => {
+                Self::is_optional_subtype_of(*ao, at, *bo, bt)
+                    && Self::is_optional_subtype_of(*ae, at, *be, bt)
+            }
+            _ => false,
+        }
+    }
+
     pub(crate) fn type_size(&self) -> u32 {
         match self {
-            Self::Primitive(_)
-            | Self::Flags(_)
-            | Self::Enum(_)
-            | Self::Own(_)
-            | Self::Borrow(_) => 1,
+            Self::Primitive(_) => 1,
+            Self::Flags(_) | Self::Enum(_) => 1,
             Self::Record(r) => r.type_size,
             Self::Variant(v) => v.type_size,
             Self::Tuple(t) => t.type_size,
@@ -834,6 +1225,18 @@ impl ComponentDefinedType {
         }
     }
 
+    fn is_optional_subtype_of(
+        a: Option<ComponentValType>,
+        at: &TypeList,
+        b: Option<ComponentValType>,
+        bt: &TypeList,
+    ) -> bool {
+        match (a, b) {
+            (None, None) => true,
+            (Some(a), Some(b)) => ComponentValType::internal_is_subtype_of(&a, at, &b, bt),
+            _ => false,
+        }
+    }
     fn push_wasm_types(&self, types: &TypeList, lowered_types: &mut LoweredTypes) -> bool {
         match self {
             Self::Primitive(ty) => push_primitive_wasm_types(ty, lowered_types),
@@ -854,7 +1257,7 @@ impl ComponentDefinedType {
             Self::Flags(names) => {
                 (0..(names.len() + 31) / 32).all(|_| lowered_types.push(ValType::I32))
             }
-            Self::Enum(_) | Self::Own(_) | Self::Borrow(_) => lowered_types.push(ValType::I32),
+            Self::Enum(_) => lowered_types.push(ValType::I32),
             Self::Union(u) => Self::push_variant_wasm_types(u.types.iter(), types, lowered_types),
             Self::Option(ty) => {
                 Self::push_variant_wasm_types([ty].into_iter(), types, lowered_types)
@@ -909,50 +1312,6 @@ impl ComponentDefinedType {
             _ => panic!("unexpected wasm type for canonical ABI"),
         }
     }
-
-    fn desc(&self) -> &'static str {
-        match self {
-            ComponentDefinedType::Record(_) => "record",
-            ComponentDefinedType::Primitive(_) => "primitive",
-            ComponentDefinedType::Variant(_) => "variant",
-            ComponentDefinedType::Tuple(_) => "tuple",
-            ComponentDefinedType::Enum(_) => "enum",
-            ComponentDefinedType::Flags(_) => "flags",
-            ComponentDefinedType::Option(_) => "option",
-            ComponentDefinedType::List(_) => "list",
-            ComponentDefinedType::Union(_) => "union",
-            ComponentDefinedType::Result { .. } => "result",
-            ComponentDefinedType::Own(_) => "own",
-            ComponentDefinedType::Borrow(_) => "borrow",
-        }
-    }
-}
-
-/// An opaque identifier intended to be used to distinguish whether two
-/// resource types are equivalent or not.
-#[derive(Debug, Clone, PartialEq, Eq, Hash, Ord, PartialOrd, Copy)]
-#[repr(packed(4))] // try to not waste 4 bytes in padding
-pub struct ResourceId {
-    // This is a globally unique identifier which is assigned once per
-    // `TypeAlloc`. This ensures that resource identifiers from different
-    // instances of `Types`, for example, are considered unique.
-    //
-    // Technically 64-bits should be enough for all resource ids ever, but
-    // they're allocated so often it's predicted that an atomic increment
-    // per resource id is probably too expensive. To amortize that cost each
-    // top-level wasm component gets a single globally unique identifier, and
-    // then within a component contextually unique identifiers are handed out.
-    globally_unique_id: u64,
-
-    // A contextually unique id within the globally unique id above. This is
-    // allocated within a `TypeAlloc` with its own counter, and allocations of
-    // this are cheap as nothing atomic is required.
-    //
-    // The 32-bit storage here should ideally be enough for any component
-    // containing resources. If memory usage becomes an issue (this struct is
-    // 12 bytes instead of 8 or 4) then this coudl get folded into the globally
-    // unique id with everything using an atomic increment perhaps.
-    contextually_unique_id: u32,
 }
 
 #[allow(clippy::large_enum_variant)]
@@ -999,303 +1358,233 @@ impl<'a> TypesRef<'a> {
         }
     }
 
+    fn types(&self, core: bool) -> Option<&'a [TypeId]> {
+        Some(match &self.kind {
+            TypesRefKind::Module(module) => {
+                if core {
+                    &module.types
+                } else {
+                    return None;
+                }
+            }
+            TypesRefKind::Component(component) => {
+                if core {
+                    &component.core_types
+                } else {
+                    &component.types
+                }
+            }
+        })
+    }
+
     /// Gets a type based on its type id.
     ///
     /// Returns `None` if the type id is unknown.
-    pub fn get(&self, id: TypeId) -> Option<&'a Type> {
+    pub fn type_from_id(&self, id: TypeId) -> Option<&'a Type> {
         self.list.get(id.index)
     }
 
-    /// Gets a core WebAssembly type id from a type index.
-    ///
-    /// Note that this is in contrast to [`TypesRef::component_type_at`] which
-    /// gets a component type from its index.
-    ///
-    /// # Panics
-    ///
-    /// This will panic if the `index` provided is out of bounds.
-    pub fn core_type_at(&self, index: u32) -> TypeId {
-        match &self.kind {
-            TypesRefKind::Module(module) => module.types[index as usize],
-            TypesRefKind::Component(component) => component.core_types[index as usize],
-        }
-    }
-
     /// Gets a type id from a type index.
     ///
-    /// # Panics
-    ///
-    /// Panics if `index` is not a valid function index or if this type
-    /// information represents a core module.
-    pub fn component_type_at(&self, index: u32) -> TypeId {
-        match &self.kind {
-            TypesRefKind::Module(_) => panic!("not a component"),
-            TypesRefKind::Component(component) => component.types[index as usize],
-        }
+    /// Returns `None` if the type index is out of bounds or the type has not
+    /// been parsed yet.
+    pub fn id_from_type_index(&self, index: u32, core: bool) -> Option<TypeId> {
+        self.types(core)?.get(index as usize).copied()
     }
 
-    /// Returns the number of core types defined so far.
-    pub fn core_type_count(&self) -> u32 {
-        match &self.kind {
-            TypesRefKind::Module(module) => module.types.len() as u32,
-            TypesRefKind::Component(component) => component.core_types.len() as u32,
-        }
+    /// Gets a type at the given type index.
+    ///
+    /// Returns `None` if the type index is out of bounds or the type has not
+    /// been parsed yet.
+    pub fn type_at(&self, index: u32, core: bool) -> Option<&'a Type> {
+        self.type_from_id(*self.types(core)?.get(index as usize)?)
     }
 
-    /// Returns the number of component types defined so far.
-    pub fn component_type_count(&self) -> u32 {
-        match &self.kind {
-            TypesRefKind::Module(_module) => 0,
-            TypesRefKind::Component(component) => component.types.len() as u32,
+    /// Gets a defined core function type at the given type index.
+    ///
+    /// Returns `None` if the type index is out of bounds or the type has not
+    /// been parsed yet.
+    pub fn func_type_at(&self, index: u32) -> Option<&'a FuncType> {
+        match self.type_at(index, true)? {
+            Type::Func(ty) => Some(ty),
+            _ => None,
         }
     }
 
     /// Gets the type of a table at the given table index.
     ///
-    /// # Panics
-    ///
-    /// This will panic if the `index` provided is out of bounds.
-    pub fn table_at(&self, index: u32) -> TableType {
+    /// Returns `None` if the type index is out of bounds or the type has not
+    /// been parsed yet.
+    pub fn table_at(&self, index: u32) -> Option<TableType> {
         let tables = match &self.kind {
             TypesRefKind::Module(module) => &module.tables,
             TypesRefKind::Component(component) => &component.core_tables,
         };
-        tables[index as usize]
-    }
 
-    /// Returns the number of tables defined so far.
-    pub fn table_count(&self) -> u32 {
-        match &self.kind {
-            TypesRefKind::Module(module) => module.tables.len() as u32,
-            TypesRefKind::Component(component) => component.core_tables.len() as u32,
-        }
+        tables.get(index as usize).copied()
     }
 
     /// Gets the type of a memory at the given memory index.
     ///
-    /// # Panics
-    ///
-    /// This will panic if the `index` provided is out of bounds.
-    pub fn memory_at(&self, index: u32) -> MemoryType {
+    /// Returns `None` if the type index is out of bounds or the type has not
+    /// been parsed yet.
+    pub fn memory_at(&self, index: u32) -> Option<MemoryType> {
         let memories = match &self.kind {
             TypesRefKind::Module(module) => &module.memories,
             TypesRefKind::Component(component) => &component.core_memories,
         };
 
-        memories[index as usize]
-    }
-
-    /// Returns the number of memories defined so far.
-    pub fn memory_count(&self) -> u32 {
-        match &self.kind {
-            TypesRefKind::Module(module) => module.memories.len() as u32,
-            TypesRefKind::Component(component) => component.core_memories.len() as u32,
-        }
+        memories.get(index as usize).copied()
     }
 
     /// Gets the type of a global at the given global index.
     ///
-    /// # Panics
-    ///
-    /// This will panic if the `index` provided is out of bounds.
-    pub fn global_at(&self, index: u32) -> GlobalType {
+    /// Returns `None` if the type index is out of bounds or the type has not
+    /// been parsed yet.
+    pub fn global_at(&self, index: u32) -> Option<GlobalType> {
         let globals = match &self.kind {
             TypesRefKind::Module(module) => &module.globals,
             TypesRefKind::Component(component) => &component.core_globals,
         };
 
-        globals[index as usize]
-    }
-
-    /// Returns the number of globals defined so far.
-    pub fn global_count(&self) -> u32 {
-        match &self.kind {
-            TypesRefKind::Module(module) => module.globals.len() as u32,
-            TypesRefKind::Component(component) => component.core_globals.len() as u32,
-        }
+        globals.get(index as usize).copied()
     }
 
     /// Gets the type of a tag at the given tag index.
     ///
-    /// # Panics
-    ///
-    /// This will panic if the `index` provided is out of bounds.
-    pub fn tag_at(&self, index: u32) -> TypeId {
+    /// Returns `None` if the type index is out of bounds or the type has not
+    /// been parsed yet.
+    pub fn tag_at(&self, index: u32) -> Option<&'a FuncType> {
         let tags = match &self.kind {
             TypesRefKind::Module(module) => &module.tags,
             TypesRefKind::Component(component) => &component.core_tags,
         };
-        tags[index as usize]
-    }
 
-    /// Returns the number of tags defined so far.
-    pub fn tag_count(&self) -> u32 {
-        match &self.kind {
-            TypesRefKind::Module(module) => module.tags.len() as u32,
-            TypesRefKind::Component(component) => component.core_tags.len() as u32,
-        }
+        Some(
+            self.list[*tags.get(index as usize)?]
+                .as_func_type()
+                .unwrap(),
+        )
     }
 
     /// Gets the type of a core function at the given function index.
     ///
-    /// # Panics
-    ///
-    /// This will panic if the `index` provided is out of bounds.
-    pub fn function_at(&self, index: u32) -> TypeId {
-        match &self.kind {
-            TypesRefKind::Module(module) => module.types[module.functions[index as usize] as usize],
-            TypesRefKind::Component(component) => component.core_funcs[index as usize],
-        }
-    }
+    /// Returns `None` if the type index is out of bounds or the type has not
+    /// been parsed yet.
+    pub fn function_at(&self, index: u32) -> Option<&'a FuncType> {
+        let id = match &self.kind {
+            TypesRefKind::Module(module) => {
+                &module.types[*module.functions.get(index as usize)? as usize]
+            }
+            TypesRefKind::Component(component) => component.core_funcs.get(index as usize)?,
+        };
 
-    /// Gets the count of core functions defined so far.
-    ///
-    /// Note that this includes imported functions, defined functions, and for
-    /// components lowered/aliased functions.
-    pub fn function_count(&self) -> u32 {
-        match &self.kind {
-            TypesRefKind::Module(module) => module.functions.len() as u32,
-            TypesRefKind::Component(component) => component.core_funcs.len() as u32,
+        match &self.list[*id] {
+            Type::Func(ty) => Some(ty),
+            _ => None,
         }
     }
 
     /// Gets the type of an element segment at the given element segment index.
     ///
-    /// # Panics
-    ///
-    /// This will panic if the `index` provided is out of bounds.
-    pub fn element_at(&self, index: u32) -> RefType {
-        match &self.kind {
-            TypesRefKind::Module(module) => module.element_types[index as usize],
-            TypesRefKind::Component(_) => {
-                panic!("no elements on a component")
-            }
-        }
-    }
-
-    /// Returns the number of elements defined so far.
-    pub fn element_count(&self) -> u32 {
+    /// Returns `None` if the type index is out of bounds or the type has not
+    /// been parsed yet.
+    pub fn element_at(&self, index: u32) -> Option<RefType> {
         match &self.kind {
-            TypesRefKind::Module(module) => module.element_types.len() as u32,
-            TypesRefKind::Component(_) => 0,
+            TypesRefKind::Module(module) => module.element_types.get(index as usize).copied(),
+            TypesRefKind::Component(_) => None,
         }
     }
 
     /// Gets the type of a component function at the given function index.
     ///
-    /// # Panics
-    ///
-    /// This will panic if the `index` provided is out of bounds or if this type
-    /// information represents a core module.
-    pub fn component_function_at(&self, index: u32) -> TypeId {
-        match &self.kind {
-            TypesRefKind::Module(_) => panic!("not a component"),
-            TypesRefKind::Component(component) => component.funcs[index as usize],
-        }
-    }
-
-    /// Returns the number of component functions defined so far.
-    pub fn component_function_count(&self) -> u32 {
+    /// Returns `None` if the type index is out of bounds or the type has not
+    /// been parsed yet.
+    pub fn component_function_at(&self, index: u32) -> Option<&'a ComponentFuncType> {
         match &self.kind {
-            TypesRefKind::Module(_module) => 0,
-            TypesRefKind::Component(component) => component.funcs.len() as u32,
+            TypesRefKind::Module(_) => None,
+            TypesRefKind::Component(component) => Some(
+                self.list[*component.funcs.get(index as usize)?]
+                    .as_component_func_type()
+                    .unwrap(),
+            ),
         }
     }
 
     /// Gets the type of a module at the given module index.
     ///
-    /// # Panics
-    ///
-    /// This will panic if the `index` provided is out of bounds or if this type
-    /// information represents a core module.
-    pub fn module_at(&self, index: u32) -> TypeId {
-        match &self.kind {
-            TypesRefKind::Module(_) => panic!("not a component"),
-            TypesRefKind::Component(component) => component.core_modules[index as usize],
-        }
-    }
-
-    /// Returns the number of core wasm modules defined so far.
-    pub fn module_count(&self) -> u32 {
+    /// Returns `None` if the type index is out of bounds or the type has not
+    /// been parsed yet.
+    pub fn module_at(&self, index: u32) -> Option<&'a ModuleType> {
         match &self.kind {
-            TypesRefKind::Module(_module) => 0,
-            TypesRefKind::Component(component) => component.core_modules.len() as u32,
+            TypesRefKind::Module(_) => None,
+            TypesRefKind::Component(component) => Some(
+                self.list[*component.core_modules.get(index as usize)?]
+                    .as_module_type()
+                    .unwrap(),
+            ),
         }
     }
 
     /// Gets the type of a module instance at the given module instance index.
     ///
-    /// # Panics
-    ///
-    /// This will panic if the `index` provided is out of bounds or if this type
-    /// information represents a core module.
-    pub fn instance_at(&self, index: u32) -> TypeId {
-        match &self.kind {
-            TypesRefKind::Module(_) => panic!("not a component"),
-            TypesRefKind::Component(component) => component.core_instances[index as usize],
-        }
-    }
-
-    /// Returns the number of core wasm instances defined so far.
-    pub fn instance_count(&self) -> u32 {
+    /// Returns `None` if the type index is out of bounds or the type has not
+    /// been parsed yet.
+    pub fn instance_at(&self, index: u32) -> Option<&'a InstanceType> {
         match &self.kind {
-            TypesRefKind::Module(_module) => 0,
-            TypesRefKind::Component(component) => component.core_instances.len() as u32,
+            TypesRefKind::Module(_) => None,
+            TypesRefKind::Component(component) => {
+                let id = component.core_instances.get(index as usize)?;
+                match &self.list[*id] {
+                    Type::Instance(ty) => Some(ty),
+                    _ => None,
+                }
+            }
         }
     }
 
     /// Gets the type of a component at the given component index.
     ///
-    /// # Panics
-    ///
-    /// This will panic if the `index` provided is out of bounds or if this type
-    /// information represents a core module.
-    pub fn component_at(&self, index: u32) -> TypeId {
-        match &self.kind {
-            TypesRefKind::Module(_) => panic!("not a component"),
-            TypesRefKind::Component(component) => component.components[index as usize],
-        }
-    }
-
-    /// Returns the number of components defined so far.
-    pub fn component_count(&self) -> u32 {
+    /// Returns `None` if the type index is out of bounds or the type has not
+    /// been parsed yet.
+    pub fn component_at(&self, index: u32) -> Option<&'a ComponentType> {
         match &self.kind {
-            TypesRefKind::Module(_module) => 0,
-            TypesRefKind::Component(component) => component.components.len() as u32,
+            TypesRefKind::Module(_) => None,
+            TypesRefKind::Component(component) => Some(
+                self.list[*component.components.get(index as usize)?]
+                    .as_component_type()
+                    .unwrap(),
+            ),
         }
     }
 
     /// Gets the type of an component instance at the given component instance index.
     ///
-    /// # Panics
-    ///
-    /// This will panic if the `index` provided is out of bounds or if this type
-    /// information represents a core module.
-    pub fn component_instance_at(&self, index: u32) -> TypeId {
-        match &self.kind {
-            TypesRefKind::Module(_) => panic!("not a component"),
-            TypesRefKind::Component(component) => component.instances[index as usize],
-        }
-    }
-
-    /// Returns the number of component instances defined so far.
-    pub fn component_instance_count(&self) -> u32 {
+    /// Returns `None` if the type index is out of bounds or the type has not
+    /// been parsed yet.
+    pub fn component_instance_at(&self, index: u32) -> Option<&'a ComponentInstanceType> {
         match &self.kind {
-            TypesRefKind::Module(_module) => 0,
-            TypesRefKind::Component(component) => component.instances.len() as u32,
+            TypesRefKind::Module(_) => None,
+            TypesRefKind::Component(component) => {
+                let id = component.instances.get(index as usize)?;
+                match &self.list[*id] {
+                    Type::ComponentInstance(ty) => Some(ty),
+                    _ => None,
+                }
+            }
         }
     }
 
     /// Gets the type of a value at the given value index.
     ///
-    /// # Panics
-    ///
-    /// This will panic if the `index` provided is out of bounds or if this type
-    /// information represents a core module.
-    pub fn value_at(&self, index: u32) -> ComponentValType {
+    /// Returns `None` if the type index is out of bounds or the type has not
+    /// been parsed yet.
+    pub fn value_at(&self, index: u32) -> Option<ComponentValType> {
         match &self.kind {
-            TypesRefKind::Module(_) => panic!("not a component"),
-            TypesRefKind::Component(component) => component.values[index as usize].0,
+            TypesRefKind::Module(_) => None,
+            TypesRefKind::Component(component) => {
+                component.values.get(index as usize).map(|(r, _)| *r)
+            }
         }
     }
 
@@ -1338,29 +1627,17 @@ impl<'a> TypesRef<'a> {
     }
 
     /// Gets the component entity type for the given component import.
-    pub fn component_entity_type_of_import(&self, name: &str) -> Option<ComponentEntityType> {
-        match &self.kind {
-            TypesRefKind::Module(_) => None,
-            TypesRefKind::Component(component) => Some(*component.imports.get(name)?),
-        }
-    }
-
-    /// Gets the component entity type for the given component export.
-    pub fn component_entity_type_of_export(&self, name: &str) -> Option<ComponentEntityType> {
+    pub fn component_entity_type_of_extern(&self, name: &str) -> Option<ComponentEntityType> {
         match &self.kind {
             TypesRefKind::Module(_) => None,
-            TypesRefKind::Component(component) => Some(*component.exports.get(name)?),
+            TypesRefKind::Component(component) => {
+                let key = KebabStr::new(name)?;
+                Some(component.externs.get(key)?.1)
+            }
         }
     }
 }
 
-impl Index<TypeId> for TypesRef<'_> {
-    type Output = Type;
-    fn index(&self, id: TypeId) -> &Type {
-        &self.list[id.index]
-    }
-}
-
 impl Types {
     pub(crate) fn from_module(types: TypeList, module: Arc<Module>) -> Self {
         Self {
@@ -1390,30 +1667,29 @@ impl Types {
     /// Gets a type based on its type id.
     ///
     /// Returns `None` if the type id is unknown.
-    pub fn get(&self, id: TypeId) -> Option<&Type> {
-        self.as_ref().get(id)
+    pub fn type_from_id(&self, id: TypeId) -> Option<&Type> {
+        self.as_ref().type_from_id(id)
     }
 
-    /// Gets a core WebAssembly type at the given type index.
-    ///
-    /// Note that this is in contrast to [`TypesRef::component_type_at`] which
-    /// gets a component type from its index.
-    ///
-    /// # Panics
+    /// Gets a type id from a type index.
     ///
-    /// Panics if `index` is not a valid function index.
-    pub fn core_type_at(&self, index: u32) -> TypeId {
-        self.as_ref().core_type_at(index)
+    /// Returns `None` if the type index is out of bounds.
+    pub fn id_from_type_index(&self, index: u32, core: bool) -> Option<TypeId> {
+        self.as_ref().id_from_type_index(index, core)
     }
 
-    /// Gets a component type from the given component type index.
+    /// Gets a type at the given type index.
     ///
-    /// # Panics
+    /// Returns `None` if the index is out of bounds.
+    pub fn type_at(&self, index: u32, core: bool) -> Option<&Type> {
+        self.as_ref().type_at(index, core)
+    }
+
+    /// Gets a defined core function type at the given type index.
     ///
-    /// Panics if `index` is not a valid function index or if this type
-    /// information represents a core module.
-    pub fn component_type_at(&self, index: u32) -> TypeId {
-        self.as_ref().component_type_at(index)
+    /// Returns `None` if the index is out of bounds.
+    pub fn func_type_at(&self, index: u32) -> Option<&FuncType> {
+        self.as_ref().func_type_at(index)
     }
 
     /// Gets the count of core types.
@@ -1426,10 +1702,8 @@ impl Types {
 
     /// Gets the type of a table at the given table index.
     ///
-    /// # Panics
-    ///
-    /// Panics if `index` is not a valid function index.
-    pub fn table_at(&self, index: u32) -> TableType {
+    /// Returns `None` if the index is out of bounds.
+    pub fn table_at(&self, index: u32) -> Option<TableType> {
         self.as_ref().table_at(index)
     }
 
@@ -1443,99 +1717,103 @@ impl Types {
 
     /// Gets the type of a memory at the given memory index.
     ///
-    /// # Panics
-    ///
-    /// Panics if `index` is not a valid function index.
-    pub fn memory_at(&self, index: u32) -> MemoryType {
+    /// Returns `None` if the index is out of bounds.
+    pub fn memory_at(&self, index: u32) -> Option<MemoryType> {
         self.as_ref().memory_at(index)
     }
 
     /// Gets the count of imported and defined memories.
-    pub fn memory_count(&self) -> u32 {
-        self.as_ref().memory_count()
+    pub fn memory_count(&self) -> usize {
+        match &self.kind {
+            TypesKind::Module(module) => module.memories.len(),
+            TypesKind::Component(component) => component.core_memories.len(),
+        }
     }
 
     /// Gets the type of a global at the given global index.
     ///
-    /// # Panics
-    ///
-    /// Panics if `index` is not a valid function index.
-    pub fn global_at(&self, index: u32) -> GlobalType {
+    /// Returns `None` if the index is out of bounds.
+    pub fn global_at(&self, index: u32) -> Option<GlobalType> {
         self.as_ref().global_at(index)
     }
 
     /// Gets the count of imported and defined globals.
-    pub fn global_count(&self) -> u32 {
-        self.as_ref().global_count()
+    pub fn global_count(&self) -> usize {
+        match &self.kind {
+            TypesKind::Module(module) => module.globals.len(),
+            TypesKind::Component(component) => component.core_globals.len(),
+        }
     }
 
     /// Gets the type of a tag at the given tag index.
     ///
-    /// # Panics
-    ///
-    /// Panics if `index` is not a valid function index.
-    pub fn tag_at(&self, index: u32) -> TypeId {
+    /// Returns `None` if the index is out of bounds.
+    pub fn tag_at(&self, index: u32) -> Option<&FuncType> {
         self.as_ref().tag_at(index)
     }
 
     /// Gets the count of imported and defined tags.
-    pub fn tag_count(&self) -> u32 {
-        self.as_ref().tag_count()
+    pub fn tag_count(&self) -> usize {
+        match &self.kind {
+            TypesKind::Module(module) => module.tags.len(),
+            TypesKind::Component(component) => component.core_tags.len(),
+        }
     }
 
     /// Gets the type of a core function at the given function index.
     ///
-    /// # Panics
-    ///
-    /// Panics if `index` is not a valid function index.
-    pub fn function_at(&self, index: u32) -> TypeId {
+    /// Returns `None` if the index is out of bounds.
+    pub fn function_at(&self, index: u32) -> Option<&FuncType> {
         self.as_ref().function_at(index)
     }
 
-    /// Gets the count of core functions defined so far.
+    /// Gets the count of imported and defined core functions.
     ///
-    /// Note that this includes imported functions, defined functions, and for
-    /// components lowered/aliased functions.
-    pub fn function_count(&self) -> u32 {
-        self.as_ref().function_count()
+    /// The count also includes aliased core functions in components.
+    pub fn function_count(&self) -> usize {
+        match &self.kind {
+            TypesKind::Module(module) => module.functions.len(),
+            TypesKind::Component(component) => component.core_funcs.len(),
+        }
     }
 
     /// Gets the type of an element segment at the given element segment index.
     ///
-    /// # Panics
-    ///
-    /// This will panic if the `index` provided is out of bounds.
-    pub fn element_at(&self, index: u32) -> RefType {
-        self.as_ref().element_at(index)
+    /// Returns `None` if the index is out of bounds.
+    pub fn element_at(&self, index: u32) -> Option<RefType> {
+        match &self.kind {
+            TypesKind::Module(module) => module.element_types.get(index as usize).copied(),
+            TypesKind::Component(_) => None,
+        }
     }
 
     /// Gets the count of element segments.
-    pub fn element_count(&self) -> u32 {
-        self.as_ref().element_count()
+    pub fn element_count(&self) -> usize {
+        match &self.kind {
+            TypesKind::Module(module) => module.element_types.len(),
+            TypesKind::Component(_) => 0,
+        }
     }
 
     /// Gets the type of a component function at the given function index.
     ///
-    /// # Panics
-    ///
-    /// This will panic if the `index` provided is out of bounds or if this type
-    /// information represents a core module.
-    pub fn component_function_at(&self, index: u32) -> TypeId {
+    /// Returns `None` if the index is out of bounds.
+    pub fn component_function_at(&self, index: u32) -> Option<&ComponentFuncType> {
         self.as_ref().component_function_at(index)
     }
 
     /// Gets the count of imported, exported, or aliased component functions.
-    pub fn component_function_count(&self) -> u32 {
-        self.as_ref().component_function_count()
+    pub fn component_function_count(&self) -> usize {
+        match &self.kind {
+            TypesKind::Module(_) => 0,
+            TypesKind::Component(component) => component.funcs.len(),
+        }
     }
 
     /// Gets the type of a module at the given module index.
     ///
-    /// # Panics
-    ///
-    /// This will panic if the `index` provided is out of bounds or if this type
-    /// information represents a core module.
-    pub fn module_at(&self, index: u32) -> TypeId {
+    /// Returns `None` if the index is out of bounds.
+    pub fn module_at(&self, index: u32) -> Option<&ModuleType> {
         self.as_ref().module_at(index)
     }
 
@@ -1549,11 +1827,8 @@ impl Types {
 
     /// Gets the type of a module instance at the given module instance index.
     ///
-    /// # Panics
-    ///
-    /// This will panic if the `index` provided is out of bounds or if this type
-    /// information represents a core module.
-    pub fn instance_at(&self, index: u32) -> TypeId {
+    /// Returns `None` if the index is out of bounds.
+    pub fn instance_at(&self, index: u32) -> Option<&InstanceType> {
         self.as_ref().instance_at(index)
     }
 
@@ -1567,11 +1842,8 @@ impl Types {
 
     /// Gets the type of a component at the given component index.
     ///
-    /// # Panics
-    ///
-    /// This will panic if the `index` provided is out of bounds or if this type
-    /// information represents a core module.
-    pub fn component_at(&self, index: u32) -> TypeId {
+    /// Returns `None` if the index is out of bounds.
+    pub fn component_at(&self, index: u32) -> Option<&ComponentType> {
         self.as_ref().component_at(index)
     }
 
@@ -1585,11 +1857,8 @@ impl Types {
 
     /// Gets the type of an component instance at the given component instance index.
     ///
-    /// # Panics
-    ///
-    /// This will panic if the `index` provided is out of bounds or if this type
-    /// information represents a core module.
-    pub fn component_instance_at(&self, index: u32) -> TypeId {
+    /// Returns `None` if the index is out of bounds.
+    pub fn component_instance_at(&self, index: u32) -> Option<&ComponentInstanceType> {
         self.as_ref().component_instance_at(index)
     }
 
@@ -1603,11 +1872,8 @@ impl Types {
 
     /// Gets the type of a value at the given value index.
     ///
-    /// # Panics
-    ///
-    /// This will panic if the `index` provided is out of bounds or if this type
-    /// information represents a core module.
-    pub fn value_at(&self, index: u32) -> ComponentValType {
+    /// Returns `None` if the index is out of bounds.
+    pub fn value_at(&self, index: u32) -> Option<ComponentValType> {
         self.as_ref().value_at(index)
     }
 
@@ -1629,14 +1895,10 @@ impl Types {
         self.as_ref().entity_type_from_export(export)
     }
 
-    /// Gets the component entity type for the given component import name.
-    pub fn component_entity_type_of_import(&self, name: &str) -> Option<ComponentEntityType> {
-        self.as_ref().component_entity_type_of_import(name)
-    }
-
-    /// Gets the component entity type for the given component export name.
-    pub fn component_entity_type_of_export(&self, name: &str) -> Option<ComponentEntityType> {
-        self.as_ref().component_entity_type_of_export(name)
+    /// Gets the component entity type for the given component import or export
+    /// name.
+    pub fn component_entity_type_of_extern(&self, name: &str) -> Option<ComponentEntityType> {
+        self.as_ref().component_entity_type_of_extern(name)
     }
 
     /// Attempts to lookup the type id that `ty` is an alias of.
@@ -1647,14 +1909,6 @@ impl Types {
     }
 }
 
-impl Index<TypeId> for Types {
-    type Output = Type;
-
-    fn index(&self, id: TypeId) -> &Type {
-        &self.list[id.index]
-    }
-}
-
 /// This is a type which mirrors a subset of the `Vec<T>` API, but is intended
 /// to be able to be cheaply snapshotted and cloned.
 ///
@@ -1716,6 +1970,22 @@ impl<T> SnapshotList<T> {
         Some(&snapshot.items[index - snapshot.prior_types])
     }
 
+    /// Same as `<&mut [T]>::get_mut`, except only works for indexes into the
+    /// current snapshot being built.
+    ///
+    /// # Panics
+    ///
+    /// Panics if an index is passed in which falls within the
+    /// previously-snapshotted list of types. This should never happen in our
+    /// context and the panic is intended to weed out possible bugs in
+    /// wasmparser.
+    pub(crate) fn get_mut(&mut self, index: usize) -> Option<&mut T> {
+        if index >= self.snapshots_total {
+            return self.cur.get_mut(index - self.snapshots_total);
+        }
+        panic!("cannot get a mutable reference in snapshotted part of list")
+    }
+
     /// Same as `Vec::push`
     pub(crate) fn push(&mut self, val: T) {
         self.cur.push(val);
@@ -1808,7 +2078,7 @@ impl<T> SnapshotList<T> {
     }
 }
 
-impl<T> Index<usize> for SnapshotList<T> {
+impl<T> std::ops::Index<usize> for SnapshotList<T> {
     type Output = T;
 
     #[inline]
@@ -1817,7 +2087,14 @@ impl<T> Index<usize> for SnapshotList<T> {
     }
 }
 
-impl<T> Index<TypeId> for SnapshotList<T> {
+impl<T> std::ops::IndexMut<usize> for SnapshotList<T> {
+    #[inline]
+    fn index_mut(&mut self, index: usize) -> &mut T {
+        self.get_mut(index).unwrap()
+    }
+}
+
+impl<T> std::ops::Index<TypeId> for SnapshotList<T> {
     type Output = T;
 
     #[inline]
@@ -1826,6 +2103,13 @@ impl<T> Index<TypeId> for SnapshotList<T> {
     }
 }
 
+impl<T> std::ops::IndexMut<TypeId> for SnapshotList<T> {
+    #[inline]
+    fn index_mut(&mut self, id: TypeId) -> &mut T {
+        self.get_mut(id.index).unwrap()
+    }
+}
+
 impl<T> Default for SnapshotList<T> {
     fn default() -> SnapshotList<T> {
         SnapshotList {
@@ -1845,25 +2129,6 @@ pub(crate) type TypeList = SnapshotList<Type>;
 /// types contained within this list.
 pub(crate) struct TypeAlloc {
     list: TypeList,
-
-    // This is assigned at creation of a `TypeAlloc` and then never changed.
-    // It's used in one entry for all `ResourceId`s contained within.
-    globally_unique_id: u64,
-
-    // This is a counter that's incremeneted each time `alloc_resource_id` is
-    // called.
-    next_resource_id: u32,
-}
-
-impl Default for TypeAlloc {
-    fn default() -> TypeAlloc {
-        static NEXT_GLOBAL_ID: AtomicU64 = AtomicU64::new(0);
-        TypeAlloc {
-            list: TypeList::default(),
-            globally_unique_id: NEXT_GLOBAL_ID.fetch_add(1, Ordering::Relaxed),
-            next_resource_id: 0,
-        }
-    }
 }
 
 impl Deref for TypeAlloc {
@@ -1880,12 +2145,9 @@ impl DerefMut for TypeAlloc {
 }
 
 impl TypeAlloc {
-    /// Pushes a new type into this list, returning an identifier which can be
-    /// used to later retrieve it.
-    ///
-    /// The returned identifier is unique within this `TypeAlloc` and won't be
-    /// hash-equivalent to anything else.
-    pub fn push_ty(&mut self, ty: Type) -> TypeId {
+    /// Pushes a new anonymous type into this list which will have its
+    /// `unique_id` field cleared.
+    pub fn push_anon(&mut self, ty: Type) -> TypeId {
         let index = self.list.len();
         let type_size = ty.type_size();
         self.list.push(ty);
@@ -1896,1302 +2158,21 @@ impl TypeAlloc {
         }
     }
 
-    /// Allocates a new unique resource identifier.
-    ///
-    /// Note that uniqueness is only a property within this `TypeAlloc`.
-    pub fn alloc_resource_id(&mut self) -> ResourceId {
-        let contextually_unique_id = self.next_resource_id;
-        self.next_resource_id = self.next_resource_id.checked_add(1).unwrap();
-        ResourceId {
-            globally_unique_id: self.globally_unique_id,
-            contextually_unique_id,
-        }
-    }
-
-    /// Adds the set of "free variables" of the `id` provided to the `set`
-    /// provided.
-    ///
-    /// Free variables are defined as resources. Any resource, perhaps
-    /// transitively, referred to but not defined by `id` is added to the `set`
-    /// and returned.
-    pub fn free_variables_type_id(&self, id: TypeId, set: &mut IndexSet<ResourceId>) {
-        match &self[id] {
-            // Core wasm constructs cannot reference resources.
-            Type::Sub(_) | Type::Module(_) | Type::Instance(_) => {}
-
-            // Recurse on the imports/exports of components, but remove the
-            // imported and defined resources within the component itself.
-            //
-            // Technically this needs to add all the free variables of the
-            // exports, remove the defined resources, then add the free
-            // variables of imports, then remove the imported resources. Given
-            // prior validation of component types, however, the defined
-            // and imported resources are disjoint and imports can't refer to
-            // defined resources, so doing this all in one go should be
-            // equivalent.
-            Type::Component(i) => {
-                for ty in i.imports.values().chain(i.exports.values()) {
-                    self.free_variables_component_entity(ty, set);
-                }
-                for (id, _path) in i.imported_resources.iter().chain(&i.defined_resources) {
-                    set.remove(id);
-                }
-            }
-
-            // Like components, add in all the free variables of referenced
-            // types but then remove those defined by this component instance
-            // itself.
-            Type::ComponentInstance(i) => {
-                for ty in i.exports.values() {
-                    self.free_variables_component_entity(ty, set);
-                }
-                for id in i.defined_resources.iter() {
-                    set.remove(id);
-                }
-            }
-
-            Type::Resource(r) => {
-                set.insert(*r);
-            }
-
-            Type::ComponentFunc(i) => {
-                for ty in i
-                    .params
-                    .iter()
-                    .map(|(_, ty)| ty)
-                    .chain(i.results.iter().map(|(_, ty)| ty))
-                {
-                    self.free_variables_valtype(ty, set);
-                }
-            }
-
-            Type::Defined(i) => match i {
-                ComponentDefinedType::Primitive(_)
-                | ComponentDefinedType::Flags(_)
-                | ComponentDefinedType::Enum(_) => {}
-                ComponentDefinedType::Record(r) => {
-                    for ty in r.fields.values() {
-                        self.free_variables_valtype(ty, set);
-                    }
-                }
-                ComponentDefinedType::Tuple(r) => {
-                    for ty in r.types.iter() {
-                        self.free_variables_valtype(ty, set);
-                    }
-                }
-                ComponentDefinedType::Union(r) => {
-                    for ty in r.types.iter() {
-                        self.free_variables_valtype(ty, set);
-                    }
-                }
-                ComponentDefinedType::Variant(r) => {
-                    for ty in r.cases.values() {
-                        if let Some(ty) = &ty.ty {
-                            self.free_variables_valtype(ty, set);
-                        }
-                    }
-                }
-                ComponentDefinedType::List(ty) | ComponentDefinedType::Option(ty) => {
-                    self.free_variables_valtype(ty, set);
-                }
-                ComponentDefinedType::Result { ok, err } => {
-                    if let Some(ok) = ok {
-                        self.free_variables_valtype(ok, set);
-                    }
-                    if let Some(err) = err {
-                        self.free_variables_valtype(err, set);
-                    }
-                }
-                ComponentDefinedType::Own(id) | ComponentDefinedType::Borrow(id) => {
-                    self.free_variables_type_id(*id, set);
-                }
-            },
-        }
-    }
-
-    /// Same as `free_variables_type_id`, but for `ComponentEntityType`.
-    pub fn free_variables_component_entity(
-        &self,
-        ty: &ComponentEntityType,
-        set: &mut IndexSet<ResourceId>,
-    ) {
-        match ty {
-            ComponentEntityType::Module(id)
-            | ComponentEntityType::Func(id)
-            | ComponentEntityType::Instance(id)
-            | ComponentEntityType::Component(id) => self.free_variables_type_id(*id, set),
-            ComponentEntityType::Type { created, .. } => {
-                self.free_variables_type_id(*created, set);
-            }
-            ComponentEntityType::Value(ty) => self.free_variables_valtype(ty, set),
-        }
-    }
-
-    /// Same as `free_variables_type_id`, but for `ComponentValType`.
-    fn free_variables_valtype(&self, ty: &ComponentValType, set: &mut IndexSet<ResourceId>) {
-        match ty {
-            ComponentValType::Primitive(_) => {}
-            ComponentValType::Type(id) => self.free_variables_type_id(*id, set),
-        }
-    }
-
-    /// Returns whether the type `id` is "named" where named types are presented
-    /// via the provided `set`.
+    /// Pushes a new defined type which has an index in core wasm onto this
+    /// list.
     ///
-    /// This requires that `id` is a `Defined` type.
-    pub(crate) fn type_named_type_id(&self, id: TypeId, set: &HashSet<TypeId>) -> bool {
-        let ty = self[id].unwrap_defined();
-        match ty {
-            // Primitives are always considered named
-            ComponentDefinedType::Primitive(_) => true,
-
-            // These structures are never allowed to be anonymous, so they
-            // themselves must be named.
-            ComponentDefinedType::Flags(_)
-            | ComponentDefinedType::Enum(_)
-            | ComponentDefinedType::Record(_)
-            | ComponentDefinedType::Union(_)
-            | ComponentDefinedType::Variant(_) => set.contains(&id),
-
-            // All types below here are allowed to be anonymous, but their
-            // own components must be appropriately named.
-            ComponentDefinedType::Tuple(r) => {
-                r.types.iter().all(|t| self.type_named_valtype(t, set))
-            }
-            ComponentDefinedType::Result { ok, err } => {
-                ok.as_ref()
-                    .map(|t| self.type_named_valtype(t, set))
-                    .unwrap_or(true)
-                    && err
-                        .as_ref()
-                        .map(|t| self.type_named_valtype(t, set))
-                        .unwrap_or(true)
-            }
-            ComponentDefinedType::List(ty) | ComponentDefinedType::Option(ty) => {
-                self.type_named_valtype(ty, set)
-            }
-
-            // own/borrow themselves don't have to be named, but the resource
-            // they refer to must be named.
-            ComponentDefinedType::Own(id) | ComponentDefinedType::Borrow(id) => set.contains(id),
-        }
-    }
-
-    pub(crate) fn type_named_valtype(&self, ty: &ComponentValType, set: &HashSet<TypeId>) -> bool {
-        match ty {
-            ComponentValType::Primitive(_) => true,
-            ComponentValType::Type(id) => self.type_named_type_id(*id, set),
-        }
+    /// The returned `TypeId` is guaranteed to be unique and not hash-equivalent
+    /// to any other prior ID in this list.
+    pub fn push_defined(&mut self, ty: Type) -> TypeId {
+        let id = self.push_anon(ty);
+        self.with_unique(id)
     }
 }
 
-/// A helper trait to provide the functionality necessary to resources within a
-/// type.
-///
-/// This currently exists to abstract over `TypeAlloc` and `SubtypeArena` which
-/// both need to perform remapping operations.
-pub(crate) trait Remap: Index<TypeId, Output = Type> {
-    /// Pushes a new anonymous type within this object, returning an identifier
-    /// which can be used to refer to it.
-    fn push_ty(&mut self, ty: Type) -> TypeId;
-
-    /// Applies a resource and type renaming map to the `id` specified,
-    /// returning `true` if the `id` was modified or `false` if it didn't need
-    /// changing.
-    ///
-    /// This will recursively modify the structure of the `id` specified and
-    /// update all references to resources found. The resource identifier keys
-    /// in the `map` specified will become the corresponding value, in addition
-    /// to any existing types in `map` becoming different tyeps.
-    ///
-    /// The `id` argument will be rewritten to a new identifier if `true` is
-    /// returned.
-    fn remap_type_id(&mut self, id: &mut TypeId, map: &mut Remapping) -> bool {
-        if let Some(new) = map.types.get(id) {
-            let changed = *new != *id;
-            *id = *new;
-            return changed;
-        }
-
-        // This function attempts what ends up probably being a relatively
-        // minor optimization where a new `id` isn't manufactured unless
-        // something about the type actually changed. That means that if the
-        // type doesn't actually use any resources, for example, then no new
-        // id is allocated.
-        let mut any_changed = false;
-
-        let map_map = |tmp: &mut IndexMap<ResourceId, Vec<usize>>,
-                       any_changed: &mut bool,
-                       map: &mut Remapping| {
-            for (id, path) in mem::take(tmp) {
-                let id = match map.resources.get(&id) {
-                    Some(id) => {
-                        *any_changed = true;
-                        *id
-                    }
-                    None => id,
-                };
-                tmp.insert(id, path);
-            }
-        };
-
-        let ty = match &self[*id] {
-            // Core wasm functions/modules/instances don't have resource types
-            // in them.
-            Type::Sub(_) | Type::Module(_) | Type::Instance(_) => return false,
-
-            Type::Component(i) => {
-                let mut tmp = i.clone();
-                for ty in tmp.imports.values_mut().chain(tmp.exports.values_mut()) {
-                    if self.remap_component_entity(ty, map) {
-                        any_changed = true;
-                    }
-                }
-                for (id, _) in tmp
-                    .imported_resources
-                    .iter_mut()
-                    .chain(&mut tmp.defined_resources)
-                {
-                    if let Some(new) = map.resources.get(id) {
-                        *id = *new;
-                        any_changed = true;
-                    }
-                }
-                map_map(&mut tmp.explicit_resources, &mut any_changed, map);
-                Type::Component(tmp)
-            }
-
-            Type::ComponentInstance(i) => {
-                let mut tmp = i.clone();
-                for ty in tmp.exports.values_mut() {
-                    if self.remap_component_entity(ty, map) {
-                        any_changed = true;
-                    }
-                }
-                for id in tmp.defined_resources.iter_mut() {
-                    if let Some(new) = map.resources.get(id) {
-                        *id = *new;
-                        any_changed = true;
-                    }
-                }
-                map_map(&mut tmp.explicit_resources, &mut any_changed, map);
-                Type::ComponentInstance(tmp)
-            }
-
-            Type::Resource(id) => {
-                let id = match map.resources.get(id).copied() {
-                    Some(id) => id,
-                    None => return false,
-                };
-                any_changed = true;
-                Type::Resource(id)
-            }
-
-            Type::ComponentFunc(i) => {
-                let mut tmp = i.clone();
-                for ty in tmp
-                    .params
-                    .iter_mut()
-                    .map(|(_, ty)| ty)
-                    .chain(tmp.results.iter_mut().map(|(_, ty)| ty))
-                {
-                    if self.remap_valtype(ty, map) {
-                        any_changed = true;
-                    }
-                }
-                Type::ComponentFunc(tmp)
-            }
-            Type::Defined(i) => {
-                let mut tmp = i.clone();
-                match &mut tmp {
-                    ComponentDefinedType::Primitive(_)
-                    | ComponentDefinedType::Flags(_)
-                    | ComponentDefinedType::Enum(_) => {}
-                    ComponentDefinedType::Record(r) => {
-                        for ty in r.fields.values_mut() {
-                            if self.remap_valtype(ty, map) {
-                                any_changed = true;
-                            }
-                        }
-                    }
-                    ComponentDefinedType::Tuple(r) => {
-                        for ty in r.types.iter_mut() {
-                            if self.remap_valtype(ty, map) {
-                                any_changed = true;
-                            }
-                        }
-                    }
-                    ComponentDefinedType::Union(r) => {
-                        for ty in r.types.iter_mut() {
-                            if self.remap_valtype(ty, map) {
-                                any_changed = true;
-                            }
-                        }
-                    }
-                    ComponentDefinedType::Variant(r) => {
-                        for ty in r.cases.values_mut() {
-                            if let Some(ty) = &mut ty.ty {
-                                if self.remap_valtype(ty, map) {
-                                    any_changed = true;
-                                }
-                            }
-                        }
-                    }
-                    ComponentDefinedType::List(ty) | ComponentDefinedType::Option(ty) => {
-                        if self.remap_valtype(ty, map) {
-                            any_changed = true;
-                        }
-                    }
-                    ComponentDefinedType::Result { ok, err } => {
-                        if let Some(ok) = ok {
-                            if self.remap_valtype(ok, map) {
-                                any_changed = true;
-                            }
-                        }
-                        if let Some(err) = err {
-                            if self.remap_valtype(err, map) {
-                                any_changed = true;
-                            }
-                        }
-                    }
-                    ComponentDefinedType::Own(id) | ComponentDefinedType::Borrow(id) => {
-                        if self.remap_type_id(id, map) {
-                            any_changed = true;
-                        }
-                    }
-                }
-                Type::Defined(tmp)
-            }
-        };
-
-        let new = if any_changed { self.push_ty(ty) } else { *id };
-        let prev = map.types.insert(*id, new);
-        assert!(prev.is_none());
-        let changed = *id != new;
-        *id = new;
-        changed
-    }
-
-    /// Same as `remap_type_id`, but works with `ComponentEntityType`.
-    fn remap_component_entity(
-        &mut self,
-        ty: &mut ComponentEntityType,
-        map: &mut Remapping,
-    ) -> bool {
-        match ty {
-            ComponentEntityType::Module(id)
-            | ComponentEntityType::Func(id)
-            | ComponentEntityType::Instance(id)
-            | ComponentEntityType::Component(id) => self.remap_type_id(id, map),
-            ComponentEntityType::Type {
-                referenced,
-                created,
-            } => {
-                let changed = self.remap_type_id(referenced, map);
-                if *referenced == *created {
-                    *created = *referenced;
-                    changed
-                } else {
-                    self.remap_type_id(created, map) || changed
-                }
-            }
-            ComponentEntityType::Value(ty) => self.remap_valtype(ty, map),
-        }
-    }
-
-    /// Same as `remap_type_id`, but works with `ComponentValType`.
-    fn remap_valtype(&mut self, ty: &mut ComponentValType, map: &mut Remapping) -> bool {
-        match ty {
-            ComponentValType::Primitive(_) => false,
-            ComponentValType::Type(id) => self.remap_type_id(id, map),
-        }
-    }
-}
-
-#[derive(Default)]
-pub(crate) struct Remapping {
-    /// A mapping from old resource ID to new resource ID.
-    pub(crate) resources: HashMap<ResourceId, ResourceId>,
-
-    /// A mapping filled in during the remapping process which records how a
-    /// type was remapped, if applicable. This avoids remapping multiple
-    /// references to the same type and instead only processing it once.
-    types: HashMap<TypeId, TypeId>,
-}
-
-impl Remap for TypeAlloc {
-    fn push_ty(&mut self, ty: Type) -> TypeId {
-        <TypeAlloc>::push_ty(self, ty)
-    }
-}
-
-impl Index<TypeId> for TypeAlloc {
-    type Output = Type;
-
-    #[inline]
-    fn index(&self, id: TypeId) -> &Type {
-        &self.list[id]
-    }
-}
-
-/// Helper structure used to perform subtyping computations.
-///
-/// This type is used whenever a subtype needs to be tested in one direction or
-/// the other. The methods of this type are the various entry points for
-/// subtyping.
-///
-/// Internally this contains arenas for two lists of types. The `a` arena is
-/// intended to be used for lookup of the first argument to all of the methods
-/// below, and the `b` arena is used for lookup of the second argument.
-///
-/// Arenas here are used specifically for component-based subtyping queries. In
-/// these situations new types must be created based on substitution mappings,
-/// but the types all have temporary lifetimes. Everything in these arenas is
-/// thrown away once the subtyping computation has finished.
-///
-/// Note that this subtyping context also explicitly supports being created
-/// from to different lists `a` and `b` originally, for testing subtyping
-/// between two different components for example.
-pub(crate) struct SubtypeCx<'a> {
-    pub(crate) a: SubtypeArena<'a>,
-    pub(crate) b: SubtypeArena<'a>,
-}
-
-impl<'a> SubtypeCx<'a> {
-    pub(crate) fn new(a: &'a TypeList, b: &'a TypeList) -> SubtypeCx<'a> {
-        SubtypeCx {
-            a: SubtypeArena::new(a),
-            b: SubtypeArena::new(b),
-        }
-    }
-
-    fn swap(&mut self) {
-        mem::swap(&mut self.a, &mut self.b);
-    }
-
-    /// Executes the closure `f`, resetting the internal arenas to their
-    /// original size after the closure finishes.
-    ///
-    /// This enables `f` to modify the internal arenas while relying on all
-    /// changes being discarded after the closure finishes.
-    fn mark<T>(&mut self, f: impl FnOnce(&mut Self) -> T) -> T {
-        let a_len = self.a.list.len();
-        let b_len = self.b.list.len();
-        let result = f(self);
-        self.a.list.truncate(a_len);
-        self.b.list.truncate(b_len);
-        result
-    }
-
-    /// Tests whether `a` is a subtype of `b`.
-    ///
-    /// Errors are reported at the `offset` specified.
-    pub fn component_entity_type(
-        &mut self,
-        a: &ComponentEntityType,
-        b: &ComponentEntityType,
-        offset: usize,
-    ) -> Result<()> {
-        use ComponentEntityType::*;
-
-        match (a, b) {
-            (Module(a), Module(b)) => {
-                // For module type subtyping, all exports in the other module
-                // type must be present in this module type's exports (i.e. it
-                // can export *more* than what this module type needs).
-                // However, for imports, the check is reversed (i.e. it is okay
-                // to import *less* than what this module type needs).
-                self.swap();
-                let a_imports = &self.b[*a].unwrap_module().imports;
-                let b_imports = &self.a[*b].unwrap_module().imports;
-                for (k, a) in a_imports {
-                    match b_imports.get(k) {
-                        Some(b) => self.entity_type(b, a, offset).with_context(|| {
-                            format!("type mismatch in import `{}::{}`", k.0, k.1)
-                        })?,
-                        None => bail!(offset, "missing expected import `{}::{}`", k.0, k.1),
-                    }
-                }
-                self.swap();
-                let a = self.a[*a].unwrap_module();
-                let b = self.b[*b].unwrap_module();
-                for (k, b) in b.exports.iter() {
-                    match a.exports.get(k) {
-                        Some(a) => self
-                            .entity_type(a, b, offset)
-                            .with_context(|| format!("type mismatch in export `{k}`"))?,
-                        None => bail!(offset, "missing expected export `{k}`"),
-                    }
-                }
-                Ok(())
-            }
-            (Module(_), b) => bail!(offset, "expected {}, found module", b.desc()),
-
-            (Func(a), Func(b)) => {
-                let a = self.a[*a].unwrap_component_func();
-                let b = self.b[*b].unwrap_component_func();
-
-                // Note that this intentionally diverges from the upstream
-                // specification in terms of subtyping. This is a full
-                // type-equality check which ensures that the structure of `a`
-                // exactly matches the structure of `b`. The rationale for this
-                // is:
-                //
-                // * Primarily in Wasmtime subtyping based on function types is
-                //   not implemented. This includes both subtyping a host
-                //   import and additionally handling subtyping as functions
-                //   cross component boundaries. The host import subtyping (or
-                //   component export subtyping) is not clear how to handle at
-                //   all at this time. The subtyping of functions between
-                //   components can more easily be handled by extending the
-                //   `fact` compiler, but that hasn't been done yet.
-                //
-                // * The upstream specification is currently pretty
-                //   intentionally vague precisely what subtyping is allowed.
-                //   Implementing a strict check here is intended to be a
-                //   conservative starting point for the component model which
-                //   can be extended in the future if necessary.
-                //
-                // * The interaction with subtyping on bindings generation, for
-                //   example, is a tricky problem that doesn't have a clear
-                //   answer at this time.  Effectively this is more rationale
-                //   for being conservative in the first pass of the component
-                //   model.
-                //
-                // So, in conclusion, the test here (and other places that
-                // reference this comment) is for exact type equality with no
-                // differences.
-                if a.params.len() != b.params.len() {
-                    bail!(
-                        offset,
-                        "expected {} parameters, found {}",
-                        b.params.len(),
-                        a.params.len(),
-                    );
-                }
-                if a.results.len() != b.results.len() {
-                    bail!(
-                        offset,
-                        "expected {} results, found {}",
-                        b.results.len(),
-                        a.results.len(),
-                    );
-                }
-                for ((an, a), (bn, b)) in a.params.iter().zip(b.params.iter()) {
-                    if an != bn {
-                        bail!(offset, "expected parameter named `{bn}`, found `{an}`");
-                    }
-                    self.component_val_type(a, b, offset)
-                        .with_context(|| format!("type mismatch in function parameter `{an}`"))?;
-                }
-                for ((an, a), (bn, b)) in a.results.iter().zip(b.results.iter()) {
-                    if an != bn {
-                        bail!(offset, "mismatched result names");
-                    }
-                    self.component_val_type(a, b, offset)
-                        .with_context(|| "type mismatch with result type")?;
-                }
-                Ok(())
-            }
-            (Func(_), b) => bail!(offset, "expected {}, found func", b.desc()),
-
-            (Value(a), Value(b)) => self.component_val_type(a, b, offset),
-            (Value(_), b) => bail!(offset, "expected {}, found value", b.desc()),
-
-            (Type { referenced: a, .. }, Type { referenced: b, .. }) => {
-                use self::Type::*;
-                match (&self.a[*a], &self.b[*b]) {
-                    (Defined(a), Defined(b)) => self.component_defined_type(a, b, offset),
-                    (Defined(_), Resource(_)) => bail!(offset, "expected resource, found type"),
-                    (Resource(a), Resource(b)) => {
-                        if a == b {
-                            Ok(())
-                        } else {
-                            bail!(offset, "resource types are not the same")
-                        }
-                    }
-                    (Resource(_), Defined(_)) => bail!(offset, "expected type, found resource"),
-                    _ => unreachable!(),
-                }
-            }
-            (Type { .. }, b) => bail!(offset, "expected {}, found type", b.desc()),
-
-            (Instance(a_id), Instance(b_id)) => {
-                // For instance type subtyping, all exports in the other
-                // instance type must be present in this instance type's
-                // exports (i.e. it can export *more* than what this instance
-                // type needs).
-                let a = self.a[*a_id].unwrap_component_instance();
-                let b = self.b[*b_id].unwrap_component_instance();
-
-                let mut exports = Vec::with_capacity(b.exports.len());
-                for (k, b) in b.exports.iter() {
-                    match a.exports.get(k) {
-                        Some(a) => exports.push((*a, *b)),
-                        None => bail!(offset, "missing expected export `{k}`"),
-                    }
-                }
-                for (i, (a, b)) in exports.iter().enumerate() {
-                    let err = match self.component_entity_type(a, b, offset) {
-                        Ok(()) => continue,
-                        Err(e) => e,
-                    };
-                    // On failure attach the name of this export as context to
-                    // the error message to leave a breadcrumb trail.
-                    let (name, _) = self.b[*b_id]
-                        .unwrap_component_instance()
-                        .exports
-                        .get_index(i)
-                        .unwrap();
-                    return Err(
-                        err.with_context(|| format!("type mismatch in instance export `{name}`"))
-                    );
-                }
-                Ok(())
-            }
-            (Instance(_), b) => bail!(offset, "expected {}, found instance", b.desc()),
-
-            (Component(a), Component(b)) => {
-                // Components are ... tricky. They follow the same basic
-                // structure as core wasm modules, but they also have extra
-                // logic to handle resource types. Resources are effectively
-                // abstract types so this is sort of where an ML module system
-                // in the component model becomes a reality.
-                //
-                // This also leverages the `open_instance_type` method below
-                // heavily which internally has its own quite large suite of
-                // logic. More-or-less what's happening here is:
-                //
-                // 1. Pretend that the imports of B are given as values to the
-                //    imports of A. If A didn't import anything, for example,
-                //    that's great and the subtyping definitely passes there.
-                //    This operation produces a mapping of all the resources of
-                //    A's imports to resources in B's imports.
-                //
-                // 2. This mapping is applied to all of A's exports. This means
-                //    that all exports of A referring to A's imported resources
-                //    now instead refer to B's. Note, though that A's exports
-                //    still refer to its own defined resources.
-                //
-                // 3. The same `open_instance_type` method used during the
-                //    first step is used again, but this time on the exports
-                //    in the reverse direction. This performs a similar
-                //    operation, though, by creating a mapping from B's
-                //    defined resources to A's defined resources. The map
-                //    itself is discarded as it's not needed.
-                //
-                // The order that everything passed here is intentional, but
-                // also subtle. I personally think of it as
-                // `open_instance_type` takes a list of things to satisfy a
-                // signature and produces a mapping of resources in the
-                // signature to those provided in the list of things. The
-                // order of operations then goes:
-                //
-                // * Someone thinks they have a component of type B, but they
-                //   actually have a component of type A (e.g. due to this
-                //   subtype check passing).
-                // * This person provides the imports of B and that must be
-                //   sufficient to satisfy the imports of A. This is the first
-                //   `open_instance_type` check.
-                // * Now though the resources provided by B are substituted
-                //   into A's exports since that's what was provided.
-                // * A's exports are then handed back to the original person,
-                //   and these exports must satisfy the signature required by B
-                //   since that's what they're expecting.
-                // * This is the second `open_instance_type` which, to get
-                //   resource types to line up, will map from A's defined
-                //   resources to B's defined resources.
-                //
-                // If all that passes then the resources should all line up
-                // perfectly. Any misalignment is reported as a subtyping
-                // error.
-                let b_imports = self.b[*b]
-                    .unwrap_component()
-                    .imports
-                    .iter()
-                    .map(|(name, ty)| (name.clone(), ty.clone()))
-                    .collect();
-                self.swap();
-                let mut import_mapping =
-                    self.open_instance_type(&b_imports, *a, ExternKind::Import, offset)?;
-                self.swap();
-                self.mark(|this| {
-                    let mut a_exports = this.a[*a]
-                        .unwrap_component()
-                        .exports
-                        .iter()
-                        .map(|(name, ty)| (name.clone(), ty.clone()))
-                        .collect::<IndexMap<_, _>>();
-                    for ty in a_exports.values_mut() {
-                        this.a.remap_component_entity(ty, &mut import_mapping);
-                    }
-                    this.open_instance_type(&a_exports, *b, ExternKind::Export, offset)?;
-                    Ok(())
-                })
-            }
-            (Component(_), b) => bail!(offset, "expected {}, found component", b.desc()),
-        }
-    }
-
-    /// The building block for subtyping checks when components are
-    /// instantiated and when components are tested if they're subtypes of each
-    /// other.
-    ///
-    /// This method takes a number of arguments:
-    ///
-    /// * `a` - this is a list of typed items which can be thought of as
-    ///   concrete values to test against `b`.
-    /// * `b` - this `TypeId` must point to `Type::Component`.
-    /// * `kind` - indicates whether the `imports` or `exports` of `b` are
-    ///   being tested against for the values in `a`.
-    /// * `offset` - the binary offset at which to report errors if one happens.
-    ///
-    /// This will attempt to determine if the items in `a` satisfy the
-    /// signature required by the `kind` items of `b`. For example component
-    /// instantiation will have `a` as the list of arguments provided to
-    /// instantiation, `b` is the component being instantiated, and `kind` is
-    /// `ExternKind::Import`.
-    ///
-    /// This function, if successful, will return a mapping of the resources in
-    /// `b` to the resources in `a` provided. This mapping is guaranteed to
-    /// contain all the resources for `b` (all imported resources for
-    /// `ExternKind::Import` or all defined resources for `ExternKind::Export`).
-    pub fn open_instance_type(
-        &mut self,
-        a: &IndexMap<String, ComponentEntityType>,
-        b: TypeId,
-        kind: ExternKind,
-        offset: usize,
-    ) -> Result<Remapping> {
-        // First, determine the mapping from resources in `b` to those supplied
-        // by arguments in `a`.
-        //
-        // This loop will iterate over all the appropriate resources in `b`
-        // and find the corresponding resource in `args`. The exact lists
-        // in use here depend on the `kind` provided. This necessarily requires
-        // a sequence of string lookups to find the corresponding items in each
-        // list.
-        //
-        // The path to each resource in `resources` is precomputed as a list of
-        // indexes. The first index is into `b`'s list of `entities`, and gives
-        // the name that `b` assigns to the resource.  Each subsequent index,
-        // if present, means that this resource was present through a layer of
-        // an instance type, and the index is into the instance type's exports.
-        // More information about this can be found on
-        // `ComponentState::imported_resources`.
-        //
-        // This loop will follow the list of indices for each resource and, at
-        // the same time, walk through the arguments supplied to instantiating
-        // the `component_type`. This means that within `component_type`
-        // index-based lookups are performed while in `args` name-based
-        // lookups are performed.
-        //
-        // Note that here it's possible that `args` doesn't actually supply the
-        // correct type of import for each item since argument checking has
-        // not proceeded yet. These type errors, however, aren't handled by
-        // this loop and are deferred below to the main subtyping check. That
-        // means that `mapping` won't necessarily have a mapping for all
-        // imported resources into `component_type`, but that should be ok.
-        let component_type = self.b[b].unwrap_component();
-        let entities = match kind {
-            ExternKind::Import => &component_type.imports,
-            ExternKind::Export => &component_type.exports,
-        };
-        let resources = match kind {
-            ExternKind::Import => &component_type.imported_resources,
-            ExternKind::Export => &component_type.defined_resources,
-        };
-        let mut mapping = Remapping::default();
-        'outer: for (resource, path) in resources.iter() {
-            // Lookup the first path item in `imports` and the corresponding
-            // entry in `args` by name.
-            let (name, ty) = entities.get_index(path[0]).unwrap();
-            let mut ty = *ty;
-            let mut arg = a.get(name);
-
-            // Lookup all the subsequent `path` entries, if any, by index in
-            // `ty` and by name in `arg`. Type errors in `arg` are skipped over
-            // entirely.
-            for i in path.iter().skip(1).copied() {
-                let id = match ty {
-                    ComponentEntityType::Instance(id) => id,
-                    _ => unreachable!(),
-                };
-                let (name, next_ty) = self.b[id]
-                    .unwrap_component_instance()
-                    .exports
-                    .get_index(i)
-                    .unwrap();
-                ty = *next_ty;
-                arg = match arg {
-                    Some(ComponentEntityType::Instance(id)) => {
-                        self.a[*id].unwrap_component_instance().exports.get(name)
-                    }
-                    _ => continue 'outer,
-                };
-            }
-
-            // Double-check that `ty`, the leaf type of `component_type`, is
-            // indeed the expected resource.
-            if cfg!(debug_assertions) {
-                let id = match ty {
-                    ComponentEntityType::Type { created, .. } => match &self.a[created] {
-                        Type::Resource(r) => *r,
-                        _ => unreachable!(),
-                    },
-                    _ => unreachable!(),
-                };
-                assert_eq!(id, *resource);
-            }
-
-            // The leaf of `arg` should be a type which is a resource. If not
-            // it's skipped and this'll wind up generating an error later on in
-            // subtype checking below.
-            if let Some(ComponentEntityType::Type { created, .. }) = arg {
-                if let Type::Resource(r) = &self.b[*created] {
-                    mapping.resources.insert(*resource, *r);
-                }
-            }
-        }
-
-        // Now that a mapping from the resources in `b` to the resources in `a`
-        // has been determined it's possible to perform the actual subtype
-        // check.
-        //
-        // This subtype check notably needs to ensure that all resource types
-        // line up. To achieve this the `mapping` previously calculated is used
-        // to perform a substitution on each component entity type.
-        //
-        // The first loop here performs a name lookup to create a list of
-        // values from `a` to expected items in `b`. Once the list is created
-        // the substitution check is performed on each element.
-        let mut to_typecheck = Vec::new();
-        for (name, expected) in entities.iter() {
-            match a.get(name) {
-                Some(arg) => to_typecheck.push((arg.clone(), expected.clone())),
-                None => bail!(offset, "missing {} named `{name}`", kind.desc()),
-            }
-        }
-        let mut type_map = HashMap::new();
-        for (i, (actual, expected)) in to_typecheck.into_iter().enumerate() {
-            let result = self.mark(|this| {
-                let mut expected = expected;
-                this.b.remap_component_entity(&mut expected, &mut mapping);
-                mapping.types.clear();
-                this.component_entity_type(&actual, &expected, offset)
-            });
-            let err = match result {
-                Ok(()) => {
-                    // On a successful type-check record a mapping of
-                    // type-to-type in `type_map` for any type imports that were
-                    // satisfied. This is then used afterwards when performing
-                    // type substitution to remap all component-local types to
-                    // those that were provided in the imports.
-                    self.register_type_renamings(actual, expected, &mut type_map);
-                    continue;
-                }
-                Err(e) => e,
-            };
-
-            // If an error happens then attach the name of the entity to the
-            // error message using the `i` iteration counter.
-            let component_type = self.b[b].unwrap_component();
-            let entities = match kind {
-                ExternKind::Import => &component_type.imports,
-                ExternKind::Export => &component_type.exports,
-            };
-            let (name, _) = entities.get_index(i).unwrap();
-            return Err(err.with_context(|| format!("type mismatch for {} `{name}`", kind.desc())));
-        }
-        mapping.types = type_map;
-        Ok(mapping)
-    }
-
-    pub(crate) fn entity_type(&self, a: &EntityType, b: &EntityType, offset: usize) -> Result<()> {
-        macro_rules! limits_match {
-            ($a:expr, $b:expr) => {{
-                let a = $a;
-                let b = $b;
-                a.initial >= b.initial
-                    && match b.maximum {
-                        Some(b_max) => match a.maximum {
-                            Some(a_max) => a_max <= b_max,
-                            None => false,
-                        },
-                        None => true,
-                    }
-            }};
-        }
-
-        match (a, b) {
-            (EntityType::Func(a), EntityType::Func(b)) => {
-                self.func_type(self.a[*a].unwrap_func(), self.b[*b].unwrap_func(), offset)
-            }
-            (EntityType::Func(_), b) => bail!(offset, "expected {}, found func", b.desc()),
-            (EntityType::Table(a), EntityType::Table(b)) => {
-                if a.element_type != b.element_type {
-                    bail!(
-                        offset,
-                        "expected table element type {}, found {}",
-                        b.element_type,
-                        a.element_type,
-                    )
-                }
-                if limits_match!(a, b) {
-                    Ok(())
-                } else {
-                    bail!(offset, "mismatch in table limits")
-                }
-            }
-            (EntityType::Table(_), b) => bail!(offset, "expected {}, found table", b.desc()),
-            (EntityType::Memory(a), EntityType::Memory(b)) => {
-                if a.shared != b.shared {
-                    bail!(offset, "mismatch in the shared flag for memories")
-                }
-                if a.memory64 != b.memory64 {
-                    bail!(offset, "mismatch in index type used for memories")
-                }
-                if limits_match!(a, b) {
-                    Ok(())
-                } else {
-                    bail!(offset, "mismatch in memory limits")
-                }
-            }
-            (EntityType::Memory(_), b) => bail!(offset, "expected {}, found memory", b.desc()),
-            (EntityType::Global(a), EntityType::Global(b)) => {
-                if a.mutable != b.mutable {
-                    bail!(offset, "global types differ in mutability")
-                }
-                if a.content_type == b.content_type {
-                    Ok(())
-                } else {
-                    bail!(
-                        offset,
-                        "expected global type {}, found {}",
-                        b.content_type,
-                        a.content_type,
-                    )
-                }
-            }
-            (EntityType::Global(_), b) => bail!(offset, "expected {}, found global", b.desc()),
-            (EntityType::Tag(a), EntityType::Tag(b)) => {
-                self.func_type(self.a[*a].unwrap_func(), self.b[*b].unwrap_func(), offset)
-            }
-            (EntityType::Tag(_), b) => bail!(offset, "expected {}, found tag", b.desc()),
-        }
-    }
-
-    fn func_type(&self, a: &FuncType, b: &FuncType, offset: usize) -> Result<()> {
-        if a == b {
-            Ok(())
-        } else {
-            bail!(
-                offset,
-                "expected: {}\n\
-                 found:    {}",
-                b.desc(),
-                a.desc(),
-            )
-        }
-    }
-
-    pub(crate) fn component_val_type(
-        &self,
-        a: &ComponentValType,
-        b: &ComponentValType,
-        offset: usize,
-    ) -> Result<()> {
-        match (a, b) {
-            (ComponentValType::Primitive(a), ComponentValType::Primitive(b)) => {
-                self.primitive_val_type(*a, *b, offset)
-            }
-            (ComponentValType::Type(a), ComponentValType::Type(b)) => self.component_defined_type(
-                self.a[*a].unwrap_defined(),
-                self.b[*b].unwrap_defined(),
-                offset,
-            ),
-            (ComponentValType::Primitive(a), ComponentValType::Type(b)) => {
-                match self.b[*b].unwrap_defined() {
-                    ComponentDefinedType::Primitive(b) => self.primitive_val_type(*a, *b, offset),
-                    b => bail!(offset, "expected {}, found {a}", b.desc()),
-                }
-            }
-            (ComponentValType::Type(a), ComponentValType::Primitive(b)) => {
-                match self.a[*a].unwrap_defined() {
-                    ComponentDefinedType::Primitive(a) => self.primitive_val_type(*a, *b, offset),
-                    a => bail!(offset, "expected {b}, found {}", a.desc()),
-                }
-            }
-        }
-    }
-
-    fn component_defined_type(
-        &self,
-        a: &ComponentDefinedType,
-        b: &ComponentDefinedType,
-        offset: usize,
-    ) -> Result<()> {
-        use ComponentDefinedType::*;
-
-        // Note that the implementation of subtyping here diverges from the
-        // upstream specification intentionally, see the documentation on
-        // function subtyping for more information.
-        match (a, b) {
-            (Primitive(a), Primitive(b)) => self.primitive_val_type(*a, *b, offset),
-            (Primitive(a), b) => bail!(offset, "expected {}, found {a}", b.desc()),
-            (Record(a), Record(b)) => {
-                if a.fields.len() != b.fields.len() {
-                    bail!(
-                        offset,
-                        "expected {} fields, found {}",
-                        b.fields.len(),
-                        a.fields.len(),
-                    );
-                }
-
-                for ((aname, a), (bname, b)) in a.fields.iter().zip(b.fields.iter()) {
-                    if aname != bname {
-                        bail!(offset, "expected field name `{bname}`, found `{aname}`");
-                    }
-                    self.component_val_type(a, b, offset)
-                        .with_context(|| format!("type mismatch in record field `{aname}`"))?;
-                }
-                Ok(())
-            }
-            (Record(_), b) => bail!(offset, "expected {}, found record", b.desc()),
-            (Variant(a), Variant(b)) => {
-                if a.cases.len() != b.cases.len() {
-                    bail!(
-                        offset,
-                        "expected {} cases, found {}",
-                        b.cases.len(),
-                        a.cases.len(),
-                    );
-                }
-                for ((aname, a), (bname, b)) in a.cases.iter().zip(b.cases.iter()) {
-                    if aname != bname {
-                        bail!(offset, "expected case named `{bname}`, found `{aname}`");
-                    }
-                    match (&a.ty, &b.ty) {
-                        (Some(a), Some(b)) => self
-                            .component_val_type(a, b, offset)
-                            .with_context(|| format!("type mismatch in variant case `{aname}`"))?,
-                        (None, None) => {}
-                        (None, Some(_)) => {
-                            bail!(offset, "expected case `{aname}` to have a type, found none")
-                        }
-                        (Some(_), None) => bail!(offset, "expected case `{aname}` to have no type"),
-                    }
-                }
-                Ok(())
-            }
-            (Variant(_), b) => bail!(offset, "expected {}, found variant", b.desc()),
-            (List(a), List(b)) | (Option(a), Option(b)) => self.component_val_type(a, b, offset),
-            (List(_), b) => bail!(offset, "expected {}, found list", b.desc()),
-            (Option(_), b) => bail!(offset, "expected {}, found option", b.desc()),
-            (Tuple(a), Tuple(b)) => {
-                if a.types.len() != b.types.len() {
-                    bail!(
-                        offset,
-                        "expected {} types, found {}",
-                        b.types.len(),
-                        a.types.len(),
-                    );
-                }
-                for (i, (a, b)) in a.types.iter().zip(b.types.iter()).enumerate() {
-                    self.component_val_type(a, b, offset)
-                        .with_context(|| format!("type mismatch in tuple field {i}"))?;
-                }
-                Ok(())
-            }
-            (Tuple(_), b) => bail!(offset, "expected {}, found tuple", b.desc()),
-            (Union(a), Union(b)) => {
-                if a.types.len() != b.types.len() {
-                    bail!(
-                        offset,
-                        "expected {} types, found {}",
-                        b.types.len(),
-                        a.types.len(),
-                    );
-                }
-                for (i, (a, b)) in a.types.iter().zip(b.types.iter()).enumerate() {
-                    self.component_val_type(a, b, offset)
-                        .with_context(|| format!("type mismatch in tuple field {i}"))?;
-                }
-                Ok(())
-            }
-            (Union(_), b) => bail!(offset, "expected {}, found union", b.desc()),
-            (at @ Flags(a), Flags(b)) | (at @ Enum(a), Enum(b)) => {
-                let desc = match at {
-                    Flags(_) => "flags",
-                    _ => "enum",
-                };
-                if a.len() == b.len() && a.iter().eq(b.iter()) {
-                    Ok(())
-                } else {
-                    bail!(offset, "mismatch in {desc} elements")
-                }
-            }
-            (Flags(_), b) => bail!(offset, "expected {}, found flags", b.desc()),
-            (Enum(_), b) => bail!(offset, "expected {}, found enum", b.desc()),
-            (Result { ok: ao, err: ae }, Result { ok: bo, err: be }) => {
-                match (ao, bo) {
-                    (None, None) => {}
-                    (Some(a), Some(b)) => self
-                        .component_val_type(a, b, offset)
-                        .with_context(|| "type mismatch in ok variant")?,
-                    (None, Some(_)) => bail!(offset, "expected ok type, but found none"),
-                    (Some(_), None) => bail!(offset, "expected ok type to not be present"),
-                }
-                match (ae, be) {
-                    (None, None) => {}
-                    (Some(a), Some(b)) => self
-                        .component_val_type(a, b, offset)
-                        .with_context(|| "type mismatch in err variant")?,
-                    (None, Some(_)) => bail!(offset, "expected err type, but found none"),
-                    (Some(_), None) => bail!(offset, "expected err type to not be present"),
-                }
-                Ok(())
-            }
-            (Result { .. }, b) => bail!(offset, "expected {}, found result", b.desc()),
-            (Own(a), Own(b)) | (Borrow(a), Borrow(b)) => {
-                let a = self.a[*a].unwrap_resource();
-                let b = self.b[*b].unwrap_resource();
-                if a == b {
-                    Ok(())
-                } else {
-                    bail!(offset, "resource types are not the same")
-                }
-            }
-            (Own(_), b) => bail!(offset, "expected {}, found own", b.desc()),
-            (Borrow(_), b) => bail!(offset, "expected {}, found borrow", b.desc()),
-        }
-    }
-
-    fn primitive_val_type(
-        &self,
-        a: PrimitiveValType,
-        b: PrimitiveValType,
-        offset: usize,
-    ) -> Result<()> {
-        // Note that this intentionally diverges from the upstream specification
-        // at this time and only considers exact equality for subtyping
-        // relationships.
-        //
-        // More information can be found in the subtyping implementation for
-        // component functions.
-        if a == b {
-            Ok(())
-        } else {
-            bail!(offset, "expected primitive `{b}` found primitive `{a}`")
-        }
-    }
-
-    fn register_type_renamings(
-        &self,
-        actual: ComponentEntityType,
-        expected: ComponentEntityType,
-        type_map: &mut HashMap<TypeId, TypeId>,
-    ) {
-        match (expected, actual) {
-            (
-                ComponentEntityType::Type {
-                    created: expected, ..
-                },
-                ComponentEntityType::Type {
-                    created: actual, ..
-                },
-            ) => {
-                let prev = type_map.insert(expected, actual);
-                assert!(prev.is_none());
-            }
-            (ComponentEntityType::Instance(expected), ComponentEntityType::Instance(actual)) => {
-                let actual = self.a[actual].unwrap_component_instance();
-                for (name, expected) in self.b[expected].unwrap_component_instance().exports.iter()
-                {
-                    let actual = actual.exports[name];
-                    self.register_type_renamings(actual, *expected, type_map);
-                }
-            }
-            _ => {}
-        }
-    }
-}
-
-/// A helper typed used purely during subtyping as part of `SubtypeCx`.
-///
-/// This takes a `types` list as input which is the "base" of the ids that can
-/// be indexed through this arena. All future types pushed into this, if any,
-/// are stored in `self.list`.
-///
-/// This is intended to have arena-like behavior where everything pushed onto
-/// `self.list` is thrown away after a subtyping computation is performed. All
-/// new types pushed into this arena are purely temporary.
-pub(crate) struct SubtypeArena<'a> {
-    types: &'a TypeList,
-    list: Vec<Type>,
-}
-
-impl<'a> SubtypeArena<'a> {
-    fn new(types: &'a TypeList) -> SubtypeArena<'a> {
-        SubtypeArena {
-            types,
-            list: Vec::new(),
-        }
-    }
-}
-
-impl Index<TypeId> for SubtypeArena<'_> {
-    type Output = Type;
-
-    fn index(&self, id: TypeId) -> &Type {
-        if id.index < self.types.len() {
-            &self.types[id]
-        } else {
-            &self.list[id.index - self.types.len()]
-        }
-    }
-}
-
-impl Remap for SubtypeArena<'_> {
-    fn push_ty(&mut self, ty: Type) -> TypeId {
-        let index = self.list.len() + self.types.len();
-        let type_size = ty.type_size();
-        self.list.push(ty);
-        TypeId {
-            index,
-            type_size,
-            unique_id: 0,
-        }
-    }
-}
-
-/// Helper trait for adding contextual information to an error, modeled after
-/// `anyhow::Context`.
-pub(crate) trait Context {
-    fn with_context<S>(self, context: impl FnOnce() -> S) -> Self
-    where
-        S: Into<String>;
-}
-
-impl<T> Context for Result<T> {
-    fn with_context<S>(self, context: impl FnOnce() -> S) -> Self
-    where
-        S: Into<String>,
-    {
-        match self {
-            Ok(val) => Ok(val),
-            Err(e) => Err(e.with_context(context)),
+impl Default for TypeAlloc {
+    fn default() -> TypeAlloc {
+        TypeAlloc {
+            list: Default::default(),
         }
     }
 }
-
-impl Context for BinaryReaderError {
-    fn with_context<S>(mut self, context: impl FnOnce() -> S) -> Self
-    where
-        S: Into<String>,
-    {
-        self.add_context(context().into());
-        self
-    }
-}
diff --git a/crates/wasmprinter/Cargo.toml b/crates/wasmprinter/Cargo.toml
index e44726a2..8ebc6b0c 100644
--- a/crates/wasmprinter/Cargo.toml
+++ b/crates/wasmprinter/Cargo.toml
@@ -1,6 +1,6 @@
 [package]
 name = "wasmprinter"
-version = "0.2.60"
+version = "0.2.54"
 authors = ["Alex Crichton <alex@alexcrichton.com>"]
 edition.workspace = true
 license = "Apache-2.0 WITH LLVM-exception"
diff --git a/crates/wasmprinter/src/lib.rs b/crates/wasmprinter/src/lib.rs
index 2c63f006..dd104cca 100644
--- a/crates/wasmprinter/src/lib.rs
+++ b/crates/wasmprinter/src/lib.rs
@@ -42,7 +42,6 @@ pub fn print_bytes(wasm: impl AsRef<[u8]>) -> Result<String> {
 #[derive(Default)]
 pub struct Printer {
     print_offsets: bool,
-    print_skeleton: bool,
     printers: HashMap<String, Box<dyn FnMut(&mut Printer, usize, &[u8]) -> Result<()>>>,
     result: String,
     /// The `i`th line in `result` is at offset `lines[i]`.
@@ -56,7 +55,7 @@ pub struct Printer {
 
 #[derive(Default)]
 struct CoreState {
-    types: Vec<Option<SubType>>,
+    types: Vec<Option<FuncType>>,
     funcs: u32,
     memories: u32,
     tags: u32,
@@ -128,12 +127,6 @@ impl Printer {
         self.print_offsets = print;
     }
 
-    /// Whether or not to print only a "skeleton" which skips function bodies,
-    /// data segment contents, element segment contents, etc.
-    pub fn print_skeleton(&mut self, print: bool) {
-        self.print_skeleton = print;
-    }
-
     /// Registers a custom `printer` function to get invoked whenever a custom
     /// section of name `section` is seen.
     ///
@@ -346,39 +339,11 @@ impl Printer {
                     }
                 }
                 Payload::CustomSection(c) => {
-                    let mut printed = false;
                     let mut printers = mem::take(&mut self.printers);
                     if let Some(printer) = printers.get_mut(c.name()) {
                         printer(self, c.data_offset(), c.data())?;
-                        printed = true;
                     }
                     self.printers = printers;
-
-                    // Attempt to print this custom section if it wasn't already
-                    // handled specifically above. Note that custom sections are
-                    // allowed to be invalid, so any parse error here is ignored
-                    // and resets the output to what it was when this started.
-                    // Otherwise I/O errors and other things are plumbed through
-                    // in case they happen.
-                    if printed {
-                        continue;
-                    }
-                    let cur = self.result.len();
-                    let err = match self.print_custom_section(c.clone()) {
-                        Ok(()) => continue,
-                        Err(e) => e,
-                    };
-                    if !err.is::<BinaryReaderError>() {
-                        return Err(err);
-                    }
-                    self.result.truncate(cur);
-                    let msg = format!("failed to parse custom section `{}`: {err}", c.name());
-                    for line in msg.lines() {
-                        self.newline(c.data_offset());
-                        self.result.push_str(";; ");
-                        self.result.push_str(line);
-                    }
-                    self.newline(c.range().end);
                 }
                 Payload::TypeSection(s) => self.print_types(states.last_mut().unwrap(), s)?,
                 Payload::ImportSection(s) => {
@@ -633,25 +598,21 @@ impl Printer {
         Ok(())
     }
 
-    fn print_core_type(&mut self, states: &mut Vec<State>, ty: CoreType) -> Result<()> {
+    fn print_core_type(&mut self, states: &mut Vec<State>, ty: wasmparser::CoreType) -> Result<()> {
         self.start_group("core type ");
         self.print_name(
             &states.last().unwrap().core.type_names,
             states.last().unwrap().core.types.len() as u32,
         )?;
         let ty = match ty {
-            CoreType::Func(ty) => {
+            wasmparser::CoreType::Func(ty) => {
                 self.result.push(' ');
                 self.start_group("func");
                 self.print_func_type(states.last().unwrap(), &ty, None)?;
                 self.end_group();
-                Some(SubType {
-                    is_final: false,
-                    supertype_idx: None,
-                    structural_type: StructuralType::Func(ty),
-                })
+                Some(ty)
             }
-            CoreType::Module(decls) => {
+            wasmparser::CoreType::Module(decls) => {
                 self.print_module_type(states, decls.into_vec())?;
                 None
             }
@@ -662,56 +623,26 @@ impl Printer {
         Ok(())
     }
 
-    fn print_type(&mut self, state: &mut State, ty: SubType) -> Result<()> {
+    fn print_type(&mut self, state: &mut State, ty: wasmparser::Type) -> Result<()> {
         self.start_group("type ");
         self.print_name(&state.core.type_names, state.core.types.len() as u32)?;
         self.result.push(' ');
-        self.print_sub(state, &ty, None)?;
-        self.end_group(); // `type`
-        state.core.types.push(Some(ty));
-        Ok(())
-    }
-
-    fn print_sub(&mut self, state: &State, ty: &SubType, names_for: Option<u32>) -> Result<u32> {
-        let r = if ty.is_final || !ty.supertype_idx.is_none() {
-            self.start_group("sub");
-            self.print_sub_type(state, ty)?;
-            let r = self.print_structural(state, &ty.structural_type, names_for)?;
-            self.end_group(); // `sub`
-            r
-        } else {
-            self.print_structural(state, &ty.structural_type, names_for)?
-        };
-        Ok(r)
-    }
-
-    fn print_structural(
-        &mut self,
-        state: &State,
-        ty: &StructuralType,
-        names_for: Option<u32>,
-    ) -> Result<u32> {
-        let r = match &ty {
-            StructuralType::Func(ty) => {
+        match ty {
+            wasmparser::Type::Func(ty) => {
                 self.start_group("func");
-                let r = self.print_func_type(state, ty, names_for)?;
-                self.end_group(); // `func`
-                r
-            }
-            StructuralType::Array(ty) => {
-                self.start_group("array");
-                let r = self.print_array_type(ty)?;
-                self.end_group(); // `array`
-                r
-            }
-            StructuralType::Struct(ty) => {
-                self.start_group("struct");
-                let r = self.print_struct_type(ty)?;
-                self.end_group(); // `struct`
-                r
+                self.print_func_type(state, &ty, None)?;
+                self.end_group();
+                state.core.types.push(Some(ty))
+            }
+            wasmparser::Type::Cont(type_index) => {
+                self.start_group("cont");
+                self.print_cont_type(state, type_index)?;
+                self.end_group();
+                state.core.types.push(None) // TODO(dhil): not too sure what the purpose of state.core.types is...
             }
         };
-        Ok(r)
+        self.end_group(); // `type` itself
+        Ok(())
     }
 
     fn print_core_types(
@@ -744,14 +675,11 @@ impl Printer {
         idx: u32,
         names_for: Option<u32>,
     ) -> Result<Option<u32>> {
-        self.print_core_type_ref(state, idx)?;
+        self.print_type_ref(state, idx, true, None)?;
 
         match state.core.types.get(idx as usize) {
-            Some(Some(SubType {
-                structural_type: StructuralType::Func(ty),
-                ..
-            })) => self.print_func_type(state, ty, names_for).map(Some),
-            Some(Some(_)) | Some(None) | None => Ok(None),
+            Some(Some(ty)) => self.print_func_type(state, ty, names_for).map(Some),
+            Some(None) | None => Ok(None),
         }
     }
 
@@ -789,50 +717,13 @@ impl Printer {
         Ok(ty.params().len() as u32)
     }
 
-    fn print_field_type(&mut self, ty: &FieldType) -> Result<u32> {
-        self.result.push(' ');
-        if ty.mutable {
-            self.result.push_str("(mut ");
-        }
-        self.print_storage_type(ty.element_type)?;
-        if ty.mutable {
-            self.result.push_str(")");
-        }
-        Ok(0)
-    }
-
-    fn print_array_type(&mut self, ty: &ArrayType) -> Result<u32> {
-        self.print_field_type(&ty.0)
-    }
-
-    fn print_struct_type(&mut self, ty: &StructType) -> Result<u32> {
-        for field in ty.fields.iter() {
-            self.result.push_str(" (field");
-            self.print_field_type(field)?;
-            self.result.push(')');
-        }
-        Ok(0)
-    }
-
-    fn print_sub_type(&mut self, state: &State, ty: &SubType) -> Result<u32> {
+    fn print_cont_type(
+        &mut self,
+        state: &State,
+        type_index: u32,
+    ) -> Result<()> {
         self.result.push(' ');
-        if ty.is_final {
-            self.result.push_str("final ");
-        }
-        for idx in &ty.supertype_idx {
-            self.print_name(&state.core.type_names, *idx)?;
-            self.result.push(' ');
-        }
-        Ok(0)
-    }
-
-    fn print_storage_type(&mut self, ty: StorageType) -> Result<()> {
-        match ty {
-            StorageType::I8 => self.result.push_str("i8"),
-            StorageType::I16 => self.result.push_str("i16"),
-            StorageType::Val(val_type) => self.print_valtype(val_type)?,
-        }
-        Ok(())
+        self.print_idx(&state.core.type_names, type_index)
     }
 
     fn print_valtype(&mut self, ty: ValType) -> Result<()> {
@@ -848,27 +739,16 @@ impl Printer {
     }
 
     fn print_reftype(&mut self, ty: RefType) -> Result<()> {
-        if ty.is_nullable() {
-            match ty.as_non_null() {
-                RefType::FUNC => self.result.push_str("funcref"),
-                RefType::EXTERN => self.result.push_str("externref"),
-                RefType::I31 => self.result.push_str("i31ref"),
-                RefType::ANY => self.result.push_str("anyref"),
-                RefType::NONE => self.result.push_str("nullref"),
-                RefType::NOEXTERN => self.result.push_str("nullexternref"),
-                RefType::NOFUNC => self.result.push_str("nullfuncref"),
-                RefType::EQ => self.result.push_str("eqref"),
-                RefType::STRUCT => self.result.push_str("structref"),
-                RefType::ARRAY => self.result.push_str("arrayref"),
-                _ => {
-                    self.result.push_str("(ref null ");
-                    self.print_heaptype(ty.heap_type())?;
-                    self.result.push_str(")");
-                }
-            }
+        if ty == RefType::FUNCREF {
+            self.result.push_str("funcref");
+        } else if ty == RefType::EXTERNREF {
+            self.result.push_str("externref");
         } else {
             self.result.push_str("(ref ");
-            self.print_heaptype(ty.heap_type())?;
+            if ty.nullable {
+                self.result.push_str("null ");
+            }
+            self.print_heaptype(ty.heap_type)?;
             self.result.push_str(")");
         }
         Ok(())
@@ -878,15 +758,7 @@ impl Printer {
         match ty {
             HeapType::Func => self.result.push_str("func"),
             HeapType::Extern => self.result.push_str("extern"),
-            HeapType::Any => self.result.push_str("any"),
-            HeapType::None => self.result.push_str("none"),
-            HeapType::NoExtern => self.result.push_str("noextern"),
-            HeapType::NoFunc => self.result.push_str("nofunc"),
-            HeapType::Eq => self.result.push_str("eq"),
-            HeapType::Struct => self.result.push_str("struct"),
-            HeapType::Array => self.result.push_str("array"),
-            HeapType::I31 => self.result.push_str("i31"),
-            HeapType::Indexed(i) => self.result.push_str(&format!("{}", u32::from(i))),
+            HeapType::TypedFunc(i) => self.result.push_str(&format!("{}", u32::from(i))),
         }
         Ok(())
     }
@@ -926,7 +798,7 @@ impl Printer {
                     self.print_name(&state.core.func_names, state.core.funcs)?;
                     self.result.push(' ');
                 }
-                self.print_core_type_ref(state, *f)?;
+                self.print_type_ref(state, *f, true, None)?;
             }
             TypeRef::Table(f) => self.print_table_type(state, f, index)?,
             TypeRef::Memory(f) => self.print_memory_type(state, f, index)?,
@@ -1076,116 +948,100 @@ impl Printer {
                 .print_core_functype_idx(state, ty, Some(func_idx))?
                 .unwrap_or(0);
 
-            if self.print_skeleton {
-                self.result.push_str(" ...");
-            } else {
-                self.print_func_body(state, func_idx, params, &mut body)?;
-            }
+            let mut first = true;
+            let mut local_idx = 0;
+            let mut locals = NamedLocalPrinter::new("local");
+            for _ in 0..body.read_var_u32()? {
+                let offset = body.original_position();
+                let cnt = body.read_var_u32()?;
+                let ty = body.read()?;
+                if MAX_LOCALS
+                    .checked_sub(local_idx)
+                    .and_then(|s| s.checked_sub(cnt))
+                    .is_none()
+                {
+                    bail!("function exceeds the maximum number of locals that can be printed");
+                }
+                for _ in 0..cnt {
+                    if first {
+                        self.newline(offset);
+                        first = false;
+                    }
+                    let name = state.core.local_names.get(&(func_idx, params + local_idx));
+                    locals.start_local(name, &mut self.result);
+                    self.print_valtype(ty)?;
+                    locals.end_local(&mut self.result);
+                    local_idx += 1;
+                }
+            }
+            locals.finish(&mut self.result);
+
+            state.core.labels = 0;
+            let nesting_start = self.nesting;
+            body.allow_memarg64(true);
+
+            let mut buf = String::new();
+            let mut op_printer = operator::PrintOperator::new(self, state);
+            while !body.eof() {
+                // TODO
+                let offset = body.original_position();
+                mem::swap(&mut buf, &mut op_printer.printer.result);
+                let op_kind = body.visit_operator(&mut op_printer)??;
+                mem::swap(&mut buf, &mut op_printer.printer.result);
+
+                match op_kind {
+                    // The final `end` in a reader is not printed, it's implied
+                    // in the text format.
+                    operator::OpKind::End if body.eof() => break,
+
+                    // When we start a block we newline to the current
+                    // indentation, then we increase the indentation so further
+                    // instructions are tabbed over.
+                    operator::OpKind::BlockStart => {
+                        op_printer.printer.newline(offset);
+                        op_printer.printer.nesting += 1;
+                    }
 
-            self.end_group();
+                    // `else`/`catch` are special in that it's printed at
+                    // the previous indentation, but it doesn't actually change
+                    // our nesting level.
+                    operator::OpKind::BlockMid => {
+                        op_printer.printer.nesting -= 1;
+                        op_printer.printer.newline(offset);
+                        op_printer.printer.nesting += 1;
+                    }
 
-            state.core.funcs += 1;
-        }
-        Ok(())
-    }
+                    // Exiting a block prints `end` at the previous indentation
+                    // level. `delegate` also ends a block like `end` for `try`.
+                    operator::OpKind::End | operator::OpKind::Delegate
+                        if op_printer.printer.nesting > nesting_start =>
+                    {
+                        op_printer.printer.nesting -= 1;
+                        op_printer.printer.newline(offset);
+                    }
 
-    fn print_func_body(
-        &mut self,
-        state: &mut State,
-        func_idx: u32,
-        params: u32,
-        body: &mut BinaryReader<'_>,
-    ) -> Result<()> {
-        let mut first = true;
-        let mut local_idx = 0;
-        let mut locals = NamedLocalPrinter::new("local");
-        for _ in 0..body.read_var_u32()? {
-            let offset = body.original_position();
-            let cnt = body.read_var_u32()?;
-            let ty = body.read()?;
-            if MAX_LOCALS
-                .checked_sub(local_idx)
-                .and_then(|s| s.checked_sub(cnt))
-                .is_none()
-            {
-                bail!("function exceeds the maximum number of locals that can be printed");
-            }
-            for _ in 0..cnt {
-                if first {
-                    self.newline(offset);
-                    first = false;
-                }
-                let name = state.core.local_names.get(&(func_idx, params + local_idx));
-                locals.start_local(name, &mut self.result);
-                self.print_valtype(ty)?;
-                locals.end_local(&mut self.result);
-                local_idx += 1;
-            }
-        }
-        locals.finish(&mut self.result);
-
-        state.core.labels = 0;
-        let nesting_start = self.nesting;
-        body.allow_memarg64(true);
-
-        let mut buf = String::new();
-        let mut op_printer = operator::PrintOperator::new(self, state);
-        while !body.eof() {
-            // TODO
-            let offset = body.original_position();
-            mem::swap(&mut buf, &mut op_printer.printer.result);
-            let op_kind = body.visit_operator(&mut op_printer)??;
-            mem::swap(&mut buf, &mut op_printer.printer.result);
-
-            match op_kind {
-                // The final `end` in a reader is not printed, it's implied
-                // in the text format.
-                operator::OpKind::End if body.eof() => break,
-
-                // When we start a block we newline to the current
-                // indentation, then we increase the indentation so further
-                // instructions are tabbed over.
-                operator::OpKind::BlockStart => {
-                    op_printer.printer.newline(offset);
-                    op_printer.printer.nesting += 1;
-                }
-
-                // `else`/`catch` are special in that it's printed at
-                // the previous indentation, but it doesn't actually change
-                // our nesting level.
-                operator::OpKind::BlockMid => {
-                    op_printer.printer.nesting -= 1;
-                    op_printer.printer.newline(offset);
-                    op_printer.printer.nesting += 1;
-                }
-
-                // Exiting a block prints `end` at the previous indentation
-                // level. `delegate` also ends a block like `end` for `try`.
-                operator::OpKind::End | operator::OpKind::Delegate
-                    if op_printer.printer.nesting > nesting_start =>
-                {
-                    op_printer.printer.nesting -= 1;
-                    op_printer.printer.newline(offset);
+                    // .. otherwise everything else just has a normal newline
+                    // out in front.
+                    _ => op_printer.printer.newline(offset),
                 }
+                op_printer.printer.result.push_str(&buf);
+                buf.truncate(0);
+            }
 
-                // .. otherwise everything else just has a normal newline
-                // out in front.
-                _ => op_printer.printer.newline(offset),
+            // If this was an invalid function body then the nesting may not
+            // have reset back to normal. Fix that up here and forcibly insert
+            // a newline as well in case the last instruction was something
+            // like an `if` which has a comment after it which could interfere
+            // with the closing paren printed for the func.
+            if self.nesting != nesting_start {
+                self.nesting = nesting_start;
+                self.newline(body.original_position());
             }
-            op_printer.printer.result.push_str(&buf);
-            buf.truncate(0);
-        }
 
-        // If this was an invalid function body then the nesting may not
-        // have reset back to normal. Fix that up here and forcibly insert
-        // a newline as well in case the last instruction was something
-        // like an `if` which has a comment after it which could interfere
-        // with the closing paren printed for the func.
-        if self.nesting != nesting_start {
-            self.nesting = nesting_start;
-            self.newline(body.original_position());
-        }
+            self.end_group();
 
+            state.core.funcs += 1;
+        }
         Ok(())
     }
 
@@ -1262,16 +1118,30 @@ impl Printer {
         Ok(())
     }
 
-    fn print_core_type_ref(&mut self, state: &State, idx: u32) -> Result<()> {
-        self.result.push_str("(type ");
-        self.print_idx(&state.core.type_names, idx)?;
-        self.result.push(')');
-        Ok(())
-    }
-
-    fn print_component_type_ref(&mut self, state: &State, idx: u32) -> Result<()> {
+    fn print_type_ref(
+        &mut self,
+        state: &State,
+        idx: u32,
+        core: bool,
+        bounds: Option<TypeBounds>,
+    ) -> Result<()> {
         self.result.push_str("(type ");
-        self.print_idx(&state.component.type_names, idx)?;
+        let closing = match bounds {
+            Some(TypeBounds::Eq) => {
+                self.result.push_str("(eq ");
+                ")"
+            }
+            None => "",
+        };
+        self.print_idx(
+            if core {
+                &state.core.type_names
+            } else {
+                &state.component.type_names
+            },
+            idx,
+        )?;
+        self.result.push_str(closing);
         self.result.push(')');
         Ok(())
     }
@@ -1314,10 +1184,9 @@ impl Printer {
                     table_index,
                     offset_expr,
                 } => {
-                    let table_index = table_index.unwrap_or(0);
-                    if table_index != 0 {
+                    if *table_index != 0 {
                         self.result.push_str(" (table ");
-                        self.print_idx(&state.core.table_names, table_index)?;
+                        self.print_idx(&state.core.table_names, *table_index)?;
                         self.result.push(')');
                     }
                     self.result.push(' ');
@@ -1326,23 +1195,19 @@ impl Printer {
             }
             self.result.push(' ');
 
-            if self.print_skeleton {
-                self.result.push_str("...");
-            } else {
-                match elem.items {
-                    ElementItems::Functions(reader) => {
-                        self.result.push_str("func");
-                        for idx in reader {
-                            self.result.push(' ');
-                            self.print_idx(&state.core.func_names, idx?)?
-                        }
+            match elem.items {
+                ElementItems::Functions(reader) => {
+                    self.result.push_str("func");
+                    for idx in reader {
+                        self.result.push(' ');
+                        self.print_idx(&state.core.func_names, idx?)?
                     }
-                    ElementItems::Expressions(reader) => {
-                        self.print_reftype(elem.ty)?;
-                        for expr in reader {
-                            self.result.push(' ');
-                            self.print_const_expr_sugar(state, &expr?, "item")?
-                        }
+                }
+                ElementItems::Expressions(reader) => {
+                    self.print_reftype(elem.ty)?;
+                    for expr in reader {
+                        self.result.push(' ');
+                        self.print_const_expr_sugar(state, &expr?, "item")?
                     }
                 }
             }
@@ -1373,11 +1238,7 @@ impl Printer {
                     self.result.push(' ');
                 }
             }
-            if self.print_skeleton {
-                self.result.push_str("...");
-            } else {
-                self.print_bytes(data.data)?;
-            }
+            self.print_bytes(data.data)?;
             self.end_group();
         }
         Ok(())
@@ -1597,16 +1458,6 @@ impl Printer {
             }
             ComponentDefinedType::Option(ty) => self.print_option_type(state, ty)?,
             ComponentDefinedType::Result { ok, err } => self.print_result_type(state, *ok, *err)?,
-            ComponentDefinedType::Own(idx) => {
-                self.start_group("own ");
-                self.print_idx(&state.component.type_names, *idx)?;
-                self.end_group();
-            }
-            ComponentDefinedType::Borrow(idx) => {
-                self.start_group("borrow ");
-                self.print_idx(&state.component.type_names, *idx)?;
-                self.end_group();
-            }
         }
 
         Ok(())
@@ -1673,16 +1524,20 @@ impl Printer {
                 ComponentTypeDeclaration::Alias(alias) => {
                     self.print_component_alias(states, alias)?;
                 }
-                ComponentTypeDeclaration::Export { name, ty } => {
+                ComponentTypeDeclaration::Export { name, url, ty } => {
                     self.start_group("export ");
                     self.print_component_kind_name(states.last_mut().unwrap(), ty.kind())?;
-                    self.print_component_import_name(name.into())?;
+                    self.print_str(name)?;
+                    if !url.is_empty() {
+                        self.result.push(' ');
+                        self.print_str(url)?;
+                    }
                     self.result.push(' ');
-                    self.print_component_import_ty(states.last_mut().unwrap(), &ty, false)?;
+                    self.print_component_import_ty(states.last().unwrap(), &ty, false)?;
                     self.end_group();
                 }
                 ComponentTypeDeclaration::Import(import) => {
-                    self.print_component_import(states.last_mut().unwrap(), &import, true)?
+                    self.print_component_import(states.last_mut().unwrap(), &import, false)?
                 }
             }
         }
@@ -1707,12 +1562,16 @@ impl Printer {
                 InstanceTypeDeclaration::Alias(alias) => {
                     self.print_component_alias(states, alias)?;
                 }
-                InstanceTypeDeclaration::Export { name, ty } => {
+                InstanceTypeDeclaration::Export { name, url, ty } => {
                     self.start_group("export ");
                     self.print_component_kind_name(states.last_mut().unwrap(), ty.kind())?;
-                    self.print_component_import_name(name.into())?;
+                    self.print_str(name)?;
+                    if !url.is_empty() {
+                        self.result.push(' ');
+                        self.print_str(url)?;
+                    }
                     self.result.push(' ');
-                    self.print_component_import_ty(states.last_mut().unwrap(), &ty, false)?;
+                    self.print_component_import_ty(states.last().unwrap(), &ty, false)?;
                     self.end_group();
                 }
             }
@@ -1818,19 +1677,6 @@ impl Printer {
             ComponentType::Instance(decls) => {
                 self.print_instance_type(states, decls.into_vec())?;
             }
-            ComponentType::Resource { rep, dtor } => {
-                self.result.push_str(" ");
-                self.start_group("resource");
-                self.result.push_str(" (rep ");
-                self.print_valtype(rep)?;
-                self.result.push_str(")");
-                if let Some(dtor) = dtor {
-                    self.result.push_str(" (dtor (func ");
-                    self.print_idx(&states.last().unwrap().core.func_names, dtor)?;
-                    self.result.push_str("))");
-                }
-                self.end_group();
-            }
         }
         self.end_group();
 
@@ -1862,6 +1708,26 @@ impl Printer {
             let (offset, import) = import?;
             self.newline(offset);
             self.print_component_import(state, &import, true)?;
+            match import.ty {
+                ComponentTypeRef::Module(_) => {
+                    state.core.modules += 1;
+                }
+                ComponentTypeRef::Func(_) => {
+                    state.component.funcs += 1;
+                }
+                ComponentTypeRef::Value(_) => {
+                    state.component.values += 1;
+                }
+                ComponentTypeRef::Type(..) => {
+                    state.component.types += 1;
+                }
+                ComponentTypeRef::Instance(_) => {
+                    state.component.instances += 1;
+                }
+                ComponentTypeRef::Component(_) => {
+                    state.component.components += 1;
+                }
+            }
         }
 
         Ok(())
@@ -1874,28 +1740,20 @@ impl Printer {
         index: bool,
     ) -> Result<()> {
         self.start_group("import ");
-        self.print_component_import_name(import.name)?;
+        self.print_str(import.name)?;
+        if !import.url.is_empty() {
+            self.result.push(' ');
+            self.print_str(import.url)?;
+        }
         self.result.push(' ');
         self.print_component_import_ty(state, &import.ty, index)?;
         self.end_group();
         Ok(())
     }
 
-    fn print_component_import_name(&mut self, name: ComponentExternName<'_>) -> Result<()> {
-        match name {
-            ComponentExternName::Kebab(s) => self.print_str(s),
-            ComponentExternName::Interface(s) => {
-                self.start_group("interface ");
-                self.print_str(s)?;
-                self.end_group();
-                Ok(())
-            }
-        }
-    }
-
     fn print_component_import_ty(
         &mut self,
-        state: &mut State,
+        state: &State,
         ty: &ComponentTypeRef,
         index: bool,
     ) -> Result<()> {
@@ -1905,9 +1763,8 @@ impl Printer {
                 if index {
                     self.print_name(&state.core.module_names, state.core.modules as u32)?;
                     self.result.push(' ');
-                    state.core.modules += 1;
                 }
-                self.print_component_type_ref(state, *idx)?;
+                self.print_type_ref(state, *idx, true, None)?;
                 self.end_group();
             }
             ComponentTypeRef::Func(idx) => {
@@ -1915,9 +1772,8 @@ impl Printer {
                 if index {
                     self.print_name(&state.component.func_names, state.component.funcs)?;
                     self.result.push(' ');
-                    state.component.funcs += 1;
                 }
-                self.print_component_type_ref(state, *idx)?;
+                self.print_type_ref(state, *idx, false, None)?;
                 self.end_group();
             }
             ComponentTypeRef::Value(ty) => {
@@ -1925,43 +1781,25 @@ impl Printer {
                 if index {
                     self.print_name(&state.component.value_names, state.component.values)?;
                     self.result.push(' ');
-                    state.component.values += 1;
                 }
                 match ty {
                     ComponentValType::Primitive(ty) => self.print_primitive_val_type(ty),
                     ComponentValType::Type(idx) => {
-                        self.print_component_type_ref(state, *idx)?;
+                        self.print_type_ref(state, *idx, false, None)?;
                     }
                 }
                 self.end_group();
             }
-            ComponentTypeRef::Type(bounds) => {
-                self.result.push_str("(type ");
-                if index {
-                    self.print_name(&state.component.type_names, state.component.types)?;
-                    self.result.push(' ');
-                    state.component.types += 1;
-                }
-                match bounds {
-                    TypeBounds::Eq(idx) => {
-                        self.result.push_str("(eq ");
-                        self.print_idx(&state.component.type_names, *idx)?;
-                        self.result.push(')');
-                    }
-                    TypeBounds::SubResource => {
-                        self.result.push_str("(sub resource)");
-                    }
-                };
-                self.result.push(')');
+            ComponentTypeRef::Type(bounds, idx) => {
+                self.print_type_ref(state, *idx, false, Some(*bounds))?;
             }
             ComponentTypeRef::Instance(idx) => {
                 self.start_group("instance ");
                 if index {
                     self.print_name(&state.component.instance_names, state.component.instances)?;
                     self.result.push(' ');
-                    state.component.instances += 1;
                 }
-                self.print_component_type_ref(state, *idx)?;
+                self.print_type_ref(state, *idx, false, None)?;
                 self.end_group();
             }
             ComponentTypeRef::Component(idx) => {
@@ -1969,9 +1807,8 @@ impl Printer {
                 if index {
                     self.print_name(&state.component.component_names, state.component.components)?;
                     self.result.push(' ');
-                    state.component.components += 1;
                 }
-                self.print_component_type_ref(state, *idx)?;
+                self.print_type_ref(state, *idx, false, None)?;
                 self.end_group();
             }
         }
@@ -2001,7 +1838,11 @@ impl Printer {
         if named {
             self.print_component_kind_name(state, export.kind)?;
         }
-        self.print_component_import_name(export.name.into())?;
+        self.print_str(export.name)?;
+        if !export.url.is_empty() {
+            self.result.push(' ');
+            self.print_str(export.url)?;
+        }
         self.result.push(' ');
         self.print_component_external_kind(state, export.kind, export.index)?;
         if let Some(ty) = &export.ty {
@@ -2162,36 +2003,6 @@ impl Printer {
                     self.end_group();
                     state.core.funcs += 1;
                 }
-                CanonicalFunction::ResourceNew { resource } => {
-                    self.start_group("core func ");
-                    self.print_name(&state.core.func_names, state.core.funcs)?;
-                    self.result.push(' ');
-                    self.start_group("canon resource.new ");
-                    self.print_idx(&state.component.type_names, resource)?;
-                    self.end_group();
-                    self.end_group();
-                    state.core.funcs += 1;
-                }
-                CanonicalFunction::ResourceDrop { resource } => {
-                    self.start_group("core func ");
-                    self.print_name(&state.core.func_names, state.core.funcs)?;
-                    self.result.push(' ');
-                    self.start_group("canon resource.drop ");
-                    self.print_idx(&state.component.type_names, resource)?;
-                    self.end_group();
-                    self.end_group();
-                    state.core.funcs += 1;
-                }
-                CanonicalFunction::ResourceRep { resource } => {
-                    self.start_group("core func ");
-                    self.print_name(&state.core.func_names, state.core.funcs)?;
-                    self.result.push(' ');
-                    self.start_group("canon resource.rep ");
-                    self.print_idx(&state.component.type_names, resource)?;
-                    self.end_group();
-                    self.end_group();
-                    state.core.funcs += 1;
-                }
             }
         }
 
@@ -2545,38 +2356,6 @@ impl Printer {
         self.result.push(to_hex((byte >> 4) & 0xf));
         self.result.push(to_hex(byte & 0xf));
     }
-
-    fn print_custom_section(&mut self, section: CustomSectionReader<'_>) -> Result<()> {
-        match section.name() {
-            "producers" => {
-                self.newline(section.range().start);
-                self.print_producers_section(ProducersSectionReader::new(
-                    section.data(),
-                    section.data_offset(),
-                )?)
-            }
-            _ => Ok(()),
-        }
-    }
-
-    fn print_producers_section(&mut self, section: ProducersSectionReader<'_>) -> Result<()> {
-        self.start_group("@producers");
-        for field in section {
-            let field = field?;
-            for value in field.values.into_iter_with_offsets() {
-                let (offset, value) = value?;
-                self.newline(offset);
-                self.start_group(field.name);
-                self.result.push_str(" ");
-                self.print_str(value.name)?;
-                self.result.push_str(" ");
-                self.print_str(value.version)?;
-                self.end_group();
-            }
-        }
-        self.end_group();
-        Ok(())
-    }
 }
 
 struct NamedLocalPrinter {
diff --git a/crates/wasmprinter/src/operator.rs b/crates/wasmprinter/src/operator.rs
index 08b42529..df383af7 100644
--- a/crates/wasmprinter/src/operator.rs
+++ b/crates/wasmprinter/src/operator.rs
@@ -1,7 +1,7 @@
 use super::{Printer, State};
 use anyhow::{bail, Result};
 use std::fmt::Write;
-use wasmparser::{BlockType, BrTable, MemArg, VisitOperator};
+use wasmparser::{BlockType, BrTable, HeapType, MemArg, ResumeTable, VisitOperator};
 
 pub struct PrintOperator<'a, 'b> {
     pub(super) printer: &'a mut Printer,
@@ -90,6 +90,18 @@ impl<'a, 'b> PrintOperator<'a, 'b> {
         Ok(())
     }
 
+    fn resumetable(&mut self, targets: ResumeTable<'_>) -> Result<()> {
+        for (_, item) in targets.targets().enumerate() {
+            let (tag, label) = item?;
+            self.push_str("(tag ");
+            self.tag_index(tag)?;
+            self.push_str(" ");
+            self.relative_depth(label)?;
+            self.push_str(")");
+        }
+        Ok(())
+    }
+
     fn function_index(&mut self, idx: u32) -> Result<()> {
         self.printer.print_idx(&self.state.core.func_names, idx)
     }
@@ -117,7 +129,7 @@ impl<'a, 'b> PrintOperator<'a, 'b> {
 
     fn type_index(&mut self, idx: u32) -> Result<()> {
         self.push_str(" ");
-        self.printer.print_core_type_ref(self.state, idx)
+        self.printer.print_type_ref(self.state, idx, true, None)
     }
 
     fn data_index(&mut self, idx: u32) -> Result<()> {
@@ -166,6 +178,10 @@ impl<'a, 'b> PrintOperator<'a, 'b> {
         }
         Ok(())
     }
+
+    fn hty(&mut self, hty: HeapType) -> Result<()> {
+        self.printer.print_heaptype(hty)
+    }
 }
 
 pub enum OpKind {
@@ -217,7 +233,7 @@ macro_rules! define_visit {
             $self.table_index($table)?;
         }
         $self.type_index($ty)?;
-        let _ = $byte;
+        drop($byte);
     );
     (payload $self:ident ReturnCallIndirect $ty:ident $table:ident) => (
         if $table != 0 {
@@ -226,14 +242,6 @@ macro_rules! define_visit {
         }
         $self.type_index($ty)?;
     );
-    (payload $self:ident CallRef $ty:ident) => (
-        $self.push_str(" ");
-        $self.printer.print_idx(&$self.state.core.type_names, $ty)?;
-    );
-    (payload $self:ident ReturnCallRef $ty:ident) => (
-        $self.push_str(" ");
-        $self.printer.print_idx(&$self.state.core.type_names, $ty)?;
-    );
     (payload $self:ident TypedSelect $ty:ident) => (
         $self.push_str(" (result ");
         $self.printer.print_valtype($ty)?;
@@ -316,6 +324,28 @@ macro_rules! define_visit {
             )?;
         }
     );
+    (payload $self:ident ContNew $hty:ident) => (
+        $self.push_str(" ");
+        $self.printer.print_type_ref($self.state, $hty, true, None)?;
+    );
+    (payload $self:ident Resume $table:ident) => (
+        if $table.len() > 0 {
+            $self.push_str(" ");
+        }
+        $self.resumetable($table)?;
+    );
+    (payload $self:ident ResumeThrow $tag:ident $table:ident) => (
+        $self.push_str(" ");
+        $self.tag_index($tag)?;
+        if $table.len() > 0 {
+            $self.push_str(" ");
+        }
+        $self.resumetable($table)?;
+    );
+    (payload $self:ident ContBind $hty:ident) => (
+        $self.push_str(" ");
+        $self.printer.print_type_ref($self.state, $hty, true, None)?;
+    );
     (payload $self:ident $op:ident $($arg:ident)*) => (
         $(
             $self.push_str(" ");
@@ -861,9 +891,14 @@ macro_rules! define_visit {
     (name I16x8RelaxedQ15mulrS) => ("i16x8.relaxed_q15mulr_s");
     (name I16x8RelaxedDotI8x16I7x16S) => ("i16x8.relaxed_dot_i8x16_i7x16_s");
     (name I32x4RelaxedDotI8x16I7x16AddS) => ("i32x4.relaxed_dot_i8x16_i7x16_add_s");
-    (name I31New) => ("i31.new");
-    (name I31GetS) => ("i31.get_s");
-    (name I31GetU) => ("i31.get_u");
+
+    // Typed continuations instructions
+    (name ContNew) => ("cont.new");
+    (name ContBind) => ("cont.bind");
+    (name Resume) => ("resume");
+    (name ResumeThrow) => ("resume_throw");
+    (name Suspend) => ("suspend");
+    (name Barrier) => ("barrier");
 }
 
 impl<'a> VisitOperator<'a> for PrintOperator<'_, '_> {
diff --git a/crates/wasmprinter/tests/all.rs b/crates/wasmprinter/tests/all.rs
index eac15a7f..8392dd1b 100644
--- a/crates/wasmprinter/tests/all.rs
+++ b/crates/wasmprinter/tests/all.rs
@@ -264,15 +264,3 @@ fn offsets_and_lines_smoke_test() {
 
     assert_eq!(actual, expected);
 }
-
-#[test]
-fn no_panic_non_func_type() {
-    let bytes = wat::parse_str(
-        "(module
-            (type (struct))
-            (func (type 0))
-        )",
-    )
-    .unwrap();
-    wasmprinter::print_bytes(&bytes).unwrap();
-}
diff --git a/crates/wast/Cargo.toml b/crates/wast/Cargo.toml
index dabca595..8e405ccd 100644
--- a/crates/wast/Cargo.toml
+++ b/crates/wast/Cargo.toml
@@ -1,6 +1,6 @@
 [package]
 name = "wast"
-version = "61.0.0"
+version = "55.0.0"
 authors = ["Alex Crichton <alex@alexcrichton.com>"]
 edition.workspace = true
 license = "Apache-2.0 WITH LLVM-exception"
diff --git a/crates/wast/src/component/alias.rs b/crates/wast/src/component/alias.rs
index d073c304..3c70a2d3 100644
--- a/crates/wast/src/component/alias.rs
+++ b/crates/wast/src/component/alias.rs
@@ -4,22 +4,17 @@ use crate::parser::{Parse, Parser, Result};
 use crate::token::{Id, Index, NameAnnotation, Span};
 
 /// A inline alias for component exported items.
-///
-/// Handles both `core export` and `export` aliases
 #[derive(Debug)]
-pub struct InlineExportAlias<'a, const CORE: bool> {
+pub struct InlineExportAlias<'a> {
     /// The instance to alias the export from.
     pub instance: Index<'a>,
     /// The name of the export to alias.
     pub name: &'a str,
 }
 
-impl<'a, const CORE: bool> Parse<'a> for InlineExportAlias<'a, CORE> {
+impl<'a> Parse<'a> for InlineExportAlias<'a> {
     fn parse(parser: Parser<'a>) -> Result<Self> {
         parser.parse::<kw::alias>()?;
-        if CORE {
-            parser.parse::<kw::core>()?;
-        }
         parser.parse::<kw::export>()?;
         let instance = parser.parse()?;
         let name = parser.parse()?;
diff --git a/crates/wast/src/component/binary.rs b/crates/wast/src/component/binary.rs
index 2c875d26..8cdef48f 100644
--- a/crates/wast/src/component/binary.rs
+++ b/crates/wast/src/component/binary.rs
@@ -66,6 +66,9 @@ fn encode_core_type(encoder: CoreTypeEncoder, ty: &CoreTypeDef) {
         CoreTypeDef::Module(t) => {
             encoder.module(&t.into());
         }
+        CoreTypeDef::Def(core::TypeDef::Cont(_)) => {
+            todo!("encoding of continuation types not yet implemented")
+        }
     }
 }
 
@@ -90,10 +93,6 @@ fn encode_type(encoder: ComponentTypeEncoder, ty: &TypeDef) {
         TypeDef::Instance(i) => {
             encoder.instance(&i.into());
         }
-        TypeDef::Resource(i) => {
-            let dtor = i.dtor.as_ref().map(|i| i.idx.into());
-            encoder.resource(i.rep.into(), dtor);
-        }
     }
 }
 
@@ -134,8 +133,6 @@ fn encode_defined_type(encoder: ComponentDefinedTypeEncoder, ty: &ComponentDefin
                 e.err.as_deref().map(Into::into),
             );
         }
-        ComponentDefinedType::Own(i) => encoder.own((*i).into()),
-        ComponentDefinedType::Borrow(i) => encoder.borrow((*i).into()),
     }
 }
 
@@ -262,7 +259,7 @@ impl<'a> Encoder<'a> {
             InstanceKind::BundleOfExports(exports) => {
                 self.instances.export_items(exports.iter().map(|e| {
                     let (kind, index) = (&e.kind).into();
-                    (e.name.into(), kind, index)
+                    (e.name, kind, index)
                 }));
             }
         }
@@ -321,18 +318,6 @@ impl<'a> Encoder<'a> {
                 self.funcs
                     .lower(info.func.idx.into(), info.opts.iter().map(Into::into));
             }
-            CanonicalFuncKind::ResourceNew(info) => {
-                self.core_func_names.push(name);
-                self.funcs.resource_new(info.ty.into());
-            }
-            CanonicalFuncKind::ResourceDrop(info) => {
-                self.core_func_names.push(name);
-                self.funcs.resource_drop(info.ty.into());
-            }
-            CanonicalFuncKind::ResourceRep(info) => {
-                self.core_func_names.push(name);
-                self.funcs.resource_rep(info.ty.into());
-            }
         }
 
         self.flush(Some(self.funcs.id()));
@@ -342,7 +327,8 @@ impl<'a> Encoder<'a> {
         let name = get_name(&import.item.id, &import.item.name);
         self.names_for_item_kind(&import.item.kind).push(name);
         self.imports.import(
-            wasm_encoder::ComponentExternName::from(import.name),
+            import.name,
+            import.url.unwrap_or(""),
             (&import.item.kind).into(),
         );
         self.flush(Some(self.imports.id()));
@@ -352,7 +338,8 @@ impl<'a> Encoder<'a> {
         let name = get_name(&export.id, &export.debug_name);
         let (kind, index) = (&export.kind).into();
         self.exports.export(
-            wasm_encoder::ComponentExternName::from(export.name),
+            export.name,
+            export.url.unwrap_or(""),
             kind,
             index,
             export.ty.as_ref().map(|ty| (&ty.0.kind).into()),
@@ -587,15 +574,12 @@ impl From<core::HeapType<'_>> for wasm_encoder::HeapType {
         match r {
             core::HeapType::Func => Self::Func,
             core::HeapType::Extern => Self::Extern,
-            core::HeapType::Index(Index::Num(i, _)) => Self::Indexed(i),
+            core::HeapType::Index(Index::Num(i, _)) => Self::TypedFunc(i),
             core::HeapType::Index(_) => panic!("unresolved index"),
             core::HeapType::Any
             | core::HeapType::Eq
             | core::HeapType::Struct
             | core::HeapType::Array
-            | core::HeapType::NoFunc
-            | core::HeapType::NoExtern
-            | core::HeapType::None
             | core::HeapType::I31 => {
                 todo!("encoding of GC proposal types not yet implemented")
             }
@@ -793,10 +777,7 @@ impl From<&ItemSigKind<'_>> for wasm_encoder::ComponentTypeRef {
             ItemSigKind::Value(v) => Self::Value((&v.0).into()),
             ItemSigKind::Func(f) => Self::Func(f.into()),
             ItemSigKind::Type(TypeBounds::Eq(t)) => {
-                Self::Type(wasm_encoder::TypeBounds::Eq((*t).into()))
-            }
-            ItemSigKind::Type(TypeBounds::SubResource) => {
-                Self::Type(wasm_encoder::TypeBounds::SubResource)
+                Self::Type(wasm_encoder::TypeBounds::Eq, (*t).into())
             }
         }
     }
@@ -818,16 +799,10 @@ impl From<&ComponentType<'_>> for wasm_encoder::ComponentType {
                     encoded.alias((&a.target).into());
                 }
                 ComponentTypeDecl::Import(i) => {
-                    encoded.import(
-                        wasm_encoder::ComponentExternName::from(i.name),
-                        (&i.item.kind).into(),
-                    );
+                    encoded.import(i.name, i.url.unwrap_or(""), (&i.item.kind).into());
                 }
                 ComponentTypeDecl::Export(e) => {
-                    encoded.export(
-                        wasm_encoder::ComponentExternName::from(e.name),
-                        (&e.item.kind).into(),
-                    );
+                    encoded.export(e.name, e.url.unwrap_or(""), (&e.item.kind).into());
                 }
             }
         }
@@ -852,10 +827,7 @@ impl From<&InstanceType<'_>> for wasm_encoder::InstanceType {
                     encoded.alias((&a.target).into());
                 }
                 InstanceTypeDecl::Export(e) => {
-                    encoded.export(
-                        wasm_encoder::ComponentExternName::from(e.name),
-                        (&e.item.kind).into(),
-                    );
+                    encoded.export(e.name, e.url.unwrap_or(""), (&e.item.kind).into());
                 }
             }
         }
@@ -878,6 +850,9 @@ impl From<&ModuleType<'_>> for wasm_encoder::ModuleType {
                     core::TypeDef::Struct(_) | core::TypeDef::Array(_) => {
                         todo!("encoding of GC proposal types not yet implemented")
                     }
+                    core::TypeDef::Cont(_) => {
+                        todo!("encoding of continuation types not yet implemented")
+                    }
                 },
                 ModuleTypeDecl::Alias(a) => match &a.target {
                     AliasTarget::Outer {
@@ -998,12 +973,3 @@ impl<'a> From<&AliasTarget<'a>> for wasm_encoder::Alias<'a> {
         }
     }
 }
-
-impl<'a> From<ComponentExternName<'a>> for wasm_encoder::ComponentExternName<'a> {
-    fn from(name: ComponentExternName<'a>) -> Self {
-        match name {
-            ComponentExternName::Kebab(name) => Self::Kebab(name),
-            ComponentExternName::Interface(name) => Self::Interface(name),
-        }
-    }
-}
diff --git a/crates/wast/src/component/component.rs b/crates/wast/src/component/component.rs
index 1dc8e15e..8424e083 100644
--- a/crates/wast/src/component/component.rs
+++ b/crates/wast/src/component/component.rs
@@ -188,7 +188,7 @@ impl<'a> Parse<'a> for ComponentField<'a> {
                 return Ok(Self::Alias(parser.parse()?));
             }
             if parser.peek::<kw::r#type>() {
-                return Ok(Self::Type(Type::parse_maybe_with_inline_exports(parser)?));
+                return Ok(Self::Type(parser.parse()?));
             }
             if parser.peek::<kw::import>() {
                 return Ok(Self::Import(parser.parse()?));
diff --git a/crates/wast/src/component/expand.rs b/crates/wast/src/component/expand.rs
index ddc6c4ee..91d23b2f 100644
--- a/crates/wast/src/component/expand.rs
+++ b/crates/wast/src/component/expand.rs
@@ -136,7 +136,7 @@ impl<'a> Expander<'a> {
     }
 
     fn expand_core_module(&mut self, module: &mut CoreModule<'a>) -> Option<ComponentField<'a>> {
-        for name in module.exports.names.drain(..) {
+        for (name, url) in module.exports.names.drain(..) {
             let id = gensym::fill(module.span, &mut module.id);
             self.component_fields_to_append
                 .push(ComponentField::Export(ComponentExport {
@@ -144,6 +144,7 @@ impl<'a> Expander<'a> {
                     id: None,
                     debug_name: None,
                     name,
+                    url,
                     kind: ComponentExportKind::module(module.span, id),
                     ty: None,
                 }));
@@ -156,6 +157,7 @@ impl<'a> Expander<'a> {
                 Some(ComponentField::Import(ComponentImport {
                     span: module.span,
                     name: import.name,
+                    url: import.url,
                     item: ItemSig {
                         span: module.span,
                         id: module.id,
@@ -182,7 +184,7 @@ impl<'a> Expander<'a> {
         &mut self,
         component: &mut NestedComponent<'a>,
     ) -> Option<ComponentField<'a>> {
-        for name in component.exports.names.drain(..) {
+        for (name, url) in component.exports.names.drain(..) {
             let id = gensym::fill(component.span, &mut component.id);
             self.component_fields_to_append
                 .push(ComponentField::Export(ComponentExport {
@@ -190,6 +192,7 @@ impl<'a> Expander<'a> {
                     id: None,
                     debug_name: None,
                     name,
+                    url,
                     kind: ComponentExportKind::component(component.span, id),
                     ty: None,
                 }));
@@ -204,6 +207,7 @@ impl<'a> Expander<'a> {
                 Some(ComponentField::Import(ComponentImport {
                     span: component.span,
                     name: import.name,
+                    url: import.url,
                     item: ItemSig {
                         span: component.span,
                         id: component.id,
@@ -216,7 +220,7 @@ impl<'a> Expander<'a> {
     }
 
     fn expand_instance(&mut self, instance: &mut Instance<'a>) -> Option<ComponentField<'a>> {
-        for name in instance.exports.names.drain(..) {
+        for (name, url) in instance.exports.names.drain(..) {
             let id = gensym::fill(instance.span, &mut instance.id);
             self.component_fields_to_append
                 .push(ComponentField::Export(ComponentExport {
@@ -224,6 +228,7 @@ impl<'a> Expander<'a> {
                     id: None,
                     debug_name: None,
                     name,
+                    url,
                     kind: ComponentExportKind::instance(instance.span, id),
                     ty: None,
                 }));
@@ -234,6 +239,7 @@ impl<'a> Expander<'a> {
                 Some(ComponentField::Import(ComponentImport {
                     span: instance.span,
                     name: import.name,
+                    url: import.url,
                     item: ItemSig {
                         span: instance.span,
                         id: instance.id,
@@ -257,10 +263,7 @@ impl<'a> Expander<'a> {
             CanonicalFuncKind::Lift { ty, .. } => {
                 self.expand_component_type_use(ty);
             }
-            CanonicalFuncKind::Lower(_)
-            | CanonicalFuncKind::ResourceNew(_)
-            | CanonicalFuncKind::ResourceRep(_)
-            | CanonicalFuncKind::ResourceDrop(_) => {}
+            CanonicalFuncKind::Lower(_) => {}
         }
     }
 
@@ -282,31 +285,11 @@ impl<'a> Expander<'a> {
                 name: func.name,
                 kind: CanonicalFuncKind::Lower(mem::take(info)),
             })),
-            CoreFuncKind::ResourceNew(info) => Some(ComponentField::CanonicalFunc(CanonicalFunc {
-                span: func.span,
-                id: func.id,
-                name: func.name,
-                kind: CanonicalFuncKind::ResourceNew(mem::take(info)),
-            })),
-            CoreFuncKind::ResourceDrop(info) => {
-                Some(ComponentField::CanonicalFunc(CanonicalFunc {
-                    span: func.span,
-                    id: func.id,
-                    name: func.name,
-                    kind: CanonicalFuncKind::ResourceDrop(mem::take(info)),
-                }))
-            }
-            CoreFuncKind::ResourceRep(info) => Some(ComponentField::CanonicalFunc(CanonicalFunc {
-                span: func.span,
-                id: func.id,
-                name: func.name,
-                kind: CanonicalFuncKind::ResourceRep(mem::take(info)),
-            })),
         }
     }
 
     fn expand_func(&mut self, func: &mut Func<'a>) -> Option<ComponentField<'a>> {
-        for name in func.exports.names.drain(..) {
+        for (name, url) in func.exports.names.drain(..) {
             let id = gensym::fill(func.span, &mut func.id);
             self.component_fields_to_append
                 .push(ComponentField::Export(ComponentExport {
@@ -314,6 +297,7 @@ impl<'a> Expander<'a> {
                     id: None,
                     debug_name: None,
                     name,
+                    url,
                     kind: ComponentExportKind::func(func.span, id),
                     ty: None,
                 }));
@@ -324,6 +308,7 @@ impl<'a> Expander<'a> {
                 Some(ComponentField::Import(ComponentImport {
                     span: func.span,
                     name: import.name,
+                    url: import.url,
                     item: ItemSig {
                         span: func.span,
                         id: func.id,
@@ -377,7 +362,6 @@ impl<'a> Expander<'a> {
             TypeDef::Func(f) => self.expand_func_ty(f),
             TypeDef::Component(c) => self.expand_component_ty(c),
             TypeDef::Instance(i) => self.expand_instance_ty(i),
-            TypeDef::Resource(_) => {}
         }
 
         let id = gensym::fill(field.span, &mut field.id);
@@ -387,15 +371,15 @@ impl<'a> Expander<'a> {
             TypeDef::Func(t) => t.key().insert(self, index),
             TypeDef::Component(t) => t.key().insert(self, index),
             TypeDef::Instance(t) => t.key().insert(self, index),
-            TypeDef::Resource(_) => {}
         }
-        for name in field.exports.names.drain(..) {
+        for (name, url) in field.exports.names.drain(..) {
             self.component_fields_to_append
                 .push(ComponentField::Export(ComponentExport {
                     span: field.span,
                     id: None,
                     debug_name: None,
                     name,
+                    url,
                     kind: ComponentExportKind::ty(field.span, id),
                     ty: None,
                 }));
@@ -432,6 +416,7 @@ impl<'a> Expander<'a> {
                     }
                     core::TypeDef::Struct(_) => {}
                     core::TypeDef::Array(_) => {}
+                    core::TypeDef::Cont(_) => {}
                 },
                 ModuleTypeDecl::Alias(_) => {}
                 ModuleTypeDecl::Import(ty) => {
@@ -475,7 +460,6 @@ impl<'a> Expander<'a> {
                         name: None,
                         def: key.to_def(item.span),
                         parent: None,
-                        final_type: None,
                     }));
                     let idx = Index::Id(id);
                     t.index = Some(idx);
@@ -569,7 +553,6 @@ impl<'a> Expander<'a> {
                     self.expand_component_val_ty(ty);
                 }
             }
-            ComponentDefinedType::Own(_) | ComponentDefinedType::Borrow(_) => {}
         }
     }
 
diff --git a/crates/wast/src/component/export.rs b/crates/wast/src/component/export.rs
index a83ec522..ce9baaf4 100644
--- a/crates/wast/src/component/export.rs
+++ b/crates/wast/src/component/export.rs
@@ -1,4 +1,4 @@
-use super::{ComponentExternName, ItemRef, ItemSigNoName};
+use super::{ItemRef, ItemSigNoName};
 use crate::kw;
 use crate::parser::{Cursor, Parse, Parser, Peek, Result};
 use crate::token::{Id, Index, NameAnnotation, Span};
@@ -13,7 +13,9 @@ pub struct ComponentExport<'a> {
     /// An optional name for this instance stored in the custom `name` section.
     pub debug_name: Option<NameAnnotation<'a>>,
     /// The name of this export from the component.
-    pub name: ComponentExternName<'a>,
+    pub name: &'a str,
+    /// The URL of the export.
+    pub url: Option<&'a str>,
     /// The kind of export.
     pub kind: ComponentExportKind<'a>,
     /// The kind of export.
@@ -26,6 +28,7 @@ impl<'a> Parse<'a> for ComponentExport<'a> {
         let id = parser.parse()?;
         let debug_name = parser.parse()?;
         let name = parser.parse()?;
+        let url = parser.parse()?;
         let kind = parser.parse()?;
         let ty = if !parser.is_empty() {
             Some(parser.parens(|p| p.parse())?)
@@ -37,6 +40,7 @@ impl<'a> Parse<'a> for ComponentExport<'a> {
             id,
             debug_name,
             name,
+            url,
             kind,
             ty,
         })
@@ -173,7 +177,7 @@ impl Peek for ComponentExportKind<'_> {
 #[derive(Debug, Default)]
 pub struct InlineExport<'a> {
     /// The extra names to export an item as, if any.
-    pub names: Vec<ComponentExternName<'a>>,
+    pub names: Vec<(&'a str, Option<&'a str>)>,
 }
 
 impl<'a> Parse<'a> for InlineExport<'a> {
@@ -182,7 +186,7 @@ impl<'a> Parse<'a> for InlineExport<'a> {
         while parser.peek::<Self>() {
             names.push(parser.parens(|p| {
                 p.parse::<kw::export>()?;
-                p.parse()
+                Ok((p.parse()?, p.parse()?))
             })?);
         }
         Ok(InlineExport { names })
@@ -199,29 +203,15 @@ impl Peek for InlineExport<'_> {
             Some(("export", cursor)) => cursor,
             _ => return false,
         };
-
-        // (export "foo")
-        if let Some((_, cursor)) = cursor.string() {
-            return cursor.rparen().is_some();
-        }
-
-        // (export (interface "foo"))
-        let cursor = match cursor.lparen() {
-            Some(cursor) => cursor,
-            None => return false,
-        };
-        let cursor = match cursor.keyword() {
-            Some(("interface", cursor)) => cursor,
-            _ => return false,
-        };
-        let cursor = match cursor.string() {
+        // Name
+        let mut cursor = match cursor.string() {
             Some((_, cursor)) => cursor,
-            _ => return false,
-        };
-        let cursor = match cursor.rparen() {
-            Some(cursor) => cursor,
-            _ => return false,
+            None => return false,
         };
+        // Optional URL
+        if let Some((_, c)) = cursor.string() {
+            cursor = c;
+        }
         cursor.rparen().is_some()
     }
 
diff --git a/crates/wast/src/component/func.rs b/crates/wast/src/component/func.rs
index 10b16cfb..4edbc631 100644
--- a/crates/wast/src/component/func.rs
+++ b/crates/wast/src/component/func.rs
@@ -38,7 +38,6 @@ impl<'a> Parse<'a> for CoreFunc<'a> {
 
 /// Represents the kind of core functions.
 #[derive(Debug)]
-#[allow(missing_docs)]
 pub enum CoreFuncKind<'a> {
     /// The core function is defined in terms of lowering a component function.
     ///
@@ -47,10 +46,7 @@ pub enum CoreFuncKind<'a> {
     /// The core function is defined in terms of aliasing a module instance export.
     ///
     /// The core function is actually a member of the core alias section.
-    Alias(InlineExportAlias<'a, true>),
-    ResourceNew(CanonResourceNew<'a>),
-    ResourceDrop(CanonResourceDrop<'a>),
-    ResourceRep(CanonResourceRep<'a>),
+    Alias(InlineExportAlias<'a>),
 }
 
 impl<'a> Parse<'a> for CoreFuncKind<'a> {
@@ -59,20 +55,9 @@ impl<'a> Parse<'a> for CoreFuncKind<'a> {
             let mut l = parser.lookahead1();
             if l.peek::<kw::canon>() {
                 parser.parse::<kw::canon>()?;
+                Ok(Self::Lower(parser.parse()?))
             } else if l.peek::<kw::alias>() {
-                return Ok(Self::Alias(parser.parse()?));
-            } else {
-                return Err(l.error());
-            }
-            let mut l = parser.lookahead1();
-            if l.peek::<kw::lower>() {
-                Ok(CoreFuncKind::Lower(parser.parse()?))
-            } else if l.peek::<kw::resource_new>() {
-                Ok(CoreFuncKind::ResourceNew(parser.parse()?))
-            } else if l.peek::<kw::resource_drop>() {
-                Ok(CoreFuncKind::ResourceDrop(parser.parse()?))
-            } else if l.peek::<kw::resource_rep>() {
-                Ok(CoreFuncKind::ResourceRep(parser.parse()?))
+                Ok(Self::Alias(parser.parse()?))
             } else {
                 Err(l.error())
             }
@@ -143,7 +128,7 @@ pub enum FuncKind<'a> {
     /// The function is defined in terms of aliasing a component instance export.
     ///
     /// The function is actually a member of the alias section.
-    Alias(InlineExportAlias<'a, false>),
+    Alias(InlineExportAlias<'a>),
 }
 
 impl<'a> Parse<'a> for FuncKind<'a> {
@@ -204,49 +189,29 @@ impl<'a> Parse<'a> for CanonicalFunc<'a> {
                 kind: CanonicalFuncKind::Lift { info, ty },
             })
         } else if parser.peek::<kw::lower>() {
-            Self::parse_core_func(span, parser, CanonicalFuncKind::Lower)
-        } else if parser.peek::<kw::resource_new>() {
-            Self::parse_core_func(span, parser, CanonicalFuncKind::ResourceNew)
-        } else if parser.peek::<kw::resource_drop>() {
-            Self::parse_core_func(span, parser, CanonicalFuncKind::ResourceDrop)
-        } else if parser.peek::<kw::resource_rep>() {
-            Self::parse_core_func(span, parser, CanonicalFuncKind::ResourceRep)
+            let info = parser.parse()?;
+            let (id, name) = parser.parens(|parser| {
+                parser.parse::<kw::core>()?;
+                parser.parse::<kw::func>()?;
+                let id = parser.parse()?;
+                let name = parser.parse()?;
+                Ok((id, name))
+            })?;
+
+            Ok(Self {
+                span,
+                id,
+                name,
+                kind: CanonicalFuncKind::Lower(info),
+            })
         } else {
             Err(parser.error("expected `canon lift` or `canon lower`"))
         }
     }
 }
 
-impl<'a> CanonicalFunc<'a> {
-    fn parse_core_func<T>(
-        span: Span,
-        parser: Parser<'a>,
-        variant: fn(T) -> CanonicalFuncKind<'a>,
-    ) -> Result<Self>
-    where
-        T: Parse<'a>,
-    {
-        let info = parser.parse()?;
-        let (id, name) = parser.parens(|parser| {
-            parser.parse::<kw::core>()?;
-            parser.parse::<kw::func>()?;
-            let id = parser.parse()?;
-            let name = parser.parse()?;
-            Ok((id, name))
-        })?;
-
-        Ok(Self {
-            span,
-            id,
-            name,
-            kind: variant(info),
-        })
-    }
-}
-
 /// Possible ways to define a canonical function in the text format.
 #[derive(Debug)]
-#[allow(missing_docs)]
 pub enum CanonicalFuncKind<'a> {
     /// A canonical function that is defined in terms of lifting a core function.
     Lift {
@@ -257,10 +222,6 @@ pub enum CanonicalFuncKind<'a> {
     },
     /// A canonical function that is defined in terms of lowering a component function.
     Lower(CanonLower<'a>),
-
-    ResourceNew(CanonResourceNew<'a>),
-    ResourceDrop(CanonResourceDrop<'a>),
-    ResourceRep(CanonResourceRep<'a>),
 }
 
 /// Information relating to lifting a core function.
@@ -334,81 +295,6 @@ impl Default for CanonLower<'_> {
     }
 }
 
-/// Information relating to the `resource.new` intrinsic.
-#[derive(Debug)]
-pub struct CanonResourceNew<'a> {
-    /// The resource type that this intrinsic creates an owned reference to.
-    pub ty: Index<'a>,
-}
-
-impl<'a> Parse<'a> for CanonResourceNew<'a> {
-    fn parse(parser: Parser<'a>) -> Result<Self> {
-        parser.parse::<kw::resource_new>()?;
-
-        Ok(Self {
-            ty: parser.parse()?,
-        })
-    }
-}
-
-impl Default for CanonResourceNew<'_> {
-    fn default() -> Self {
-        CanonResourceNew {
-            ty: Index::Num(0, Span::from_offset(0)),
-        }
-    }
-}
-
-/// Information relating to the `resource.drop` intrinsic.
-#[derive(Debug)]
-pub struct CanonResourceDrop<'a> {
-    /// The resource type that this intrinsic is dropping.
-    pub ty: Index<'a>,
-}
-
-impl<'a> Parse<'a> for CanonResourceDrop<'a> {
-    fn parse(parser: Parser<'a>) -> Result<Self> {
-        parser.parse::<kw::resource_drop>()?;
-
-        Ok(Self {
-            ty: parser.parse()?,
-        })
-    }
-}
-
-impl Default for CanonResourceDrop<'_> {
-    fn default() -> Self {
-        CanonResourceDrop {
-            ty: Index::Num(0, Span::from_offset(0)),
-        }
-    }
-}
-
-/// Information relating to the `resource.rep` intrinsic.
-#[derive(Debug)]
-pub struct CanonResourceRep<'a> {
-    /// The resource type that this intrinsic is accessing.
-    pub ty: Index<'a>,
-}
-
-impl<'a> Parse<'a> for CanonResourceRep<'a> {
-    fn parse(parser: Parser<'a>) -> Result<Self> {
-        parser.parse::<kw::resource_rep>()?;
-
-        Ok(Self {
-            ty: parser.parse()?,
-        })
-    }
-}
-
-impl Default for CanonResourceRep<'_> {
-    fn default() -> Self {
-        CanonResourceRep {
-            ty: Index::Num(0, Span::from_offset(0)),
-        }
-    }
-}
-
 #[derive(Debug)]
 /// Canonical ABI options.
 pub enum CanonOpt<'a> {
diff --git a/crates/wast/src/component/import.rs b/crates/wast/src/component/import.rs
index dad83166..98fec55a 100644
--- a/crates/wast/src/component/import.rs
+++ b/crates/wast/src/component/import.rs
@@ -1,15 +1,18 @@
 use crate::component::*;
 use crate::kw;
 use crate::parser::{Cursor, Parse, Parser, Peek, Result};
-use crate::token::{Id, Index, LParen, NameAnnotation, Span};
+use crate::token::Index;
+use crate::token::{Id, NameAnnotation, Span};
 
 /// An `import` statement and entry in a WebAssembly component.
 #[derive(Debug)]
 pub struct ComponentImport<'a> {
     /// Where this `import` was defined
     pub span: Span,
-    /// The name of the item being imported.
-    pub name: ComponentExternName<'a>,
+    /// The name of the item to import.
+    pub name: &'a str,
+    /// The optional URL of the import.
+    pub url: Option<&'a str>,
     /// The item that's being imported.
     pub item: ItemSig<'a>,
 }
@@ -18,30 +21,14 @@ impl<'a> Parse<'a> for ComponentImport<'a> {
     fn parse(parser: Parser<'a>) -> Result<Self> {
         let span = parser.parse::<kw::import>()?.0;
         let name = parser.parse()?;
+        let url = parser.parse()?;
         let item = parser.parens(|p| p.parse())?;
-        Ok(ComponentImport { span, name, item })
-    }
-}
-
-/// The different ways an import can be named.
-#[derive(Debug, Copy, Clone)]
-pub enum ComponentExternName<'a> {
-    /// This is a kebab-named import where a top-level name is assigned.
-    Kebab(&'a str),
-    /// This is an interface import where the string is an ID.
-    Interface(&'a str),
-}
-
-impl<'a> Parse<'a> for ComponentExternName<'a> {
-    fn parse(parser: Parser<'a>) -> Result<Self> {
-        if parser.peek::<LParen>() {
-            Ok(ComponentExternName::Interface(parser.parens(|p| {
-                p.parse::<kw::interface>()?;
-                p.parse()
-            })?))
-        } else {
-            Ok(ComponentExternName::Kebab(parser.parse()?))
-        }
+        Ok(ComponentImport {
+            span,
+            name,
+            url,
+            item,
+        })
     }
 }
 
@@ -132,23 +119,13 @@ pub enum ItemSigKind<'a> {
 pub enum TypeBounds<'a> {
     /// The equality type bounds.
     Eq(Index<'a>),
-    /// A resource type is imported/exported,
-    SubResource,
 }
 
 impl<'a> Parse<'a> for TypeBounds<'a> {
     fn parse(parser: Parser<'a>) -> Result<Self> {
-        let mut l = parser.lookahead1();
-        if l.peek::<kw::eq>() {
-            parser.parse::<kw::eq>()?;
-            Ok(Self::Eq(parser.parse()?))
-        } else if l.peek::<kw::sub>() {
-            parser.parse::<kw::sub>()?;
-            parser.parse::<kw::resource>()?;
-            Ok(Self::SubResource)
-        } else {
-            Err(l.error())
-        }
+        // Currently this is the only supported type bounds.
+        parser.parse::<kw::eq>()?;
+        Ok(Self::Eq(parser.parse()?))
     }
 }
 
@@ -159,14 +136,19 @@ impl<'a> Parse<'a> for TypeBounds<'a> {
 #[derive(Debug, Clone)]
 pub struct InlineImport<'a> {
     /// The name of the item being imported.
-    pub name: ComponentExternName<'a>,
+    pub name: &'a str,
+    /// The optional URL of the item being imported.
+    pub url: Option<&'a str>,
 }
 
 impl<'a> Parse<'a> for InlineImport<'a> {
     fn parse(parser: Parser<'a>) -> Result<Self> {
         parser.parens(|p| {
             p.parse::<kw::import>()?;
-            Ok(InlineImport { name: p.parse()? })
+            Ok(InlineImport {
+                name: p.parse()?,
+                url: p.parse()?,
+            })
         })
     }
 }
@@ -181,28 +163,9 @@ impl Peek for InlineImport<'_> {
             Some(("import", cursor)) => cursor,
             _ => return false,
         };
-
-        // (import "foo")
-        if let Some((_, cursor)) = cursor.string() {
-            return cursor.rparen().is_some();
-        }
-
-        // (import (interface "foo"))
-        let cursor = match cursor.lparen() {
-            Some(cursor) => cursor,
-            None => return false,
-        };
-        let cursor = match cursor.keyword() {
-            Some(("interface", cursor)) => cursor,
-            _ => return false,
-        };
         let cursor = match cursor.string() {
             Some((_, cursor)) => cursor,
-            _ => return false,
-        };
-        let cursor = match cursor.rparen() {
-            Some(cursor) => cursor,
-            _ => return false,
+            None => return false,
         };
         cursor.rparen().is_some()
     }
diff --git a/crates/wast/src/component/resolve.rs b/crates/wast/src/component/resolve.rs
index d4de1d4c..e87350e3 100644
--- a/crates/wast/src/component/resolve.rs
+++ b/crates/wast/src/component/resolve.rs
@@ -1,5 +1,5 @@
 use crate::component::*;
-use crate::core::{self, ValType};
+use crate::core;
 use crate::kw;
 use crate::names::Namespace;
 use crate::token::Span;
@@ -257,7 +257,6 @@ impl<'a> Resolver<'a> {
             ItemSigKind::Value(t) => self.component_val_type(&mut t.0),
             ItemSigKind::Type(b) => match b {
                 TypeBounds::Eq(i) => self.resolve_ns(i, Ns::Type),
-                TypeBounds::SubResource => Ok(()),
             },
         }
     }
@@ -373,11 +372,6 @@ impl<'a> Resolver<'a> {
                 self.component_item_ref(&mut info.func)?;
                 &mut info.opts
             }
-            CanonicalFuncKind::ResourceNew(info) => return self.resolve_ns(&mut info.ty, Ns::Type),
-            CanonicalFuncKind::ResourceRep(info) => return self.resolve_ns(&mut info.ty, Ns::Type),
-            CanonicalFuncKind::ResourceDrop(info) => {
-                return self.resolve_ns(&mut info.ty, Ns::Type)
-            }
         };
 
         for opt in opts {
@@ -471,9 +465,6 @@ impl<'a> Resolver<'a> {
                     self.component_val_type(ty)?;
                 }
             }
-            ComponentDefinedType::Own(t) | ComponentDefinedType::Borrow(t) => {
-                self.resolve_ns(t, Ns::Type)?;
-            }
         }
         Ok(())
     }
@@ -522,29 +513,6 @@ impl<'a> Resolver<'a> {
                 self.instance_type(i)?;
                 self.stack.pop();
             }
-            TypeDef::Resource(r) => {
-                match &mut r.rep {
-                    ValType::I32 | ValType::I64 | ValType::F32 | ValType::F64 | ValType::V128 => {}
-                    ValType::Ref(r) => match &mut r.heap {
-                        core::HeapType::Func
-                        | core::HeapType::Extern
-                        | core::HeapType::Any
-                        | core::HeapType::Eq
-                        | core::HeapType::Array
-                        | core::HeapType::I31
-                        | core::HeapType::Struct
-                        | core::HeapType::None
-                        | core::HeapType::NoFunc
-                        | core::HeapType::NoExtern => {}
-                        core::HeapType::Index(id) => {
-                            self.resolve_ns(id, Ns::Type)?;
-                        }
-                    },
-                }
-                if let Some(dtor) = &mut r.dtor {
-                    self.core_item_ref(dtor)?;
-                }
-            }
         }
         Ok(())
     }
@@ -820,12 +788,7 @@ impl<'a> ComponentState<'a> {
             ComponentField::Type(t) => self.types.register(t.id, "type")?,
             ComponentField::CanonicalFunc(f) => match &f.kind {
                 CanonicalFuncKind::Lift { .. } => self.funcs.register(f.id, "func")?,
-                CanonicalFuncKind::Lower(_)
-                | CanonicalFuncKind::ResourceNew(_)
-                | CanonicalFuncKind::ResourceRep(_)
-                | CanonicalFuncKind::ResourceDrop(_) => {
-                    self.core_funcs.register(f.id, "core func")?
-                }
+                CanonicalFuncKind::Lower(_) => self.core_funcs.register(f.id, "core func")?,
             },
             ComponentField::CoreFunc(_) | ComponentField::Func(_) => {
                 unreachable!("should be expanded already")
diff --git a/crates/wast/src/component/types.rs b/crates/wast/src/component/types.rs
index 9e40ef70..0ff8cc01 100644
--- a/crates/wast/src/component/types.rs
+++ b/crates/wast/src/component/types.rs
@@ -138,26 +138,12 @@ pub struct Type<'a> {
     pub def: TypeDef<'a>,
 }
 
-impl<'a> Type<'a> {
-    /// Parses a `Type` while allowing inline `(export "...")` names to be
-    /// defined.
-    pub fn parse_maybe_with_inline_exports(parser: Parser<'a>) -> Result<Self> {
-        Type::parse(parser, true)
-    }
-
-    fn parse_no_inline_exports(parser: Parser<'a>) -> Result<Self> {
-        Type::parse(parser, false)
-    }
-
-    fn parse(parser: Parser<'a>, allow_inline_exports: bool) -> Result<Self> {
+impl<'a> Parse<'a> for Type<'a> {
+    fn parse(parser: Parser<'a>) -> Result<Self> {
         let span = parser.parse::<kw::r#type>()?.0;
         let id = parser.parse()?;
         let name = parser.parse()?;
-        let exports = if allow_inline_exports {
-            parser.parse()?
-        } else {
-            Default::default()
-        };
+        let exports = parser.parse()?;
         let def = parser.parse()?;
 
         Ok(Self {
@@ -181,8 +167,6 @@ pub enum TypeDef<'a> {
     Component(ComponentType<'a>),
     /// An instance type.
     Instance(InstanceType<'a>),
-    /// A resource type.
-    Resource(ResourceType<'a>),
 }
 
 impl<'a> Parse<'a> for TypeDef<'a> {
@@ -199,9 +183,6 @@ impl<'a> Parse<'a> for TypeDef<'a> {
                 } else if l.peek::<kw::instance>() {
                     parser.parse::<kw::instance>()?;
                     Ok(Self::Instance(parser.parse()?))
-                } else if l.peek::<kw::resource>() {
-                    parser.parse::<kw::resource>()?;
-                    Ok(Self::Resource(parser.parse()?))
                 } else {
                     Ok(Self::Defined(ComponentDefinedType::parse_non_primitive(
                         parser, l,
@@ -375,8 +356,6 @@ pub enum ComponentDefinedType<'a> {
     Union(Union<'a>),
     Option(OptionType<'a>),
     Result(ResultType<'a>),
-    Own(Index<'a>),
-    Borrow(Index<'a>),
 }
 
 impl<'a> ComponentDefinedType<'a> {
@@ -400,12 +379,6 @@ impl<'a> ComponentDefinedType<'a> {
             Ok(Self::Option(parser.parse()?))
         } else if l.peek::<kw::result>() {
             Ok(Self::Result(parser.parse()?))
-        } else if l.peek::<kw::own>() {
-            parser.parse::<kw::own>()?;
-            Ok(Self::Own(parser.parse()?))
-        } else if l.peek::<kw::borrow>() {
-            parser.parse::<kw::borrow>()?;
-            Ok(Self::Borrow(parser.parse()?))
         } else {
             Err(l.error())
         }
@@ -436,8 +409,6 @@ impl Peek for ComponentDefinedType<'_> {
                     | Some(("union", _))
                     | Some(("option", _))
                     | Some(("result", _))
-                    | Some(("own", _))
-                    | Some(("borrow", _))
             ),
             None => false,
         }
@@ -768,7 +739,9 @@ pub struct ComponentExportType<'a> {
     /// Where this export was defined.
     pub span: Span,
     /// The name of this export.
-    pub name: ComponentExternName<'a>,
+    pub name: &'a str,
+    /// The optional URL of this export.
+    pub url: Option<&'a str>,
     /// The signature of the item.
     pub item: ItemSig<'a>,
 }
@@ -779,13 +752,19 @@ impl<'a> Parse<'a> for ComponentExportType<'a> {
         let id = parser.parse()?;
         let debug_name = parser.parse()?;
         let name = parser.parse()?;
+        let url = parser.parse()?;
         let item = parser.parens(|p| {
             let mut item = p.parse::<ItemSigNoName<'_>>()?.0;
             item.id = id;
             item.name = debug_name;
             Ok(item)
         })?;
-        Ok(Self { span, name, item })
+        Ok(Self {
+            span,
+            name,
+            url,
+            item,
+        })
     }
 }
 
@@ -826,7 +805,7 @@ impl<'a> Parse<'a> for ComponentTypeDecl<'a> {
         if l.peek::<kw::core>() {
             Ok(Self::CoreType(parser.parse()?))
         } else if l.peek::<kw::r#type>() {
-            Ok(Self::Type(Type::parse_no_inline_exports(parser)?))
+            Ok(Self::Type(parser.parse()?))
         } else if l.peek::<kw::alias>() {
             Ok(Self::Alias(parser.parse()?))
         } else if l.peek::<kw::import>() {
@@ -884,7 +863,7 @@ impl<'a> Parse<'a> for InstanceTypeDecl<'a> {
         if l.peek::<kw::core>() {
             Ok(Self::CoreType(parser.parse()?))
         } else if l.peek::<kw::r#type>() {
-            Ok(Self::Type(Type::parse_no_inline_exports(parser)?))
+            Ok(Self::Type(parser.parse()?))
         } else if l.peek::<kw::alias>() {
             Ok(Self::Alias(parser.parse()?))
         } else if l.peek::<kw::export>() {
@@ -905,33 +884,6 @@ impl<'a> Parse<'a> for Vec<InstanceTypeDecl<'a>> {
     }
 }
 
-/// A type definition for an instance type.
-#[derive(Debug)]
-pub struct ResourceType<'a> {
-    /// Representation, in core WebAssembly, of this resource.
-    pub rep: core::ValType<'a>,
-    /// The declarations of the instance type.
-    pub dtor: Option<CoreItemRef<'a, kw::func>>,
-}
-
-impl<'a> Parse<'a> for ResourceType<'a> {
-    fn parse(parser: Parser<'a>) -> Result<Self> {
-        let rep = parser.parens(|p| {
-            p.parse::<kw::rep>()?;
-            p.parse()
-        })?;
-        let dtor = if parser.is_empty() {
-            None
-        } else {
-            Some(parser.parens(|p| {
-                p.parse::<kw::dtor>()?;
-                p.parens(|p| p.parse())
-            })?)
-        };
-        Ok(Self { rep, dtor })
-    }
-}
-
 /// A value type declaration used for values in import signatures.
 #[derive(Debug)]
 pub struct ComponentValTypeUse<'a>(pub ComponentValType<'a>);
diff --git a/crates/wast/src/core/binary.rs b/crates/wast/src/core/binary.rs
index 507ef330..de509f6e 100644
--- a/crates/wast/src/core/binary.rs
+++ b/crates/wast/src/core/binary.rs
@@ -108,8 +108,8 @@ impl Encoder<'_> {
 
     fn custom_sections(&mut self, place: CustomPlace) {
         for entry in self.customs.iter() {
-            if entry.place() == place {
-                self.section(0, &(entry.name(), entry));
+            if entry.place == place {
+                self.section(0, &(entry.name, entry));
             }
         }
     }
@@ -157,6 +157,12 @@ impl Encode for ExportType<'_> {
     }
 }
 
+impl Encode for ContinuationType<'_> {
+    fn encode(&self, e: &mut Vec<u8>) {
+        self.idx.encode(e);
+    }
+}
+
 enum RecOrType<'a> {
     Type(&'a Type<'a>),
     Rec(&'a Rec<'a>),
@@ -173,25 +179,10 @@ impl Encode for RecOrType<'_> {
 
 impl Encode for Type<'_> {
     fn encode(&self, e: &mut Vec<u8>) {
-        match (&self.parent, self.final_type) {
-            (Some(parent), Some(true)) => {
-                // Type is final with a supertype
-                e.push(0x4e);
-                e.push(0x01);
-                parent.encode(e);
-            }
-            (Some(parent), Some(false) | None) => {
-                // Type is not final and has a declared supertype
-                e.push(0x50);
-                e.push(0x01);
-                parent.encode(e);
-            }
-            (None, Some(false)) => {
-                // Sub was used without any declared supertype
-                e.push(0x50);
-                e.push(0x00);
-            }
-            (None, _) => {} // No supertype, sub wasn't used
+        if let Some(parent) = &self.parent {
+            e.push(0x50);
+            (1 as usize).encode(e);
+            parent.encode(e);
         }
         match &self.def {
             TypeDef::Func(func) => {
@@ -206,6 +197,10 @@ impl Encode for Type<'_> {
                 e.push(0x5e);
                 array.encode(e)
             }
+            TypeDef::Cont(u) => {
+                e.push(0x5d);
+                u.encode(e)
+            }
         }
     }
 }
@@ -256,9 +251,6 @@ impl<'a> Encode for HeapType<'a> {
             HeapType::Struct => e.push(0x67),
             HeapType::Array => e.push(0x66),
             HeapType::I31 => e.push(0x6a),
-            HeapType::NoFunc => e.push(0x68),
-            HeapType::NoExtern => e.push(0x69),
-            HeapType::None => e.push(0x65),
             // Note that this is encoded as a signed leb128 so be sure to cast
             // to an i64 first
             HeapType::Index(Index::Num(n, _)) => i64::from(*n).encode(e),
@@ -297,23 +289,8 @@ impl<'a> Encode for RefType<'a> {
                 nullable: true,
                 heap: HeapType::I31,
             } => e.push(0x6a),
-            // The 'nullfuncref' binary abbreviation
-            RefType {
-                nullable: true,
-                heap: HeapType::NoFunc,
-            } => e.push(0x68),
-            // The 'nullexternref' binary abbreviation
-            RefType {
-                nullable: true,
-                heap: HeapType::NoExtern,
-            } => e.push(0x69),
-            // The 'nullref' binary abbreviation
-            RefType {
-                nullable: true,
-                heap: HeapType::None,
-            } => e.push(0x65),
 
-            // Generic 'ref null <heaptype>' encoding
+            // Generic 'ref opt <heaptype>' encoding
             RefType {
                 nullable: true,
                 heap,
@@ -641,10 +618,10 @@ impl Encode for Func<'_> {
     }
 }
 
-impl Encode for Box<[Local<'_>]> {
+impl Encode for Vec<Local<'_>> {
     fn encode(&self, e: &mut Vec<u8>) {
         let mut locals_compressed = Vec::<(u32, ValType)>::new();
-        for local in self.iter() {
+        for local in self {
             if let Some((cnt, prev)) = locals_compressed.last_mut() {
                 if *prev == local.ty {
                     *cnt += 1;
@@ -783,6 +760,19 @@ impl Encode for BrTableIndices<'_> {
     }
 }
 
+impl Encode for ResumeTableIndices<'_> {
+    fn encode(&self, e: &mut Vec<u8>) {
+        self.targets.encode(e);
+    }
+}
+
+impl Encode for ResumeThrow<'_> {
+    fn encode(&self, e: &mut Vec<u8>) {
+        self.index.encode(e);
+        self.table.encode(e);
+    }
+}
+
 impl Encode for Float32 {
     fn encode(&self, e: &mut Vec<u8>) {
         e.extend_from_slice(&self.bits.to_le_bytes());
@@ -919,7 +909,7 @@ fn find_names<'a>(
                 locals, expression, ..
             } = &f.kind
             {
-                for local in locals.iter() {
+                for local in locals {
                     if let Some(name) = get_name(&local.id, &local.name) {
                         local_names.push((local_idx, name));
                     }
@@ -932,7 +922,8 @@ fn find_names<'a>(
                         | Instruction::Block(block)
                         | Instruction::Loop(block)
                         | Instruction::Try(block)
-                        | Instruction::Let(LetType { block, .. }) => {
+                        | Instruction::Let(LetType { block, .. })
+                        | Instruction::Barrier(block) => {
                             if let Some(name) = get_name(&block.label, &block.label_name) {
                                 label_names.push((label_idx, name));
                             }
@@ -1058,15 +1049,6 @@ impl<'a> Encode for SelectTypes<'a> {
 }
 
 impl Encode for Custom<'_> {
-    fn encode(&self, e: &mut Vec<u8>) {
-        match self {
-            Custom::Raw(r) => r.encode(e),
-            Custom::Producers(p) => p.encode(e),
-        }
-    }
-}
-
-impl Encode for RawCustomSection<'_> {
     fn encode(&self, e: &mut Vec<u8>) {
         for list in self.data.iter() {
             e.extend_from_slice(list);
@@ -1074,12 +1056,6 @@ impl Encode for RawCustomSection<'_> {
     }
 }
 
-impl Encode for Producers<'_> {
-    fn encode(&self, e: &mut Vec<u8>) {
-        self.fields.encode(e);
-    }
-}
-
 impl Encode for Tag<'_> {
     fn encode(&self, e: &mut Vec<u8>) {
         self.ty.encode(e);
@@ -1108,12 +1084,6 @@ impl Encode for StructAccess<'_> {
     }
 }
 
-impl Encode for ArrayFill<'_> {
-    fn encode(&self, e: &mut Vec<u8>) {
-        self.array.encode(e);
-    }
-}
-
 impl Encode for ArrayCopy<'_> {
     fn encode(&self, e: &mut Vec<u8>) {
         self.dest_array.encode(e);
@@ -1121,13 +1091,6 @@ impl Encode for ArrayCopy<'_> {
     }
 }
 
-impl Encode for ArrayInit<'_> {
-    fn encode(&self, e: &mut Vec<u8>) {
-        self.array.encode(e);
-        self.segment.encode(e);
-    }
-}
-
 impl Encode for ArrayNewFixed<'_> {
     fn encode(&self, e: &mut Vec<u8>) {
         self.array.encode(e);
@@ -1149,70 +1112,9 @@ impl Encode for ArrayNewElem<'_> {
     }
 }
 
-impl Encode for RefTest<'_> {
-    fn encode(&self, e: &mut Vec<u8>) {
-        e.push(0xfb);
-        if self.r#type.nullable {
-            e.push(0x48);
-        } else {
-            e.push(0x40);
-        }
-        self.r#type.heap.encode(e);
-    }
-}
-
-impl Encode for RefCast<'_> {
-    fn encode(&self, e: &mut Vec<u8>) {
-        e.push(0xfb);
-        if self.r#type.nullable {
-            e.push(0x49);
-        } else {
-            e.push(0x41);
-        }
-        self.r#type.heap.encode(e);
-    }
-}
-
-fn br_on_cast_flags(on_fail: bool, from_nullable: bool, to_nullable: bool) -> u8 {
-    let mut flag = 0;
-    if from_nullable {
-        flag |= 1 << 0;
-    }
-    if to_nullable {
-        flag |= 1 << 1;
-    }
-    if on_fail {
-        flag |= 1 << 2;
-    }
-    flag
-}
-
 impl Encode for BrOnCast<'_> {
     fn encode(&self, e: &mut Vec<u8>) {
-        e.push(0xfb);
-        e.push(0x4f);
-        e.push(br_on_cast_flags(
-            false,
-            self.from_type.nullable,
-            self.to_type.nullable,
-        ));
-        self.label.encode(e);
-        self.from_type.heap.encode(e);
-        self.to_type.heap.encode(e);
-    }
-}
-
-impl Encode for BrOnCastFail<'_> {
-    fn encode(&self, e: &mut Vec<u8>) {
-        e.push(0xfb);
-        e.push(0x4f);
-        e.push(br_on_cast_flags(
-            true,
-            self.from_type.nullable,
-            self.to_type.nullable,
-        ));
         self.label.encode(e);
-        self.from_type.heap.encode(e);
-        self.to_type.heap.encode(e);
+        self.r#type.encode(e);
     }
 }
diff --git a/crates/wast/src/core/custom.rs b/crates/wast/src/core/custom.rs
index 554a0b8d..40c20b1c 100644
--- a/crates/wast/src/core/custom.rs
+++ b/crates/wast/src/core/custom.rs
@@ -2,46 +2,9 @@ use crate::parser::{Parse, Parser, Result};
 use crate::token::{self, Span};
 use crate::{annotation, kw};
 
-/// A custom section within a wasm module.
-#[derive(Debug)]
-pub enum Custom<'a> {
-    /// A raw custom section with the manual placement and bytes specified.
-    Raw(RawCustomSection<'a>),
-    /// A producers custom section.
-    Producers(Producers<'a>),
-}
-
-impl Custom<'_> {
-    /// Where this custom section is placed.
-    pub fn place(&self) -> CustomPlace {
-        match self {
-            Custom::Raw(s) => s.place,
-            Custom::Producers(_) => CustomPlace::AfterLast,
-        }
-    }
-
-    /// The name of this custom section
-    pub fn name(&self) -> &str {
-        match self {
-            Custom::Raw(s) => s.name,
-            Custom::Producers(_) => "producers",
-        }
-    }
-}
-
-impl<'a> Parse<'a> for Custom<'a> {
-    fn parse(parser: Parser<'a>) -> Result<Self> {
-        if parser.peek::<annotation::producers>() {
-            Ok(Custom::Producers(parser.parse()?))
-        } else {
-            Ok(Custom::Raw(parser.parse()?))
-        }
-    }
-}
-
 /// A wasm custom section within a module.
 #[derive(Debug)]
-pub struct RawCustomSection<'a> {
+pub struct Custom<'a> {
     /// Where this `@custom` was defined.
     pub span: Span,
 
@@ -86,7 +49,7 @@ pub enum CustomPlaceAnchor {
     Tag,
 }
 
-impl<'a> Parse<'a> for RawCustomSection<'a> {
+impl<'a> Parse<'a> for Custom<'a> {
     fn parse(parser: Parser<'a>) -> Result<Self> {
         let span = parser.parse::<annotation::custom>()?.0;
         let name = parser.parse()?;
@@ -99,7 +62,7 @@ impl<'a> Parse<'a> for RawCustomSection<'a> {
         while !parser.is_empty() {
             data.push(parser.parse()?);
         }
-        Ok(RawCustomSection {
+        Ok(Custom {
             span,
             name,
             place,
@@ -186,51 +149,3 @@ impl<'a> Parse<'a> for CustomPlaceAnchor {
         Err(parser.error("expected a valid section name"))
     }
 }
-
-/// A producers custom section
-#[allow(missing_docs)]
-#[derive(Debug)]
-pub struct Producers<'a> {
-    pub fields: Vec<(&'a str, Vec<(&'a str, &'a str)>)>,
-}
-
-impl<'a> Parse<'a> for Producers<'a> {
-    fn parse(parser: Parser<'a>) -> Result<Self> {
-        parser.parse::<annotation::producers>()?.0;
-        let mut languages = Vec::new();
-        let mut sdks = Vec::new();
-        let mut processed_by = Vec::new();
-        while !parser.is_empty() {
-            parser.parens(|parser| {
-                let mut l = parser.lookahead1();
-                let dst = if l.peek::<kw::language>() {
-                    parser.parse::<kw::language>()?;
-                    &mut languages
-                } else if l.peek::<kw::sdk>() {
-                    parser.parse::<kw::sdk>()?;
-                    &mut sdks
-                } else if l.peek::<kw::processed_by>() {
-                    parser.parse::<kw::processed_by>()?;
-                    &mut processed_by
-                } else {
-                    return Err(l.error());
-                };
-
-                dst.push((parser.parse()?, parser.parse()?));
-                Ok(())
-            })?;
-        }
-
-        let mut fields = Vec::new();
-        if !languages.is_empty() {
-            fields.push(("language", languages));
-        }
-        if !sdks.is_empty() {
-            fields.push(("sdk", sdks));
-        }
-        if !processed_by.is_empty() {
-            fields.push(("processed-by", processed_by));
-        }
-        Ok(Producers { fields })
-    }
-}
diff --git a/crates/wast/src/core/expr.rs b/crates/wast/src/core/expr.rs
index 01316f96..bd175a47 100644
--- a/crates/wast/src/core/expr.rs
+++ b/crates/wast/src/core/expr.rs
@@ -1,7 +1,7 @@
 use crate::core::*;
 use crate::encode::Encode;
 use crate::kw;
-use crate::parser::{Cursor, Parse, Parser, Result};
+use crate::parser::{Cursor, Parse, Parser, Peek, Result};
 use crate::token::*;
 use std::mem;
 
@@ -153,7 +153,8 @@ impl<'a> ExpressionParser<'a> {
                         // seen
                         i @ Instruction::Block(_)
                         | i @ Instruction::Loop(_)
-                        | i @ Instruction::Let(_) => {
+                        | i @ Instruction::Let(_)
+                        | i @ Instruction::Barrier(_) => {
                             self.instrs.push(i);
                             self.stack.push(Level::EndWith(Instruction::End(None)));
                         }
@@ -502,10 +503,10 @@ macro_rules! instructions {
 
 instructions! {
     pub enum Instruction<'a> {
-        Block(Box<BlockType<'a>>) : [0x02] : "block",
-        If(Box<BlockType<'a>>) : [0x04] : "if",
+        Block(BlockType<'a>) : [0x02] : "block",
+        If(BlockType<'a>) : [0x04] : "if",
         Else(Option<Id<'a>>) : [0x05] : "else",
-        Loop(Box<BlockType<'a>>) : [0x03] : "loop",
+        Loop(BlockType<'a>) : [0x03] : "loop",
         End(Option<Id<'a>>) : [0x0b] : "end",
 
         Unreachable : [0x00] : "unreachable",
@@ -515,15 +516,15 @@ instructions! {
         BrTable(BrTableIndices<'a>) : [0x0e] : "br_table",
         Return : [0x0f] : "return",
         Call(Index<'a>) : [0x10] : "call",
-        CallIndirect(Box<CallIndirect<'a>>) : [0x11] : "call_indirect",
+        CallIndirect(CallIndirect<'a>) : [0x11] : "call_indirect",
 
         // tail-call proposal
         ReturnCall(Index<'a>) : [0x12] : "return_call",
-        ReturnCallIndirect(Box<CallIndirect<'a>>) : [0x13] : "return_call_indirect",
+        ReturnCallIndirect(CallIndirect<'a>) : [0x13] : "return_call_indirect",
 
         // function-references proposal
-        CallRef(Index<'a>) : [0x14] : "call_ref",
-        ReturnCallRef(Index<'a>) : [0x15] : "return_call_ref",
+        CallRef(HeapType<'a>) : [0x14] : "call_ref",
+        ReturnCallRef(HeapType<'a>) : [0x15] : "return_call_ref",
         FuncBind(FuncBindType<'a>) : [0x16] : "func.bind",
         Let(LetType<'a>) : [0x17] : "let",
 
@@ -602,16 +603,13 @@ instructions! {
         ArrayNewDefault(Index<'a>) : [0xfb, 0x1c] : "array.new_default",
         ArrayNewFixed(ArrayNewFixed<'a>) : [0xfb, 0x1a] : "array.new_fixed",
         ArrayNewData(ArrayNewData<'a>) : [0xfb, 0x1d] : "array.new_data",
-        ArrayNewElem(ArrayNewElem<'a>) : [0xfb, 0x1f] : "array.new_elem",
+        ArrayNewElem(ArrayNewElem<'a>) : [0xfb, 0x10] : "array.new_elem",
         ArrayGet(Index<'a>) : [0xfb, 0x13] : "array.get",
         ArrayGetS(Index<'a>) : [0xfb, 0x14] : "array.get_s",
         ArrayGetU(Index<'a>) : [0xfb, 0x15] : "array.get_u",
         ArraySet(Index<'a>) : [0xfb, 0x16] : "array.set",
-        ArrayLen : [0xfb, 0x19] : "array.len",
-        ArrayFill(ArrayFill<'a>) : [0xfb, 0x0f] : "array.fill",
         ArrayCopy(ArrayCopy<'a>) : [0xfb, 0x18] : "array.copy",
-        ArrayInitData(ArrayInit<'a>) : [0xfb, 0x54] : "array.init_data",
-        ArrayInitElem(ArrayInit<'a>) : [0xfb, 0x55] : "array.init_elem",
+        ArrayLen : [0xfb, 0x19] : "array.len",
 
         // gc proposal, i31
         I31New : [0xfb, 0x20] : "i31.new",
@@ -619,10 +617,31 @@ instructions! {
         I31GetU : [0xfb, 0x22] : "i31.get_u",
 
         // gc proposal, concrete casting
-        RefTest(RefTest<'a>) : [] : "ref.test",
-        RefCast(RefCast<'a>) : [] : "ref.cast",
-        BrOnCast(Box<BrOnCast<'a>>) : [] : "br_on_cast",
-        BrOnCastFail(Box<BrOnCastFail<'a>>) : [] : "br_on_cast_fail",
+        RefTest(Index<'a>) : [0xfb, 0x44] : "ref.test",
+        RefCast(Index<'a>) : [0xfb, 0x45] : "ref.cast",
+        BrOnCast(BrOnCast<'a>) : [0xfb, 0x46] : "br_on_cast",
+        BrOnCastFail(BrOnCast<'a>) : [0xfb, 0x47] : "br_on_cast_fail",
+
+        // gc proposal, heap casting
+        RefIsFunc : [0xfb, 0x50] : "ref.is_func",
+        RefIsData : [0xfb, 0x51] : "ref.is_data",
+        RefIsI31 : [0xfb, 0x52] : "ref.is_i31",
+        RefIsArray : [0xfb, 0x53] : "ref.is_array",
+
+        RefAsFunc : [0xfb, 0x58] : "ref.as_func",
+        RefAsData : [0xfb, 0x59] : "ref.as_data",
+        RefAsI31 : [0xfb, 0x5a] : "ref.as_i31",
+        RefAsArray : [0xfb, 0x5b] : "ref.as_array",
+
+        BrOnFunc(Index<'a>) : [0xfb, 0x60] : "br_on_func",
+        BrOnData(Index<'a>) : [0xfb, 0x61] : "br_on_data",
+        BrOnI31(Index<'a>) : [0xfb, 0x62] : "br_on_i31",
+        BrOnArray(Index<'a>) : [0xfb, 0x66] : "br_on_array",
+
+        BrOnNonFunc(Index<'a>) : [0xfb, 0x63] : "br_on_non_func",
+        BrOnNonData(Index<'a>) : [0xfb, 0x64] : "br_on_non_data",
+        BrOnNonI31(Index<'a>) : [0xfb, 0x65] : "br_on_non_i31",
+        BrOnNonArray(Index<'a>) : [0xfb, 0x67] : "br_on_non_array",
 
         // gc proposal extern/any coercion operations
         ExternInternalize : [0xfb, 0x70] : "extern.internalize",
@@ -1118,7 +1137,7 @@ instructions! {
         F64x2PromoteLowF32x4 : [0xfd, 95] : "f64x2.promote_low_f32x4",
 
         // Exception handling proposal
-        Try(Box<BlockType<'a>>) : [0x06] : "try",
+        Try(BlockType<'a>) : [0x06] : "try",
         Catch(Index<'a>) : [0x07] : "catch",
         Throw(Index<'a>) : [0x08] : "throw",
         Rethrow(Index<'a>) : [0x09] : "rethrow",
@@ -1146,19 +1165,17 @@ instructions! {
         I16x8RelaxedQ15mulrS: [0xfd, 0x111]: "i16x8.relaxed_q15mulr_s",
         I16x8RelaxedDotI8x16I7x16S: [0xfd, 0x112]: "i16x8.relaxed_dot_i8x16_i7x16_s",
         I32x4RelaxedDotI8x16I7x16AddS: [0xfd, 0x113]: "i32x4.relaxed_dot_i8x16_i7x16_add_s",
+
+        // Typed continuations proposal
+        ContNew(TypeUse<'a, FunctionType<'a>>) : [0xe0] : "cont.new",
+        ContBind(TypeUse<'a, FunctionType<'a>>) : [0xe1] : "cont.bind",
+        Suspend(Index<'a>)              : [0xe2] : "suspend",
+        Resume(ResumeTableIndices<'a>)  : [0xe3] : "resume",
+        ResumeThrow(ResumeThrow<'a>)    : [0xe4] : "resume_throw",
+        Barrier(BlockType<'a>)          : [0xe5] : "barrier",
     }
 }
 
-// As shown in #1095 the size of this variant is somewhat performance-sensitive
-// since big `*.wat` files will have a lot of these. This is a small ratchet to
-// make sure that this enum doesn't become larger than it already is, although
-// ideally it also wouldn't be as large as it is now.
-const _: () = {
-    let size = std::mem::size_of::<Instruction<'_>>();
-    let pointer = std::mem::size_of::<u64>();
-    assert!(size <= pointer * 10);
-};
-
 impl<'a> Instruction<'a> {
     pub(crate) fn needs_data_count(&self) -> bool {
         match self {
@@ -1194,6 +1211,23 @@ impl<'a> Parse<'a> for BlockType<'a> {
     }
 }
 
+/// Extra information associated with the resume_throw instruction
+#[derive(Debug)]
+#[allow(missing_docs)]
+pub struct ResumeThrow<'a> {
+    pub index: Index<'a>,
+    pub table: ResumeTableIndices<'a>,
+}
+
+impl<'a> Parse<'a> for ResumeThrow<'a> {
+    fn parse(parser: Parser<'a>) -> Result<Self> {
+        Ok(ResumeThrow {
+            index: parser.parse()?,
+            table: parser.parse()?,
+        })
+    }
+}
+
 /// Extra information associated with the func.bind instruction.
 #[derive(Debug)]
 #[allow(missing_docs)]
@@ -1215,15 +1249,15 @@ impl<'a> Parse<'a> for FuncBindType<'a> {
 #[derive(Debug)]
 #[allow(missing_docs)]
 pub struct LetType<'a> {
-    pub block: Box<BlockType<'a>>,
-    pub locals: Box<[Local<'a>]>,
+    pub block: BlockType<'a>,
+    pub locals: Vec<Local<'a>>,
 }
 
 impl<'a> Parse<'a> for LetType<'a> {
     fn parse(parser: Parser<'a>) -> Result<Self> {
         Ok(LetType {
             block: parser.parse()?,
-            locals: Local::parse_remainder(parser)?.into(),
+            locals: Local::parse_remainder(parser)?,
         })
     }
 }
@@ -1247,6 +1281,53 @@ impl<'a> Parse<'a> for BrTableIndices<'a> {
     }
 }
 
+/// Extra information associated with the `resume` instruction.
+#[allow(missing_docs)]
+#[derive(Debug)]
+pub struct ResumeTableIndices<'a> {
+    pub targets: Vec<(Index<'a>, Index<'a>)>,
+}
+
+impl Peek for (Index<'_>, Index<'_>) {
+    fn peek(cursor: Cursor<'_>) -> bool {
+        Index::peek(cursor) && Index::peek2(cursor)
+    }
+
+    fn display() -> &'static str {
+        "index pair"
+    }
+}
+
+impl<'a> Parse<'a> for (Index<'a>, Index<'a>) {
+    fn parse(parser: Parser<'a>) -> Result<Self> {
+        if parser.peek::<Index>() {
+            let fst = parser.parse()?;
+            if parser.peek::<Index>() {
+                let snd = parser.parse()?;
+                Ok((fst, snd))
+            } else {
+                Err(parser.error("expected index"))
+            }
+        } else {
+            Err(parser.error("expected index"))
+        }
+    }
+}
+
+impl<'a> Parse<'a> for ResumeTableIndices<'a> {
+    fn parse(parser: Parser<'a>) -> Result<Self> {
+        let mut targets = vec![];
+        while parser.peek2::<kw::tag>() {
+            parser.parens(|p| {
+                p.parse::<kw::tag>()?;
+                targets.push(p.parse()?);
+                Ok(())
+            })?;
+        }
+        Ok(ResumeTableIndices { targets })
+    }
+}
+
 /// Payload for lane-related instructions. Unsigned with no + prefix.
 #[derive(Debug)]
 pub struct LaneArg {
@@ -1567,21 +1648,6 @@ impl<'a> Parse<'a> for StructAccess<'a> {
     }
 }
 
-/// Extra data associated with the `array.fill` instruction
-#[derive(Debug)]
-pub struct ArrayFill<'a> {
-    /// The index of the array type we're filling.
-    pub array: Index<'a>,
-}
-
-impl<'a> Parse<'a> for ArrayFill<'a> {
-    fn parse(parser: Parser<'a>) -> Result<Self> {
-        Ok(ArrayFill {
-            array: parser.parse()?,
-        })
-    }
-}
-
 /// Extra data associated with the `array.copy` instruction
 #[derive(Debug)]
 pub struct ArrayCopy<'a> {
@@ -1600,24 +1666,6 @@ impl<'a> Parse<'a> for ArrayCopy<'a> {
     }
 }
 
-/// Extra data associated with the `array.init_[data/elem]` instruction
-#[derive(Debug)]
-pub struct ArrayInit<'a> {
-    /// The index of the array type we're initializing.
-    pub array: Index<'a>,
-    /// The index of the data or elem segment we're reading from.
-    pub segment: Index<'a>,
-}
-
-impl<'a> Parse<'a> for ArrayInit<'a> {
-    fn parse(parser: Parser<'a>) -> Result<Self> {
-        Ok(ArrayInit {
-            array: parser.parse()?,
-            segment: parser.parse()?,
-        })
-    }
-}
-
 /// Extra data associated with the `array.new_fixed` instruction
 #[derive(Debug)]
 pub struct ArrayNewFixed<'a> {
@@ -1672,74 +1720,20 @@ impl<'a> Parse<'a> for ArrayNewElem<'a> {
     }
 }
 
-/// Extra data associated with the `ref.cast` instruction
-#[derive(Debug)]
-pub struct RefCast<'a> {
-    /// The type to cast to.
-    pub r#type: RefType<'a>,
-}
-
-impl<'a> Parse<'a> for RefCast<'a> {
-    fn parse(parser: Parser<'a>) -> Result<Self> {
-        Ok(RefCast {
-            r#type: parser.parse()?,
-        })
-    }
-}
-
-/// Extra data associated with the `ref.test` instruction
-#[derive(Debug)]
-pub struct RefTest<'a> {
-    /// The type to test for.
-    pub r#type: RefType<'a>,
-}
-
-impl<'a> Parse<'a> for RefTest<'a> {
-    fn parse(parser: Parser<'a>) -> Result<Self> {
-        Ok(RefTest {
-            r#type: parser.parse()?,
-        })
-    }
-}
-
 /// Extra data associated with the `br_on_cast` instruction
 #[derive(Debug)]
 pub struct BrOnCast<'a> {
     /// The label to branch to.
     pub label: Index<'a>,
-    /// The type we're casting from.
-    pub from_type: RefType<'a>,
-    /// The type we're casting to.
-    pub to_type: RefType<'a>,
+    /// The index of the type we're casting.
+    pub r#type: Index<'a>,
 }
 
 impl<'a> Parse<'a> for BrOnCast<'a> {
     fn parse(parser: Parser<'a>) -> Result<Self> {
         Ok(BrOnCast {
             label: parser.parse()?,
-            from_type: parser.parse()?,
-            to_type: parser.parse()?,
-        })
-    }
-}
-
-/// Extra data associated with the `br_on_cast_fail` instruction
-#[derive(Debug)]
-pub struct BrOnCastFail<'a> {
-    /// The label to branch to.
-    pub label: Index<'a>,
-    /// The type we're casting from.
-    pub from_type: RefType<'a>,
-    /// The type we're casting to.
-    pub to_type: RefType<'a>,
-}
-
-impl<'a> Parse<'a> for BrOnCastFail<'a> {
-    fn parse(parser: Parser<'a>) -> Result<Self> {
-        Ok(BrOnCastFail {
-            label: parser.parse()?,
-            from_type: parser.parse()?,
-            to_type: parser.parse()?,
+            r#type: parser.parse()?,
         })
     }
 }
diff --git a/crates/wast/src/core/func.rs b/crates/wast/src/core/func.rs
index 550af12a..84abdf85 100644
--- a/crates/wast/src/core/func.rs
+++ b/crates/wast/src/core/func.rs
@@ -38,7 +38,7 @@ pub enum FuncKind<'a> {
     /// Almost all functions, those defined inline in a wasm module.
     Inline {
         /// The list of locals, if any, for this function.
-        locals: Box<[Local<'a>]>,
+        locals: Vec<Local<'a>>,
 
         /// The instructions of the function.
         expression: Expression<'a>,
@@ -56,7 +56,7 @@ impl<'a> Parse<'a> for Func<'a> {
             (parser.parse()?, FuncKind::Import(import))
         } else {
             let ty = parser.parse()?;
-            let locals = Local::parse_remainder(parser)?.into();
+            let locals = Local::parse_remainder(parser)?;
             (
                 ty,
                 FuncKind::Inline {
diff --git a/crates/wast/src/core/module.rs b/crates/wast/src/core/module.rs
index 6a30134a..b6e3ca0a 100644
--- a/crates/wast/src/core/module.rs
+++ b/crates/wast/src/core/module.rs
@@ -110,6 +110,7 @@ impl<'a> Module<'a> {
 
 impl<'a> Parse<'a> for Module<'a> {
     fn parse(parser: Parser<'a>) -> Result<Self> {
+        let _r = parser.register_annotation("custom");
         let span = parser.parse::<kw::module>()?.0;
         let id = parser.parse()?;
         let name = parser.parse()?;
@@ -154,8 +155,6 @@ pub enum ModuleField<'a> {
 
 impl<'a> ModuleField<'a> {
     pub(crate) fn parse_remaining(parser: Parser<'a>) -> Result<Vec<ModuleField>> {
-        let _r = parser.register_annotation("custom");
-        let _r = parser.register_annotation("producers");
         let mut fields = Vec::new();
         while !parser.is_empty() {
             fields.push(parser.parens(ModuleField::parse)?);
@@ -203,7 +202,7 @@ impl<'a> Parse<'a> for ModuleField<'a> {
         if parser.peek::<kw::tag>() {
             return Ok(ModuleField::Tag(parser.parse()?));
         }
-        if parser.peek::<annotation::custom>() || parser.peek::<annotation::producers>() {
+        if parser.peek::<annotation::custom>() {
             return Ok(ModuleField::Custom(parser.parse()?));
         }
         Err(parser.error("expected valid module field"))
diff --git a/crates/wast/src/core/resolve/names.rs b/crates/wast/src/core/resolve/names.rs
index 03b4d851..a9509b2f 100644
--- a/crates/wast/src/core/resolve/names.rs
+++ b/crates/wast/src/core/resolve/names.rs
@@ -60,7 +60,7 @@ impl<'a> Resolver<'a> {
                 }
             }
 
-            TypeDef::Array(_) | TypeDef::Func(_) => {}
+            TypeDef::Array(_) | TypeDef::Func(_) | TypeDef::Cont(_) => {}
         }
 
         // Record function signatures as we see them to so we can
@@ -124,6 +124,7 @@ impl<'a> Resolver<'a> {
                 }
             }
             TypeDef::Array(array) => self.resolve_storagetype(&mut array.ty)?,
+            TypeDef::Cont(cont) => self.resolve_continuationtype(cont)?,
         }
         if let Some(parent) = &mut ty.parent {
             self.resolve(parent, Ns::Type)?;
@@ -176,7 +177,7 @@ impl<'a> Resolver<'a> {
                     }
 
                     // .. followed by locals themselves
-                    for local in locals.iter() {
+                    for local in locals {
                         scope.register(local.id, "local")?;
                     }
 
@@ -283,10 +284,6 @@ impl<'a> Resolver<'a> {
         Ok(())
     }
 
-    fn resolve_reftype(&self, ty: &mut RefType<'a>) -> Result<(), Error> {
-        self.resolve_heaptype(&mut ty.heap)
-    }
-
     fn resolve_heaptype(&self, ty: &mut HeapType<'a>) -> Result<(), Error> {
         match ty {
             HeapType::Index(i) => {
@@ -305,6 +302,11 @@ impl<'a> Resolver<'a> {
         Ok(())
     }
 
+    fn resolve_continuationtype(&self, ty: &mut ContinuationType<'a>) -> Result<(), Error> {
+        self.resolve(&mut ty.idx, Ns::Type)?;
+        Ok(())
+    }
+
     fn resolve_item_sig(&self, item: &mut ItemSig<'a>) -> Result<(), Error> {
         match &mut item.kind {
             ItemKind::Func(t) | ItemKind::Tag(TagType::Exception(t)) => {
@@ -482,23 +484,19 @@ impl<'a, 'b> ExprResolver<'a, 'b> {
                 self.resolver.resolve_type_use(&mut c.ty)?;
             }
 
-            CallRef(i) | ReturnCallRef(i) => {
-                self.resolver.resolve(i, Ns::Type)?;
-            }
-
             FuncBind(b) => {
                 self.resolver.resolve_type_use(&mut b.ty)?;
             }
 
             Let(t) => {
                 // Resolve (ref T) in locals
-                for local in t.locals.iter_mut() {
+                for local in &mut t.locals {
                     self.resolver.resolve_valtype(&mut local.ty)?;
                 }
 
                 // Register all locals defined in this let
                 let mut scope = Namespace::default();
-                for local in t.locals.iter() {
+                for local in &t.locals {
                     scope.register(local.id, "local")?;
                 }
                 self.scopes.push(scope);
@@ -510,7 +508,7 @@ impl<'a, 'b> ExprResolver<'a, 'b> {
                 self.resolve_block_type(&mut t.block)?;
             }
 
-            Block(bt) | If(bt) | Loop(bt) | Try(bt) => {
+            Block(bt) | If(bt) | Loop(bt) | Try(bt) | Barrier(bt) => {
                 self.blocks.push(ExprBlock {
                     label: bt.label,
                     pushed_scope: false,
@@ -563,13 +561,10 @@ impl<'a, 'b> ExprResolver<'a, 'b> {
                 self.resolve_label(&mut i.default)?;
             }
 
-            Throw(i) => {
-                self.resolver.resolve(i, Ns::Tag)?;
-            }
             Rethrow(i) => {
                 self.resolve_label(i)?;
             }
-            Catch(i) => {
+            Throw(i) | Catch(i) | Suspend(i) => {
                 self.resolver.resolve(i, Ns::Tag)?;
             }
             Delegate(i) => {
@@ -579,6 +574,16 @@ impl<'a, 'b> ExprResolver<'a, 'b> {
                 self.resolve_label(i)?;
             }
 
+            BrOnCast(i) | BrOnCastFail(i) => {
+                self.resolve_label(&mut i.label)?;
+                self.resolver.resolve(&mut i.r#type, Ns::Type)?;
+            }
+
+            BrOnFunc(l) | BrOnData(l) | BrOnI31(l) | BrOnArray(l) | BrOnNonFunc(l)
+            | BrOnNonData(l) | BrOnNonI31(l) | BrOnNonArray(l) => {
+                self.resolve_label(l)?;
+            }
+
             Select(s) => {
                 if let Some(list) = &mut s.tys {
                     for ty in list {
@@ -587,25 +592,8 @@ impl<'a, 'b> ExprResolver<'a, 'b> {
                 }
             }
 
-            RefTest(i) => {
-                self.resolver.resolve_reftype(&mut i.r#type)?;
-            }
-            RefCast(i) => {
-                self.resolver.resolve_reftype(&mut i.r#type)?;
-            }
-            BrOnCast(i) => {
-                self.resolve_label(&mut i.label)?;
-                self.resolver.resolve_reftype(&mut i.to_type)?;
-                self.resolver.resolve_reftype(&mut i.from_type)?;
-            }
-            BrOnCastFail(i) => {
-                self.resolve_label(&mut i.label)?;
-                self.resolver.resolve_reftype(&mut i.to_type)?;
-                self.resolver.resolve_reftype(&mut i.from_type)?;
-            }
-
-            StructNew(i) | StructNewDefault(i) | ArrayNew(i) | ArrayNewDefault(i) | ArrayGet(i)
-            | ArrayGetS(i) | ArrayGetU(i) | ArraySet(i) => {
+            RefTest(i) | RefCast(i) | StructNew(i) | StructNewDefault(i) | ArrayNew(i)
+            | ArrayNewDefault(i) | ArrayGet(i) | ArrayGetS(i) | ArrayGetU(i) | ArraySet(i) => {
                 self.resolver.resolve(i, Ns::Type)?;
             }
 
@@ -625,24 +613,29 @@ impl<'a, 'b> ExprResolver<'a, 'b> {
                 self.resolver.resolve(&mut a.array, Ns::Type)?;
                 self.resolver.elems.resolve(&mut a.elem_idx, "elem")?;
             }
-            ArrayFill(a) => {
-                self.resolver.resolve(&mut a.array, Ns::Type)?;
-            }
             ArrayCopy(a) => {
                 self.resolver.resolve(&mut a.dest_array, Ns::Type)?;
                 self.resolver.resolve(&mut a.src_array, Ns::Type)?;
             }
-            ArrayInitData(a) => {
-                self.resolver.resolve(&mut a.array, Ns::Type)?;
-                self.resolver.datas.resolve(&mut a.segment, "data")?;
-            }
-            ArrayInitElem(a) => {
-                self.resolver.resolve(&mut a.array, Ns::Type)?;
-                self.resolver.elems.resolve(&mut a.segment, "elem")?;
-            }
 
-            RefNull(ty) => self.resolver.resolve_heaptype(ty)?,
+            RefNull(ty) | CallRef(ty) | ReturnCallRef(ty) => self.resolver.resolve_heaptype(ty)?,
 
+            ContNew(ty) | ContBind(ty) => {
+                self.resolver.resolve_type_use(ty)?;
+            }
+            Resume(table) => {
+                for (tag, label) in &mut table.targets {
+                    self.resolver.resolve(tag, Ns::Tag)?;
+                    self.resolve_label(label)?;
+                }
+            }
+            ResumeThrow(rt) => {
+                self.resolver.resolve(&mut rt.index, Ns::Tag)?;
+                for (tag, label) in &mut rt.table.targets {
+                    self.resolver.resolve(tag, Ns::Tag)?;
+                    self.resolve_label(label)?;
+                }
+            }
             _ => {}
         }
         Ok(())
diff --git a/crates/wast/src/core/resolve/types.rs b/crates/wast/src/core/resolve/types.rs
index aaf2988c..b8b27f14 100644
--- a/crates/wast/src/core/resolve/types.rs
+++ b/crates/wast/src/core/resolve/types.rs
@@ -55,7 +55,7 @@ impl<'a> Expander<'a> {
                     TypeDef::Func(f) => {
                         f.key().insert(self, Index::Id(id));
                     }
-                    TypeDef::Array(_) | TypeDef::Struct(_) => {}
+                    TypeDef::Array(_) | TypeDef::Struct(_) | TypeDef::Cont(_) => {}
                 }
             }
             _ => {}
@@ -140,7 +140,8 @@ impl<'a> Expander<'a> {
             | Instruction::If(bt)
             | Instruction::Loop(bt)
             | Instruction::Let(LetType { block: bt, .. })
-            | Instruction::Try(bt) => {
+            | Instruction::Try(bt)
+            | Instruction::Barrier(bt) => {
                 // No expansion necessary, a type reference is already here.
                 // We'll verify that it's the same as the inline type, if any,
                 // later.
@@ -179,6 +180,9 @@ impl<'a> Expander<'a> {
             Instruction::CallIndirect(c) | Instruction::ReturnCallIndirect(c) => {
                 self.expand_type_use(&mut c.ty);
             }
+            Instruction::ContNew(c) | Instruction::ContBind(c) => {
+                self.expand_type_use(c);
+            }
             _ => {}
         }
     }
@@ -218,7 +222,6 @@ impl<'a> Expander<'a> {
             name: None,
             def: key.to_def(span),
             parent: None,
-            final_type: None,
         }));
         let idx = Index::Id(id);
         key.insert(self, idx);
diff --git a/crates/wast/src/core/types.rs b/crates/wast/src/core/types.rs
index 5cf7becc..a8fbf078 100644
--- a/crates/wast/src/core/types.rs
+++ b/crates/wast/src/core/types.rs
@@ -76,14 +76,9 @@ pub enum HeapType<'a> {
     Struct,
     /// A reference to a GC array. This is part of the GC proposal.
     Array,
-    /// An unboxed 31-bit integer: i31ref. Part of the GC proposal.
+    /// An unboxed 31-bit integer: i31ref. This may be going away if there is no common
+    /// supertype of all reference types. Part of the GC proposal.
     I31,
-    /// The bottom type of the funcref hierarchy. Part of the GC proposal.
-    NoFunc,
-    /// The bottom type of the externref hierarchy. Part of the GC proposal.
-    NoExtern,
-    /// The bottom type of the anyref hierarchy. Part of the GC proposal.
-    None,
     /// A reference to a function, struct, or array: ref T. This is part of the
     /// GC proposal.
     Index(Index<'a>),
@@ -113,15 +108,6 @@ impl<'a> Parse<'a> for HeapType<'a> {
         } else if l.peek::<kw::i31>() {
             parser.parse::<kw::i31>()?;
             Ok(HeapType::I31)
-        } else if l.peek::<kw::nofunc>() {
-            parser.parse::<kw::nofunc>()?;
-            Ok(HeapType::NoFunc)
-        } else if l.peek::<kw::noextern>() {
-            parser.parse::<kw::noextern>()?;
-            Ok(HeapType::NoExtern)
-        } else if l.peek::<kw::none>() {
-            parser.parse::<kw::none>()?;
-            Ok(HeapType::None)
         } else if l.peek::<Index>() {
             Ok(HeapType::Index(parser.parse()?))
         } else {
@@ -139,9 +125,6 @@ impl<'a> Peek for HeapType<'a> {
             || kw::r#struct::peek(cursor)
             || kw::array::peek(cursor)
             || kw::i31::peek(cursor)
-            || kw::nofunc::peek(cursor)
-            || kw::noextern::peek(cursor)
-            || kw::none::peek(cursor)
             || (LParen::peek(cursor) && kw::r#type::peek2(cursor))
     }
     fn display() -> &'static str {
@@ -213,30 +196,6 @@ impl<'a> RefType<'a> {
             heap: HeapType::I31,
         }
     }
-
-    /// A `nullfuncref` as an abbreviation for `(ref null nofunc)`.
-    pub fn nullfuncref() -> Self {
-        RefType {
-            nullable: true,
-            heap: HeapType::NoFunc,
-        }
-    }
-
-    /// A `nullexternref` as an abbreviation for `(ref null noextern)`.
-    pub fn nullexternref() -> Self {
-        RefType {
-            nullable: true,
-            heap: HeapType::NoExtern,
-        }
-    }
-
-    /// A `nullref` as an abbreviation for `(ref null none)`.
-    pub fn nullref() -> Self {
-        RefType {
-            nullable: true,
-            heap: HeapType::None,
-        }
-    }
 }
 
 impl<'a> Parse<'a> for RefType<'a> {
@@ -266,15 +225,6 @@ impl<'a> Parse<'a> for RefType<'a> {
         } else if l.peek::<kw::i31ref>() {
             parser.parse::<kw::i31ref>()?;
             Ok(RefType::i31())
-        } else if l.peek::<kw::nullfuncref>() {
-            parser.parse::<kw::nullfuncref>()?;
-            Ok(RefType::nullfuncref())
-        } else if l.peek::<kw::nullexternref>() {
-            parser.parse::<kw::nullexternref>()?;
-            Ok(RefType::nullexternref())
-        } else if l.peek::<kw::nullref>() {
-            parser.parse::<kw::nullref>()?;
-            Ok(RefType::nullref())
         } else if l.peek::<LParen>() {
             parser.parens(|p| {
                 let mut l = parser.lookahead1();
@@ -311,9 +261,6 @@ impl<'a> Peek for RefType<'a> {
             || kw::structref::peek(cursor)
             || kw::arrayref::peek(cursor)
             || kw::i31ref::peek(cursor)
-            || kw::nullfuncref::peek(cursor)
-            || kw::nullexternref::peek(cursor)
-            || kw::nullref::peek(cursor)
             || (LParen::peek(cursor) && kw::r#ref::peek2(cursor))
     }
     fn display() -> &'static str {
@@ -681,6 +628,19 @@ impl<'a> Parse<'a> for ExportType<'a> {
     }
 }
 
+/// A continuation type.
+#[derive(Clone, Debug)]
+pub struct ContinuationType<'a> {
+    /// Function type index.
+    pub idx: Index<'a>,
+}
+
+impl<'a> Parse<'a> for ContinuationType<'a> {
+    fn parse(parser: Parser<'a>) -> Result<Self> {
+        Ok(ContinuationType { idx: parser.parse::<Index<'a>>()? })
+    }
+}
+
 /// A definition of a type.
 #[derive(Debug)]
 pub enum TypeDef<'a> {
@@ -690,6 +650,8 @@ pub enum TypeDef<'a> {
     Struct(StructType<'a>),
     /// An array type definition.
     Array(ArrayType<'a>),
+    /// A continuation type definition.
+    Cont(ContinuationType<'a>),
 }
 
 impl<'a> Parse<'a> for TypeDef<'a> {
@@ -701,6 +663,9 @@ impl<'a> Parse<'a> for TypeDef<'a> {
         } else if l.peek::<kw::r#struct>() {
             parser.parse::<kw::r#struct>()?;
             Ok(TypeDef::Struct(parser.parse()?))
+        } else if l.peek::<kw::cont>() {
+            parser.parse::<kw::cont>()?;
+            Ok(TypeDef::Cont(parser.parse()?))
         } else if l.peek::<kw::array>() {
             parser.parse::<kw::array>()?;
             Ok(TypeDef::Array(parser.parse()?))
@@ -724,60 +689,48 @@ pub struct Type<'a> {
     pub def: TypeDef<'a>,
     /// The declared parent type of this definition.
     pub parent: Option<Index<'a>>,
-    /// Whether this type is final or not. By default types are final.
-    pub final_type: Option<bool>,
-}
-
-impl<'a> Peek for Type<'a> {
-    fn peek(cursor: Cursor<'_>) -> bool {
-        kw::r#type::peek(cursor)
-    }
-    fn display() -> &'static str {
-        "type"
-    }
 }
 
-impl<'a> Parse<'a> for Type<'a> {
-    fn parse(parser: Parser<'a>) -> Result<Self> {
+impl<'a> Type<'a> {
+    fn parse_inner(parser: Parser<'a>, parent: Option<Index<'a>>) -> Result<Self> {
         let span = parser.parse::<kw::r#type>()?.0;
         let id = parser.parse()?;
         let name = parser.parse()?;
-
-        let (parent, def, final_type) = if parser.peek2::<kw::sub>() {
-            parser.parens(|parser| {
-                parser.parse::<kw::sub>()?;
-
-                let final_type: Option<bool> =
-                if parser.peek::<kw::r#final>() {
-                    parser.parse::<kw::r#final>()?;
-                    Some(true)
-                } else {
-                    Some(false)
-                };
-
-                let parent = if parser.peek::<Index<'a>>() {
-                    parser.parse()?
-                } else {
-                    None
-                };
-                let def = parser.parens(|parser| parser.parse())?;
-                Ok((parent, def, final_type))
-            })?
-        } else {
-            (None, parser.parens(|parser| parser.parse())?, None)
-        };
-
+        let def = parser.parens(|parser| parser.parse())?;
         Ok(Type {
             span,
             id,
             name,
             def,
             parent,
-            final_type,
         })
     }
 }
 
+impl<'a> Peek for Type<'a> {
+    fn peek(cursor: Cursor<'_>) -> bool {
+        kw::r#type::peek(cursor) || kw::sub::peek(cursor)
+    }
+    fn display() -> &'static str {
+        "type"
+    }
+}
+
+impl<'a> Parse<'a> for Type<'a> {
+    fn parse(parser: Parser<'a>) -> Result<Self> {
+        if parser.peek::<kw::sub>() {
+            parser.parse::<kw::sub>()?;
+            let parent = if parser.peek::<Index<'a>>() {
+                parser.parse()?
+            } else {
+                None
+            };
+            return parser.parens(|parser| Type::parse_inner(parser, parent));
+        }
+        Type::parse_inner(parser, None)
+    }
+}
+
 /// A recursion group declaration in a module
 #[derive(Debug)]
 pub struct Rec<'a> {
diff --git a/crates/wast/src/encode.rs b/crates/wast/src/encode.rs
index 966a64f4..3fc93269 100644
--- a/crates/wast/src/encode.rs
+++ b/crates/wast/src/encode.rs
@@ -8,12 +8,6 @@ impl<T: Encode + ?Sized> Encode for &'_ T {
     }
 }
 
-impl<T: Encode + ?Sized> Encode for Box<T> {
-    fn encode(&self, e: &mut Vec<u8>) {
-        T::encode(self, e)
-    }
-}
-
 impl<T: Encode> Encode for [T] {
     fn encode(&self, e: &mut Vec<u8>) {
         self.len().encode(e);
diff --git a/crates/wast/src/lexer.rs b/crates/wast/src/lexer.rs
index f588ec2f..a4f8f128 100644
--- a/crates/wast/src/lexer.rs
+++ b/crates/wast/src/lexer.rs
@@ -43,100 +43,55 @@ pub struct Lexer<'a> {
     allow_confusing_unicode: bool,
 }
 
-/// A single token parsed from a `Lexer`.
-#[derive(Debug, PartialEq)]
-pub struct Token {
-    /// The kind of token this represents, such as whether it's whitespace, a
-    /// keyword, etc.
-    pub kind: TokenKind,
-    /// The byte offset within the original source for where this token came
-    /// from.
-    pub offset: usize,
-    /// The byte length of this token as it resides in the original source.
-    //
-    // NB: this is `u32` to enable packing `Token` into two pointers of size.
-    // This does limit a single token to being at most 4G large, but that seems
-    // probably ok.
-    pub len: u32,
-}
-
-const _: () = {
-    assert!(std::mem::size_of::<Token>() <= std::mem::size_of::<u64>() * 2);
-};
-
-/// Classification of what was parsed from the input stream.
+/// A fragment of source lex'd from an input string.
 ///
 /// This enumeration contains all kinds of fragments, including comments and
-/// whitespace.
-#[derive(Copy, Clone, Debug, PartialEq)]
-pub enum TokenKind {
+/// whitespace. For most cases you'll probably ignore these and simply look at
+/// tokens.
+#[derive(Debug, PartialEq)]
+pub enum Token<'a> {
     /// A line comment, preceded with `;;`
-    LineComment,
+    LineComment(&'a str),
 
     /// A block comment, surrounded by `(;` and `;)`. Note that these can be
     /// nested.
-    BlockComment,
+    BlockComment(&'a str),
 
     /// A fragment of source that represents whitespace.
-    Whitespace,
+    Whitespace(&'a str),
 
     /// A left-parenthesis, including the source text for where it comes from.
-    LParen,
+    LParen(&'a str),
     /// A right-parenthesis, including the source text for where it comes from.
-    RParen,
+    RParen(&'a str),
 
     /// A string literal, which is actually a list of bytes.
-    String,
+    String(WasmString<'a>),
 
     /// An identifier (like `$foo`).
     ///
     /// All identifiers start with `$` and the payload here is the original
     /// source text.
-    Id,
+    Id(&'a str),
 
     /// A keyword, or something that starts with an alphabetic character.
     ///
     /// The payload here is the original source text.
-    Keyword,
+    Keyword(&'a str),
 
     /// A reserved series of `idchar` symbols. Unknown what this is meant to be
     /// used for, you'll probably generate an error about an unexpected token.
-    Reserved,
+    Reserved(&'a str),
 
     /// An integer.
-    Integer(IntegerKind),
+    Integer(Integer<'a>),
 
     /// A float.
-    Float(FloatKind),
+    Float(Float<'a>),
 }
 
-/// Description of the parsed integer from the source.
-#[derive(Copy, Clone, Debug, PartialEq)]
-pub struct IntegerKind {
-    sign: Option<SignToken>,
-    has_underscores: bool,
-    hex: bool,
-}
-
-/// Description of a parsed float from the source.
-#[allow(missing_docs)]
-#[derive(Copy, Clone, Debug, PartialEq)]
-pub enum FloatKind {
-    #[doc(hidden)]
-    Inf { negative: bool },
-    #[doc(hidden)]
-    Nan { negative: bool },
-    #[doc(hidden)]
-    NanVal {
-        negative: bool,
-        has_underscores: bool,
-    },
-    #[doc(hidden)]
-    Normal { has_underscores: bool, hex: bool },
-}
-
-enum ReservedKind {
-    String,
+enum ReservedKind<'a> {
+    String(Cow<'a, [u8]>),
     Idchars,
     Reserved,
 }
@@ -210,18 +165,45 @@ pub enum SignToken {
     Minus,
 }
 
-/// A fully parsed integer from a source string with a payload ready to parse
-/// into an integral type.
+/// A parsed integer, signed or unsigned.
+///
+/// Methods can be use to access the value of the integer.
 #[derive(Debug, PartialEq)]
-pub struct Integer<'a> {
+pub struct Integer<'a>(Box<IntegerInner<'a>>);
+
+#[derive(Debug, PartialEq)]
+struct IntegerInner<'a> {
     sign: Option<SignToken>,
+    src: &'a str,
     val: Cow<'a, str>,
     hex: bool,
 }
 
+/// A parsed float.
+///
+/// Methods can be use to access the value of the float.
+#[derive(Debug, PartialEq)]
+pub struct Float<'a>(Box<FloatInner<'a>>);
+
+#[derive(Debug, PartialEq)]
+struct FloatInner<'a> {
+    src: &'a str,
+    val: FloatVal<'a>,
+}
+
+/// A parsed string.
+#[derive(Debug, PartialEq)]
+pub struct WasmString<'a>(Box<WasmStringInner<'a>>);
+
+#[derive(Debug, PartialEq)]
+struct WasmStringInner<'a> {
+    src: &'a str,
+    val: Cow<'a, [u8]>,
+}
+
 /// Possible parsed float values
 #[derive(Debug, PartialEq, Eq)]
-pub enum Float<'a> {
+pub enum FloatVal<'a> {
     /// A float `NaN` representation
     Nan {
         /// The specific bits to encode for this float, optionally
@@ -319,19 +301,7 @@ impl<'a> Lexer<'a> {
     /// # Errors
     ///
     /// Returns an error if the input is malformed.
-    pub fn parse(&mut self) -> Result<Option<Token>, Error> {
-        let offset = self.cur();
-        Ok(match self.parse_kind()? {
-            Some(kind) => Some(Token {
-                kind,
-                offset,
-                len: (self.cur() - offset).try_into().unwrap(),
-            }),
-            None => None,
-        })
-    }
-
-    fn parse_kind(&mut self) -> Result<Option<TokenKind>, Error> {
+    pub fn parse(&mut self) -> Result<Option<Token<'a>>, Error> {
         let pos = self.cur();
         // This `match` generally parses the grammar specified at
         //
@@ -376,7 +346,7 @@ impl<'a> Lexer<'a> {
                                         let (comment, remaining) = self.remaining.split_at(len);
                                         self.remaining = remaining;
                                         self.check_confusing_comment(comment)?;
-                                        return Ok(Some(TokenKind::BlockComment));
+                                        return Ok(Some(Token::BlockComment(comment)));
                                     }
                                 }
                             }
@@ -385,42 +355,38 @@ impl<'a> Lexer<'a> {
                     }
                     Err(self.error(pos, LexError::DanglingBlockComment))
                 }
-                _ => {
-                    self.remaining = &self.remaining[1..];
-                    Ok(Some(TokenKind::LParen))
-                }
+                _ => Ok(Some(Token::LParen(self.split_first_byte()))),
             },
 
-            b')' => {
-                self.remaining = &self.remaining[1..];
-                Ok(Some(TokenKind::RParen))
-            }
+            b')' => Ok(Some(Token::RParen(self.split_first_byte()))),
 
             // https://webassembly.github.io/spec/core/text/lexical.html#white-space
-            b' ' | b'\n' | b'\r' | b'\t' => {
-                self.skip_ws();
-                Ok(Some(TokenKind::Whitespace))
-            }
+            b' ' | b'\n' | b'\r' | b'\t' => Ok(Some(Token::Whitespace(self.split_ws()))),
 
             c @ (idchars!() | b'"') => {
-                let (kind, src) = self.parse_reserved()?;
+                let (kind, src) = self.split_reserved()?;
                 match kind {
                     // If the reserved token was simply a single string then
                     // that is converted to a standalone string token
-                    ReservedKind::String => return Ok(Some(TokenKind::String)),
+                    ReservedKind::String(val) => {
+                        return Ok(Some(Token::String(WasmString(Box::new(WasmStringInner {
+                            val,
+                            src,
+                        })))));
+                    }
 
                     // If only idchars were consumed then this could be a
                     // specific kind of standalone token we're interested in.
                     ReservedKind::Idchars => {
                         // https://webassembly.github.io/spec/core/text/values.html#integers
-                        if let Some(ret) = self.classify_number(src) {
-                            return Ok(Some(ret));
+                        if let Some(number) = self.number(src) {
+                            return Ok(Some(number));
                         // https://webassembly.github.io/spec/core/text/values.html#text-id
                         } else if *c == b'$' && src.len() > 1 {
-                            return Ok(Some(TokenKind::Id));
+                            return Ok(Some(Token::Id(src)));
                         // https://webassembly.github.io/spec/core/text/lexical.html#text-keyword
                         } else if b'a' <= *c && *c <= b'z' {
-                            return Ok(Some(TokenKind::Keyword));
+                            return Ok(Some(Token::Keyword(src)));
                         }
                     }
 
@@ -431,7 +397,7 @@ impl<'a> Lexer<'a> {
                     ReservedKind::Reserved => {}
                 }
 
-                Ok(Some(TokenKind::Reserved))
+                Ok(Some(Token::Reserved(src)))
             }
 
             // This could be a line comment, otherwise `;` is a reserved token.
@@ -443,22 +409,16 @@ impl<'a> Lexer<'a> {
                 Some(b';') => {
                     let comment = self.split_until(b'\n');
                     self.check_confusing_comment(comment)?;
-                    Ok(Some(TokenKind::LineComment))
-                }
-                _ => {
-                    self.remaining = &self.remaining[1..];
-                    Ok(Some(TokenKind::Reserved))
+                    Ok(Some(Token::LineComment(comment)))
                 }
+                _ => Ok(Some(Token::Reserved(self.split_first_byte()))),
             },
 
             // Other known reserved tokens other than `;`
             //
             // Note that these characters being considered as part of a
             // `reserved` token is part of the annotations proposal.
-            b',' | b'[' | b']' | b'{' | b'}' => {
-                self.remaining = &self.remaining[1..];
-                Ok(Some(TokenKind::Reserved))
-            }
+            b',' | b'[' | b']' | b'{' | b'}' => Ok(Some(Token::Reserved(self.split_first_byte()))),
 
             _ => {
                 let ch = self.remaining.chars().next().unwrap();
@@ -467,6 +427,12 @@ impl<'a> Lexer<'a> {
         }
     }
 
+    fn split_first_byte(&mut self) -> &'a str {
+        let (token, remaining) = self.remaining.split_at(1);
+        self.remaining = remaining;
+        token
+    }
+
     fn split_until(&mut self, byte: u8) -> &'a str {
         let pos = memchr::memchr(byte, self.remaining.as_bytes()).unwrap_or(self.remaining.len());
         let (ret, remaining) = self.remaining.split_at(pos);
@@ -474,7 +440,7 @@ impl<'a> Lexer<'a> {
         ret
     }
 
-    fn skip_ws(&mut self) {
+    fn split_ws(&mut self) -> &'a str {
         // This table is a byte lookup table to determine whether a byte is a
         // whitespace byte. There are only 4 whitespace bytes for the `*.wat`
         // format right now which are ' ', '\t', '\r', and '\n'. These 4 bytes
@@ -518,7 +484,9 @@ impl<'a> Lexer<'a> {
             .iter()
             .position(|b| WS[*b as usize] != 1)
             .unwrap_or(self.remaining.len());
-        self.remaining = &self.remaining[pos..];
+        let (ret, remaining) = self.remaining.split_at(pos);
+        self.remaining = remaining;
+        ret
     }
 
     /// Splits off a "reserved" token which is then further processed later on
@@ -536,9 +504,10 @@ impl<'a> Lexer<'a> {
     /// tokens (e.g. `a"b"c`) and returning the classification of what was
     /// eaten. The classification assists in determining what the actual token
     /// here eaten looks like.
-    fn parse_reserved(&mut self) -> Result<(ReservedKind, &'a str), Error> {
+    fn split_reserved(&mut self) -> Result<(ReservedKind<'a>, &'a str), Error> {
         let mut idchars = false;
         let mut strings = 0u32;
+        let mut last_string_val = None;
         let mut pos = 0;
         while let Some(byte) = self.remaining.as_bytes().get(pos) {
             match byte {
@@ -557,7 +526,7 @@ impl<'a> Lexer<'a> {
                     let result = Lexer::parse_str(&mut it, self.allow_confusing_unicode);
                     pos = self.remaining.len() - it.as_str().len();
                     match result {
-                        Ok(_) => {}
+                        Ok(s) => last_string_val = Some(s),
                         Err(e) => {
                             let start = self.input.len() - self.remaining.len();
                             self.remaining = &self.remaining[pos..];
@@ -584,13 +553,13 @@ impl<'a> Lexer<'a> {
         self.remaining = remaining;
         Ok(match (idchars, strings) {
             (false, 0) => unreachable!(),
-            (false, 1) => (ReservedKind::String, ret),
+            (false, 1) => (ReservedKind::String(last_string_val.unwrap()), ret),
             (true, 0) => (ReservedKind::Idchars, ret),
             _ => (ReservedKind::Reserved, ret),
         })
     }
 
-    fn classify_number(&self, src: &str) -> Option<TokenKind> {
+    fn number(&self, src: &'a str) -> Option<Token<'a>> {
         let (sign, num) = if let Some(stripped) = src.strip_prefix('+') {
             (Some(SignToken::Plus), stripped)
         } else if let Some(stripped) = src.strip_prefix('-') {
@@ -603,19 +572,32 @@ impl<'a> Lexer<'a> {
 
         // Handle `inf` and `nan` which are special numbers here
         if num == "inf" {
-            return Some(TokenKind::Float(FloatKind::Inf { negative }));
+            return Some(Token::Float(Float(Box::new(FloatInner {
+                src,
+                val: FloatVal::Inf { negative },
+            }))));
         } else if num == "nan" {
-            return Some(TokenKind::Float(FloatKind::Nan { negative }));
+            return Some(Token::Float(Float(Box::new(FloatInner {
+                src,
+                val: FloatVal::Nan {
+                    val: None,
+                    negative,
+                },
+            }))));
         } else if let Some(stripped) = num.strip_prefix("nan:0x") {
             let mut it = stripped.chars();
-            let has_underscores = skip_underscores(&mut it, char::is_ascii_hexdigit)?;
+            let to_parse = skip_undescores(&mut it, false, char::is_ascii_hexdigit)?;
             if it.next().is_some() {
                 return None;
             }
-            return Some(TokenKind::Float(FloatKind::NanVal {
-                negative,
-                has_underscores,
-            }));
+            let n = u64::from_str_radix(&to_parse, 16).ok()?;
+            return Some(Token::Float(Float(Box::new(FloatInner {
+                src,
+                val: FloatVal::Nan {
+                    val: Some(n),
+                    negative,
+                },
+            }))));
         }
 
         // Figure out if we're a hex number or not
@@ -634,7 +616,7 @@ impl<'a> Lexer<'a> {
         };
 
         // Evaluate the first part, moving out all underscores
-        let mut has_underscores = skip_underscores(&mut it, test_valid)?;
+        let val = skip_undescores(&mut it, negative, test_valid)?;
 
         match it.clone().next() {
             // If we're followed by something this may be a float so keep going.
@@ -642,48 +624,47 @@ impl<'a> Lexer<'a> {
 
             // Otherwise this is a valid integer literal!
             None => {
-                return Some(TokenKind::Integer(IntegerKind {
-                    has_underscores,
+                return Some(Token::Integer(Integer(Box::new(IntegerInner {
                     sign,
+                    src,
+                    val,
                     hex,
-                }))
+                }))))
             }
         }
 
         // A number can optionally be after the decimal so only actually try to
         // parse one if it's there.
-        if it.clone().next() == Some('.') {
+        let decimal = if it.clone().next() == Some('.') {
             it.next();
             match it.clone().next() {
-                Some(c) if test_valid(&c) => {
-                    if skip_underscores(&mut it, test_valid)? {
-                        has_underscores = true;
-                    }
-                }
-                Some(_) | None => {}
+                Some(c) if test_valid(&c) => Some(skip_undescores(&mut it, false, test_valid)?),
+                Some(_) | None => None,
             }
+        } else {
+            None
         };
 
         // Figure out if there's an exponential part here to make a float, and
         // if so parse it but defer its actual calculation until later.
-        match (hex, it.next()) {
+        let exponent = match (hex, it.next()) {
             (true, Some('p')) | (true, Some('P')) | (false, Some('e')) | (false, Some('E')) => {
-                match it.clone().next() {
+                let negative = match it.clone().next() {
                     Some('-') => {
                         it.next();
+                        true
                     }
                     Some('+') => {
                         it.next();
+                        false
                     }
-                    _ => {}
-                }
-                if skip_underscores(&mut it, char::is_ascii_digit)? {
-                    has_underscores = true;
-                }
+                    _ => false,
+                };
+                Some(skip_undescores(&mut it, negative, char::is_ascii_digit)?)
             }
-            (_, None) => {}
+            (_, None) => None,
             _ => return None,
-        }
+        };
 
         // We should have eaten everything by now, if not then this is surely
         // not a float or integer literal.
@@ -691,21 +672,45 @@ impl<'a> Lexer<'a> {
             return None;
         }
 
-        return Some(TokenKind::Float(FloatKind::Normal {
-            has_underscores,
-            hex,
-        }));
-
-        fn skip_underscores<'a>(it: &mut str::Chars<'a>, good: fn(&char) -> bool) -> Option<bool> {
+        return Some(Token::Float(Float(Box::new(FloatInner {
+            src,
+            val: FloatVal::Val {
+                hex,
+                integral: val,
+                exponent,
+                decimal,
+            },
+        }))));
+
+        fn skip_undescores<'a>(
+            it: &mut str::Chars<'a>,
+            negative: bool,
+            good: fn(&char) -> bool,
+        ) -> Option<Cow<'a, str>> {
+            enum State {
+                Raw,
+                Collecting(String),
+            }
             let mut last_underscore = false;
-            let mut has_underscores = false;
+            let mut state = if negative {
+                State::Collecting("-".to_string())
+            } else {
+                State::Raw
+            };
+            let input = it.as_str();
             let first = it.next()?;
             if !good(&first) {
                 return None;
             }
+            if let State::Collecting(s) = &mut state {
+                s.push(first);
+            }
+            let mut last = 1;
             while let Some(c) = it.clone().next() {
                 if c == '_' && !last_underscore {
-                    has_underscores = true;
+                    if let State::Raw = state {
+                        state = State::Collecting(input[..last].to_string());
+                    }
                     it.next();
                     last_underscore = true;
                     continue;
@@ -713,13 +718,20 @@ impl<'a> Lexer<'a> {
                 if !good(&c) {
                     break;
                 }
+                if let State::Collecting(s) = &mut state {
+                    s.push(c);
+                }
                 last_underscore = false;
                 it.next();
+                last += 1;
             }
             if last_underscore {
                 return None;
             }
-            Some(has_underscores)
+            Some(match state {
+                State::Raw => input[..last].into(),
+                State::Collecting(s) => s.into(),
+            })
         }
     }
 
@@ -889,185 +901,72 @@ impl<'a> Lexer<'a> {
 }
 
 impl<'a> Iterator for Lexer<'a> {
-    type Item = Result<Token, Error>;
+    type Item = Result<Token<'a>, Error>;
 
     fn next(&mut self) -> Option<Self::Item> {
         self.parse().transpose()
     }
 }
 
-impl Token {
+impl<'a> Token<'a> {
     /// Returns the original source text for this token.
-    pub fn src<'a>(&self, s: &'a str) -> &'a str {
-        &s[self.offset..][..self.len.try_into().unwrap()]
+    pub fn src(&self) -> &'a str {
+        match self {
+            Token::Whitespace(s) => s,
+            Token::BlockComment(s) => s,
+            Token::LineComment(s) => s,
+            Token::LParen(s) => s,
+            Token::RParen(s) => s,
+            Token::String(s) => s.src(),
+            Token::Id(s) => s,
+            Token::Keyword(s) => s,
+            Token::Reserved(s) => s,
+            Token::Integer(i) => i.src(),
+            Token::Float(f) => f.src(),
+        }
     }
+}
 
-    /// Returns the identifier, without the leading `$` symbol, that this token
-    /// represents.
-    ///
-    /// Should only be used with `TokenKind::Id`.
-    pub fn id<'a>(&self, s: &'a str) -> &'a str {
-        &self.src(s)[1..]
+impl<'a> Integer<'a> {
+    /// Returns the sign token for this integer.
+    pub fn sign(&self) -> Option<SignToken> {
+        self.0.sign
     }
 
-    /// Returns the keyword this token represents.
-    ///
-    /// Should only be used with `TokenKind::Keyword`.
-    pub fn keyword<'a>(&self, s: &'a str) -> &'a str {
-        self.src(s)
+    /// Returns the original source text for this integer.
+    pub fn src(&self) -> &'a str {
+        self.0.src
     }
 
-    /// Returns the reserved string this token represents.
-    ///
-    /// Should only be used with `TokenKind::Reserved`.
-    pub fn reserved<'a>(&self, s: &'a str) -> &'a str {
-        self.src(s)
+    /// Returns the value string that can be parsed for this integer, as well as
+    /// the base that it should be parsed in
+    pub fn val(&self) -> (&str, u32) {
+        (&self.0.val, if self.0.hex { 16 } else { 10 })
     }
+}
 
-    /// Returns the parsed string that this token represents.
-    ///
-    /// This returns either a raw byte slice into the source if that's possible
-    /// or an owned representation to handle escaped characters and such.
-    ///
-    /// Should only be used with `TokenKind::String`.
-    pub fn string<'a>(&self, s: &'a str) -> Cow<'a, [u8]> {
-        let mut ch = self.src(s).chars();
-        ch.next().unwrap();
-        Lexer::parse_str(&mut ch, true).unwrap()
+impl<'a> Float<'a> {
+    /// Returns the original source text for this integer.
+    pub fn src(&self) -> &'a str {
+        self.0.src
     }
 
-    /// Returns the decomposed float token that this represents.
-    ///
-    /// This will slice up the float token into its component parts and return a
-    /// description of the float token in the source.
-    ///
-    /// Should only be used with `TokenKind::Float`.
-    pub fn float<'a>(&self, s: &'a str, kind: FloatKind) -> Float<'a> {
-        match kind {
-            FloatKind::Inf { negative } => Float::Inf { negative },
-            FloatKind::Nan { negative } => Float::Nan {
-                val: None,
-                negative,
-            },
-            FloatKind::NanVal {
-                negative,
-                has_underscores,
-            } => {
-                let src = self.src(s);
-                let src = if src.starts_with("n") { src } else { &src[1..] };
-                let mut src = src.strip_prefix("nan:0x").unwrap();
-                let owned;
-                if has_underscores {
-                    owned = src.replace("_", "");
-                    src = &owned;
-                }
-                let val = u64::from_str_radix(src, 16).unwrap();
-                Float::Nan {
-                    val: Some(val),
-                    negative,
-                }
-            }
-            FloatKind::Normal {
-                has_underscores,
-                hex,
-            } => {
-                let src = self.src(s);
-                let (integral, decimal, exponent) = match src.find('.') {
-                    Some(i) => {
-                        let integral = &src[..i];
-                        let rest = &src[i + 1..];
-                        let exponent = if hex {
-                            rest.find('p').or_else(|| rest.find('P'))
-                        } else {
-                            rest.find('e').or_else(|| rest.find('E'))
-                        };
-                        match exponent {
-                            Some(i) => (integral, Some(&rest[..i]), Some(&rest[i + 1..])),
-                            None => (integral, Some(rest), None),
-                        }
-                    }
-                    None => {
-                        let exponent = if hex {
-                            src.find('p').or_else(|| src.find('P'))
-                        } else {
-                            src.find('e').or_else(|| src.find('E'))
-                        };
-                        match exponent {
-                            Some(i) => (&src[..i], None, Some(&src[i + 1..])),
-                            None => (src, None, None),
-                        }
-                    }
-                };
-                let mut integral = Cow::Borrowed(integral.strip_prefix('+').unwrap_or(integral));
-                let mut decimal = decimal.and_then(|s| {
-                    if s.is_empty() {
-                        None
-                    } else {
-                        Some(Cow::Borrowed(s))
-                    }
-                });
-                let mut exponent =
-                    exponent.map(|s| Cow::Borrowed(s.strip_prefix('+').unwrap_or(s)));
-                if has_underscores {
-                    *integral.to_mut() = integral.replace("_", "");
-                    if let Some(decimal) = &mut decimal {
-                        *decimal.to_mut() = decimal.replace("_", "");
-                    }
-                    if let Some(exponent) = &mut exponent {
-                        *exponent.to_mut() = exponent.replace("_", "");
-                    }
-                }
-                if hex {
-                    *integral.to_mut() = integral.replace("0x", "");
-                }
-                Float::Val {
-                    hex,
-                    integral,
-                    decimal,
-                    exponent,
-                }
-            }
-        }
-    }
-
-    /// Returns the decomposed integer token that this represents.
-    ///
-    /// This will slice up the integer token into its component parts and
-    /// return a description of the integer token in the source.
-    ///
-    /// Should only be used with `TokenKind::Integer`.
-    pub fn integer<'a>(&self, s: &'a str, kind: IntegerKind) -> Integer<'a> {
-        let src = self.src(s);
-        let val = match kind.sign {
-            Some(SignToken::Plus) => src.strip_prefix('+').unwrap(),
-            Some(SignToken::Minus) => src,
-            None => src,
-        };
-        let mut val = Cow::Borrowed(val);
-        if kind.has_underscores {
-            *val.to_mut() = val.replace("_", "");
-        }
-        if kind.hex {
-            *val.to_mut() = val.replace("0x", "");
-        }
-        Integer {
-            sign: kind.sign,
-            hex: kind.hex,
-            val,
-        }
+    /// Returns a parsed value of this float with all of the components still
+    /// listed as strings.
+    pub fn val(&self) -> &FloatVal<'a> {
+        &self.0.val
     }
 }
 
-impl<'a> Integer<'a> {
-    /// Returns the sign token for this integer.
-    pub fn sign(&self) -> Option<SignToken> {
-        self.sign
+impl<'a> WasmString<'a> {
+    /// Returns the original source text for this string.
+    pub fn src(&self) -> &'a str {
+        self.0.src
     }
 
-    /// Returns the value string that can be parsed for this integer, as well
-    /// as the base that it should be parsed in
-    pub fn val(&self) -> (&str, u32) {
-        (&self.val, if self.hex { 16 } else { 10 })
+    /// Returns a parsed value, as a list of bytes, for this string.
+    pub fn val(&self) -> &[u8] {
+        &self.0.val
     }
 }
 
@@ -1150,9 +1049,8 @@ mod tests {
     #[test]
     fn ws_smoke() {
         fn get_whitespace(input: &str) -> &str {
-            let token = get_token(input);
-            match token.kind {
-                TokenKind::Whitespace => token.src(input),
+            match Lexer::new(input).parse().expect("no first token") {
+                Some(Token::Whitespace(s)) => s,
                 other => panic!("unexpected {:?}", other),
             }
         }
@@ -1166,9 +1064,8 @@ mod tests {
     #[test]
     fn line_comment_smoke() {
         fn get_line_comment(input: &str) -> &str {
-            let token = get_token(input);
-            match token.kind {
-                TokenKind::LineComment => token.src(input),
+            match Lexer::new(input).parse().expect("no first token") {
+                Some(Token::LineComment(s)) => s,
                 other => panic!("unexpected {:?}", other),
             }
         }
@@ -1182,9 +1079,8 @@ mod tests {
     #[test]
     fn block_comment_smoke() {
         fn get_block_comment(input: &str) -> &str {
-            let token = get_token(input);
-            match token.kind {
-                TokenKind::BlockComment => token.src(input),
+            match Lexer::new(input).parse().expect("no first token") {
+                Some(Token::BlockComment(s)) => s,
                 other => panic!("unexpected {:?}", other),
             }
         }
@@ -1193,7 +1089,7 @@ mod tests {
         assert_eq!(get_block_comment("(; (;;) ;)"), "(; (;;) ;)");
     }
 
-    fn get_token(input: &str) -> Token {
+    fn get_token(input: &str) -> Token<'_> {
         Lexer::new(input)
             .parse()
             .expect("no first token")
@@ -1202,21 +1098,23 @@ mod tests {
 
     #[test]
     fn lparen() {
-        assert_eq!(get_token("((").kind, TokenKind::LParen);
+        assert_eq!(get_token("(("), Token::LParen("("));
     }
 
     #[test]
     fn rparen() {
-        assert_eq!(get_token(")(").kind, TokenKind::RParen);
+        assert_eq!(get_token(")("), Token::RParen(")"));
     }
 
     #[test]
     fn strings() {
         fn get_string(input: &str) -> Vec<u8> {
-            let token = get_token(input);
-            match token.kind {
-                TokenKind::String => token.string(input).to_vec(),
-                other => panic!("not keyword {:?}", other),
+            match get_token(input) {
+                Token::String(s) => {
+                    assert_eq!(input, s.src());
+                    s.val().to_vec()
+                }
+                other => panic!("not string {:?}", other),
             }
         }
         assert_eq!(&*get_string("\"\""), b"");
@@ -1248,27 +1146,25 @@ mod tests {
     #[test]
     fn id() {
         fn get_id(input: &str) -> &str {
-            let token = get_token(input);
-            match token.kind {
-                TokenKind::Id => token.id(input),
+            match get_token(input) {
+                Token::Id(s) => s,
                 other => panic!("not id {:?}", other),
             }
         }
-        assert_eq!(get_id("$x"), "x");
-        assert_eq!(get_id("$xyz"), "xyz");
-        assert_eq!(get_id("$x_z"), "x_z");
-        assert_eq!(get_id("$0^"), "0^");
-        assert_eq!(get_id("$0^;;"), "0^");
-        assert_eq!(get_id("$0^ ;;"), "0^");
+        assert_eq!(get_id("$x"), "$x");
+        assert_eq!(get_id("$xyz"), "$xyz");
+        assert_eq!(get_id("$x_z"), "$x_z");
+        assert_eq!(get_id("$0^"), "$0^");
+        assert_eq!(get_id("$0^;;"), "$0^");
+        assert_eq!(get_id("$0^ ;;"), "$0^");
     }
 
     #[test]
     fn keyword() {
         fn get_keyword(input: &str) -> &str {
-            let token = get_token(input);
-            match token.kind {
-                TokenKind::Keyword => token.keyword(input),
-                other => panic!("not keyword {:?}", other),
+            match get_token(input) {
+                Token::Keyword(s) => s,
+                other => panic!("not id {:?}", other),
             }
         }
         assert_eq!(get_keyword("x"), "x");
@@ -1281,9 +1177,8 @@ mod tests {
     #[test]
     fn reserved() {
         fn get_reserved(input: &str) -> &str {
-            let token = get_token(input);
-            match token.kind {
-                TokenKind::Reserved => token.reserved(input),
+            match get_token(input) {
+                Token::Reserved(s) => s,
                 other => panic!("not reserved {:?}", other),
             }
         }
@@ -1294,9 +1189,11 @@ mod tests {
     #[test]
     fn integer() {
         fn get_integer(input: &str) -> String {
-            let token = get_token(input);
-            match token.kind {
-                TokenKind::Integer(i) => token.integer(input, i).val.to_string(),
+            match get_token(input) {
+                Token::Integer(i) => {
+                    assert_eq!(input, i.src());
+                    i.val().0.to_string()
+                }
                 other => panic!("not integer {:?}", other),
             }
         }
@@ -1313,55 +1210,57 @@ mod tests {
 
     #[test]
     fn float() {
-        fn get_float(input: &str) -> Float<'_> {
-            let token = get_token(input);
-            match token.kind {
-                TokenKind::Float(f) => token.float(input, f),
-                other => panic!("not float {:?}", other),
+        fn get_float(input: &str) -> FloatVal<'_> {
+            match get_token(input) {
+                Token::Float(i) => {
+                    assert_eq!(input, i.src());
+                    i.0.val
+                }
+                other => panic!("not reserved {:?}", other),
             }
         }
         assert_eq!(
             get_float("nan"),
-            Float::Nan {
+            FloatVal::Nan {
                 val: None,
                 negative: false
             },
         );
         assert_eq!(
             get_float("-nan"),
-            Float::Nan {
+            FloatVal::Nan {
                 val: None,
                 negative: true,
             },
         );
         assert_eq!(
             get_float("+nan"),
-            Float::Nan {
+            FloatVal::Nan {
                 val: None,
                 negative: false,
             },
         );
         assert_eq!(
             get_float("+nan:0x1"),
-            Float::Nan {
+            FloatVal::Nan {
                 val: Some(1),
                 negative: false,
             },
         );
         assert_eq!(
             get_float("nan:0x7f_ffff"),
-            Float::Nan {
+            FloatVal::Nan {
                 val: Some(0x7fffff),
                 negative: false,
             },
         );
-        assert_eq!(get_float("inf"), Float::Inf { negative: false });
-        assert_eq!(get_float("-inf"), Float::Inf { negative: true });
-        assert_eq!(get_float("+inf"), Float::Inf { negative: false });
+        assert_eq!(get_float("inf"), FloatVal::Inf { negative: false });
+        assert_eq!(get_float("-inf"), FloatVal::Inf { negative: true });
+        assert_eq!(get_float("+inf"), FloatVal::Inf { negative: false });
 
         assert_eq!(
             get_float("1.2"),
-            Float::Val {
+            FloatVal::Val {
                 integral: "1".into(),
                 decimal: Some("2".into()),
                 exponent: None,
@@ -1370,7 +1269,7 @@ mod tests {
         );
         assert_eq!(
             get_float("1.2e3"),
-            Float::Val {
+            FloatVal::Val {
                 integral: "1".into(),
                 decimal: Some("2".into()),
                 exponent: Some("3".into()),
@@ -1379,7 +1278,7 @@ mod tests {
         );
         assert_eq!(
             get_float("-1_2.1_1E+0_1"),
-            Float::Val {
+            FloatVal::Val {
                 integral: "-12".into(),
                 decimal: Some("11".into()),
                 exponent: Some("01".into()),
@@ -1388,7 +1287,7 @@ mod tests {
         );
         assert_eq!(
             get_float("+1_2.1_1E-0_1"),
-            Float::Val {
+            FloatVal::Val {
                 integral: "12".into(),
                 decimal: Some("11".into()),
                 exponent: Some("-01".into()),
@@ -1397,7 +1296,7 @@ mod tests {
         );
         assert_eq!(
             get_float("0x1_2.3_4p5_6"),
-            Float::Val {
+            FloatVal::Val {
                 integral: "12".into(),
                 decimal: Some("34".into()),
                 exponent: Some("56".into()),
@@ -1406,7 +1305,7 @@ mod tests {
         );
         assert_eq!(
             get_float("+0x1_2.3_4P-5_6"),
-            Float::Val {
+            FloatVal::Val {
                 integral: "12".into(),
                 decimal: Some("34".into()),
                 exponent: Some("-56".into()),
@@ -1415,7 +1314,7 @@ mod tests {
         );
         assert_eq!(
             get_float("1."),
-            Float::Val {
+            FloatVal::Val {
                 integral: "1".into(),
                 decimal: None,
                 exponent: None,
@@ -1424,7 +1323,7 @@ mod tests {
         );
         assert_eq!(
             get_float("0x1p-24"),
-            Float::Val {
+            FloatVal::Val {
                 integral: "1".into(),
                 decimal: None,
                 exponent: Some("-24".into()),
diff --git a/crates/wast/src/lib.rs b/crates/wast/src/lib.rs
index b1079b83..648c79d3 100644
--- a/crates/wast/src/lib.rs
+++ b/crates/wast/src/lib.rs
@@ -386,21 +386,21 @@ pub mod kw {
     custom_keyword!(assert_invalid);
     custom_keyword!(assert_malformed);
     custom_keyword!(assert_return);
+    custom_keyword!(assert_suspension);
     custom_keyword!(assert_trap);
     custom_keyword!(assert_unlinkable);
     custom_keyword!(before);
     custom_keyword!(binary);
     custom_keyword!(block);
-    custom_keyword!(borrow);
     custom_keyword!(catch);
     custom_keyword!(catch_all);
     custom_keyword!(code);
     custom_keyword!(component);
+    custom_keyword!(cont);
     custom_keyword!(data);
     custom_keyword!(declare);
     custom_keyword!(delegate);
     custom_keyword!(r#do = "do");
-    custom_keyword!(dtor);
     custom_keyword!(elem);
     custom_keyword!(end);
     custom_keyword!(tag);
@@ -432,7 +432,6 @@ pub mod kw {
     custom_keyword!(import);
     custom_keyword!(instance);
     custom_keyword!(instantiate);
-    custom_keyword!(interface);
     custom_keyword!(invoke);
     custom_keyword!(item);
     custom_keyword!(last);
@@ -442,16 +441,10 @@ pub mod kw {
     custom_keyword!(modulecode);
     custom_keyword!(nan_arithmetic = "nan:arithmetic");
     custom_keyword!(nan_canonical = "nan:canonical");
-    custom_keyword!(nofunc);
-    custom_keyword!(noextern);
-    custom_keyword!(none);
     custom_keyword!(null);
-    custom_keyword!(nullfuncref);
-    custom_keyword!(nullexternref);
     custom_keyword!(nullref);
     custom_keyword!(offset);
     custom_keyword!(outer);
-    custom_keyword!(own);
     custom_keyword!(param);
     custom_keyword!(parent);
     custom_keyword!(passive);
@@ -466,16 +459,10 @@ pub mod kw {
     custom_keyword!(ref_null = "ref.null");
     custom_keyword!(register);
     custom_keyword!(rec);
-    custom_keyword!(rep);
-    custom_keyword!(resource);
-    custom_keyword!(resource_new = "resource.new");
-    custom_keyword!(resource_drop = "resource.drop");
-    custom_keyword!(resource_rep = "resource.rep");
     custom_keyword!(result);
     custom_keyword!(shared);
     custom_keyword!(start);
     custom_keyword!(sub);
-    custom_keyword!(r#final = "final");
     custom_keyword!(table);
     custom_keyword!(then);
     custom_keyword!(r#try = "try");
@@ -519,14 +506,17 @@ pub mod kw {
     custom_keyword!(core);
     custom_keyword!(true_ = "true");
     custom_keyword!(false_ = "false");
-    custom_keyword!(language);
-    custom_keyword!(sdk);
-    custom_keyword!(processed_by = "processed-by");
+
+    // custom_keyword!(cont_new = "cont.new");
+    // custom_keyword!(cont_bind = "cont.bind");
+    // custom_keyword!(suspend);
+    // custom_keyword!(resume);
+    // custom_keyword!(resume_throw);
+    // custom_keyword!(barrier);
 }
 
 /// Common annotations used to parse WebAssembly text files.
 pub mod annotation {
     annotation!(custom);
     annotation!(name);
-    annotation!(producers);
 }
diff --git a/crates/wast/src/parser.rs b/crates/wast/src/parser.rs
index 3c274712..6b1a9deb 100644
--- a/crates/wast/src/parser.rs
+++ b/crates/wast/src/parser.rs
@@ -64,10 +64,9 @@
 //! This module is heavily inspired by [`syn`](https://docs.rs/syn) so you can
 //! likely also draw inspiration from the excellent examples in the `syn` crate.
 
-use crate::lexer::{Float, Integer, Lexer, Token, TokenKind};
+use crate::lexer::{Float, Integer, Lexer, Token};
 use crate::token::Span;
 use crate::Error;
-use std::borrow::Cow;
 use std::cell::{Cell, RefCell};
 use std::collections::HashMap;
 use std::fmt;
@@ -244,15 +243,6 @@ pub trait Parse<'a>: Sized {
     fn parse(parser: Parser<'a>) -> Result<Self>;
 }
 
-impl<'a, T> Parse<'a> for Box<T>
-where
-    T: Parse<'a>,
-{
-    fn parse(parser: Parser<'a>) -> Result<Self> {
-        Ok(Box::new(parser.parse()?))
-    }
-}
-
 /// A trait for types which be used to "peek" to see if they're the next token
 /// in an input stream of [`Parser`].
 ///
@@ -304,12 +294,11 @@ pub struct ParseBuffer<'a> {
     // list of tokens from the tokenized source (including whitespace and
     // comments), and the second element is how to skip this token, if it can be
     // skipped.
-    tokens: Box<[(Token, Cell<NextTokenAt>)]>,
+    tokens: Box<[(Token<'a>, Cell<NextTokenAt>)]>,
     input: &'a str,
     cur: Cell<usize>,
     known_annotations: RefCell<HashMap<String, usize>>,
     depth: Cell<usize>,
-    strings: RefCell<Vec<Box<[u8]>>>,
 }
 
 #[derive(Copy, Clone, Debug)]
@@ -382,7 +371,6 @@ impl ParseBuffer<'_> {
             depth: Cell::new(0),
             input,
             known_annotations: Default::default(),
-            strings: Default::default(),
         };
         ret.validate_annotations()?;
         Ok(ret)
@@ -396,7 +384,7 @@ impl ParseBuffer<'_> {
     // delimiters. This is required since while parsing we generally skip
     // annotations and there's no real opportunity to return a parse error.
     fn validate_annotations(&self) -> Result<()> {
-        use crate::lexer::TokenKind::*;
+        use crate::lexer::Token::*;
         enum State {
             None,
             LParen,
@@ -404,40 +392,33 @@ impl ParseBuffer<'_> {
         }
         let mut state = State::None;
         for token in self.tokens.iter() {
-            state = match (token.0.kind, state) {
+            state = match (&token.0, state) {
                 // From nothing, a `(` starts the search for an annotation
-                (LParen, State::None) => State::LParen,
+                (LParen(_), State::None) => State::LParen,
                 // ... otherwise in nothing we always preserve that state.
                 (_, State::None) => State::None,
 
-                // ... otherwise anything after an `LParen` kills the lparen
-                // state.
-                (kind, State::LParen) => {
-                    // If the previous state was an `LParen`, we may have an
-                    // annotation if the next keyword is reserved
-                    if let Reserved = kind {
-                        let reserved = token.0.reserved(self.input);
-                        if reserved.starts_with('@') && reserved.len() > 1 {
-                            state = State::Annotation {
-                                span: Span {
-                                    offset: token.0.offset,
-                                },
-                                depth: 1,
-                            };
-                            continue;
-                        }
+                // If the previous state was an `LParen`, we may have an
+                // annotation if the next keyword is reserved
+                (Reserved(s), State::LParen) if s.starts_with('@') && !s.is_empty() => {
+                    let offset = self.input_pos(s);
+                    State::Annotation {
+                        span: Span { offset },
+                        depth: 1,
                     }
-                    State::None
                 }
+                // ... otherwise anything after an `LParen` kills the lparen
+                // state.
+                (_, State::LParen) => State::None,
 
                 // Once we're in an annotation we need to balance parentheses,
                 // so handle the depth changes.
-                (LParen, State::Annotation { span, depth }) => State::Annotation {
+                (LParen(_), State::Annotation { span, depth }) => State::Annotation {
                     span,
                     depth: depth + 1,
                 },
-                (RParen, State::Annotation { depth: 1, .. }) => State::None,
-                (RParen, State::Annotation { span, depth }) => State::Annotation {
+                (RParen(_), State::Annotation { depth: 1, .. }) => State::None,
+                (RParen(_), State::Annotation { span, depth }) => State::Annotation {
                     span,
                     depth: depth - 1,
                 },
@@ -451,20 +432,8 @@ impl ParseBuffer<'_> {
         Ok(())
     }
 
-    /// Stores an owned allocation in this `Parser` to attach the lifetime of
-    /// the vector to `self`.
-    ///
-    /// This will return a reference to `s`, but one that's safely rooted in the
-    /// `Parser`.
-    fn push_str(&self, s: Vec<u8>) -> &[u8] {
-        let s = Box::from(s);
-        let ret = &*s as *const [u8];
-        self.strings.borrow_mut().push(s);
-        // This should be safe in that the address of `ret` isn't changing as
-        // it's on the heap itself. Additionally the lifetime of this return
-        // value is tied to the lifetime of `self` (nothing is deallocated
-        // early), so it should be safe to say the two have the same lifetime.
-        unsafe { &*ret }
+    fn input_pos(&self, src: &str) -> usize {
+        src.as_ptr() as usize - self.input.as_ptr() as usize
     }
 }
 
@@ -480,16 +449,16 @@ impl<'a> Parser<'a> {
     /// and whitespace are not considered for whether this parser is empty.
     pub fn is_empty(self) -> bool {
         match self.cursor().advance_token() {
-            Some(token) => matches!(token.kind, TokenKind::RParen),
-            None => true,
+            Some(Token::RParen(_)) | None => true,
+            Some(_) => false, // more tokens to parse!
         }
     }
 
     pub(crate) fn has_meaningful_tokens(self) -> bool {
         self.buf.tokens[self.cursor().cur..].iter().any(|(t, _)| {
             !matches!(
-                t.kind,
-                TokenKind::Whitespace | TokenKind::LineComment | TokenKind::BlockComment
+                t,
+                Token::Whitespace(_) | Token::LineComment(_) | Token::BlockComment(_)
             )
         })
     }
@@ -975,7 +944,7 @@ impl<'a> Cursor<'a> {
     /// Does not take into account whitespace or comments.
     pub fn cur_span(&self) -> Span {
         let offset = match self.clone().advance_token() {
-            Some(t) => t.offset,
+            Some(t) => self.parser.buf.input_pos(t.src()),
             None => self.parser.buf.input.len(),
         };
         Span { offset }
@@ -987,7 +956,7 @@ impl<'a> Cursor<'a> {
     pub(crate) fn prev_span(&self) -> Option<Span> {
         let (token, _) = self.parser.buf.tokens.get(self.cur.checked_sub(1)?)?;
         Some(Span {
-            offset: token.offset,
+            offset: self.parser.buf.input_pos(token.src()),
         })
     }
 
@@ -1005,8 +974,8 @@ impl<'a> Cursor<'a> {
     /// This function will automatically skip over any comments, whitespace, or
     /// unknown annotations.
     pub fn lparen(mut self) -> Option<Self> {
-        match self.advance_token()?.kind {
-            TokenKind::LParen => Some(self),
+        match self.advance_token()? {
+            Token::LParen(_) => Some(self),
             _ => None,
         }
     }
@@ -1019,8 +988,8 @@ impl<'a> Cursor<'a> {
     /// This function will automatically skip over any comments, whitespace, or
     /// unknown annotations.
     pub fn rparen(mut self) -> Option<Self> {
-        match self.advance_token()?.kind {
-            TokenKind::RParen => Some(self),
+        match self.advance_token()? {
+            Token::RParen(_) => Some(self),
             _ => None,
         }
     }
@@ -1035,9 +1004,8 @@ impl<'a> Cursor<'a> {
     /// This function will automatically skip over any comments, whitespace, or
     /// unknown annotations.
     pub fn id(mut self) -> Option<(&'a str, Self)> {
-        let token = self.advance_token()?;
-        match token.kind {
-            TokenKind::Id => Some((token.id(self.parser.buf.input), self)),
+        match self.advance_token()? {
+            Token::Id(id) => Some((&id[1..], self)),
             _ => None,
         }
     }
@@ -1052,9 +1020,8 @@ impl<'a> Cursor<'a> {
     /// This function will automatically skip over any comments, whitespace, or
     /// unknown annotations.
     pub fn keyword(mut self) -> Option<(&'a str, Self)> {
-        let token = self.advance_token()?;
-        match token.kind {
-            TokenKind::Keyword => Some((token.keyword(self.parser.buf.input), self)),
+        match self.advance_token()? {
+            Token::Keyword(id) => Some((id, self)),
             _ => None,
         }
     }
@@ -1069,9 +1036,8 @@ impl<'a> Cursor<'a> {
     /// This function will automatically skip over any comments, whitespace, or
     /// unknown annotations.
     pub fn reserved(mut self) -> Option<(&'a str, Self)> {
-        let token = self.advance_token()?;
-        match token.kind {
-            TokenKind::Reserved => Some((token.reserved(self.parser.buf.input), self)),
+        match self.advance_token()? {
+            Token::Reserved(id) => Some((id, self)),
             _ => None,
         }
     }
@@ -1085,10 +1051,9 @@ impl<'a> Cursor<'a> {
     ///
     /// This function will automatically skip over any comments, whitespace, or
     /// unknown annotations.
-    pub fn integer(mut self) -> Option<(Integer<'a>, Self)> {
-        let token = self.advance_token()?;
-        match token.kind {
-            TokenKind::Integer(i) => Some((token.integer(self.parser.buf.input, i), self)),
+    pub fn integer(mut self) -> Option<(&'a Integer<'a>, Self)> {
+        match self.advance_token()? {
+            Token::Integer(i) => Some((i, self)),
             _ => None,
         }
     }
@@ -1102,10 +1067,9 @@ impl<'a> Cursor<'a> {
     ///
     /// This function will automatically skip over any comments, whitespace, or
     /// unknown annotations.
-    pub fn float(mut self) -> Option<(Float<'a>, Self)> {
-        let token = self.advance_token()?;
-        match token.kind {
-            TokenKind::Float(f) => Some((token.float(self.parser.buf.input, f), self)),
+    pub fn float(mut self) -> Option<(&'a Float<'a>, Self)> {
+        match self.advance_token()? {
+            Token::Float(f) => Some((f, self)),
             _ => None,
         }
     }
@@ -1120,16 +1084,10 @@ impl<'a> Cursor<'a> {
     /// This function will automatically skip over any comments, whitespace, or
     /// unknown annotations.
     pub fn string(mut self) -> Option<(&'a [u8], Self)> {
-        let token = self.advance_token()?;
-        match token.kind {
-            TokenKind::String => {}
-            _ => return None,
+        match self.advance_token()? {
+            Token::String(s) => Some((s.val(), self)),
+            _ => None,
         }
-        let string = match token.string(self.parser.buf.input) {
-            Cow::Borrowed(s) => s,
-            Cow::Owned(s) => self.parser.buf.push_str(s),
-        };
-        Some((string, self))
     }
 
     /// Attempts to advance this cursor if the current token is a
@@ -1157,8 +1115,8 @@ impl<'a> Cursor<'a> {
         if !token.starts_with('@') || token.len() <= 1 {
             return None;
         }
-        match self.parser.buf.tokens.get(self.cur.wrapping_sub(1))?.0.kind {
-            TokenKind::LParen => Some((&token[1..], cursor)),
+        match &self.parser.buf.tokens.get(self.cur.wrapping_sub(1))?.0 {
+            Token::LParen(_) => Some((&token[1..], cursor)),
             _ => None,
         }
     }
@@ -1170,13 +1128,12 @@ impl<'a> Cursor<'a> {
     /// This function will only skip whitespace, no other tokens.
     pub fn comment(mut self) -> Option<(&'a str, Self)> {
         let comment = loop {
-            let token = &self.parser.buf.tokens.get(self.cur)?.0;
-            match token.kind {
-                TokenKind::LineComment | TokenKind::BlockComment => {
+            match &self.parser.buf.tokens.get(self.cur)?.0 {
+                Token::LineComment(c) | Token::BlockComment(c) => {
                     self.cur += 1;
-                    break token.src(self.parser.buf.input);
+                    break c;
                 }
-                TokenKind::Whitespace => {
+                Token::Whitespace(_) => {
                     self.cur += 1;
                 }
                 _ => return None,
@@ -1185,7 +1142,7 @@ impl<'a> Cursor<'a> {
         Some((comment, self))
     }
 
-    fn advance_token(&mut self) -> Option<&'a Token> {
+    fn advance_token(&mut self) -> Option<&'a Token<'a>> {
         let known_annotations = self.parser.buf.known_annotations.borrow();
         let is_known_annotation = |name: &str| match known_annotations.get(name) {
             Some(0) | None => false,
@@ -1198,8 +1155,8 @@ impl<'a> Cursor<'a> {
             // If we're currently pointing at a token, and it's not the start
             // of an annotation, then we return that token and advance
             // ourselves to just after that token.
-            match token.kind {
-                TokenKind::Whitespace | TokenKind::LineComment | TokenKind::BlockComment => {}
+            match token {
+                Token::Whitespace(_) | Token::LineComment(_) | Token::BlockComment(_) => {}
                 _ => match self.annotation_start() {
                     Some(n) if !is_known_annotation(n) => {}
                     _ => {
@@ -1243,16 +1200,14 @@ impl<'a> Cursor<'a> {
     }
 
     fn annotation_start(&self) -> Option<&'a str> {
-        match self.parser.buf.tokens.get(self.cur)?.0.kind {
-            TokenKind::LParen => {}
+        match self.parser.buf.tokens.get(self.cur).map(|p| &p.0) {
+            Some(Token::LParen(_)) => {}
             _ => return None,
         }
-        let reserved = &self.parser.buf.tokens.get(self.cur + 1)?.0;
-        match reserved.kind {
-            TokenKind::Reserved => {}
+        let reserved = match self.parser.buf.tokens.get(self.cur + 1).map(|p| &p.0) {
+            Some(Token::Reserved(n)) => n,
             _ => return None,
-        }
-        let reserved = reserved.src(self.parser.buf.input);
+        };
         if reserved.starts_with('@') && reserved.len() > 1 {
             Some(&reserved[1..])
         } else {
@@ -1275,9 +1230,9 @@ impl<'a> Cursor<'a> {
             let mut depth = 1;
             self.cur += 1;
             while depth > 0 {
-                match self.parser.buf.tokens.get(self.cur)?.0.kind {
-                    TokenKind::LParen => depth += 1,
-                    TokenKind::RParen => depth -= 1,
+                match &self.parser.buf.tokens.get(self.cur)?.0 {
+                    Token::LParen(_) => depth += 1,
+                    Token::RParen(_) => depth -= 1,
                     _ => {}
                 }
                 self.cur += 1;
@@ -1291,8 +1246,8 @@ impl<'a> Cursor<'a> {
             let (token, _) = self.parser.buf.tokens.get(self.cur)?;
             // and otherwise we skip all comments/whitespace and only
             // get interested once a normal `Token` pops up.
-            match token.kind {
-                TokenKind::Whitespace | TokenKind::LineComment | TokenKind::BlockComment => {
+            match token {
+                Token::Whitespace(_) | Token::LineComment(_) | Token::BlockComment(_) => {
                     self.cur += 1
                 }
                 _ => return Some(self.cur),
diff --git a/crates/wast/src/token.rs b/crates/wast/src/token.rs
index 575d62e7..a2bcfed5 100644
--- a/crates/wast/src/token.rs
+++ b/crates/wast/src/token.rs
@@ -3,7 +3,7 @@
 //! contexts too perhaps).
 
 use crate::annotation;
-use crate::lexer::Float;
+use crate::lexer::FloatVal;
 use crate::parser::{Cursor, Parse, Parser, Peek, Result};
 use std::fmt;
 use std::hash::{Hash, Hasher};
@@ -167,15 +167,14 @@ impl Index<'_> {
 
 impl<'a> Parse<'a> for Index<'a> {
     fn parse(parser: Parser<'a>) -> Result<Self> {
-        if parser.peek::<Id>() {
+        let mut l = parser.lookahead1();
+        if l.peek::<Id>() {
             Ok(Index::Id(parser.parse()?))
-        } else if parser.peek::<u32>() {
+        } else if l.peek::<u32>() {
             let (val, span) = parser.parse()?;
             Ok(Index::Num(val, span))
         } else {
-            Err(parser.error(format!(
-                "unexpected token, expected an index or an identifier"
-            )))
+            Err(l.error())
         }
     }
 }
@@ -390,11 +389,11 @@ macro_rules! float {
             fn parse(parser: Parser<'a>) -> Result<Self> {
                 parser.step(|c| {
                     let (val, rest) = if let Some((f, rest)) = c.float() {
-                        ($parse(&f), rest)
+                        ($parse(f.val()), rest)
                     } else if let Some((i, rest)) = c.integer() {
                         let (s, base) = i.val();
                         (
-                            $parse(&Float::Val {
+                            $parse(&FloatVal::Val {
                                 hex: base == 16,
                                 integral: s.into(),
                                 decimal: None,
@@ -413,7 +412,7 @@ macro_rules! float {
             }
         }
 
-        fn $parse(val: &Float<'_>) -> Option<$int> {
+        fn $parse(val: &FloatVal<'_>) -> Option<$int> {
             // Compute a few well-known constants about the float representation
             // given the parameters to the macro here.
             let width = std::mem::size_of::<$int>() * 8;
@@ -426,7 +425,7 @@ macro_rules! float {
             let (hex, integral, decimal, exponent_str) = match val {
                 // Infinity is when the exponent bits are all set and
                 // the significand is zero.
-                Float::Inf { negative } => {
+                FloatVal::Inf { negative } => {
                     let exp_bits = (1 << $exp_bits) - 1;
                     let neg_bit = *negative as $int;
                     return Some(
@@ -438,7 +437,7 @@ macro_rules! float {
                 // NaN is when the exponent bits are all set and
                 // the significand is nonzero. The default of NaN is
                 // when only the highest bit of the significand is set.
-                Float::Nan { negative, val } => {
+                FloatVal::Nan { negative, val } => {
                     let exp_bits = (1 << $exp_bits) - 1;
                     let neg_bit = *negative as $int;
                     let signif = val.unwrap_or(1 << (signif_bits - 1)) as $int;
@@ -455,7 +454,7 @@ macro_rules! float {
                 }
 
                 // This is trickier, handle this below
-                Float::Val { hex, integral, decimal, exponent } => {
+                FloatVal::Val { hex, integral, decimal, exponent } => {
                     (hex, integral, decimal, exponent)
                 }
             };
@@ -664,7 +663,7 @@ mod tests {
             ($a:tt p $e:tt) => (f!(@mk $a, None, Some($e.into())));
             ($a:tt . $b:tt) => (f!(@mk $a, Some($b.into()), None));
             ($a:tt . $b:tt p $e:tt) => (f!(@mk $a, Some($b.into()), Some($e.into())));
-            (@mk $a:tt, $b:expr, $e:expr) => (crate::lexer::Float::Val {
+            (@mk $a:tt, $b:expr, $e:expr) => (crate::lexer::FloatVal::Val {
                 hex: true,
                 integral: $a.into(),
                 decimal: $b,
diff --git a/crates/wast/src/wast.rs b/crates/wast/src/wast.rs
index ec589e59..012c30c4 100644
--- a/crates/wast/src/wast.rs
+++ b/crates/wast/src/wast.rs
@@ -102,6 +102,11 @@ pub enum WastDirective<'a> {
         span: Span,
         exec: WastExecute<'a>,
     },
+    AssertSuspension {
+        span: Span,
+        exec: WastExecute<'a>,
+        message: &'a str,
+    },
 }
 
 impl WastDirective<'_> {
@@ -119,7 +124,8 @@ impl WastDirective<'_> {
             | WastDirective::AssertExhaustion { span, .. }
             | WastDirective::AssertUnlinkable { span, .. }
             | WastDirective::AssertInvalid { span, .. }
-            | WastDirective::AssertException { span, .. } => *span,
+            | WastDirective::AssertException { span, .. }
+            | WastDirective::AssertSuspension { span, .. } => *span,
             WastDirective::Invoke(i) => i.span,
         }
     }
@@ -192,6 +198,13 @@ impl<'a> Parse<'a> for WastDirective<'a> {
                 span,
                 exec: parser.parens(|p| p.parse())?,
             })
+        } else if l.peek::<kw::assert_suspension>() {
+            let span = parser.parse::<kw::assert_suspension>()?.0;
+            Ok(WastDirective::AssertSuspension {
+                span,
+                exec: parser.parens(|p| p.parse())?,
+                message: parser.parse()?,
+            })
         } else {
             Err(l.error())
         }
diff --git a/crates/wast/tests/parse-fail/bad-core-func-alias.wat b/crates/wast/tests/parse-fail/bad-core-func-alias.wat
deleted file mode 100644
index c2ebee5e..00000000
--- a/crates/wast/tests/parse-fail/bad-core-func-alias.wat
+++ /dev/null
@@ -1,7 +0,0 @@
-(component
-  (core module $mod (func (export "fun")))
-  (core instance $inst (instantiate $mod))
-  (alias core export $inst "fun" (core func $fun1))
-  (core func $fun2 (alias core export $inst "fun"))
-  (core func $fun3 (alias export $inst "fun"))
-)
diff --git a/crates/wast/tests/parse-fail/bad-core-func-alias.wat.err b/crates/wast/tests/parse-fail/bad-core-func-alias.wat.err
deleted file mode 100644
index b782905f..00000000
--- a/crates/wast/tests/parse-fail/bad-core-func-alias.wat.err
+++ /dev/null
@@ -1,5 +0,0 @@
-expected keyword `core`
-     --> tests/parse-fail/bad-core-func-alias.wat:6:27
-      |
-    6 |   (core func $fun3 (alias export $inst "fun"))
-      |                           ^
diff --git a/crates/wast/tests/parse-fail/bad-func-alias.wat b/crates/wast/tests/parse-fail/bad-func-alias.wat
deleted file mode 100644
index d558ebbf..00000000
--- a/crates/wast/tests/parse-fail/bad-func-alias.wat
+++ /dev/null
@@ -1,7 +0,0 @@
-(component
-    (component $comp)
-    (instance $inst (instantiate $comp))
-    (func $alias1 (alias export $inst "fun"))
-    (alias export $inst "fun" (func $alias2))
-    (alias export $inst "fun" (core func $alias3))
-)
diff --git a/crates/wast/tests/parse-fail/bad-func-alias.wat.err b/crates/wast/tests/parse-fail/bad-func-alias.wat.err
deleted file mode 100644
index ff8a8ee3..00000000
--- a/crates/wast/tests/parse-fail/bad-func-alias.wat.err
+++ /dev/null
@@ -1,5 +0,0 @@
-unexpected token, expected `module`
-     --> tests/parse-fail/bad-func-alias.wat:6:37
-      |
-    6 |     (alias export $inst "fun" (core func $alias3))
-      |                                     ^
diff --git a/crates/wat/Cargo.toml b/crates/wat/Cargo.toml
index 070fdfe2..3f7bc165 100644
--- a/crates/wat/Cargo.toml
+++ b/crates/wat/Cargo.toml
@@ -1,6 +1,6 @@
 [package]
 name = "wat"
-version = "1.0.67"
+version = "1.0.61"
 authors = ["Alex Crichton <alex@alexcrichton.com>"]
 edition.workspace = true
 license = "Apache-2.0 WITH LLVM-exception"
diff --git a/crates/wat/src/lib.rs b/crates/wat/src/lib.rs
index c1617460..bd0bafcb 100644
--- a/crates/wat/src/lib.rs
+++ b/crates/wat/src/lib.rs
@@ -287,7 +287,7 @@ impl fmt::Display for Error {
             },
             ErrorKind::Io { err, file, .. } => match file {
                 Some(file) => {
-                    write!(f, "failed to read from `{}`", file.display())
+                    write!(f, "failed to read from `{}`: {}", file.display(), err)
                 }
                 None => err.fmt(f),
             },
@@ -321,7 +321,7 @@ mod test {
         let e = parse_file("_does_not_exist_").unwrap_err();
         assert!(e
             .to_string()
-            .starts_with("failed to read from `_does_not_exist_`"));
+            .starts_with("failed to read from `_does_not_exist_`: "));
 
         let mut e = parse_bytes("()".as_bytes()).unwrap_err();
         e.set_path("foo");
diff --git a/crates/wit-component/Cargo.toml b/crates/wit-component/Cargo.toml
index bff4abe9..dffbbe28 100644
--- a/crates/wit-component/Cargo.toml
+++ b/crates/wit-component/Cargo.toml
@@ -1,7 +1,7 @@
 [package]
 name = "wit-component"
 authors = ["Peter Huene <peter@huene.dev>"]
-version = "0.12.0"
+version = "0.7.4"
 edition.workspace = true
 license = "Apache-2.0 WITH LLVM-exception"
 readme = "README.md"
@@ -21,6 +21,7 @@ anyhow = { workspace = true }
 log = "0.4.17"
 bitflags = "1.3.2"
 indexmap = { workspace = true }
+url = { workspace = true }
 wat = { workspace = true, optional = true }
 
 [dev-dependencies]
diff --git a/crates/wit-component/src/builder.rs b/crates/wit-component/src/builder.rs
index 68c9c97e..01c130ff 100644
--- a/crates/wit-component/src/builder.rs
+++ b/crates/wit-component/src/builder.rs
@@ -124,11 +124,12 @@ impl ComponentBuilder {
     pub fn export(
         &mut self,
         name: &str,
+        url: &str,
         kind: ComponentExportKind,
         idx: u32,
         ty: Option<ComponentTypeRef>,
     ) -> u32 {
-        self.exports().export(name, kind, idx, ty);
+        self.exports().export(name, url, kind, idx, ty);
         match kind {
             ComponentExportKind::Type => inc(&mut self.types),
             ComponentExportKind::Func => inc(&mut self.funcs),
@@ -138,15 +139,14 @@ impl ComponentBuilder {
         }
     }
 
-    pub fn import(&mut self, name: &str, ty: ComponentTypeRef) -> u32 {
+    pub fn import(&mut self, name: &str, url: &str, ty: ComponentTypeRef) -> u32 {
         let ret = match &ty {
             ComponentTypeRef::Instance(_) => inc(&mut self.instances),
             ComponentTypeRef::Func(_) => inc(&mut self.funcs),
             ComponentTypeRef::Type(..) => inc(&mut self.types),
-            ComponentTypeRef::Component(_) => inc(&mut self.components),
             _ => unimplemented!(),
         };
-        self.imports().import(name, ty);
+        self.imports().import(name, url, ty);
         ret
     }
 
@@ -170,11 +170,6 @@ impl ComponentBuilder {
         (inc(&mut self.types), self.types().function())
     }
 
-    pub fn resource(&mut self, rep: ValType, dtor: Option<u32>) -> u32 {
-        self.types().resource(rep, dtor);
-        inc(&mut self.types)
-    }
-
     pub fn alias_type_export(&mut self, instance: u32, name: &str) -> u32 {
         self.aliases().alias(Alias::InstanceExport {
             instance,
@@ -184,6 +179,15 @@ impl ComponentBuilder {
         inc(&mut self.types)
     }
 
+    pub fn alias_outer_type(&mut self, count: u32, index: u32) -> u32 {
+        self.aliases().alias(Alias::Outer {
+            count,
+            index,
+            kind: ComponentOuterAliasKind::Type,
+        });
+        inc(&mut self.types)
+    }
+
     pub fn component(&mut self, mut builder: ComponentBuilder) -> u32 {
         builder.flush();
         self.flush();
@@ -192,16 +196,6 @@ impl ComponentBuilder {
         inc(&mut self.components)
     }
 
-    pub fn raw_component(&mut self, data: &[u8]) -> u32 {
-        let raw_section = RawSection {
-            id: ComponentSectionId::Component.into(),
-            data,
-        };
-        self.flush();
-        self.component.section(&raw_section);
-        inc(&mut self.components)
-    }
-
     pub fn instantiate_component<A, S>(&mut self, component_index: u32, args: A) -> u32
     where
         A: IntoIterator<Item = (S, ComponentExportKind, u32)>,
@@ -216,21 +210,6 @@ impl ComponentBuilder {
     pub fn add_producers(&mut self, producers: &Producers) {
         self.producers.merge(producers)
     }
-
-    pub fn resource_drop(&mut self, ty: u32) -> u32 {
-        self.canonical_functions().resource_drop(ty);
-        inc(&mut self.core_funcs)
-    }
-
-    pub fn resource_new(&mut self, ty: u32) -> u32 {
-        self.canonical_functions().resource_new(ty);
-        inc(&mut self.core_funcs)
-    }
-
-    pub fn resource_rep(&mut self, ty: u32) -> u32 {
-        self.canonical_functions().resource_rep(ty);
-        inc(&mut self.core_funcs)
-    }
 }
 
 // Helper macro to generate methods on `ComponentBuilder` to get specific
diff --git a/crates/wit-component/src/decoding.rs b/crates/wit-component/src/decoding.rs
index e5755132..ee1c1fb9 100644
--- a/crates/wit-component/src/decoding.rs
+++ b/crates/wit-component/src/decoding.rs
@@ -2,10 +2,10 @@ use anyhow::{anyhow, bail, Context, Result};
 use indexmap::{IndexMap, IndexSet};
 use std::collections::HashMap;
 use std::mem;
+use url::Url;
 use wasmparser::{
-    names::{KebabName, KebabNameKind},
-    types, ComponentExport, ComponentExternName, ComponentExternalKind, ComponentImport, Parser,
-    Payload, PrimitiveValType, ValidPayload, Validator, WasmFeatures,
+    types, ComponentExport, ComponentExternalKind, ComponentImport, Parser, Payload,
+    PrimitiveValType, ValidPayload, Validator, WasmFeatures,
 };
 use wit_parser::*;
 
@@ -15,7 +15,7 @@ struct ComponentInfo<'a> {
     /// validated.
     types: types::Types,
     /// List of all imports and exports from this component.
-    externs: Vec<(ComponentExternName<'a>, Extern<'a>)>,
+    externs: Vec<(&'a str, Extern<'a>)>,
 }
 
 enum Extern<'a> {
@@ -80,102 +80,190 @@ impl<'a> ComponentInfo<'a> {
                     _ => return false,
                 };
                 match export.kind {
-                    ComponentExternalKind::Type => matches!(
-                        &self.types[self.types.component_type_at(export.index)],
-                        types::Type::Component(_)
-                    ),
+                    ComponentExternalKind::Type => match self.types.type_at(export.index, false) {
+                        Some(types::Type::Component(_)) => true,
+                        _ => false,
+                    },
                     _ => false,
                 }
             })
     }
 
-    fn decode_wit_package(&self) -> Result<(Resolve, PackageId)> {
+    fn decode_wit_package(&self, name: &str) -> Result<(Resolve, PackageId)> {
         assert!(self.is_wit_package());
         let resolve = Resolve::default();
         let mut decoder = WitPackageDecoder {
             resolve,
             info: self,
+            url_to_package: IndexMap::default(),
             type_map: HashMap::new(),
-            foreign_packages: Default::default(),
-            iface_to_package_index: Default::default(),
-            named_interfaces: Default::default(),
-            resources: Default::default(),
+            url_to_interface: HashMap::new(),
         };
 
-        let mut pkg = None;
-        for (name, item) in self.externs.iter() {
+        let mut docs = Vec::new();
+        for (doc, item) in self.externs.iter() {
             let export = match item {
                 Extern::Export(e) => e,
                 _ => unreachable!(),
             };
-            let id = self.types.component_type_at(export.index);
-            let ty = self.types[id].unwrap_component();
-            if pkg.is_some() {
-                bail!("more than one top-level exported component type found");
-            }
-            let name = KebabName::new(*name, 0).unwrap();
-            pkg = Some(
-                decoder
-                    .decode_package(&name, ty)
-                    .with_context(|| format!("failed to decode document `{name}`"))?,
-            );
+            let ty = match self.types.type_at(export.index, false) {
+                Some(types::Type::Component(ty)) => ty,
+                _ => unreachable!(),
+            };
+            let id = decoder
+                .decode_document(doc, ty)
+                .with_context(|| format!("failed to decode document `{doc}`"))?;
+            docs.push((doc, id));
         }
 
-        let pkg = pkg.ok_or_else(|| anyhow!("no exported component type found"))?;
-        let (resolve, package) = decoder.finish(pkg);
+        let (resolve, package) = decoder.finish(Package {
+            name: name.to_string(),
+            documents: docs
+                .iter()
+                .map(|(name, d)| (name.to_string(), *d))
+                .collect(),
+            url: None,
+        });
+
         Ok((resolve, package))
     }
 
-    fn decode_component(&self) -> Result<(Resolve, WorldId)> {
+    fn decode_component(&self, name: &str) -> Result<(Resolve, WorldId)> {
         assert!(!self.is_wit_package());
         let mut resolve = Resolve::default();
-        // Note that this name is arbitrarily chosen. We may one day perhaps
-        // want to encode this in the component binary format itself, but for
-        // now it shouldn't be an issue to have a defaulted name here.
-        let world_name = "root";
+        let doc = resolve.documents.alloc(Document {
+            name: "root".to_string(),
+            interfaces: Default::default(),
+            worlds: Default::default(),
+            default_interface: None,
+            default_world: None,
+            package: None,
+        });
         let world = resolve.worlds.alloc(World {
-            name: world_name.to_string(),
+            name: name.to_string(),
             docs: Default::default(),
             imports: Default::default(),
             exports: Default::default(),
-            package: None,
-            includes: Default::default(),
-            include_names: Default::default(),
+            document: doc,
         });
+        resolve.documents[doc]
+            .worlds
+            .insert(name.to_string(), world);
+        resolve.documents[doc].default_world = Some(world);
         let mut decoder = WitPackageDecoder {
             resolve,
             info: self,
+            url_to_package: IndexMap::default(),
             type_map: HashMap::new(),
-            foreign_packages: Default::default(),
-            iface_to_package_index: Default::default(),
-            named_interfaces: Default::default(),
-            resources: Default::default(),
-        };
-        let mut package = Package {
-            // Similar to `world_name` above this is arbitrarily chosen as it's
-            // not otherwise encoded in a binary component. This theoretically
-            // shouldn't cause issues, however.
-            name: PackageName {
-                namespace: "root".to_string(),
-                version: None,
-                name: "component".to_string(),
-            },
-            worlds: [(world_name.to_string(), world)].into_iter().collect(),
-            interfaces: Default::default(),
+            url_to_interface: HashMap::new(),
         };
 
-        for (_name, item) in self.externs.iter() {
+        for (name, item) in self.externs.iter() {
             match item {
                 Extern::Import(import) => {
-                    decoder.decode_component_import(import, world, &mut package)?
+                    let ty = self
+                        .types
+                        .component_entity_type_of_extern(import.name)
+                        .unwrap();
+                    let item = match ty {
+                        types::ComponentEntityType::Instance(i) => {
+                            let ty = match self.types.type_from_id(i) {
+                                Some(types::Type::ComponentInstance(ty)) => ty,
+                                _ => unreachable!(),
+                            };
+                            let id = decoder
+                                .register_interface(doc, Some(name), ty)
+                                .with_context(|| {
+                                    format!("failed to decode WIT from import `{name}`")
+                                })?;
+                            decoder.resolve.documents[doc]
+                                .interfaces
+                                .insert(name.to_string(), id);
+                            WorldItem::Interface(id)
+                        }
+                        types::ComponentEntityType::Func(i) => {
+                            let ty = match self.types.type_from_id(i) {
+                                Some(types::Type::ComponentFunc(ty)) => ty,
+                                _ => unreachable!(),
+                            };
+                            let func = decoder.convert_function(name, ty).with_context(|| {
+                                format!("failed to decode function from import `{name}`")
+                            })?;
+                            WorldItem::Function(func)
+                        }
+                        types::ComponentEntityType::Type {
+                            referenced,
+                            created,
+                        } => {
+                            let id = decoder
+                                .register_type_export(
+                                    name,
+                                    TypeOwner::World(world),
+                                    referenced,
+                                    created,
+                                )
+                                .with_context(|| {
+                                    format!("failed to decode type from export `{name}`")
+                                })?;
+                            WorldItem::Type(id)
+                        }
+                        _ => {
+                            bail!("component import `{name}` was not a function, instance, or type")
+                        }
+                    };
+                    decoder.resolve.worlds[world]
+                        .imports
+                        .insert(name.to_string(), item);
                 }
+
                 Extern::Export(export) => {
-                    decoder.decode_component_export(export, world, &mut package)?
+                    let ty = self
+                        .types
+                        .component_entity_type_of_extern(export.name)
+                        .unwrap();
+                    let item = match ty {
+                        types::ComponentEntityType::Func(i) => {
+                            let ty = match self.types.type_from_id(i) {
+                                Some(types::Type::ComponentFunc(ty)) => ty,
+                                _ => unreachable!(),
+                            };
+                            let func = decoder.convert_function(name, ty).with_context(|| {
+                                format!("failed to decode function from export `{name}`")
+                            })?;
+
+                            WorldItem::Function(func)
+                        }
+                        types::ComponentEntityType::Instance(i) => {
+                            let ty = match self.types.type_from_id(i) {
+                                Some(types::Type::ComponentInstance(ty)) => ty,
+                                _ => unreachable!(),
+                            };
+                            let id = decoder
+                                .register_interface(doc, Some(name), ty)
+                                .with_context(|| {
+                                    format!("failed to decode WIT from export `{name}`")
+                                })?;
+                            decoder.resolve.documents[doc]
+                                .interfaces
+                                .insert(name.to_string(), id);
+                            WorldItem::Interface(id)
+                        }
+                        _ => {
+                            bail!("component export `{name}` was not a function or instance")
+                        }
+                    };
+                    decoder.resolve.worlds[world]
+                        .exports
+                        .insert(name.to_string(), item);
                 }
             }
         }
 
-        let (resolve, _) = decoder.finish(package);
+        let (resolve, _) = decoder.finish(Package {
+            name: name.to_string(),
+            documents: [("root".to_string(), doc)].into_iter().collect(),
+            url: None,
+        });
         Ok((resolve, world))
     }
 }
@@ -207,7 +295,10 @@ impl DecodedWasm {
     pub fn package(&self) -> PackageId {
         match self {
             DecodedWasm::WitPackage(_, id) => *id,
-            DecodedWasm::Component(resolve, world) => resolve.worlds[*world].package.unwrap(),
+            DecodedWasm::Component(resolve, world) => {
+                let doc = resolve.worlds[*world].document;
+                resolve.documents[doc].package.unwrap()
+            }
         }
     }
 }
@@ -218,14 +309,14 @@ impl DecodedWasm {
 /// The WebAssembly binary provided here can either be a
 /// WIT-package-encoded-as-binary or an actual component itself. A [`Resolve`]
 /// is always created and the return value indicates which was detected.
-pub fn decode(bytes: &[u8]) -> Result<DecodedWasm> {
+pub fn decode(name: &str, bytes: &[u8]) -> Result<DecodedWasm> {
     let info = ComponentInfo::new(bytes)?;
 
     if info.is_wit_package() {
-        let (resolve, pkg) = info.decode_wit_package()?;
+        let (resolve, pkg) = info.decode_wit_package(name)?;
         Ok(DecodedWasm::WitPackage(resolve, pkg))
     } else {
-        let (resolve, world) = info.decode_component()?;
+        let (resolve, world) = info.decode_component(name)?;
         Ok(DecodedWasm::Component(resolve, world))
     }
 }
@@ -233,187 +324,106 @@ pub fn decode(bytes: &[u8]) -> Result<DecodedWasm> {
 struct WitPackageDecoder<'a> {
     resolve: Resolve,
     info: &'a ComponentInfo<'a>,
-    foreign_packages: IndexMap<String, Package>,
-    iface_to_package_index: HashMap<InterfaceId, usize>,
-    named_interfaces: HashMap<String, InterfaceId>,
-
-    /// A map which tracks named resources to what their corresponding `TypeId`
-    /// is. This first layer of key in this map is the owner scope of a
-    /// resource, more-or-less the `world` or `interface` that it's defined
-    /// within. The second layer of this map is keyed by name of the resource
-    /// and points to the actual ID of the resource.
-    ///
-    /// This map is populated in `register_type_export`.
-    resources: HashMap<TypeOwner, HashMap<String, TypeId>>,
+    url_to_package: IndexMap<Url, Package>,
+    url_to_interface: HashMap<Url, InterfaceId>,
 
     /// A map from a type id to what it's been translated to.
     type_map: HashMap<types::TypeId, TypeId>,
 }
 
 impl WitPackageDecoder<'_> {
-    fn decode_package(&mut self, name: &KebabName, ty: &types::ComponentType) -> Result<Package> {
-        // Process all imports for this package first, where imports are
-        // importing from remote packages.
-        for (name, ty) in ty.imports.iter() {
+    fn decode_document(&mut self, name: &str, ty: &types::ComponentType) -> Result<DocumentId> {
+        // Process all imports for this document first, where imports are either
+        // importing interfaces from previously defined documents or from remote
+        // packages. Note that the URL must be specified here for these
+        // reconstruction purposes.
+        for (name, (url, ty)) in ty.imports.iter() {
+            let url = match url {
+                Some(url) => url,
+                None => bail!("no url specified for import `{name}`"),
+            };
             let ty = match ty {
                 types::ComponentEntityType::Instance(idx) => {
-                    self.info.types[*idx].unwrap_component_instance()
+                    match self.info.types.type_from_id(*idx) {
+                        Some(types::Type::ComponentInstance(ty)) => ty,
+                        _ => unreachable!(),
+                    }
                 }
                 _ => bail!("import `{name}` is not an instance"),
             };
-            self.register_import(name, ty)
+            self.register_import(url, ty)
                 .with_context(|| format!("failed to process import `{name}`"))?;
         }
 
-        let mut package = Package {
-            // The name encoded for packages must be of the form `foo:bar/wit`
-            // where "wit" is just a placeholder for now. The package name in
-            // this case would be `foo:bar`.
-            name: match name.kind() {
-                KebabNameKind::Id {
-                    namespace,
-                    package,
-                    version,
-                    interface,
-                } if interface.as_str() == "wit" => PackageName {
-                    namespace: namespace.to_string(),
-                    name: package.to_string(),
-                    version,
-                },
-                _ => bail!("package name is not a valid id: {name}"),
-            },
-            interfaces: Default::default(),
-            worlds: Default::default(),
-        };
+        let doc = self.resolve.documents.alloc(Document {
+            name: name.to_string(),
+            interfaces: IndexMap::new(),
+            worlds: IndexMap::new(),
+            default_interface: None,
+            default_world: None,
+            package: None,
+        });
 
-        for (name, ty) in ty.exports.iter() {
+        for (name, (url, ty)) in ty.exports.iter() {
             match ty {
                 types::ComponentEntityType::Instance(idx) => {
-                    let ty = self.info.types[*idx].unwrap_component_instance();
-                    self.register_interface(name.as_str(), ty, &mut package)
+                    let ty = match self.info.types.type_from_id(*idx) {
+                        Some(types::Type::ComponentInstance(ty)) => ty,
+                        _ => unreachable!(),
+                    };
+                    let id = self
+                        .register_interface(doc, Some(name), ty)
                         .with_context(|| format!("failed to process export `{name}`"))?;
+                    let prev = self.resolve.documents[doc]
+                        .interfaces
+                        .insert(name.to_string(), id);
+                    assert!(prev.is_none());
+                    if let Some(url) = url {
+                        let prev = self.url_to_interface.insert(url.clone(), id);
+                        assert!(prev.is_none());
+                    }
                 }
                 types::ComponentEntityType::Component(idx) => {
-                    let ty = self.info.types[*idx].unwrap_component();
-                    self.register_world(name.as_str(), ty, &mut package)
+                    let ty = match self.info.types.type_from_id(*idx) {
+                        Some(types::Type::Component(ty)) => ty,
+                        _ => unreachable!(),
+                    };
+                    let id = self
+                        .register_world(doc, name, ty)
                         .with_context(|| format!("failed to process export `{name}`"))?;
+                    let prev = self.resolve.documents[doc]
+                        .worlds
+                        .insert(name.to_string(), id);
+                    assert!(prev.is_none());
                 }
                 _ => bail!("component export `{name}` is not an instance or component"),
             }
         }
-        Ok(package)
-    }
-
-    fn decode_component_import(
-        &mut self,
-        import: &ComponentImport<'_>,
-        world: WorldId,
-        package: &mut Package,
-    ) -> Result<()> {
-        let name = import.name.as_str();
-        let ty = self
-            .info
-            .types
-            .component_entity_type_of_import(import.name.as_str())
-            .unwrap();
-        let owner = TypeOwner::World(world);
-        let (name, item) = match ty {
-            types::ComponentEntityType::Instance(i) => {
-                let ty = self.info.types[i].unwrap_component_instance();
-                let (name, id) = if name.contains('/') {
-                    let id = self.register_import(name, ty)?;
-                    (WorldKey::Interface(id), id)
-                } else {
-                    self.register_interface(name, ty, package)
-                        .with_context(|| format!("failed to decode WIT from import `{name}`"))?
-                };
-                (name, WorldItem::Interface(id))
-            }
-            types::ComponentEntityType::Func(i) => {
-                let ty = self.info.types[i].unwrap_component_func();
-                let func = self
-                    .convert_function(name, ty, owner)
-                    .with_context(|| format!("failed to decode function from import `{name}`"))?;
-                (WorldKey::Name(name.to_string()), WorldItem::Function(func))
-            }
-            types::ComponentEntityType::Type {
-                referenced,
-                created,
-            } => {
-                let id = self
-                    .register_type_export(name, owner, referenced, created)
-                    .with_context(|| format!("failed to decode type from export `{name}`"))?;
-                (WorldKey::Name(name.to_string()), WorldItem::Type(id))
-            }
-            // All other imports do not form part of the component's world
-            _ => return Ok(()),
-        };
-        self.resolve.worlds[world].imports.insert(name, item);
-        Ok(())
-    }
-
-    fn decode_component_export(
-        &mut self,
-        export: &ComponentExport<'_>,
-        world: WorldId,
-        package: &mut Package,
-    ) -> Result<()> {
-        let name = export.name.as_str();
-        let types = &self.info.types;
-        let ty = types.component_entity_type_of_export(name).unwrap();
-        let (name, item) = match ty {
-            types::ComponentEntityType::Func(i) => {
-                let ty = types[i].unwrap_component_func();
-                let func = self
-                    .convert_function(name, ty, TypeOwner::World(world))
-                    .with_context(|| format!("failed to decode function from export `{name}`"))?;
-
-                (WorldKey::Name(name.to_string()), WorldItem::Function(func))
-            }
-            types::ComponentEntityType::Instance(i) => {
-                let ty = types[i].unwrap_component_instance();
-                let (name, id) = if name.contains('/') {
-                    let id = self.register_import(name, ty)?;
-                    (WorldKey::Interface(id), id)
-                } else {
-                    self.register_interface(name, ty, package)
-                        .with_context(|| format!("failed to decode WIT from export `{name}`"))?
-                };
-                (name, WorldItem::Interface(id))
-            }
-            _ => {
-                bail!("component export `{name}` was not a function or instance")
-            }
-        };
-        self.resolve.worlds[world].exports.insert(name, item);
-        Ok(())
+        Ok(doc)
     }
 
-    /// Registers that the `name` provided is either imported interface from a
-    /// foreign package or  referencing a previously defined interface in this
-    /// package.
-    ///
-    /// This function will internally ensure that `name` is well-structured and
-    /// will fill in any information as necessary. For example with a foreign
-    /// dependency the foreign package structure, types, etc, all need to be
-    /// created. For a local dependency it's instead ensured that all the types
-    /// line up with the previous definitions.
     fn register_import(
         &mut self,
-        name: &str,
+        url: &Url,
         ty: &types::ComponentInstanceType,
     ) -> Result<InterfaceId> {
-        let (is_local, interface) = match self.named_interfaces.get(name) {
-            Some(id) => (true, *id),
-            None => (false, self.extract_dep_interface(name)?),
-        };
-        let owner = TypeOwner::Interface(interface);
-        for (name, ty) in ty.exports.iter() {
-            match *ty {
+        let interface = self.extract_url_interface(url)?;
+
+        for (name, export_url, ty) in ty.exports(self.info.types.as_ref()) {
+            if export_url.is_some() {
+                bail!("instance type export `{name}` should not have a url")
+            }
+
+            match ty {
                 types::ComponentEntityType::Type {
                     referenced,
                     created,
                 } => {
+                    let def = match self.info.types.type_from_id(referenced) {
+                        Some(types::Type::Defined(ty)) => ty,
+                        _ => unreachable!(),
+                    };
+
                     match self.resolve.interfaces[interface]
                         .types
                         .get(name.as_str())
@@ -437,11 +447,7 @@ impl WitPackageDecoder<'_> {
                         // is not strictly necessary but assists with
                         // roundtripping assertions during fuzzing.
                         Some(id) => {
-                            match &self.info.types[referenced] {
-                                types::Type::Defined(ty) => self.register_defined(id, ty)?,
-                                types::Type::Resource(_) => {}
-                                _ => unreachable!(),
-                            }
+                            self.register_defined(id, def)?;
                             let prev = self.type_map.insert(created, id);
                             assert!(prev.is_none());
                         }
@@ -460,12 +466,12 @@ impl WitPackageDecoder<'_> {
                         //   slice needed for this resolve, which is what's
                         //   intended.
                         None => {
-                            if is_local {
+                            if url.scheme() == "pkg" {
                                 bail!("instance type export `{name}` not defined in interface");
                             }
                             let id = self.register_type_export(
-                                name.as_str(),
-                                owner,
+                                name,
+                                TypeOwner::Interface(interface),
                                 referenced,
                                 created,
                             )?;
@@ -481,7 +487,10 @@ impl WitPackageDecoder<'_> {
                 // functions for remote dependencies and otherwise assert
                 // they're already defined for local dependencies.
                 types::ComponentEntityType::Func(ty) => {
-                    let def = self.info.types[ty].unwrap_component_func();
+                    let def = match self.info.types.type_from_id(ty) {
+                        Some(types::Type::ComponentFunc(ty)) => ty,
+                        _ => unreachable!(),
+                    };
                     if self.resolve.interfaces[interface]
                         .functions
                         .contains_key(name.as_str())
@@ -490,10 +499,10 @@ impl WitPackageDecoder<'_> {
                         // match.
                         continue;
                     }
-                    if is_local {
+                    if url.scheme() == "pkg" {
                         bail!("instance function export `{name}` not defined in interface");
                     }
-                    let func = self.convert_function(name.as_str(), def, owner)?;
+                    let func = self.convert_function(name, def)?;
                     let prev = self.resolve.interfaces[interface]
                         .functions
                         .insert(name.to_string(), func);
@@ -526,39 +535,69 @@ impl WitPackageDecoder<'_> {
         prev
     }
 
-    /// This will parse the `name_string` as a component model ID string and
-    /// ensure that there's an `InterfaceId` corresponding to its components.
-    fn extract_dep_interface(&mut self, name_string: &str) -> Result<InterfaceId> {
-        let import_name = if name_string.contains('/') {
-            ComponentExternName::Interface(name_string)
+    fn extract_url_interface(&mut self, url: &Url) -> Result<InterfaceId> {
+        Ok(if url.scheme() == "pkg" {
+            self.url_to_interface
+                .get(url)
+                .copied()
+                .ok_or_else(|| anyhow!("no previously defined interface with url: {url}"))?
         } else {
-            ComponentExternName::Kebab(name_string)
-        };
-        let name = KebabName::new(import_name, 0).unwrap();
-        let (namespace, name, version, interface) = match name.kind() {
-            KebabNameKind::Id {
-                namespace,
-                package,
-                version,
-                interface,
-            } => (namespace, package, version, interface),
-            _ => bail!("package name is not a valid id: {name_string}"),
-        };
-        let package_name = PackageName {
-            name: name.to_string(),
-            namespace: namespace.to_string(),
-            version,
-        };
-        // Lazily create a `Package` as necessary, along with the interface.
+            self.extract_dep_interface(url)
+                .with_context(|| format!("failed to parse url: {url}"))?
+        })
+    }
+
+    /// TODO: Ideally this function should not need to exist.
+    ///
+    /// This function parses the `url` provided and requires it to have a
+    /// particular structure. That's not really great, however, since otherwise
+    /// there's no need to impose structure on the url field of imports/exports.
+    ///
+    /// Note that this is only used for foreign dependencies of which the binary
+    /// encoding does not currently reflect the package/document/interface
+    /// organization. Instead foreign dependencies simply have their interfaces
+    /// imported, and from this interface import we need to somehow translate
+    /// back into a package/document structure as well.
+    ///
+    /// Resolving this may require changing the binary format for components, or
+    /// otherwise encoding more pieces into the binary encoding of a WIT
+    /// document. In any case this is "good enough" for now hopefully.
+    fn extract_dep_interface(&mut self, url: &Url) -> Result<InterfaceId> {
+        // Extract the interface and the document from the url
+        let mut segments = url.path_segments().ok_or_else(|| anyhow!("invalid url"))?;
+        let interface = segments.next_back().ok_or_else(|| anyhow!("invalid url"))?;
+        let document = segments.next_back().ok_or_else(|| anyhow!("invalid url"))?;
+        let package_name = segments.next_back().ok_or_else(|| anyhow!("invalid url"))?;
+
+        // Then drop the two path segments from the url as a key to lookup the
+        // dependency package by url.
+        let mut url = url.clone();
+        url.path_segments_mut().unwrap().pop().pop();
+
+        // Lazily create a `Package` as necessary, along with the document and
+        // interface.
         let package = self
-            .foreign_packages
-            .entry(package_name.to_string())
+            .url_to_package
+            .entry(url.clone())
             .or_insert_with(|| Package {
-                name: package_name.clone(),
-                interfaces: Default::default(),
-                worlds: Default::default(),
+                name: package_name.to_string(),
+                documents: Default::default(),
+                url: Some(url.to_string()),
+            });
+        let doc = *package
+            .documents
+            .entry(document.to_string())
+            .or_insert_with(|| {
+                self.resolve.documents.alloc(Document {
+                    name: document.to_string(),
+                    interfaces: IndexMap::new(),
+                    worlds: IndexMap::new(),
+                    default_interface: None,
+                    default_world: None,
+                    package: None,
+                })
             });
-        let interface = *package
+        let interface = *self.resolve.documents[doc]
             .interfaces
             .entry(interface.to_string())
             .or_insert_with(|| {
@@ -567,120 +606,59 @@ impl WitPackageDecoder<'_> {
                     docs: Default::default(),
                     types: IndexMap::default(),
                     functions: IndexMap::new(),
-                    package: None,
+                    document: doc,
                 })
             });
-
-        // Record a mapping of which foreign package this interface belongs to
-        self.iface_to_package_index.insert(
-            interface,
-            self.foreign_packages
-                .get_full(&package_name.to_string())
-                .unwrap()
-                .0,
-        );
         Ok(interface)
     }
 
-    /// A general-purpose helper function to translate a component instance
-    /// into a WIT interface.
-    ///
-    /// This is one of the main workhorses of this module. This handles
-    /// interfaces both at the type level, for concrete components, and
-    /// internally within worlds as well.
-    ///
-    /// The `name` provided is the contextual ID or name of the interface. This
-    /// could be a kebab-name in the case of a world import or export or it can
-    /// also be an ID. This is used to guide insertion into various maps.
-    ///
-    /// The `ty` provided is the actual component type being decoded.
-    ///
-    /// The `package` is where to insert the final interface if `name` is an ID
-    /// meaning it's registered as a named standalone item within the package.
     fn register_interface(
         &mut self,
-        name: &str,
+        doc: DocumentId,
+        name: Option<&str>,
         ty: &types::ComponentInstanceType,
-        package: &mut Package,
-    ) -> Result<(WorldKey, InterfaceId)> {
-        // If this interface's name is already known then that means this is an
-        // interface that's both imported and exported.  Use `register_import`
-        // to draw connections between types and this interface's types.
-        if self.named_interfaces.contains_key(name) {
-            let id = self.register_import(name, ty)?;
-            return Ok((WorldKey::Interface(id), id));
-        }
-
-        // If this is a bare kebab-name for an interface then the interface's
-        // listed name is `None` and the name goes out through the key.
-        // Otherwise this name is extracted from `name` interpreted as an ID.
-        let interface_name = self.extract_interface_name_from_kebab_name(name)?;
-
+    ) -> Result<InterfaceId> {
         let mut interface = Interface {
-            name: interface_name.clone(),
+            name: name.map(|n| n.to_string()),
             docs: Default::default(),
             types: IndexMap::default(),
             functions: IndexMap::new(),
-            package: None,
+            document: doc,
         };
 
-        let owner = TypeOwner::Interface(self.resolve.interfaces.next_id());
-        for (name, ty) in ty.exports.iter() {
-            match *ty {
+        for (name, export_url, ty) in ty.exports(self.info.types.as_ref()) {
+            if export_url.is_some() {
+                bail!("instance type export `{name}` should not have a url")
+            }
+
+            match ty {
                 types::ComponentEntityType::Type {
                     referenced,
                     created,
                 } => {
-                    let ty = self
-                        .register_type_export(name.as_str(), owner, referenced, created)
-                        .with_context(|| format!("failed to register type export '{name}'"))?;
+                    let ty = self.register_type_export(
+                        name,
+                        TypeOwner::Interface(self.resolve.interfaces.next_id()),
+                        referenced,
+                        created,
+                    )?;
                     let prev = interface.types.insert(name.to_string(), ty);
                     assert!(prev.is_none());
                 }
 
                 types::ComponentEntityType::Func(ty) => {
-                    let ty = self.info.types[ty].unwrap_component_func();
-                    let func = self
-                        .convert_function(name.as_str(), ty, owner)
-                        .with_context(|| format!("failed to convert function '{name}'"))?;
+                    let ty = match self.info.types.type_from_id(ty) {
+                        Some(types::Type::ComponentFunc(ty)) => ty,
+                        _ => unreachable!(),
+                    };
+                    let func = self.convert_function(&name, ty)?;
                     let prev = interface.functions.insert(name.to_string(), func);
                     assert!(prev.is_none());
                 }
                 _ => bail!("instance type export `{name}` is not a type or function"),
             };
         }
-        let id = self.resolve.interfaces.alloc(interface);
-        let key = match interface_name {
-            // If this interface is named then it's part of the package, so
-            // insert it. Additionally register it in `named_interfaces` so
-            // further use comes back to this original definition.
-            Some(interface_name) => {
-                let prev = package.interfaces.insert(interface_name, id);
-                assert!(prev.is_none(), "duplicate interface added for {name:?}");
-                let prev = self.named_interfaces.insert(name.to_string(), id);
-                assert!(prev.is_none());
-                WorldKey::Interface(id)
-            }
-
-            // If this interface isn't named then its key is always a
-            // kebab-name.
-            None => WorldKey::Name(name.to_string()),
-        };
-        Ok((key, id))
-    }
-
-    fn extract_interface_name_from_kebab_name(&self, name: &str) -> Result<Option<String>> {
-        let import_name = if name.contains('/') {
-            ComponentExternName::Interface(name)
-        } else {
-            ComponentExternName::Kebab(name)
-        };
-        let kebab_name = KebabName::new(import_name, 0);
-        match kebab_name.as_ref().map(|k| k.kind()) {
-            Ok(KebabNameKind::Id { interface, .. }) => Ok(Some(interface.to_string())),
-            Ok(KebabNameKind::Normal(_name)) => Ok(None),
-            _ => bail!("cannot extract item name from: {name}"),
-        }
+        Ok(self.resolve.interfaces.alloc(interface))
     }
 
     fn register_type_export(
@@ -690,6 +668,10 @@ impl WitPackageDecoder<'_> {
         referenced: types::TypeId,
         created: types::TypeId,
     ) -> Result<TypeId> {
+        let ty = match self.info.types.type_from_id(referenced) {
+            Some(types::Type::Defined(ty)) => ty,
+            _ => unreachable!(),
+        };
         let kind = match self.find_alias(referenced) {
             // If this `TypeId` points to a type which has
             // previously been defined, meaning we're aliasing a
@@ -698,13 +680,7 @@ impl WitPackageDecoder<'_> {
 
             // ... or this `TypeId`'s source definition has never
             // been seen before, so declare the full type.
-            None => match &self.info.types[referenced] {
-                types::Type::Defined(ty) => self
-                    .convert_defined(ty)
-                    .context("failed to convert unaliased type")?,
-                types::Type::Resource(_) => TypeDefKind::Resource,
-                _ => unreachable!(),
-            },
+            None => self.convert_defined(ty)?,
         };
         let ty = self.resolve.types.alloc(TypeDef {
             name: Some(name.to_string()),
@@ -713,18 +689,6 @@ impl WitPackageDecoder<'_> {
             owner,
         });
 
-        // If this is a resource then doubly-register it in `self.resources` so
-        // the ID allocated here can be looked up via name later on during
-        // `convert_function`.
-        if let TypeDefKind::Resource = self.resolve.types[ty].kind {
-            let prev = self
-                .resources
-                .entry(owner)
-                .or_insert(HashMap::new())
-                .insert(name.to_string(), ty);
-            assert!(prev.is_none());
-        }
-
         let prev = self.type_map.insert(created, ty);
         assert!(prev.is_none());
         Ok(ty)
@@ -732,114 +696,108 @@ impl WitPackageDecoder<'_> {
 
     fn register_world(
         &mut self,
+        document: DocumentId,
         name: &str,
         ty: &types::ComponentType,
-        package: &mut Package,
     ) -> Result<WorldId> {
-        let name = self
-            .extract_interface_name_from_kebab_name(name)?
-            .context("expected world name to have an ID form")?;
         let mut world = World {
-            name: name.clone(),
+            name: name.to_string(),
             docs: Default::default(),
             imports: Default::default(),
             exports: Default::default(),
-            includes: Default::default(),
-            include_names: Default::default(),
-            package: None,
+            document,
         };
 
-        let owner = TypeOwner::World(self.resolve.worlds.next_id());
-        for (name, ty) in ty.imports.iter() {
-            let (name, item) = match ty {
+        for (name, (url, ty)) in ty.imports.iter() {
+            let item = match ty {
                 types::ComponentEntityType::Instance(idx) => {
-                    let ty = self.info.types[*idx].unwrap_component_instance();
-                    let (name, id) = if name.contains('/') {
-                        // If a name is an interface import then it is either to
-                        // a package-local or foreign interface, and both
+                    let ty = match self.info.types.type_from_id(*idx) {
+                        Some(types::Type::ComponentInstance(ty)) => ty,
+                        _ => unreachable!(),
+                    };
+                    let id = match url {
+                        // If a URL is specified then the import is either to a
+                        // package-local or foreign interface, and both
                         // situations are handled in `register_import`.
-                        let id = self.register_import(name, ty)?;
-                        (WorldKey::Interface(id), id)
-                    } else {
-                        // A plain kebab-name indicates an inline interface that
+                        Some(url) => self.register_import(url, ty)?,
+
+                        // Without a URL this indicates an inline interface that
                         // wasn't declared explicitly elsewhere with a name, and
                         // `register_interface` will create a new `Interface`
                         // with no name.
-                        self.register_interface(name, ty, package)?
+                        None => self.register_interface(document, None, ty)?,
                     };
-                    (name, WorldItem::Interface(id))
+                    WorldItem::Interface(id)
                 }
                 types::ComponentEntityType::Type {
                     created,
                     referenced,
                 } => {
-                    let ty =
-                        self.register_type_export(name.as_str(), owner, *referenced, *created)?;
-                    (WorldKey::Name(name.to_string()), WorldItem::Type(ty))
+                    let ty = self.register_type_export(
+                        name,
+                        TypeOwner::World(self.resolve.worlds.next_id()),
+                        *referenced,
+                        *created,
+                    )?;
+                    WorldItem::Type(ty)
                 }
                 types::ComponentEntityType::Func(idx) => {
-                    let ty = self.info.types[*idx].unwrap_component_func();
-                    let func = self.convert_function(name.as_str(), ty, owner)?;
-                    (WorldKey::Name(name.to_string()), WorldItem::Function(func))
+                    let ty = match self.info.types.type_from_id(*idx) {
+                        Some(types::Type::ComponentFunc(ty)) => ty,
+                        _ => unreachable!(),
+                    };
+                    let func = self.convert_function(name, ty)?;
+                    WorldItem::Function(func)
                 }
                 _ => bail!("component import `{name}` is not an instance, func, or type"),
             };
-            world.imports.insert(name, item);
+            world.imports.insert(name.to_string(), item);
         }
 
-        for (name, ty) in ty.exports.iter() {
-            let (name, item) = match ty {
+        for (name, (url, ty)) in ty.exports.iter() {
+            let item = match ty {
                 types::ComponentEntityType::Instance(idx) => {
-                    let ty = self.info.types[*idx].unwrap_component_instance();
-                    let (name, id) = if name.contains('/') {
+                    let ty = match self.info.types.type_from_id(*idx) {
+                        Some(types::Type::ComponentInstance(ty)) => ty,
+                        _ => unreachable!(),
+                    };
+                    let id = match url {
                         // Note that despite this being an export this is
                         // calling `register_import`. With a URL this interface
                         // must have been previously defined so this will
                         // trigger the logic of either filling in a remotely
                         // defined interface or connecting items to local
                         // definitions of our own interface.
-                        let id = self.register_import(name, ty)?;
-                        (WorldKey::Interface(id), id)
-                    } else {
-                        self.register_interface(name, ty, package)?
+                        Some(url) => self.register_import(url, ty)?,
+                        None => self.register_interface(document, None, ty)?,
                     };
-                    (name, WorldItem::Interface(id))
+                    WorldItem::Interface(id)
                 }
 
                 types::ComponentEntityType::Func(idx) => {
-                    let ty = self.info.types[*idx].unwrap_component_func();
-                    let func = self.convert_function(name.as_str(), ty, owner)?;
-                    (WorldKey::Name(name.to_string()), WorldItem::Function(func))
+                    let ty = match self.info.types.type_from_id(*idx) {
+                        Some(types::Type::ComponentFunc(ty)) => ty,
+                        _ => unreachable!(),
+                    };
+                    let func = self.convert_function(name, ty)?;
+                    WorldItem::Function(func)
                 }
 
                 _ => bail!("component export `{name}` is not an instance or function"),
             };
-            world.exports.insert(name, item);
+            world.exports.insert(name.to_string(), item);
         }
-        let id = self.resolve.worlds.alloc(world);
-        let prev = package.worlds.insert(name, id);
-        assert!(prev.is_none());
-        Ok(id)
+        Ok(self.resolve.worlds.alloc(world))
     }
 
-    fn convert_function(
-        &mut self,
-        name: &str,
-        ty: &types::ComponentFuncType,
-        owner: TypeOwner,
-    ) -> Result<Function> {
-        let name = KebabName::new(ComponentExternName::Kebab(name), 0).unwrap();
+    fn convert_function(&mut self, name: &str, ty: &types::ComponentFuncType) -> Result<Function> {
         let params = ty
             .params
             .iter()
             .map(|(name, ty)| Ok((name.to_string(), self.convert_valtype(ty)?)))
-            .collect::<Result<Vec<_>>>()
-            .context("failed to convert params")?;
+            .collect::<Result<Vec<_>>>()?;
         let results = if ty.results.len() == 1 && ty.results[0].0.is_none() {
-            Results::Anon(
-                self.convert_valtype(&ty.results[0].1)
-                    .context("failed to convert anonymous result type")?,
-            )
+            Results::Anon(self.convert_valtype(&ty.results[0].1)?)
         } else {
             Results::Named(
                 ty.results
@@ -850,32 +808,12 @@ impl WitPackageDecoder<'_> {
                             self.convert_valtype(ty)?,
                         ))
                     })
-                    .collect::<Result<Vec<_>>>()
-                    .context("failed to convert named result types")?,
+                    .collect::<Result<Vec<_>>>()?,
             )
         };
         Ok(Function {
             docs: Default::default(),
-            kind: match name.kind() {
-                KebabNameKind::Normal(_) => FunctionKind::Freestanding,
-                KebabNameKind::Constructor(resource) => {
-                    FunctionKind::Constructor(self.resources[&owner][resource.as_str()])
-                }
-                KebabNameKind::Method { resource, .. } => {
-                    FunctionKind::Method(self.resources[&owner][resource.as_str()])
-                }
-                KebabNameKind::Static { resource, .. } => {
-                    FunctionKind::Static(self.resources[&owner][resource.as_str()])
-                }
-
-                // Functions shouldn't have ID-based names at this time.
-                KebabNameKind::Id { .. } => unreachable!(),
-            },
-
-            // Note that this name includes "name mangling" such as
-            // `[method]foo.bar` which is intentional. The `FunctionKind`
-            // discriminant calculated above indicates how to interpret this
-            // name.
+            kind: FunctionKind::Freestanding,
             name: name.to_string(),
             params,
             results,
@@ -898,25 +836,26 @@ impl WitPackageDecoder<'_> {
         // errors on those types, but eventually the `bail!` here  is
         // more-or-less unreachable due to expected validation to be added to
         // the component model binary format itself.
-        let def = self.info.types[id].unwrap_defined();
+        let def = match self.info.types.type_from_id(id) {
+            Some(types::Type::Defined(ty)) => ty,
+            _ => unreachable!(),
+        };
         let kind = self.convert_defined(def)?;
         match &kind {
             TypeDefKind::Type(_)
             | TypeDefKind::List(_)
             | TypeDefKind::Tuple(_)
             | TypeDefKind::Option(_)
-            | TypeDefKind::Result(_)
-            | TypeDefKind::Handle(_) => {}
+            | TypeDefKind::Result(_) => {}
 
-            TypeDefKind::Resource
-            | TypeDefKind::Record(_)
+            TypeDefKind::Record(_)
             | TypeDefKind::Enum(_)
             | TypeDefKind::Variant(_)
             | TypeDefKind::Union(_)
             | TypeDefKind::Flags(_)
             | TypeDefKind::Future(_)
             | TypeDefKind::Stream(_) => {
-                bail!("unexpected unnamed type of kind '{}'", kind.as_str());
+                bail!("unexpected unnamed type");
             }
             TypeDefKind::Unknown => unreachable!(),
         }
@@ -978,9 +917,7 @@ impl WitPackageDecoder<'_> {
                     .map(|(name, ty)| {
                         Ok(Field {
                             name: name.to_string(),
-                            ty: self.convert_valtype(ty).with_context(|| {
-                                format!("failed to convert record field '{name}'")
-                            })?,
+                            ty: self.convert_valtype(ty)?,
                             docs: Default::default(),
                         })
                     })
@@ -1045,16 +982,6 @@ impl WitPackageDecoder<'_> {
                     .collect();
                 Ok(TypeDefKind::Enum(Enum { cases }))
             }
-
-            types::ComponentDefinedType::Own(id) => {
-                let id = self.type_map[id];
-                Ok(TypeDefKind::Handle(Handle::Own(id)))
-            }
-
-            types::ComponentDefinedType::Borrow(id) => {
-                let id = self.type_map[id];
-                Ok(TypeDefKind::Handle(Handle::Borrow(id)))
-            }
         }
     }
 
@@ -1090,22 +1017,32 @@ impl WitPackageDecoder<'_> {
     ///
     /// Takes the root package as an argument to insert.
     fn finish(mut self, package: Package) -> (Resolve, PackageId) {
-        // Build a topological ordering is then calculated by visiting all the
-        // transitive dependencies of packages.
+        // First build a map from all documents to what index their package
+        // resides at in the `url_to_package` array.
+        let mut doc_to_package_index = HashMap::new();
+        for (i, (_url, pkg)) in self.url_to_package.iter().enumerate() {
+            for (_, doc) in pkg.documents.iter() {
+                let prev = doc_to_package_index.insert(*doc, i);
+                assert!(prev.is_none());
+            }
+        }
+
+        // Using the above map a topological ordering is then calculated by
+        // visiting all the transitive dependencies of packages.
         let mut order = IndexSet::new();
-        for i in 0..self.foreign_packages.len() {
-            self.visit_package(i, &mut order);
+        for i in 0..self.url_to_package.len() {
+            self.visit_package(&doc_to_package_index, i, &mut order);
         }
 
         // Using the topological ordering create a temporary map from
-        // index-in-`foreign_packages` to index-in-`order`
-        let mut idx_to_pos = vec![0; self.foreign_packages.len()];
+        // index-in-`url_to_package` to index-in-`order`
+        let mut idx_to_pos = vec![0; self.url_to_package.len()];
         for (pos, idx) in order.iter().enumerate() {
             idx_to_pos[*idx] = pos;
         }
-        // .. and then using `idx_to_pos` sort the `foreign_packages` array based
+        // .. and then using `idx_to_pos` sort the `url_to_package` array based
         // on the position it's at in the topological ordering
-        let mut deps = mem::take(&mut self.foreign_packages)
+        let mut deps = mem::take(&mut self.url_to_package)
             .into_iter()
             .enumerate()
             .collect::<Vec<_>>();
@@ -1118,68 +1055,58 @@ impl WitPackageDecoder<'_> {
         }
 
         let id = self.insert_package(package);
-        assert!(self.resolve.worlds.iter().all(|(_, w)| w.package.is_some()));
-        assert!(self
-            .resolve
-            .interfaces
-            .iter()
-            .all(|(_, i)| i.package.is_some()));
         (self.resolve, id)
     }
 
     fn insert_package(&mut self, package: Package) -> PackageId {
-        let name = package.name.clone();
         let id = self.resolve.packages.alloc(package);
-        let prev = self.resolve.package_names.insert(name, id);
-        assert!(prev.is_none());
-        for (_, iface) in self.resolve.packages[id].interfaces.iter() {
-            self.resolve.interfaces[*iface].package = Some(id);
-        }
-        for (_, world) in self.resolve.packages[id].worlds.iter() {
-            self.resolve.worlds[*world].package = Some(id);
-            let world = &self.resolve.worlds[*world];
-            for (name, item) in world.imports.iter().chain(world.exports.iter()) {
-                if let WorldKey::Name(_) = name {
-                    if let WorldItem::Interface(iface) = item {
-                        self.resolve.interfaces[*iface].package = Some(id);
-                    }
-                }
-            }
+        for (_, doc) in self.resolve.packages[id].documents.iter() {
+            self.resolve.documents[*doc].package = Some(id);
         }
         id
     }
 
-    fn visit_package(&self, idx: usize, order: &mut IndexSet<usize>) {
+    fn visit_package(
+        &self,
+        doc_to_package_index: &HashMap<DocumentId, usize>,
+        idx: usize,
+        order: &mut IndexSet<usize>,
+    ) {
         if order.contains(&idx) {
             return;
         }
 
-        let (_name, pkg) = self.foreign_packages.get_index(idx).unwrap();
-        let interfaces = pkg.interfaces.values().copied().chain(
-            pkg.worlds
-                .values()
-                .flat_map(|w| {
-                    let world = &self.resolve.worlds[*w];
-                    world.imports.values().chain(world.exports.values())
-                })
-                .filter_map(|item| match item {
-                    WorldItem::Interface(id) => Some(*id),
-                    WorldItem::Function(_) | WorldItem::Type(_) => None,
-                }),
-        );
-        for iface in interfaces {
-            for ty in self.resolve.interfaces[iface].types.values() {
-                let id = match self.resolve.types[*ty].kind {
-                    TypeDefKind::Type(Type::Id(id)) => id,
-                    _ => continue,
-                };
-                let owner = match self.resolve.types[id].owner {
-                    TypeOwner::Interface(i) => i,
-                    _ => continue,
-                };
-                let owner_idx = self.iface_to_package_index[&owner];
-                if owner_idx != idx {
-                    self.visit_package(owner_idx, order);
+        let (_url, pkg) = self.url_to_package.get_index(idx).unwrap();
+        for (_, id) in pkg.documents.iter() {
+            let doc = &self.resolve.documents[*id];
+
+            let interfaces = doc.interfaces.values().copied().chain(
+                doc.worlds
+                    .values()
+                    .flat_map(|w| {
+                        let world = &self.resolve.worlds[*w];
+                        world.imports.values().chain(world.exports.values())
+                    })
+                    .filter_map(|item| match item {
+                        WorldItem::Interface(id) => Some(*id),
+                        WorldItem::Function(_) | WorldItem::Type(_) => None,
+                    }),
+            );
+            for iface in interfaces {
+                for ty in self.resolve.interfaces[iface].types.values() {
+                    let id = match self.resolve.types[*ty].kind {
+                        TypeDefKind::Type(Type::Id(id)) => id,
+                        _ => continue,
+                    };
+                    let owner = match self.resolve.types[id].owner {
+                        TypeOwner::Interface(i) => i,
+                        _ => continue,
+                    };
+                    let doc = self.resolve.interfaces[owner].document;
+                    let owner_idx = doc_to_package_index[&doc];
+                    if owner_idx != idx {
+                        self.visit_package(doc_to_package_index, owner_idx, order);
+                    }
                 }
             }
         }
@@ -1318,10 +1245,8 @@ impl Registrar<'_> {
             }
 
             // These have no recursive structure so they can bail out.
-            types::ComponentDefinedType::Flags(_)
-            | types::ComponentDefinedType::Enum(_)
-            | types::ComponentDefinedType::Own(_)
-            | types::ComponentDefinedType::Borrow(_) => Ok(()),
+            types::ComponentDefinedType::Flags(_) => Ok(()),
+            types::ComponentDefinedType::Enum(_) => Ok(()),
         }
     }
 
@@ -1342,7 +1267,10 @@ impl Registrar<'_> {
                         Ok(())
                     }
                     None => {
-                        let wasm = self.types[*wasm].unwrap_defined();
+                        let wasm = match self.types.type_from_id(*wasm) {
+                            Some(types::Type::Defined(ty)) => ty,
+                            _ => unreachable!(),
+                        };
                         self.defined(wit, wasm)
                     }
                 }
diff --git a/crates/wit-component/src/dummy.rs b/crates/wit-component/src/dummy.rs
index 709bfbfb..bcc9ae6c 100644
--- a/crates/wit-component/src/dummy.rs
+++ b/crates/wit-component/src/dummy.rs
@@ -1,5 +1,5 @@
 use wit_parser::abi::{AbiVariant, WasmType};
-use wit_parser::{Function, Resolve, TypeDefKind, TypeId, WorldId, WorldItem};
+use wit_parser::{Function, Resolve, WorldId, WorldItem};
 
 /// Generate a dummy implementation core Wasm module for a given WIT document
 pub fn dummy_module(resolve: &Resolve, world: WorldId) -> Vec<u8> {
@@ -17,7 +17,6 @@ pub fn dummy_module(resolve: &Resolve, world: WorldId) -> Vec<u8> {
                 wat.push_str("))\n");
             }
             WorldItem::Interface(import) => {
-                let name = resolve.name_world_key(name);
                 for (_, func) in resolve.interfaces[*import].functions.iter() {
                     let sig = resolve.wasm_signature(AbiVariant::GuestImport, func);
 
@@ -26,36 +25,8 @@ pub fn dummy_module(resolve: &Resolve, world: WorldId) -> Vec<u8> {
                     push_tys(&mut wat, "result", &sig.results);
                     wat.push_str("))\n");
                 }
-                for (_, ty) in resolve.interfaces[*import].types.iter() {
-                    push_resource_func_imports(&mut wat, resolve, &name, *ty);
-                }
-            }
-            WorldItem::Type(id) => {
-                push_resource_func_imports(&mut wat, resolve, "$root", *id);
-            }
-        }
-    }
-
-    // Import any resource-related functions for exports.
-    for (name, export) in world.exports.iter() {
-        let export = match export {
-            WorldItem::Interface(export) => *export,
-            _ => continue,
-        };
-        let module = format!("[export]{}", resolve.name_world_key(name));
-        for (name, ty) in resolve.interfaces[export].types.iter() {
-            let ty = &resolve.types[*ty];
-            match ty.kind {
-                TypeDefKind::Resource => {}
-                _ => continue,
             }
-            wat.push_str(&format!(
-                "\
-(import \"{module}\" \"[resource-drop]{name}\" (func (param i32)))
-(import \"{module}\" \"[resource-new]{name}\" (func (param i32) (result i32)))
-(import \"{module}\" \"[resource-rep]{name}\" (func (param i32) (result i32)))
-                "
-            ));
+            WorldItem::Type(_) => {}
         }
     }
 
@@ -65,24 +36,10 @@ pub fn dummy_module(resolve: &Resolve, world: WorldId) -> Vec<u8> {
                 push_func(&mut wat, &func.name, resolve, func);
             }
             WorldItem::Interface(export) => {
-                let name = resolve.name_world_key(name);
                 for (_, func) in resolve.interfaces[*export].functions.iter() {
-                    let name = func.core_export_name(Some(&name));
+                    let name = func.core_export_name(Some(name));
                     push_func(&mut wat, &name, resolve, func);
                 }
-
-                // Feign destructors for any resource that this interface
-                // exports
-                for (resource_name, ty) in resolve.interfaces[*export].types.iter() {
-                    let ty = &resolve.types[*ty];
-                    match ty.kind {
-                        TypeDefKind::Resource => {}
-                        _ => continue,
-                    }
-                    wat.push_str(&format!(
-                        "(func (export \"{name}#[dtor]{resource_name}\") (param i32))"
-                    ));
-                }
             }
             WorldItem::Type(_) => {}
         }
@@ -96,17 +53,6 @@ pub fn dummy_module(resolve: &Resolve, world: WorldId) -> Vec<u8> {
 
     return wat::parse_str(&wat).unwrap();
 
-    fn push_resource_func_imports(wat: &mut String, resolve: &Resolve, module: &str, ty: TypeId) {
-        let ty = &resolve.types[ty];
-        match ty.kind {
-            TypeDefKind::Resource => {}
-            _ => return,
-        }
-        let name = ty.name.as_ref().unwrap();
-        wat.push_str(&format!("(import \"{module}\" \"[resource-drop]{name}\""));
-        wat.push_str(" (func (param i32)))\n");
-    }
-
     fn push_func(wat: &mut String, name: &str, resolve: &Resolve, func: &Function) {
         let sig = resolve.wasm_signature(AbiVariant::GuestExport, func);
         wat.push_str(&format!("(func (export \"{name}\")"));
@@ -128,7 +74,7 @@ pub fn dummy_module(resolve: &Resolve, world: WorldId) -> Vec<u8> {
         dst.push_str(" (");
         dst.push_str(desc);
         for ty in params {
-            dst.push(' ');
+            dst.push_str(" ");
             match ty {
                 WasmType::I32 => dst.push_str("i32"),
                 WasmType::I64 => dst.push_str("i64"),
@@ -136,6 +82,6 @@ pub fn dummy_module(resolve: &Resolve, world: WorldId) -> Vec<u8> {
                 WasmType::F64 => dst.push_str("f64"),
             }
         }
-        dst.push(')');
+        dst.push_str(")");
     }
 }
diff --git a/crates/wit-component/src/encoding.rs b/crates/wit-component/src/encoding.rs
index 6d54a69d..f0992100 100644
--- a/crates/wit-component/src/encoding.rs
+++ b/crates/wit-component/src/encoding.rs
@@ -3,7 +3,7 @@
 //! This module, at a high level, is tasked with transforming a core wasm
 //! module into a component. This will process the imports/exports of the core
 //! wasm module and translate between the `wit-parser` AST and the component
-//! model binary format, producing a final component which will import
+//! model binary format, producing a final component which sill import
 //! `*.wit` defined interfaces and export `*.wit` defined interfaces as well
 //! with everything wired up internally according to the canonical ABI and such.
 //!
@@ -76,26 +76,25 @@ use crate::metadata::{self, Bindgen, ModuleMetadata};
 use crate::validation::{ValidatedModule, BARE_FUNC_MODULE_NAME, MAIN_MODULE_IMPORT_NAME};
 use crate::StringEncoding;
 use anyhow::{anyhow, bail, Context, Result};
-use indexmap::{IndexMap, IndexSet};
+use indexmap::IndexMap;
 use std::collections::HashMap;
 use std::hash::Hash;
 use wasm_encoder::*;
 use wasmparser::{Validator, WasmFeatures};
 use wit_parser::{
     abi::{AbiVariant, WasmSignature, WasmType},
-    Function, FunctionKind, InterfaceId, LiveTypes, Resolve, Type, TypeDefKind, TypeId, TypeOwner,
-    WorldItem, WorldKey,
+    Function, InterfaceId, Resolve, Type, TypeDefKind, TypeId, TypeOwner, WorldId, WorldItem,
 };
 
 const INDIRECT_TABLE_NAME: &str = "$imports";
 
 mod wit;
-pub use wit::{encode, encode_component, encode_world};
+pub use wit::{encode, encode_component};
 
 mod types;
 use types::{InstanceTypeEncoder, RootTypeEncoder, ValtypeEncoder};
 mod world;
-use world::{ComponentWorld, ImportedInterface, Lowering};
+use world::{ComponentWorld, ImportedInterface};
 
 fn to_val_type(ty: &WasmType) -> ValType {
     match ty {
@@ -286,11 +285,6 @@ impl TypeContents {
     fn for_type(resolve: &Resolve, ty: &Type) -> Self {
         match ty {
             Type::Id(id) => match &resolve.types[*id].kind {
-                TypeDefKind::Handle(h) => match h {
-                    wit_parser::Handle::Own(_) => Self::empty(),
-                    wit_parser::Handle::Borrow(_) => Self::empty(),
-                },
-                TypeDefKind::Resource => Self::empty(),
                 TypeDefKind::Record(r) => Self::for_types(resolve, r.fields.iter().map(|f| &f.ty)),
                 TypeDefKind::Tuple(t) => Self::for_types(resolve, t.types.iter()),
                 TypeDefKind::Flags(_) => Self::empty(),
@@ -358,17 +352,13 @@ pub struct EncodingState<'a> {
 
     /// Imported instances and what index they were imported as.
     imported_instances: IndexMap<InterfaceId, u32>,
-    imported_funcs: IndexMap<String, u32>,
+    imported_funcs: IndexMap<&'a str, u32>,
     exported_instances: IndexMap<InterfaceId, u32>,
 
-    /// Maps used when translating types to the component model binary format.
-    /// Note that imports and exports are stored in separate maps since they
-    /// need fresh hierarchies of types in case the same interface is both
-    /// imported and exported.
-    import_type_map: HashMap<TypeId, u32>,
-    import_func_type_map: HashMap<types::FunctionKey<'a>, u32>,
-    export_type_map: HashMap<TypeId, u32>,
-    export_func_type_map: HashMap<types::FunctionKey<'a>, u32>,
+    /// Map of types defined within the component's root index space.
+    type_map: HashMap<TypeId, u32>,
+    /// Map of function types defined within the component's root index space.
+    func_type_map: HashMap<types::FunctionKey<'a>, u32>,
 
     /// Metadata about the world inferred from the input to `ComponentEncoder`.
     info: &'a ComponentWorld<'a>,
@@ -394,24 +384,12 @@ impl<'a> EncodingState<'a> {
         }
     }
 
-    fn root_import_type_encoder(
-        &mut self,
-        interface: Option<InterfaceId>,
-    ) -> RootTypeEncoder<'_, 'a> {
-        RootTypeEncoder {
-            state: self,
-            interface,
-            import_types: true,
-        }
-    }
-
-    fn root_export_type_encoder(
-        &mut self,
-        interface: Option<InterfaceId>,
-    ) -> RootTypeEncoder<'_, 'a> {
+    fn root_type_encoder(&mut self, interface: Option<InterfaceId>) -> RootTypeEncoder<'_, 'a> {
         RootTypeEncoder {
             state: self,
             interface,
+            type_map: Default::default(),
+            func_type_map: Default::default(),
             import_types: false,
         }
     }
@@ -439,8 +417,9 @@ impl<'a> EncodingState<'a> {
         let world = &resolve.worlds[self.info.encoder.metadata.world];
         for (_name, item) in world.imports.iter() {
             if let WorldItem::Type(ty) = item {
-                self.root_import_type_encoder(None)
-                    .encode_valtype(resolve, &Type::Id(*ty))?;
+                let mut enc = self.root_type_encoder(None);
+                enc.import_types = true;
+                enc.encode_valtype(resolve, &Type::Id(*ty))?;
             }
         }
 
@@ -453,33 +432,34 @@ impl<'a> EncodingState<'a> {
 
     fn encode_interface_import(&mut self, name: &str, info: &ImportedInterface) -> Result<()> {
         let resolve = &self.info.encoder.metadata.resolve;
-        let interface_id = info.interface.as_ref().unwrap();
+        let (interface_id, url) = info.interface.as_ref().unwrap();
         let interface_id = *interface_id;
         let interface = &resolve.interfaces[interface_id];
         log::trace!("encoding imports for `{name}` as {:?}", interface_id);
         let mut encoder = self.instance_type_encoder(interface_id);
 
-        // First encode all type information
-        if let Some(live) = encoder.state.info.live_types.get(&interface_id) {
-            for ty in live {
-                log::trace!(
-                    "encoding extra type {ty:?} name={:?}",
-                    resolve.types[*ty].name
-                );
-                encoder.encode_valtype(resolve, &Type::Id(*ty))?;
-            }
-        }
-
-        // Next encode all required functions from this imported interface
+        // Encode all required functions from this imported interface
         // into the instance type.
         for (_, func) in interface.functions.iter() {
-            if !info.lowerings.contains_key(&func.name) {
+            if !info.required.contains(func.name.as_str()) {
                 continue;
             }
             log::trace!("encoding function type for `{}`", func.name);
             let idx = encoder.encode_func_type(resolve, func)?;
 
-            encoder.ty.export(&func.name, ComponentTypeRef::Func(idx));
+            encoder
+                .ty
+                .export(&func.name, "", ComponentTypeRef::Func(idx));
+        }
+
+        // If there were any live types from this instance which weren't
+        // otherwise reached through the above function types then this
+        // will forward them through.
+        if let Some(live) = encoder.state.info.live_types.get(&interface_id) {
+            for ty in live {
+                log::trace!("encoding extra type {ty:?}");
+                encoder.encode_valtype(resolve, &Type::Id(*ty))?;
+            }
         }
 
         let ty = encoder.ty;
@@ -489,9 +469,9 @@ impl<'a> EncodingState<'a> {
             return Ok(());
         }
         let instance_type_idx = self.component.instance_type(&ty);
-        let instance_idx = self
-            .component
-            .import(name, ComponentTypeRef::Instance(instance_type_idx));
+        let instance_idx =
+            self.component
+                .import(name, url, ComponentTypeRef::Instance(instance_type_idx));
         let prev = self.imported_instances.insert(interface_id, instance_idx);
         assert!(prev.is_none());
         Ok(())
@@ -505,38 +485,42 @@ impl<'a> EncodingState<'a> {
                 WorldItem::Function(f) => f,
                 WorldItem::Interface(_) | WorldItem::Type(_) => continue,
             };
-            let name = resolve.name_world_key(name);
-            if !info.lowerings.contains_key(&name) {
+            if !info.required.contains(name.as_str()) {
                 continue;
             }
             log::trace!("encoding function type for `{}`", func.name);
-            let idx = self
-                .root_import_type_encoder(None)
-                .encode_func_type(resolve, func)?;
-            let func_idx = self.component.import(&name, ComponentTypeRef::Func(idx));
+            let mut encoder = self.root_type_encoder(None);
+            let idx = encoder.encode_func_type(resolve, func)?;
+            let func_idx = self.component.import(name, "", ComponentTypeRef::Func(idx));
             let prev = self.imported_funcs.insert(name, func_idx);
             assert!(prev.is_none());
         }
         Ok(())
     }
 
-    fn alias_imported_type(&mut self, interface: InterfaceId, id: TypeId) -> u32 {
-        let ty = &self.info.encoder.metadata.resolve.types[id];
-        let name = ty.name.as_ref().expect("type must have a name");
-        let instance = self.imported_instances[&interface];
-        self.component.alias_type_export(instance, name)
-    }
-
-    fn alias_exported_type(&mut self, interface: InterfaceId, id: TypeId) -> u32 {
+    fn index_of_type_export(&mut self, id: TypeId) -> u32 {
+        // Using the original `interface` definition of `id` and its name create
+        // an alias which refers to the type export of that instance which must
+        // have previously been imported.
         let ty = &self.info.encoder.metadata.resolve.types[id];
-        let name = ty.name.as_ref().expect("type must have a name");
-        let instance = self.exported_instances[&interface];
+        let interface = match ty.owner {
+            TypeOwner::Interface(id) => id,
+            _ => panic!("cannot import anonymous type across interfaces"),
+        };
+        let name = ty
+            .name
+            .as_ref()
+            .expect("cannot import anonymous type across interfaces");
+        let instance = self
+            .exported_instances
+            .get(&interface)
+            .copied()
+            .unwrap_or_else(|| self.imported_instances[&interface]);
         self.component.alias_type_export(instance, name)
     }
 
     fn encode_core_instantiation(&mut self) -> Result<()> {
         let info = &self.info.info;
-
         // Encode a shim instantiation if needed
         let shims = self.encode_shim_instantiation();
 
@@ -546,7 +530,7 @@ impl<'a> EncodingState<'a> {
         for core_wasm_name in info.required_imports.keys() {
             let index = self.import_instance_to_lowered_core_instance(
                 CustomModule::Main,
-                core_wasm_name,
+                *core_wasm_name,
                 &shims,
                 info.metadata,
             );
@@ -576,44 +560,6 @@ impl<'a> EncodingState<'a> {
             args.push((*adapter, ModuleArg::Instance(index)));
         }
 
-        for (import, info) in info.required_resource_funcs.iter() {
-            let mut exports = Vec::new();
-            for (resource, info) in info {
-                // Destructors for resources live on the shim module previously
-                // created, so if one is specified create the resource with
-                // the shim module that currently exists. The shim will get
-                // filled in later with the actual destructor after the main
-                // module is instantiated.
-                let dtor = info.dtor_export.map(|_| {
-                    self.component.alias_core_item(
-                        self.shim_instance_index.unwrap(),
-                        ExportKind::Func,
-                        &shims.shim_names[&ShimKind::ResourceDtor { import, resource }],
-                    )
-                });
-                let resource_idx = self.component.resource(ValType::I32, dtor);
-                let prev = self.export_type_map.insert(info.id, resource_idx);
-                assert!(prev.is_none());
-
-                if let Some(name) = info.drop_import {
-                    let index = self.component.resource_drop(resource_idx);
-                    exports.push((name, ExportKind::Func, index));
-                }
-                if let Some(name) = info.rep_import {
-                    let index = self.component.resource_rep(resource_idx);
-                    exports.push((name, ExportKind::Func, index));
-                }
-                if let Some(name) = info.new_import {
-                    let index = self.component.resource_new(resource_idx);
-                    exports.push((name, ExportKind::Func, index));
-                }
-            }
-            if !exports.is_empty() {
-                let index = self.component.instantiate_core_exports(exports);
-                args.push((import.as_str(), ModuleArg::Instance(index)));
-            }
-        }
-
         // Instantiate the main module now that all of its arguments have been
         // prepared. With this we know have the main linear memory for
         // liftings/lowerings later on as well as the adapter modules, if any,
@@ -644,102 +590,66 @@ impl<'a> EncodingState<'a> {
         let interface = if core_wasm_name == BARE_FUNC_MODULE_NAME {
             None
         } else {
-            Some(core_wasm_name.to_string())
+            Some(core_wasm_name)
         };
         let import = &self.info.import_map[&interface];
-        let required_imports = match for_module {
-            CustomModule::Main => &self.info.info.required_imports[core_wasm_name],
-            CustomModule::Adapter(name) => {
-                &self.info.adapters[name].0.required_imports[core_wasm_name]
-            }
-        };
-        let mut exports = Vec::with_capacity(import.lowerings.len());
-
-        for (index, (name, lowering)) in import.lowerings.iter().enumerate() {
-            if !required_imports.funcs.contains(name.as_str()) {
-                continue;
-            }
-            let index = match lowering {
-                // All direct lowerings can be `canon lower`'d here immediately
-                // and passed as arguments.
-                Lowering::Direct => {
-                    let func_index = match &import.interface {
-                        Some(interface) => {
-                            let instance_index = self.imported_instances[interface];
-                            self.component.alias_func(instance_index, name)
-                        }
-                        None => self.imported_funcs[name],
-                    };
-                    self.component.lower_func(func_index, [])
-                }
-
-                // Add an entry for all indirect lowerings which come as an
-                // export of the shim module.
-                Lowering::Indirect { .. } => {
-                    let encoding =
-                        metadata.import_encodings[&(core_wasm_name.to_string(), name.clone())];
-                    self.component.alias_core_item(
-                        self.shim_instance_index
-                            .expect("shim should be instantiated"),
-                        ExportKind::Func,
-                        &shims.shim_names[&ShimKind::IndirectLowering {
-                            interface: interface.clone(),
-                            index,
-                            realloc: for_module,
-                            encoding,
-                        }],
-                    )
-                }
+        let mut exports = Vec::with_capacity(import.direct.len() + import.indirect.len());
+
+        // Add an entry for all indirect lowerings which come as an export of
+        // the shim module.
+        for (i, lowering) in import.indirect.iter().enumerate() {
+            let encoding =
+                metadata.import_encodings[&(core_wasm_name.to_string(), lowering.name.to_string())];
+            let index = self.component.alias_core_item(
+                self.shim_instance_index
+                    .expect("shim should be instantiated"),
+                ExportKind::Func,
+                &shims.shim_names[&ShimKind::IndirectLowering {
+                    interface,
+                    indirect_index: i,
+                    realloc: for_module,
+                    encoding,
+                }],
+            );
+            exports.push((lowering.name, ExportKind::Func, index));
+        }
 
-                Lowering::ResourceDrop(id) => {
-                    let resource_idx = self.lookup_resource_index(*id);
-                    self.component.resource_drop(resource_idx)
+        // All direct lowerings can be `canon lower`'d here immediately and
+        // passed as arguments.
+        for lowering in &import.direct {
+            let func_index = match &import.interface {
+                Some((interface, _url)) => {
+                    let instance_index = self.imported_instances[interface];
+                    self.component.alias_func(instance_index, lowering.name)
                 }
+                None => self.imported_funcs[lowering.name],
             };
-            exports.push((name.as_str(), ExportKind::Func, index));
+            let core_func_index = self.component.lower_func(func_index, []);
+            exports.push((lowering.name, ExportKind::Func, core_func_index));
         }
 
         self.component.instantiate_core_exports(exports)
     }
 
-    fn lookup_resource_index(&mut self, id: TypeId) -> u32 {
-        let resolve = &self.info.encoder.metadata.resolve;
-        let ty = &resolve.types[id];
-        match ty.owner {
-            // If this resource is owned by a world then it's a top-level
-            // resource which means it must have already been translated so
-            // it's available for lookup in `import_type_map`.
-            TypeOwner::World(_) => self.import_type_map[&id],
-            TypeOwner::Interface(i) => {
-                let instance = self.imported_instances[&i];
-                let name = ty.name.as_ref().expect("resources must be named");
-                self.component.alias_type_export(instance, name)
-            }
-            TypeOwner::None => panic!("resources must have an owner"),
-        }
-    }
-
     fn encode_exports(&mut self, module: CustomModule) -> Result<()> {
         let resolve = &self.info.encoder.metadata.resolve;
-        let exports = match module {
-            CustomModule::Main => &self.info.encoder.main_module_exports,
-            CustomModule::Adapter(name) => &self.info.encoder.adapters[name].2,
+        let world = match module {
+            CustomModule::Main => self.info.encoder.metadata.world,
+            CustomModule::Adapter(name) => self.info.encoder.adapters[name].2,
         };
-        let world = &resolve.worlds[self.info.encoder.metadata.world];
-        for export_name in exports {
-            let export_string = resolve.name_world_key(export_name);
-            match &world.exports[export_name] {
+        let world = &resolve.worlds[world];
+        for (export_name, export) in world.exports.iter() {
+            match export {
                 WorldItem::Function(func) => {
-                    let ty = self
-                        .root_import_type_encoder(None)
-                        .encode_func_type(resolve, func)?;
+                    let mut enc = self.root_type_encoder(None);
+                    let ty = enc.encode_func_type(resolve, func)?;
                     let core_name = func.core_export_name(None);
                     let idx = self.encode_lift(module, &core_name, func, ty)?;
                     self.component
-                        .export(&export_string, ComponentExportKind::Func, idx, None);
+                        .export(export_name, "", ComponentExportKind::Func, idx, None);
                 }
                 WorldItem::Interface(export) => {
-                    self.encode_interface_export(&export_string, module, *export)?;
+                    self.encode_interface_export(export_name, module, *export)?;
                 }
                 WorldItem::Type(_) => unreachable!(),
             }
@@ -754,7 +664,6 @@ impl<'a> EncodingState<'a> {
         module: CustomModule<'_>,
         export: InterfaceId,
     ) -> Result<()> {
-        log::trace!("encode interface export `{export_name}`");
         let resolve = &self.info.encoder.metadata.resolve;
 
         // First execute a `canon lift` for all the functions in this interface
@@ -764,13 +673,15 @@ impl<'a> EncodingState<'a> {
         // function is saved off into an `imports` array to get imported into
         // the nested component synthesized below.
         let mut imports = Vec::new();
-        let mut root = self.root_export_type_encoder(Some(export));
+        let mut root = self.root_type_encoder(Some(export));
+        let mut func_types = Vec::new();
         for (_, func) in &resolve.interfaces[export].functions {
             let core_name = func.core_export_name(Some(export_name));
             let ty = root.encode_func_type(resolve, func)?;
             let func_index = root.state.encode_lift(module, &core_name, func, ty)?;
+            func_types.push(ty);
             imports.push((
-                import_func_name(func),
+                format!("import-{}", func.name),
                 ComponentExportKind::Func,
                 func_index,
             ));
@@ -786,112 +697,21 @@ impl<'a> EncodingState<'a> {
             export_types: false,
             interface: export,
             state: self,
-            imports: IndexMap::new(),
         };
 
-        // Import all transitively-referenced types from other interfaces into
-        // this component. This temporarily switches the `interface` listed to
-        // the interface of the referred-to-type to generate the import. After
-        // this loop `interface` is rewritten to `export`.
-        //
-        // Each component is a standalone "island" so the necessary type
-        // information needs to be rebuilt within this component. This ensures
-        // that we're able to build a valid component and additionally connect
-        // all the type information to the outer context.
-        let mut types_to_import = LiveTypes::default();
-        types_to_import.add_interface(resolve, export);
-        let exports_used = &nested.state.info.exports_used[&export];
-        for ty in types_to_import.iter() {
-            if let TypeOwner::Interface(owner) = resolve.types[ty].owner {
-                if owner == export {
-                    // Here this deals with the current exported interface which
-                    // is handled below.
-                    continue;
-                }
-
-                // Ensure that `self` has encoded this type before. If so this
-                // is a noop but otherwise it generates the type here.
-                let mut encoder = if exports_used.contains(&owner) {
-                    nested.state.root_export_type_encoder(Some(export))
-                } else {
-                    nested.state.root_import_type_encoder(Some(export))
-                };
-                encoder.encode_valtype(resolve, &Type::Id(ty))?;
-
-                // Next generate the same type but this time within the
-                // component itself. The type generated above (or prior) will be
-                // used to satisfy this type import.
-                nested.interface = owner;
-                nested.encode_valtype(resolve, &Type::Id(ty))?;
-            }
-        }
-        nested.interface = export;
-
-        // Record the map of types imported to their index at where they were
-        // imported. This is used after imports are encoded as exported types
-        // will refer to these.
-        let imported_types = nested.type_map.clone();
-
-        // Handle resource types for this instance specially, namely importing
-        // them into the nested component. This models how the resource is
-        // imported from its definition in the outer component to get reexported
-        // internally. This chiefly avoids creating a second resource which is
-        // not desired in this situation.
-        let mut resources = HashMap::new();
-        for (_name, ty) in resolve.interfaces[export].types.iter() {
-            if !matches!(resolve.types[*ty].kind, TypeDefKind::Resource) {
-                continue;
-            }
-            let idx = match nested.encode_valtype(resolve, &Type::Id(*ty))? {
-                ComponentValType::Type(idx) => idx,
-                _ => unreachable!(),
-            };
-            resources.insert(*ty, idx);
-        }
-
-        // Next import each function of this interface. This will end up
-        // defining local types as necessary or using the types as imported
-        // above.
-        for (_, func) in resolve.interfaces[export].functions.iter() {
-            let ty = nested.encode_func_type(resolve, func)?;
-            nested
-                .component
-                .import(&import_func_name(func), ComponentTypeRef::Func(ty));
-        }
-
-        // Swap the `nested.type_map` which was previously from `TypeId` to
-        // `u32` to instead being from `u32` to `TypeId`. This reverse map is
-        // then used in conjunction with `self.type_map` to satisfy all type
-        // imports of the nested component generated. The type import's index in
-        // the inner component is translated to a `TypeId` via `reverse_map`
-        // which is then translated back to our own index space via `type_map`.
-        let reverse_map = nested
-            .type_map
-            .drain()
-            .map(|p| (p.1, p.0))
-            .collect::<HashMap<_, _>>();
-        for (name, idx) in nested.imports.drain(..) {
-            let id = reverse_map[&idx];
-            let owner = match resolve.types[id].owner {
-                TypeOwner::Interface(id) => id,
-                _ => unreachable!(),
-            };
-            let idx = if owner == export || exports_used.contains(&owner) {
-                log::trace!("consulting exports for {id:?}");
-                nested.state.export_type_map[&id]
-            } else {
-                log::trace!("consulting imports for {id:?}");
-                nested.state.import_type_map[&id]
-            };
-            imports.push((name, ComponentExportKind::Type, idx))
+        // Our nested component starts off by importing each function of this
+        // interface. Note that the type used here is the same type that was
+        // used to execute the `canon lift`, so the type is aliased from the
+        // outer component.
+        for ((_, func), ty) in resolve.interfaces[export].functions.iter().zip(func_types) {
+            let ty = nested.component.alias_outer_type(1, ty);
+            nested.component.import(
+                &format!("import-{}", func.name),
+                "",
+                ComponentTypeRef::Func(ty),
+            );
         }
 
-        // Before encoding exports reset the type map to what all was imported
-        // from foreign interfaces. This will enable any encoded types below to
-        // refer to imports which, after type substitution, will point to the
-        // correct type in the outer component context.
-        nested.type_map = imported_types;
-
         // Next the component reexports all of its imports, but notably uses the
         // type ascription feature to change the type of the function. Note that
         // no structural change is happening to the types here but instead types
@@ -899,42 +719,26 @@ impl<'a> EncodingState<'a> {
         // new type index space. Hence the `export_types = true` flag here which
         // flows through the type encoding and when types are emitted.
         nested.export_types = true;
+        nested.type_map.clear();
         nested.func_type_map.clear();
-
-        // To start off all type information is encoded. This will be used by
-        // functions below but notably this also has special handling for
-        // resources. Resources reexport their imported resource type under
-        // the final name which achieves the desired goal of threading through
-        // the original resource without creating a new one.
-        if let Some(live) = nested.state.info.live_types.get(&export) {
-            for id in live {
-                let ty = &resolve.types[*id];
-                match ty.kind {
-                    TypeDefKind::Resource => {
-                        let idx = nested.component.export(
-                            ty.name.as_ref().expect("resources must be named"),
-                            ComponentExportKind::Type,
-                            resources[id],
-                            None,
-                        );
-                        nested.type_map.insert(*id, idx);
-                    }
-                    _ => {
-                        nested.encode_valtype(resolve, &Type::Id(*id))?;
-                    }
-                }
-            }
-        }
-
         for (i, (_, func)) in resolve.interfaces[export].functions.iter().enumerate() {
             let ty = nested.encode_func_type(resolve, func)?;
             nested.component.export(
                 &func.name,
+                "",
                 ComponentExportKind::Func,
                 i as u32,
                 Some(ComponentTypeRef::Func(ty)),
             );
         }
+        // Be sure that if any live types are needed from this interface that
+        // they're encoded. This will pick up any stragglers that weren't
+        // already encoded through exported functions.
+        if let Some(live) = nested.state.info.live_types.get(&export) {
+            for ty in live {
+                nested.encode_valtype(resolve, &Type::Id(*ty))?;
+            }
+        }
 
         // Embed the component within our component and then instantiate it with
         // the lifted functions. That final instance is then exported under the
@@ -944,26 +748,16 @@ impl<'a> EncodingState<'a> {
         let instance_index = self
             .component
             .instantiate_component(component_index, imports);
+        let url = resolve.url_of(export).unwrap_or(String::new());
         let idx = self.component.export(
             export_name,
+            &url,
             ComponentExportKind::Instance,
             instance_index,
             None,
         );
         let prev = self.exported_instances.insert(export, idx);
         assert!(prev.is_none());
-
-        // After everything is all said and done remove all the type information
-        // about type exports of this interface. Any entries in the map
-        // currently were used to create the instance above but aren't the
-        // actual copy of the exported type since that comes from the exported
-        // instance itself. Entries will be re-inserted into this map as
-        // necessary via aliases from the exported instance which is the new
-        // source of truth for all these types.
-        for (_name, id) in resolve.interfaces[export].types.iter() {
-            self.export_type_map.remove(id);
-        }
-
         return Ok(());
 
         struct NestedComponentTypeEncoder<'state, 'a> {
@@ -973,7 +767,6 @@ impl<'a> EncodingState<'a> {
             export_types: bool,
             interface: InterfaceId,
             state: &'state mut EncodingState<'a>,
-            imports: IndexMap<String, u32>,
         }
 
         impl<'a> ValtypeEncoder<'a> for NestedComponentTypeEncoder<'_, 'a> {
@@ -987,31 +780,15 @@ impl<'a> EncodingState<'a> {
                 if self.export_types {
                     Some(
                         self.component
-                            .export(name, ComponentExportKind::Type, idx, None),
+                            .export(name, "", ComponentExportKind::Type, idx, None),
                     )
                 } else {
-                    let name = self.unique_import_name(name);
-                    let ret = self
-                        .component
-                        .import(&name, ComponentTypeRef::Type(TypeBounds::Eq(idx)));
-                    self.imports.insert(name, ret);
-                    Some(ret)
+                    None
                 }
             }
-            fn export_resource(&mut self, name: &'a str) -> u32 {
-                if self.export_types {
-                    panic!("resources should already be exported")
-                } else {
-                    let name = self.unique_import_name(name);
-                    let ret = self
-                        .component
-                        .import(&name, ComponentTypeRef::Type(TypeBounds::SubResource));
-                    self.imports.insert(name, ret);
-                    ret
-                }
-            }
-            fn import_type(&mut self, _: InterfaceId, _id: TypeId) -> u32 {
-                unreachable!()
+            fn import_type(&mut self, _: InterfaceId, id: TypeId) -> u32 {
+                self.component
+                    .alias_outer_type(1, self.state.index_of_type_export(id))
             }
             fn type_map(&mut self) -> &mut HashMap<TypeId, u32> {
                 &mut self.type_map
@@ -1023,42 +800,6 @@ impl<'a> EncodingState<'a> {
                 Some(self.interface)
             }
         }
-
-        impl NestedComponentTypeEncoder<'_, '_> {
-            fn unique_import_name(&mut self, name: &str) -> String {
-                let mut name = format!("import-type-{name}");
-                let mut n = 0;
-                while self.imports.contains_key(&name) {
-                    name = format!("{name}{n}");
-                    n += 1;
-                }
-                name
-            }
-        }
-
-        fn import_func_name(f: &Function) -> String {
-            match f.kind {
-                FunctionKind::Freestanding => {
-                    format!("import-func-{}", f.name)
-                }
-
-                // transform `[method]foo.bar` into `import-method-foo-bar` to
-                // have it be a valid kebab-name which can't conflict with
-                // anything else.
-                //
-                // There's probably a better and more "formal" way to do this
-                // but quick-and-dirty string manipulation should work well
-                // enough for now hopefully.
-                FunctionKind::Method(_)
-                | FunctionKind::Static(_)
-                | FunctionKind::Constructor(_) => {
-                    format!(
-                        "import-{}",
-                        f.name.replace('[', "").replace([']', '.'], "-")
-                    )
-                }
-            }
-        }
     }
 
     fn encode_lift(
@@ -1116,18 +857,17 @@ impl<'a> EncodingState<'a> {
 
         // For all interfaces imported into the main module record all of their
         // indirect lowerings into `Shims`.
-        for (core_wasm_name, required) in info.required_imports.iter() {
+        for core_wasm_name in info.required_imports.keys() {
             let import_name = if *core_wasm_name == BARE_FUNC_MODULE_NAME {
                 None
             } else {
-                Some(core_wasm_name.to_string())
+                Some(*core_wasm_name)
             };
             let import = &self.info.import_map[&import_name];
             ret.append_indirect(
                 core_wasm_name,
                 CustomModule::Main,
                 import,
-                &required.funcs,
                 info.metadata,
                 &mut signatures,
             );
@@ -1137,13 +877,12 @@ impl<'a> EncodingState<'a> {
         // function and additionally a set of shims are created for the
         // interface imported into the shim module itself.
         for (adapter, (info, _wasm)) in self.info.adapters.iter() {
-            for (name, required) in info.required_imports.iter() {
-                let import = &self.info.import_map[&Some(name.clone())];
+            for (name, _) in info.required_imports.iter() {
+                let import = &self.info.import_map[&Some(*name)];
                 ret.append_indirect(
                     name,
                     CustomModule::Adapter(adapter),
                     import,
-                    &required.funcs,
                     info.metadata,
                     &mut signatures,
                 );
@@ -1172,40 +911,12 @@ impl<'a> EncodingState<'a> {
                 });
             }
         }
-
-        // Any resource destructors are encoded through the shim module. The
-        // core wasm probably imports resource intrinsics which requires the
-        // resource definition, but the resource definition requires
-        // the destructor to be available. The shim module breaks this
-        // circular dependency.
-        for (import, info) in self.info.info.required_resource_funcs.iter() {
-            for (resource, info) in info {
-                if info.dtor_export.is_none() {
-                    continue;
-                }
-                signatures.push(WasmSignature {
-                    params: vec![WasmType::I32],
-                    results: Vec::new(),
-                    indirect_params: false,
-                    retptr: false,
-                });
-                let name = ret.list.len().to_string();
-                ret.list.push(Shim {
-                    name,
-                    debug_name: format!("dtor-{import}-{resource}"),
-                    options: RequiredOptions::empty(),
-                    kind: ShimKind::ResourceDtor { import, resource },
-                });
-            }
-        }
-
         if ret.list.is_empty() {
             return ret;
         }
 
         for shim in ret.list.iter() {
-            let prev = ret.shim_names.insert(shim.kind.clone(), shim.name.clone());
-            assert!(prev.is_none());
+            ret.shim_names.insert(shim.kind, shim.name.clone());
         }
 
         assert!(self.shim_instance_index.is_none());
@@ -1353,14 +1064,14 @@ impl<'a> EncodingState<'a> {
                 // memory always comes from the main module.
                 ShimKind::IndirectLowering {
                     interface,
-                    index,
+                    indirect_index,
                     realloc,
                     encoding,
                 } => {
                     let interface = &self.info.import_map[interface];
-                    let (name, _) = interface.lowerings.get_index(*index).unwrap();
+                    let name = interface.indirect[*indirect_index].name;
                     let func_index = match &interface.interface {
-                        Some(interface_id) => {
+                        Some((interface_id, _url)) => {
                             let instance_index = self.imported_instances[interface_id];
                             self.component.alias_func(instance_index, name)
                         }
@@ -1388,18 +1099,6 @@ impl<'a> EncodingState<'a> {
                     ExportKind::Func,
                     func,
                 ),
-
-                // Resources are required for a module to be instantiated
-                // meaning that any destructor for the resource must be called
-                // indirectly due to the otherwise circular dependency between
-                // the module and the resource itself.
-                ShimKind::ResourceDtor { import, resource } => self.component.alias_core_item(
-                    self.instance_index.unwrap(),
-                    ExportKind::Func,
-                    self.info.info.required_resource_funcs[*import][*resource]
-                        .dtor_export
-                        .unwrap(),
-                ),
             };
 
             exports.push((shim.name.as_str(), ExportKind::Func, core_func_index));
@@ -1454,19 +1153,11 @@ impl<'a> EncodingState<'a> {
 
             let mut core_exports = Vec::new();
             for export_name in info.needs_core_exports.iter() {
-                let mut core_export_name = export_name.as_str();
-                // provide cabi_realloc_adapter as cabi_realloc to adapters
-                // if it exists
-                if export_name == "cabi_realloc" {
-                    if let Some(adapter_realloc) = self.info.info.adapter_realloc {
-                        core_export_name = adapter_realloc;
-                    }
-                }
                 let index = self.component.alias_core_item(
                     self.instance_index
                         .expect("adaptee index set at this point"),
                     ExportKind::Func,
-                    core_export_name,
+                    export_name,
                 );
                 core_exports.push((export_name.as_str(), ExportKind::Func, index));
             }
@@ -1561,16 +1252,16 @@ struct Shim<'a> {
     kind: ShimKind<'a>,
 }
 
-#[derive(Debug, Clone, Hash, Eq, PartialEq)]
+#[derive(Debug, Copy, Clone, Hash, Eq, PartialEq)]
 enum ShimKind<'a> {
     /// This shim is a late indirect lowering of an imported function in a
     /// component which is only possible after prior core wasm modules are
     /// instantiated so their memories and functions are available.
     IndirectLowering {
         /// The name of the interface that's being lowered.
-        interface: Option<String>,
-        /// The index within the `lowerings` array of the function being lowered.
-        index: usize,
+        interface: Option<&'a str>,
+        /// The index within the `indirect` array of the function being lowered.
+        indirect_index: usize,
         /// Which instance to pull the `realloc` function from, if necessary.
         realloc: CustomModule<'a>,
         /// The string encoding that this lowering is going to use.
@@ -1584,14 +1275,6 @@ enum ShimKind<'a> {
         /// The name of the export in the adapter module this shim points to.
         func: &'a str,
     },
-    /// A shim used as the destructor for a resource which allows defining the
-    /// resource before the core module being instantiated.
-    ResourceDtor {
-        /// The import that the resource was defined for.
-        import: &'a str,
-        /// The name of the resource being destroyed.
-        resource: &'a str,
-    },
 }
 
 /// Indicator for which module is being used for a lowering or where options
@@ -1620,44 +1303,35 @@ impl<'a> Shims<'a> {
         &mut self,
         core_wasm_module: &'a str,
         for_module: CustomModule<'a>,
-        import: &ImportedInterface,
-        required: &IndexSet<String>,
+        import: &ImportedInterface<'a>,
         metadata: &ModuleMetadata,
         sigs: &mut Vec<WasmSignature>,
     ) {
         let interface = if core_wasm_module == BARE_FUNC_MODULE_NAME {
             None
         } else {
-            Some(core_wasm_module.to_string())
+            Some(core_wasm_module)
         };
-        for (index, (name, lowering)) in import.lowerings.iter().enumerate() {
-            if !required.contains(name.as_str()) {
-                continue;
-            }
+        for (indirect_index, lowering) in import.indirect.iter().enumerate() {
             let shim_name = self.list.len().to_string();
             log::debug!(
-                "shim {shim_name} is import `{core_wasm_module}` lowering {index} `{name}`",
+                "shim {shim_name} is import `{core_wasm_module}` lowering {indirect_index} `{}`",
+                lowering.name
             );
-            match lowering {
-                Lowering::Direct | Lowering::ResourceDrop(_) => {}
-
-                Lowering::Indirect { sig, options } => {
-                    sigs.push(sig.clone());
-                    let encoding =
-                        metadata.import_encodings[&(core_wasm_module.to_string(), name.clone())];
-                    self.list.push(Shim {
-                        name: shim_name,
-                        debug_name: format!("indirect-{core_wasm_module}-{name}"),
-                        options: *options,
-                        kind: ShimKind::IndirectLowering {
-                            interface: interface.clone(),
-                            index,
-                            realloc: for_module,
-                            encoding,
-                        },
-                    });
-                }
-            }
+            sigs.push(lowering.sig.clone());
+            let encoding = metadata.import_encodings
+                [&(core_wasm_module.to_string(), lowering.name.to_string())];
+            self.list.push(Shim {
+                name: shim_name,
+                debug_name: format!("indirect-{core_wasm_module}-{}", lowering.name),
+                options: lowering.options,
+                kind: ShimKind::IndirectLowering {
+                    interface,
+                    indirect_index,
+                    realloc: for_module,
+                    encoding,
+                },
+            });
         }
     }
 }
@@ -1668,7 +1342,6 @@ pub struct ComponentEncoder {
     module: Vec<u8>,
     metadata: Bindgen,
     validate: bool,
-    main_module_exports: IndexSet<WorldKey>,
 
     // This is a map from the name of the adapter to a pair of:
     //
@@ -1676,9 +1349,8 @@ pub struct ComponentEncoder {
     //   stripped.
     // * the metadata for the adapter, verified to have no exports and only
     //   imports.
-    // * The set of exports from the final world which are defined by this
-    //   adapter.
-    adapters: IndexMap<String, (Vec<u8>, ModuleMetadata, IndexSet<WorldKey>)>,
+    // * The world within `self.metadata.doc` which the adapter works with.
+    adapters: IndexMap<String, (Vec<u8>, ModuleMetadata, WorldId)>,
 }
 
 impl ComponentEncoder {
@@ -1689,12 +1361,7 @@ impl ComponentEncoder {
     /// core module.
     pub fn module(mut self, module: &[u8]) -> Result<Self> {
         let (wasm, metadata) = metadata::decode(module)?;
-        let world = self
-            .metadata
-            .merge(metadata)
-            .context("failed merge WIT package sets together")?;
-        self.main_module_exports
-            .extend(self.metadata.resolve.worlds[world].exports.keys().cloned());
+        self.metadata.merge(metadata)?;
         self.module = if let Some(producers) = &self.metadata.producers {
             producers.add_to_wasm(&wasm)?
         } else {
@@ -1729,35 +1396,11 @@ impl ComponentEncoder {
     pub fn adapter(mut self, name: &str, bytes: &[u8]) -> Result<Self> {
         let (wasm, metadata) = metadata::decode(bytes)?;
         // Merge the adapter's document into our own document to have one large
-        // document, and then afterwards merge worlds as well.
-        //
-        // The first `merge` operation will interleave equivalent packages from
-        // each adapter into packages that are stored within our own resolve.
-        // The second `merge_worlds` operation will then ensure that both the
-        // adapter and the main module have compatible worlds, meaning that they
-        // either import the same items or they import disjoint items, for
-        // example.
-        let world = self
-            .metadata
-            .resolve
-            .merge(metadata.resolve)
-            .with_context(|| {
-                format!("failed to merge WIT packages of adapter `{name}` into main packages")
-            })?
-            .worlds[metadata.world.index()];
-        self.metadata
-            .resolve
-            .merge_worlds(world, self.metadata.world)
-            .with_context(|| {
-                format!("failed to merge WIT world of adapter `{name}` into main package")
-            })?;
-        let exports = self.metadata.resolve.worlds[world]
-            .exports
-            .keys()
-            .cloned()
-            .collect();
+        // document, but the adapter's world isn't merged in to our world so
+        // retain it separately.
+        let world = self.metadata.resolve.merge(metadata.resolve).worlds[metadata.world.index()];
         self.adapters
-            .insert(name.to_string(), (wasm, metadata.metadata, exports));
+            .insert(name.to_string(), (wasm, metadata.metadata, world));
         Ok(self)
     }
 
@@ -1780,10 +1423,8 @@ impl ComponentEncoder {
             adapter_instances: IndexMap::new(),
             adapter_import_reallocs: IndexMap::new(),
             adapter_export_reallocs: IndexMap::new(),
-            import_type_map: HashMap::new(),
-            import_func_type_map: HashMap::new(),
-            export_type_map: HashMap::new(),
-            export_func_type_map: HashMap::new(),
+            type_map: HashMap::new(),
+            func_type_map: HashMap::new(),
             imported_instances: Default::default(),
             imported_funcs: Default::default(),
             exported_instances: Default::default(),
diff --git a/crates/wit-component/src/encoding/types.rs b/crates/wit-component/src/encoding/types.rs
index 4e037159..5a08e8c8 100644
--- a/crates/wit-component/src/encoding/types.rs
+++ b/crates/wit-component/src/encoding/types.rs
@@ -3,8 +3,8 @@ use anyhow::Result;
 use std::collections::HashMap;
 use wasm_encoder::*;
 use wit_parser::{
-    Enum, Flags, Function, Handle, InterfaceId, Params, Record, Resolve, Result_, Results, Tuple,
-    Type, TypeDefKind, TypeId, TypeOwner, Union, Variant,
+    Enum, Flags, Function, InterfaceId, Params, Record, Resolve, Result_, Results, Tuple, Type,
+    TypeDefKind, TypeId, TypeOwner, Union, Variant,
 };
 
 /// Represents a key type for interface function definitions.
@@ -36,10 +36,6 @@ pub trait ValtypeEncoder<'a> {
     /// Creates an export item for the specified type index.
     fn export_type(&mut self, index: u32, name: &'a str) -> Option<u32>;
 
-    /// Creates a new `(type (sub resource))` export with the given name,
-    /// returning the type index that refers to the fresh type created.
-    fn export_resource(&mut self, name: &'a str) -> u32;
-
     /// Returns a map of all types previously defined in this type index space.
     fn type_map(&mut self) -> &mut HashMap<TypeId, u32>;
 
@@ -131,7 +127,6 @@ pub trait ValtypeEncoder<'a> {
                 // If this type is imported from another interface then return
                 // it as it was bound here with an alias.
                 let ty = &resolve.types[id];
-                log::trace!("encode type name={:?}", ty.name);
                 if let Some(index) = self.maybe_import_type(resolve, id) {
                     self.type_map().insert(id, index);
                     return Ok(ComponentValType::Type(index));
@@ -157,30 +152,6 @@ pub trait ValtypeEncoder<'a> {
                     TypeDefKind::Future(_) => todo!("encoding for future type"),
                     TypeDefKind::Stream(_) => todo!("encoding for stream type"),
                     TypeDefKind::Unknown => unreachable!(),
-                    TypeDefKind::Resource => {
-                        let name = ty.name.as_ref().expect("resources must be named");
-                        let index = self.export_resource(name);
-                        self.type_map().insert(id, index);
-                        return Ok(ComponentValType::Type(index));
-                    }
-                    TypeDefKind::Handle(Handle::Own(id)) => {
-                        let ty = match self.encode_valtype(resolve, &Type::Id(*id))? {
-                            ComponentValType::Type(index) => index,
-                            _ => panic!("must be an indexed type"),
-                        };
-                        let (index, encoder) = self.defined_type();
-                        encoder.own(ty);
-                        ComponentValType::Type(index)
-                    }
-                    TypeDefKind::Handle(Handle::Borrow(id)) => {
-                        let ty = match self.encode_valtype(resolve, &Type::Id(*id))? {
-                            ComponentValType::Type(index) => index,
-                            _ => panic!("must be an indexed type"),
-                        };
-                        let (index, encoder) = self.defined_type();
-                        encoder.borrow(ty);
-                        ComponentValType::Type(index)
-                    }
                 };
 
                 if let Some(name) = &ty.name {
@@ -328,6 +299,11 @@ pub struct RootTypeEncoder<'state, 'a> {
     pub state: &'state mut EncodingState<'a>,
     pub interface: Option<InterfaceId>,
     pub import_types: bool,
+
+    // These maps are used when `interface` is set to `Some` as all the type
+    // information will be per-interface.
+    pub type_map: HashMap<TypeId, u32>,
+    pub func_type_map: HashMap<FunctionKey<'a>, u32>,
 }
 
 impl<'a> ValtypeEncoder<'a> for RootTypeEncoder<'_, 'a> {
@@ -350,47 +326,32 @@ impl<'a> ValtypeEncoder<'a> for RootTypeEncoder<'_, 'a> {
             Some(if self.import_types {
                 self.state
                     .component
-                    .import(name, ComponentTypeRef::Type(TypeBounds::Eq(idx)))
+                    .import(name, "", ComponentTypeRef::Type(TypeBounds::Eq, idx))
             } else {
                 self.state
                     .component
-                    .export(name, ComponentExportKind::Type, idx, None)
+                    .export(name, "", ComponentExportKind::Type, idx, None)
             })
         } else {
             assert!(!self.import_types);
             None
         }
     }
-    fn export_resource(&mut self, name: &'a str) -> u32 {
-        assert!(self.interface.is_none());
-        assert!(self.import_types);
-        self.state
-            .component
-            .import(name, ComponentTypeRef::Type(TypeBounds::SubResource))
-    }
-    fn import_type(&mut self, interface: InterfaceId, id: TypeId) -> u32 {
-        if !self.import_types {
-            if let Some(cur) = self.interface {
-                let set = &self.state.info.exports_used[&cur];
-                if set.contains(&interface) {
-                    return self.state.alias_exported_type(interface, id);
-                }
-            }
-        }
-        self.state.alias_imported_type(interface, id)
+    fn import_type(&mut self, _: InterfaceId, id: TypeId) -> u32 {
+        self.state.index_of_type_export(id)
     }
     fn type_map(&mut self) -> &mut HashMap<TypeId, u32> {
-        if self.import_types {
-            &mut self.state.import_type_map
+        if self.interface.is_some() {
+            &mut self.type_map
         } else {
-            &mut self.state.export_type_map
+            &mut self.state.type_map
         }
     }
     fn func_type_map(&mut self) -> &mut HashMap<FunctionKey<'a>, u32> {
-        if self.import_types {
-            &mut self.state.import_func_type_map
+        if self.interface.is_some() {
+            &mut self.func_type_map
         } else {
-            &mut self.state.export_func_type_map
+            &mut self.state.func_type_map
         }
     }
 }
@@ -413,25 +374,19 @@ impl<'a> ValtypeEncoder<'a> for InstanceTypeEncoder<'_, 'a> {
     fn export_type(&mut self, idx: u32, name: &str) -> Option<u32> {
         let ret = self.ty.type_count();
         self.ty
-            .export(name, ComponentTypeRef::Type(TypeBounds::Eq(idx)));
+            .export(name, "", ComponentTypeRef::Type(TypeBounds::Eq, idx));
         Some(ret)
     }
-    fn export_resource(&mut self, name: &str) -> u32 {
-        let ret = self.ty.type_count();
-        self.ty
-            .export(name, ComponentTypeRef::Type(TypeBounds::SubResource));
-        ret
-    }
     fn type_map(&mut self) -> &mut HashMap<TypeId, u32> {
         &mut self.type_map
     }
     fn interface(&self) -> Option<InterfaceId> {
         Some(self.interface)
     }
-    fn import_type(&mut self, interface: InterfaceId, id: TypeId) -> u32 {
+    fn import_type(&mut self, _: InterfaceId, id: TypeId) -> u32 {
         self.ty.alias(Alias::Outer {
             count: 1,
-            index: self.state.alias_imported_type(interface, id),
+            index: self.state.index_of_type_export(id),
             kind: ComponentOuterAliasKind::Type,
         });
         self.ty.type_count() - 1
diff --git a/crates/wit-component/src/encoding/wit.rs b/crates/wit-component/src/encoding/wit.rs
index fa74f4f1..8a73aa06 100644
--- a/crates/wit-component/src/encoding/wit.rs
+++ b/crates/wit-component/src/encoding/wit.rs
@@ -4,6 +4,7 @@ use anyhow::Result;
 use indexmap::IndexSet;
 use std::collections::HashMap;
 use std::mem;
+use url::Url;
 use wasm_encoder::*;
 use wit_parser::*;
 
@@ -49,6 +50,16 @@ struct Encoder<'a> {
 
 impl Encoder<'_> {
     fn run(&mut self) -> Result<()> {
+        for (name, doc) in self.resolve.packages[self.package].documents.iter() {
+            let ty = self.encode_document(*doc)?;
+            let url = format!("pkg:/{name}");
+            self.component
+                .export(name, &url, ComponentExportKind::Type, ty, None);
+        }
+        Ok(())
+    }
+
+    fn encode_document(&mut self, doc: DocumentId) -> Result<u32> {
         // Build a set of interfaces reachable from this document, including the
         // interfaces in the document itself. This is used to import instances
         // into the component type we're encoding. Note that entire interfaces
@@ -58,7 +69,7 @@ impl Encoder<'_> {
         // notably on the order that types are defined in to assist with
         // roundtripping.
         let mut interfaces = IndexSet::new();
-        for (_, id) in self.resolve.packages[self.package].interfaces.iter() {
+        for (_, id) in self.resolve.documents[doc].interfaces.iter() {
             self.add_live_interfaces(&mut interfaces, *id);
         }
 
@@ -68,15 +79,11 @@ impl Encoder<'_> {
         let mut used_names = IndexSet::new();
         for id in interfaces.iter() {
             let iface = &self.resolve.interfaces[*id];
-            if iface.package == Some(self.package) {
+            if iface.document == doc {
                 let first = used_names.insert(iface.name.as_ref().unwrap().clone());
                 assert!(first);
             }
         }
-        for (name, _world) in self.resolve.packages[self.package].worlds.iter() {
-            let first = used_names.insert(name.clone());
-            assert!(first);
-        }
 
         // Encode all interfaces, foreign and local, into this component type.
         // Local interfaces get their functions defined as well and are
@@ -86,11 +93,13 @@ impl Encoder<'_> {
         for interface in interfaces {
             encoder.interface = Some(interface);
             let iface = &self.resolve.interfaces[interface];
-            let name = self.resolve.id_of(interface).unwrap();
-            log::trace!("encoding interface {name}");
-            if iface.package == Some(self.package) {
+            let name = iface.name.as_ref().unwrap();
+            if iface.document == doc {
                 let idx = encoder.encode_instance(interface)?;
-                encoder.outer.export(&name, ComponentTypeRef::Instance(idx));
+                let url = format!("pkg:/{}/{name}", self.resolve.documents[doc].name);
+                encoder
+                    .outer
+                    .export(name, &url, ComponentTypeRef::Instance(idx));
             } else {
                 encoder.push_instance();
                 for (_, id) in iface.types.iter() {
@@ -101,24 +110,81 @@ impl Encoder<'_> {
                 encoder.outer.ty().instance(&instance);
                 encoder.import_map.insert(interface, encoder.instances);
                 encoder.instances += 1;
-                encoder.outer.import(&name, ComponentTypeRef::Instance(idx));
+
+                let import_name = if used_names.insert(name.clone()) {
+                    name.clone()
+                } else {
+                    let mut i = 2;
+                    loop {
+                        let name = format!("{name}{i}");
+                        if used_names.insert(name.clone()) {
+                            break name;
+                        }
+                        i += 1;
+                    }
+                };
+
+                let url = self.url_of(interface);
+                encoder
+                    .outer
+                    .import(&import_name, &url, ComponentTypeRef::Instance(idx));
             }
         }
         encoder.interface = None;
 
-        for (name, world) in self.resolve.packages[self.package].worlds.iter() {
-            let component_ty = encode_world(self.resolve, *world)?;
+        let doc = &self.resolve.documents[doc];
+        for (name, world) in doc.worlds.iter() {
+            let world = &self.resolve.worlds[*world];
+            let mut component = InterfaceEncoder::new(self.resolve);
+
+            for (name, import) in world.imports.iter() {
+                let (url, ty) = match import {
+                    WorldItem::Interface(i) => {
+                        component.interface = Some(*i);
+                        let idx = component.encode_instance(*i)?;
+                        (self.url_of(*i), ComponentTypeRef::Instance(idx))
+                    }
+                    WorldItem::Function(f) => {
+                        component.interface = None;
+                        let idx = component.encode_func_type(self.resolve, f)?;
+                        (String::new(), ComponentTypeRef::Func(idx))
+                    }
+                    WorldItem::Type(t) => {
+                        component.interface = None;
+                        component.import_types = true;
+                        component.encode_valtype(self.resolve, &Type::Id(*t))?;
+                        component.import_types = false;
+                        continue;
+                    }
+                };
+                component.outer.import(name, &url, ty);
+            }
+
+            for (name, export) in world.exports.iter() {
+                let (url, ty) = match export {
+                    WorldItem::Interface(i) => {
+                        component.interface = Some(*i);
+                        let idx = component.encode_instance(*i)?;
+                        (self.url_of(*i), ComponentTypeRef::Instance(idx))
+                    }
+                    WorldItem::Function(f) => {
+                        component.interface = None;
+                        let idx = component.encode_func_type(self.resolve, f)?;
+                        (String::new(), ComponentTypeRef::Func(idx))
+                    }
+                    WorldItem::Type(_) => unreachable!(),
+                };
+                component.outer.export(name, &url, ty);
+            }
             let idx = encoder.outer.type_count();
-            encoder.outer.ty().component(&component_ty);
-            let id = self.resolve.packages[self.package].name.interface_id(name);
-            encoder.outer.export(&id, ComponentTypeRef::Component(idx));
+            encoder.outer.ty().component(&component.outer);
+            let url = format!("pkg:/{}/{name}", doc.name);
+            encoder
+                .outer
+                .export(&name, &url, ComponentTypeRef::Component(idx));
         }
 
-        let ty = self.component.component_type(&encoder.outer);
-        let id = self.resolve.packages[self.package].name.interface_id("wit");
-        self.component
-            .export(&id, ComponentExportKind::Type, ty, None);
-        Ok(())
+        Ok(self.component.component_type(&encoder.outer))
     }
 
     /// Recursively add all live interfaces reachable from `id` into the
@@ -147,6 +213,27 @@ impl Encoder<'_> {
         }
         assert!(interfaces.insert(id));
     }
+
+    fn url_of(&self, interface: InterfaceId) -> String {
+        let iface = &self.resolve.interfaces[interface];
+        let iface_name = match &iface.name {
+            Some(name) => name,
+            None => return String::new(),
+        };
+        let doc = &self.resolve.documents[iface.document];
+        let pkg = doc.package.unwrap();
+        let mut base = if pkg == self.package {
+            Url::parse("pkg:/").unwrap()
+        } else {
+            let pkg = &self.resolve.packages[pkg];
+            Url::parse(pkg.url.as_ref().unwrap()).unwrap()
+        };
+        let mut segments = base.path_segments_mut().unwrap();
+        segments.push(&doc.name);
+        segments.push(iface_name);
+        drop(segments);
+        base.to_string()
+    }
 }
 
 struct InterfaceEncoder<'a> {
@@ -183,41 +270,15 @@ impl InterfaceEncoder<'_> {
     fn encode_instance(&mut self, interface: InterfaceId) -> Result<u32> {
         self.push_instance();
         let iface = &self.resolve.interfaces[interface];
-        let mut type_order = IndexSet::new();
         for (_, id) in iface.types.iter() {
             self.encode_valtype(self.resolve, &Type::Id(*id))?;
-            type_order.insert(*id);
         }
-
-        // Sort functions based on whether or not they're associated with
-        // resources.
-        //
-        // This is done here to ensure that when a WIT package is printed as WIT
-        // then decoded, or if it's printed as Wasm then decoded, the final
-        // result is the same. When printing via WIT resource methods are
-        // attached to the resource types themselves meaning that they'll appear
-        // intermingled with the rest of the types, namely first before all
-        // other functions. The purpose of this sort is to perform a stable sort
-        // over all functions by shuffling the resource-related functions first,
-        // in order of when their associated resource was encoded, and putting
-        // freestanding functions last.
-        //
-        // Note that this is not actually required for correctness, it's
-        // basically here to make fuzzing happy.
-        let mut funcs = iface.functions.iter().collect::<Vec<_>>();
-        funcs.sort_by_key(|(_name, func)| match func.kind {
-            FunctionKind::Freestanding => type_order.len(),
-            FunctionKind::Method(id) | FunctionKind::Constructor(id) | FunctionKind::Static(id) => {
-                type_order.get_index_of(&id).unwrap()
-            }
-        });
-
-        for (name, func) in funcs {
+        for (name, func) in iface.functions.iter() {
             let ty = self.encode_func_type(self.resolve, func)?;
             self.ty
                 .as_mut()
                 .unwrap()
-                .export(name, ComponentTypeRef::Func(ty));
+                .export(name, "", ComponentTypeRef::Func(ty));
         }
         let instance = self.pop_instance();
         let idx = self.outer.type_count();
@@ -263,40 +324,22 @@ impl<'a> ValtypeEncoder<'a> for InterfaceEncoder<'a> {
             Some(ty) => {
                 assert!(!self.import_types);
                 let ret = ty.type_count();
-                ty.export(name, ComponentTypeRef::Type(TypeBounds::Eq(index)));
+                ty.export(name, "", ComponentTypeRef::Type(TypeBounds::Eq, index));
                 Some(ret)
             }
             None => {
                 let ret = self.outer.type_count();
                 if self.import_types {
                     self.outer
-                        .import(name, ComponentTypeRef::Type(TypeBounds::Eq(index)));
+                        .import(name, "", ComponentTypeRef::Type(TypeBounds::Eq, index));
                 } else {
                     self.outer
-                        .export(name, ComponentTypeRef::Type(TypeBounds::Eq(index)));
+                        .export(name, "", ComponentTypeRef::Type(TypeBounds::Eq, index));
                 }
                 Some(ret)
             }
         }
     }
-    fn export_resource(&mut self, name: &'a str) -> u32 {
-        let type_ref = ComponentTypeRef::Type(TypeBounds::SubResource);
-        match &mut self.ty {
-            Some(ty) => {
-                assert!(!self.import_types);
-                ty.export(name, type_ref);
-                ty.type_count() - 1
-            }
-            None => {
-                if self.import_types {
-                    self.outer.import(name, type_ref);
-                } else {
-                    self.outer.export(name, type_ref);
-                }
-                self.outer.type_count() - 1
-            }
-        }
-    }
     fn type_map(&mut self) -> &mut HashMap<TypeId, u32> {
         &mut self.type_map
     }
@@ -332,79 +375,3 @@ impl<'a> ValtypeEncoder<'a> for InterfaceEncoder<'a> {
         &mut self.func_type_map
     }
 }
-
-/// Encodes a `world` as a component type.
-pub fn encode_world(resolve: &Resolve, world_id: WorldId) -> Result<ComponentType> {
-    let mut component = InterfaceEncoder::new(resolve);
-    let world = &resolve.worlds[world_id];
-    log::trace!("encoding world {}", world.name);
-
-    // This sort is similar in purpose to the sort below in
-    // `encode_instance`, but different in its sort. The purpose here is
-    // to ensure that when a document is either printed as WIT or
-    // encoded as wasm that decoding from those artifacts produces the
-    // same WIT package. Namely both encoding processes should encode
-    // things in the same order.
-    //
-    // When printing worlds in WIT freestanding function imports are
-    // printed first, then types. Resource functions are attached to
-    // types which means that they all come last. Sort all
-    // resource-related functions here to the back of the `imports` list
-    // while keeping everything else in front, using a stable sort to
-    // preserve preexisting ordering.
-    let mut imports = world.imports.iter().collect::<Vec<_>>();
-    imports.sort_by_key(|(_name, import)| match import {
-        WorldItem::Function(f) => match f.kind {
-            FunctionKind::Freestanding => 0,
-            _ => 1,
-        },
-        _ => 0,
-    });
-
-    // Encode the imports
-    for (name, import) in imports {
-        let name = resolve.name_world_key(name);
-        log::trace!("encoding import {name}");
-        let ty = match import {
-            WorldItem::Interface(i) => {
-                component.interface = Some(*i);
-                let idx = component.encode_instance(*i)?;
-                ComponentTypeRef::Instance(idx)
-            }
-            WorldItem::Function(f) => {
-                component.interface = None;
-                let idx = component.encode_func_type(resolve, f)?;
-                ComponentTypeRef::Func(idx)
-            }
-            WorldItem::Type(t) => {
-                component.interface = None;
-                component.import_types = true;
-                component.encode_valtype(resolve, &Type::Id(*t))?;
-                component.import_types = false;
-                continue;
-            }
-        };
-        component.outer.import(&name, ty);
-    }
-    // Encode the exports
-    for (name, export) in world.exports.iter() {
-        let name = resolve.name_world_key(name);
-        log::trace!("encoding export {name}");
-        let ty = match export {
-            WorldItem::Interface(i) => {
-                component.interface = Some(*i);
-                let idx = component.encode_instance(*i)?;
-                ComponentTypeRef::Instance(idx)
-            }
-            WorldItem::Function(f) => {
-                component.interface = None;
-                let idx = component.encode_func_type(resolve, f)?;
-                ComponentTypeRef::Func(idx)
-            }
-            WorldItem::Type(_) => unreachable!(),
-        };
-        component.outer.export(&name, ty);
-    }
-
-    Ok(component.outer)
-}
diff --git a/crates/wit-component/src/encoding/world.rs b/crates/wit-component/src/encoding/world.rs
index 71bc4bc0..7771482f 100644
--- a/crates/wit-component/src/encoding/world.rs
+++ b/crates/wit-component/src/encoding/world.rs
@@ -1,18 +1,15 @@
 use super::{ComponentEncoder, RequiredOptions};
 use crate::validation::{
-    validate_adapter_module, validate_module, RequiredImports, ValidatedAdapter, ValidatedModule,
-    BARE_FUNC_MODULE_NAME, RESOURCE_DROP,
+    validate_adapter_module, validate_module, ValidatedAdapter, ValidatedModule,
+    BARE_FUNC_MODULE_NAME,
 };
 use anyhow::{Context, Result};
 use indexmap::{IndexMap, IndexSet};
-use std::borrow::Borrow;
-use std::collections::{HashMap, HashSet};
-use std::hash::Hash;
+use std::collections::HashSet;
 use wasmparser::FuncType;
 use wit_parser::{
     abi::{AbiVariant, WasmSignature, WasmType},
-    Function, InterfaceId, LiveTypes, Resolve, Type, TypeDefKind, TypeId, TypeOwner, WorldId,
-    WorldItem, WorldKey,
+    Function, InterfaceId, LiveTypes, Resolve, TypeId, TypeOwner, WorldId, WorldItem,
 };
 
 /// Metadata discovered from the state configured in a `ComponentEncoder`.
@@ -30,32 +27,32 @@ pub struct ComponentWorld<'a> {
     /// adapters. Additionally stores the gc'd wasm for each adapter.
     pub adapters: IndexMap<&'a str, (ValidatedAdapter<'a>, Vec<u8>)>,
     /// Map of all imports and descriptions of what they're importing.
-    pub import_map: IndexMap<Option<String>, ImportedInterface>,
+    pub import_map: IndexMap<Option<&'a str>, ImportedInterface<'a>>,
     /// Set of all live types which must be exported either because they're
     /// directly used or because they're transitively used.
     pub live_types: IndexMap<InterfaceId, IndexSet<TypeId>>,
-    /// For each exported interface in the desired world this map lists
-    /// the set of interfaces that it depends on which are also exported.
-    ///
-    /// This set is used to determine when types are imported/used whether they
-    /// come from imports or exports.
-    pub exports_used: HashMap<InterfaceId, HashSet<InterfaceId>>,
 }
 
 #[derive(Debug)]
-pub struct ImportedInterface {
-    pub lowerings: IndexMap<String, Lowering>,
-    pub interface: Option<InterfaceId>,
+pub struct ImportedInterface<'a> {
+    pub direct: Vec<DirectLowering<'a>>,
+    pub indirect: Vec<IndirectLowering<'a>>,
+    /// Required functions on the interface, or the filter on the functions list
+    /// in `interface`.
+    pub required: HashSet<&'a str>,
+    pub interface: Option<(InterfaceId, String)>,
 }
 
 #[derive(Debug)]
-pub enum Lowering {
-    Direct,
-    Indirect {
-        sig: WasmSignature,
-        options: RequiredOptions,
-    },
-    ResourceDrop(TypeId),
+pub struct DirectLowering<'a> {
+    pub name: &'a str,
+}
+
+#[derive(Debug)]
+pub struct IndirectLowering<'a> {
+    pub name: &'a str,
+    pub sig: WasmSignature,
+    pub options: RequiredOptions,
 }
 
 impl<'a> ComponentWorld<'a> {
@@ -65,12 +62,7 @@ impl<'a> ComponentWorld<'a> {
             .keys()
             .map(|s| s.as_str())
             .collect::<IndexSet<_>>();
-        let info = validate_module(
-            &encoder.module,
-            &encoder.metadata,
-            &encoder.main_module_exports,
-            &adapters,
-        )?;
+        let info = validate_module(&encoder.module, &encoder.metadata, &adapters)?;
 
         let mut ret = ComponentWorld {
             encoder,
@@ -78,13 +70,11 @@ impl<'a> ComponentWorld<'a> {
             adapters: IndexMap::new(),
             import_map: IndexMap::new(),
             live_types: Default::default(),
-            exports_used: HashMap::new(),
         };
 
         ret.process_adapters()?;
         ret.process_imports()?;
         ret.process_live_types();
-        ret.process_exports_used();
 
         Ok(ret)
     }
@@ -95,17 +85,15 @@ impl<'a> ComponentWorld<'a> {
     /// main module or they're part of the adapter's exports.
     fn process_adapters(&mut self) -> Result<()> {
         let resolve = &self.encoder.metadata.resolve;
-        let world = self.encoder.metadata.world;
-        for (name, (wasm, metadata, required_exports)) in self.encoder.adapters.iter() {
+        for (name, (wasm, metadata, world)) in self.encoder.adapters.iter() {
             let required_by_import = self.info.adapters_required.get(name.as_str());
-            let required =
-                self.required_adapter_exports(resolve, world, required_exports, required_by_import);
+            let required = self.required_adapter_exports(resolve, *world, required_by_import);
             if required.is_empty() {
                 continue;
             }
             let wasm = crate::gc::run(wasm, &required, self.info.realloc)
                 .context("failed to reduce input adapter module to its minimal size")?;
-            let info = validate_adapter_module(&wasm, resolve, world, metadata, &required)
+            let info = validate_adapter_module(&wasm, resolve, *world, metadata, &required)
                 .context("failed to validate the imports of the minimized adapter module")?;
             self.adapters.insert(name, (info, wasm));
         }
@@ -119,7 +107,6 @@ impl<'a> ComponentWorld<'a> {
         &self,
         resolve: &Resolve,
         world: WorldId,
-        required_exports: &IndexSet<WorldKey>,
         required_by_import: Option<&IndexMap<&str, FuncType>>,
     ) -> IndexMap<String, FuncType> {
         use wasmparser::ValType;
@@ -142,13 +129,12 @@ impl<'a> ComponentWorld<'a> {
             );
             assert!(prev.is_none());
         };
-        for name in required_exports {
-            match &resolve.worlds[world].exports[name] {
+        for (name, item) in resolve.worlds[world].exports.iter() {
+            match item {
                 WorldItem::Function(func) => add_func(func, None),
                 WorldItem::Interface(id) => {
-                    let name = resolve.name_world_key(name);
                     for (_, func) in resolve.interfaces[*id].functions.iter() {
-                        add_func(func, Some(&name));
+                        add_func(func, Some(name));
                     }
                 }
                 WorldItem::Type(_) => {}
@@ -172,76 +158,96 @@ impl<'a> ComponentWorld<'a> {
     fn process_imports(&mut self) -> Result<()> {
         let resolve = &self.encoder.metadata.resolve;
         let world = self.encoder.metadata.world;
-        let mut all_required_imports = IndexMap::new();
-        for map in self.adapters.values().map(|(i, _)| &i.required_imports) {
-            for (k, v) in map {
-                all_required_imports
-                    .entry(k.as_str())
-                    .or_insert_with(IndexSet::new)
-                    .extend(v.funcs.iter().map(|v| v.as_str()));
-            }
-        }
-        for (k, v) in self.info.required_imports.iter() {
-            all_required_imports
-                .entry(*k)
-                .or_insert_with(IndexSet::new)
-                .extend(v.funcs.iter().map(|v| v.as_str()));
-        }
         for (name, item) in resolve.worlds[world].imports.iter() {
             add_item(
                 &mut self.import_map,
                 resolve,
                 name,
                 item,
-                &all_required_imports,
+                &self.info.required_imports,
             )?;
         }
+        for (adapter_name, (info, _wasm)) in self.adapters.iter() {
+            let (_, _, world) = self.encoder.adapters[*adapter_name];
+            for (name, item) in resolve.worlds[world].imports.iter() {
+                add_item(
+                    &mut self.import_map,
+                    resolve,
+                    name,
+                    item,
+                    &info.required_imports,
+                )?;
+            }
+        }
         return Ok(());
 
-        fn add_item(
-            import_map: &mut IndexMap<Option<String>, ImportedInterface>,
-            resolve: &Resolve,
-            name: &WorldKey,
-            item: &WorldItem,
+        fn add_item<'a>(
+            import_map: &mut IndexMap<Option<&'a str>, ImportedInterface<'a>>,
+            resolve: &'a Resolve,
+            name: &'a str,
+            item: &'a WorldItem,
             required: &IndexMap<&str, IndexSet<&str>>,
         ) -> Result<()> {
-            let name = resolve.name_world_key(name);
-            log::trace!("register import `{name}`");
             let empty = IndexSet::new();
-            let import_map_key = match item {
-                WorldItem::Function(_) | WorldItem::Type(_) => None,
-                WorldItem::Interface(_) => Some(name),
-            };
-            let interface_id = match item {
-                WorldItem::Function(_) | WorldItem::Type(_) => None,
-                WorldItem::Interface(id) => Some(*id),
-            };
-            let required = required
-                .get(import_map_key.as_deref().unwrap_or(BARE_FUNC_MODULE_NAME))
-                .unwrap_or(&empty);
-            let interface = import_map
-                .entry(import_map_key)
-                .or_insert_with(|| ImportedInterface {
-                    interface: interface_id,
-                    lowerings: Default::default(),
-                });
-            assert_eq!(interface.interface, interface_id);
             match item {
                 WorldItem::Function(func) => {
-                    interface.add_func(required, resolve, func);
-                }
-                WorldItem::Type(ty) => {
-                    interface.add_type(required, resolve, *ty);
+                    let required = required.get(BARE_FUNC_MODULE_NAME).unwrap_or(&empty);
+                    // If this function isn't actually required then skip it
+                    if !required.contains(name) {
+                        return Ok(());
+                    }
+                    let interface = import_map.entry(None).or_insert_with(|| ImportedInterface {
+                        interface: None,
+                        direct: Default::default(),
+                        indirect: Default::default(),
+                        required: Default::default(),
+                    });
+                    add_import(interface, resolve, func)
                 }
                 WorldItem::Interface(id) => {
-                    for (_name, ty) in resolve.interfaces[*id].types.iter() {
-                        interface.add_type(required, resolve, *ty);
-                    }
+                    let required = required.get(name).unwrap_or(&empty);
+                    let url = resolve.url_of(*id).unwrap_or(String::new());
+                    let interface =
+                        import_map
+                            .entry(Some(name))
+                            .or_insert_with(|| ImportedInterface {
+                                interface: Some((*id, url)),
+                                direct: Default::default(),
+                                indirect: Default::default(),
+                                required: Default::default(),
+                            });
                     for (_name, func) in resolve.interfaces[*id].functions.iter() {
-                        interface.add_func(required, resolve, func);
+                        // If this function isn't actually required then skip it
+                        if required.contains(func.name.as_str()) {
+                            add_import(interface, resolve, func)?;
+                        }
                     }
+                    Ok(())
                 }
+                WorldItem::Type(_) => Ok(()),
+            }
+        }
+
+        fn add_import<'a>(
+            interface: &mut ImportedInterface<'a>,
+            resolve: &'a Resolve,
+            func: &'a Function,
+        ) -> Result<()> {
+            if !interface.required.insert(func.name.as_str()) {
+                return Ok(());
+            }
+            let options = RequiredOptions::for_import(resolve, func);
+            if options.is_empty() {
+                interface.direct.push(DirectLowering { name: &func.name });
+            } else {
+                let sig = resolve.wasm_signature(AbiVariant::GuestImport, func);
+                interface.indirect.push(IndirectLowering {
+                    name: &func.name,
+                    sig,
+                    options,
+                });
             }
+
             Ok(())
         }
     }
@@ -252,15 +258,21 @@ impl<'a> ComponentWorld<'a> {
     fn process_live_types(&mut self) {
         let mut live = LiveTypes::default();
         let resolve = &self.encoder.metadata.resolve;
-        let world = self.encoder.metadata.world;
-        self.add_live_imports(world, &self.info.required_imports, &mut live);
+        let world = &resolve.worlds[self.encoder.metadata.world];
+        self.add_live_imports(
+            self.encoder.metadata.world,
+            &self.info.required_imports,
+            &mut live,
+        );
+        for (_, item) in world.exports.iter() {
+            live.add_world_item(resolve, item);
+        }
         for (adapter_name, (info, _wasm)) in self.adapters.iter() {
-            log::trace!("processing adapter `{adapter_name}`");
+            let (_, _, world) = self.encoder.adapters[*adapter_name];
             self.add_live_imports(world, &info.required_imports, &mut live);
-        }
-        for (name, item) in resolve.worlds[world].exports.iter() {
-            log::trace!("add live world export `{}`", resolve.name_world_key(name));
-            live.add_world_item(resolve, item);
+            for (_, item) in resolve.worlds[world].exports.iter() {
+                live.add_world_item(resolve, item);
+            }
         }
 
         for live in live.iter() {
@@ -275,27 +287,23 @@ impl<'a> ComponentWorld<'a> {
         }
     }
 
-    fn add_live_imports<S>(
+    fn add_live_imports(
         &self,
         world: WorldId,
-        required: &IndexMap<S, RequiredImports>,
+        required: &IndexMap<&str, IndexSet<&str>>,
         live: &mut LiveTypes,
-    ) where
-        S: Borrow<str> + Hash + Eq,
-    {
+    ) {
         let resolve = &self.encoder.metadata.resolve;
         for (name, item) in resolve.worlds[world].imports.iter() {
-            let name = resolve.name_world_key(name);
             match item {
                 WorldItem::Function(func) => {
                     let required = match required.get(BARE_FUNC_MODULE_NAME) {
                         Some(set) => set,
                         None => continue,
                     };
-                    if !required.funcs.contains(name.as_str()) {
+                    if !required.contains(name.as_str()) {
                         continue;
                     }
-                    log::trace!("add live function import `{name}`");
                     live.add_func(resolve, func);
                 }
                 WorldItem::Interface(id) => {
@@ -303,104 +311,14 @@ impl<'a> ComponentWorld<'a> {
                         Some(set) => set,
                         None => continue,
                     };
-                    log::trace!("add live interface import `{name}`");
                     for (name, func) in resolve.interfaces[*id].functions.iter() {
-                        if required.funcs.contains(name.as_str()) {
-                            log::trace!("add live func `{name}`");
+                        if required.contains(name.as_str()) {
                             live.add_func(resolve, func);
                         }
                     }
-                    for (name, ty) in resolve.interfaces[*id].types.iter() {
-                        if required.resources.contains(name.as_str()) {
-                            live.add_type_id(resolve, *ty);
-                        }
-                    }
                 }
                 WorldItem::Type(id) => live.add_type_id(resolve, *id),
             }
         }
     }
-
-    fn process_exports_used(&mut self) {
-        let resolve = &self.encoder.metadata.resolve;
-        let world = self.encoder.metadata.world;
-
-        let exports = &resolve.worlds[world].exports;
-        for (_name, item) in exports.iter() {
-            let id = match item {
-                WorldItem::Function(_) => continue,
-                WorldItem::Interface(id) => *id,
-                WorldItem::Type(_) => unreachable!(),
-            };
-            let mut set = HashSet::new();
-
-            for (_name, ty) in resolve.interfaces[id].types.iter() {
-                // Find `other` which `ty` is defined within to determine which
-                // interfaces this interface depends on.
-                let dep = match resolve.types[*ty].kind {
-                    TypeDefKind::Type(Type::Id(id)) => id,
-                    _ => continue,
-                };
-                let other = match resolve.types[dep].owner {
-                    TypeOwner::Interface(id) => id,
-                    _ => continue,
-                };
-                if other == id {
-                    continue;
-                }
-
-                // If this dependency is not exported, then it'll show up
-                // through an import, so we're not interested in it.
-                if !exports.contains_key(&WorldKey::Interface(other)) {
-                    continue;
-                }
-
-                // Otherwise this is a new exported dependency of ours, and
-                // additionally this interface inherits all the transitive
-                // dependencies too.
-                if set.insert(other) {
-                    set.extend(self.exports_used[&other].iter().copied());
-                }
-            }
-            let prev = self.exports_used.insert(id, set);
-            assert!(prev.is_none());
-        }
-    }
-}
-
-impl ImportedInterface {
-    fn add_func(&mut self, required: &IndexSet<&str>, resolve: &Resolve, func: &Function) {
-        if !required.contains(func.name.as_str()) {
-            return;
-        }
-        log::trace!("add func {}", func.name);
-        let options = RequiredOptions::for_import(resolve, func);
-        let lowering = if options.is_empty() {
-            Lowering::Direct
-        } else {
-            let sig = resolve.wasm_signature(AbiVariant::GuestImport, func);
-            Lowering::Indirect { sig, options }
-        };
-
-        let prev = self.lowerings.insert(func.name.clone(), lowering);
-        assert!(prev.is_none());
-    }
-
-    fn add_type(&mut self, required: &IndexSet<&str>, resolve: &Resolve, id: TypeId) {
-        let ty = &resolve.types[id];
-        match &ty.kind {
-            TypeDefKind::Resource => {}
-            _ => return,
-        }
-        let name = ty.name.as_deref().expect("resources must be named");
-
-        let mut maybe_add = |name: String, lowering: Lowering| {
-            if !required.contains(name.as_str()) {
-                return;
-            }
-            let prev = self.lowerings.insert(name, lowering);
-            assert!(prev.is_none());
-        };
-        maybe_add(format!("{RESOURCE_DROP}{name}"), Lowering::ResourceDrop(id));
-    }
 }
diff --git a/crates/wit-component/src/gc.rs b/crates/wit-component/src/gc.rs
index a742946c..2e057c80 100644
--- a/crates/wit-component/src/gc.rs
+++ b/crates/wit-component/src/gc.rs
@@ -2,7 +2,6 @@ use self::bitvec::BitVec;
 use anyhow::{bail, Result};
 use indexmap::{IndexMap, IndexSet};
 use std::{
-    borrow::Cow,
     collections::{HashMap, HashSet},
     mem,
     ops::Deref,
@@ -118,10 +117,10 @@ fn realloc_via_memory_grow() -> wasm_encoder::Function {
 
 #[repr(i32)]
 #[non_exhaustive]
-enum StackAllocationState {
-    Unallocated,
-    Allocating,
-    Allocated,
+enum AllocationState {
+    StackUnallocated,
+    StackAllocating,
+    StackAllocated,
 }
 
 fn allocate_stack_via_realloc(
@@ -136,10 +135,10 @@ fn allocate_stack_via_realloc(
     if let Some(allocation_state) = allocation_state {
         // This means we're lazily allocating the stack, keeping track of state via `$allocation_state`
         func.instruction(&GlobalGet(allocation_state));
-        func.instruction(&I32Const(StackAllocationState::Unallocated as _));
+        func.instruction(&I32Const(AllocationState::StackUnallocated as _));
         func.instruction(&I32Eq);
         func.instruction(&If(wasm_encoder::BlockType::Empty));
-        func.instruction(&I32Const(StackAllocationState::Allocating as _));
+        func.instruction(&I32Const(AllocationState::StackAllocating as _));
         func.instruction(&GlobalSet(allocation_state));
         // We could also set `sp` to zero here to ensure the yet-to-be-allocated stack is empty.  However, we
         // assume it defaults to zero anyway, in which case setting it would be redundant.
@@ -155,7 +154,7 @@ fn allocate_stack_via_realloc(
     func.instruction(&GlobalSet(sp));
 
     if let Some(allocation_state) = allocation_state {
-        func.instruction(&I32Const(StackAllocationState::Allocated as _));
+        func.instruction(&I32Const(AllocationState::StackAllocated as _));
         func.instruction(&GlobalSet(allocation_state));
         func.instruction(&End);
     }
@@ -178,7 +177,7 @@ type WorklistFunc<'a> = fn(&mut Module<'a>, u32) -> Result<()>;
 #[derive(Default)]
 struct Module<'a> {
     // Definitions found when parsing a module
-    types: Vec<SubType>,
+    types: Vec<wasmparser::Type>,
     tables: Vec<Table<'a>>,
     globals: Vec<Global<'a>>,
     memories: Vec<Memory<'a>>,
@@ -475,31 +474,15 @@ impl<'a> Module<'a> {
 
     fn valty(&mut self, ty: ValType) {
         match ty {
-            ValType::Ref(r) => self.heapty(r.heap_type()),
+            ValType::Ref(r) => self.heapty(r.heap_type),
             ValType::I32 | ValType::I64 | ValType::F32 | ValType::F64 | ValType::V128 => {}
         }
     }
 
-    fn storagety(&mut self, ty: StorageType) {
-        match ty {
-            StorageType::I8 | StorageType::I16 => {}
-            StorageType::Val(ty) => self.valty(ty),
-        }
-    }
-
     fn heapty(&mut self, ty: HeapType) {
         match ty {
-            HeapType::Func
-            | HeapType::Extern
-            | HeapType::Any
-            | HeapType::None
-            | HeapType::NoExtern
-            | HeapType::NoFunc
-            | HeapType::Eq
-            | HeapType::Struct
-            | HeapType::Array
-            | HeapType::I31 => {}
-            HeapType::Indexed(i) => self.ty(i),
+            HeapType::Func | HeapType::Extern => {}
+            HeapType::TypedFunc(i) => self.ty(i.into()),
         }
     }
 
@@ -508,21 +491,13 @@ impl<'a> Module<'a> {
             return;
         }
         self.worklist.push((ty, |me, ty| {
-            match me.types[ty as usize].clone().structural_type {
-                StructuralType::Func(ty) => {
-                    for param in ty.params().iter().chain(ty.results()) {
-                        me.valty(*param);
-                    }
-                }
-                StructuralType::Array(ArrayType(ty)) => {
-                    me.storagety(ty.element_type);
-                }
-                StructuralType::Struct(ty) => {
-                    for field in ty.fields.iter() {
-                        me.storagety(field.element_type);
-                    }
-                }
+            let ty = match me.types[ty as usize].clone() {
+                wasmparser::Type::Func(f) => f,
+                wasmparser::Type::Cont(_) => unimplemented!(), // TODO(dhil): revisit later
             };
+            for param in ty.params().iter().chain(ty.results()) {
+                me.valty(*param);
+            }
             Ok(())
         }));
     }
@@ -534,7 +509,7 @@ impl<'a> Module<'a> {
         Ok(())
     }
 
-    fn live_types(&self) -> impl Iterator<Item = (u32, &SubType)> + '_ {
+    fn live_types(&self) -> impl Iterator<Item = (u32, &wasmparser::Type)> + '_ {
         live_iter(&self.live_types, self.types.iter())
     }
 
@@ -574,15 +549,21 @@ impl<'a> Module<'a> {
         let mut empty_type = None;
         for (i, ty) in self.live_types() {
             map.types.push(i);
-            types.subtype(&map.subtype(ty));
-
-            // Keep track of the "empty type" to see if we can reuse an
-            // existing one or one needs to be injected if a `start`
-            // function is calculated at the end.
-            if let StructuralType::Func(ty) = &ty.structural_type {
-                if ty.params().is_empty() && ty.results().is_empty() {
-                    empty_type = Some(map.types.remap(i));
+            match ty {
+                Type::Func(ty) => {
+                    types.function(
+                        ty.params().iter().copied().map(|t| map.valty(t)),
+                        ty.results().iter().copied().map(|t| map.valty(t)),
+                    );
+
+                    // Keep track of the "empty type" to see if we can reuse an
+                    // existing one or one needs to be injected if a `start`
+                    // function is calculated at the end.
+                    if ty.params().is_empty() && ty.results().is_empty() {
+                        empty_type = Some(map.types.remap(i));
+                    }
                 }
+                Type::Cont(_) => unimplemented!(), // TODO(dhil): revisit later.
             }
         }
 
@@ -958,8 +939,8 @@ impl<'a> Module<'a> {
         encode_subsection(0x07, &global_names);
         if !section.is_empty() {
             ret.section(&wasm_encoder::CustomSection {
-                name: "name".into(),
-                data: Cow::Borrowed(&section),
+                name: "name",
+                data: &section,
             });
         }
         if let Some(producers) = &self.producers {
@@ -1042,6 +1023,7 @@ macro_rules! define_visit {
     (mark_live $self:ident $arg:ident targets) => {};
     (mark_live $self:ident $arg:ident data_index) => {};
     (mark_live $self:ident $arg:ident elem_index) => {};
+    (mark_live $self:ident $arg:ident resumetable) => {}; // TODO(dhil): I don't understand what's going on here. I'll revisit later.
 }
 
 impl<'a> VisitOperator<'a> for Module<'a> {
@@ -1111,72 +1093,20 @@ impl Encoder {
         }
     }
 
-    fn storagety(&self, ty: StorageType) -> wasm_encoder::StorageType {
-        match ty {
-            StorageType::I8 => wasm_encoder::StorageType::I8,
-            StorageType::I16 => wasm_encoder::StorageType::I16,
-            StorageType::Val(ty) => wasm_encoder::StorageType::Val(self.valty(ty)),
-        }
-    }
-
     fn refty(&self, rt: wasmparser::RefType) -> wasm_encoder::RefType {
         wasm_encoder::RefType {
-            nullable: rt.is_nullable(),
-            heap_type: self.heapty(rt.heap_type()),
+            nullable: rt.nullable,
+            heap_type: self.heapty(rt.heap_type),
         }
     }
 
     fn heapty(&self, ht: wasmparser::HeapType) -> wasm_encoder::HeapType {
         match ht {
-            HeapType::Func => wasm_encoder::HeapType::Func,
-            HeapType::Extern => wasm_encoder::HeapType::Extern,
-            HeapType::Any => wasm_encoder::HeapType::Any,
-            HeapType::None => wasm_encoder::HeapType::None,
-            HeapType::NoExtern => wasm_encoder::HeapType::NoExtern,
-            HeapType::NoFunc => wasm_encoder::HeapType::NoFunc,
-            HeapType::Eq => wasm_encoder::HeapType::Eq,
-            HeapType::Struct => wasm_encoder::HeapType::Struct,
-            HeapType::Array => wasm_encoder::HeapType::Array,
-            HeapType::I31 => wasm_encoder::HeapType::I31,
-            HeapType::Indexed(idx) => wasm_encoder::HeapType::Indexed(self.types.remap(idx)),
-        }
-    }
-
-    fn subtype(&self, ty: &SubType) -> wasm_encoder::SubType {
-        wasm_encoder::SubType {
-            is_final: ty.is_final,
-            supertype_idx: ty.supertype_idx,
-            structural_type: self.structural_type(&ty.structural_type),
-        }
-    }
-
-    fn structural_type(&self, ty: &StructuralType) -> wasm_encoder::StructuralType {
-        match ty {
-            StructuralType::Func(ty) => {
-                wasm_encoder::StructuralType::Func(wasm_encoder::FuncType::new(
-                    ty.params().iter().map(|t| self.valty(*t)),
-                    ty.results().iter().map(|t| self.valty(*t)),
-                ))
-            }
-
-            StructuralType::Struct(ty) => {
-                wasm_encoder::StructuralType::Struct(wasm_encoder::StructType {
-                    fields: ty
-                        .fields
-                        .iter()
-                        .map(|f| wasm_encoder::FieldType {
-                            element_type: self.storagety(f.element_type),
-                            mutable: f.mutable,
-                        })
-                        .collect(),
-                })
+            wasmparser::HeapType::Func => wasm_encoder::HeapType::Func,
+            wasmparser::HeapType::Extern => wasm_encoder::HeapType::Extern,
+            wasmparser::HeapType::TypedFunc(idx) => {
+                wasm_encoder::HeapType::TypedFunc(self.types.remap(idx.into()).try_into().unwrap())
             }
-            StructuralType::Array(ty) => wasm_encoder::StructuralType::Array(
-                wasm_encoder::ArrayType(wasm_encoder::FieldType {
-                    element_type: self.storagety(ty.0.element_type),
-                    mutable: ty.0.mutable,
-                }),
-            ),
         }
     }
 }
@@ -1216,18 +1146,18 @@ macro_rules! define_encode {
         BrTable($arg.0, $arg.1)
     });
     (mk CallIndirect $ty:ident $table:ident $table_byte:ident) => ({
-        let _ = $table_byte;
+        drop($table_byte);
         CallIndirect { ty: $ty, table: $table }
     });
     (mk ReturnCallIndirect $ty:ident $table:ident) => (
         ReturnCallIndirect { ty: $ty, table: $table }
     );
     (mk MemorySize $mem:ident $mem_byte:ident) => ({
-        let _ = $mem_byte;
+        drop($mem_byte);
         MemorySize($mem)
     });
     (mk MemoryGrow $mem:ident $mem_byte:ident) => ({
-        let _ = $mem_byte;
+        drop($mem_byte);
         MemoryGrow($mem)
     });
     (mk I32Const $v:ident) => (I32Const($v));
@@ -1235,6 +1165,9 @@ macro_rules! define_encode {
     (mk F32Const $v:ident) => (F32Const(f32::from_bits($v.bits())));
     (mk F64Const $v:ident) => (F64Const(f64::from_bits($v.bits())));
     (mk V128Const $v:ident) => (V128Const($v.i128()));
+    (mk ResumeThrow $tag_index:ident $resumetable:ident) => ({
+        ResumeThrow($tag_index, $resumetable)
+    });
 
     // Catch-all for the translation of one payload argument which is typically
     // represented as a tuple-enum in wasm-encoder.
@@ -1274,6 +1207,9 @@ macro_rules! define_encode {
         $arg.targets().map(|i| i.unwrap()).collect::<Vec<_>>().into(),
         $arg.default(),
     ));
+    (map $self:ident $arg:ident resumetable) => (
+        $arg.targets().map(|r| r.unwrap()).collect::<Vec<_>>().into()
+    );
 }
 
 impl<'a> VisitOperator<'a> for Encoder {
diff --git a/crates/wit-component/src/lib.rs b/crates/wit-component/src/lib.rs
index d31c735b..1944efa6 100644
--- a/crates/wit-component/src/lib.rs
+++ b/crates/wit-component/src/lib.rs
@@ -12,13 +12,11 @@ mod decoding;
 mod encoding;
 mod gc;
 mod printing;
-mod targets;
 mod validation;
 
 pub use decoding::{decode, DecodedWasm};
 pub use encoding::{encode, ComponentEncoder};
 pub use printing::*;
-pub use targets::*;
 
 pub mod metadata;
 
@@ -28,10 +26,9 @@ pub use dummy::dummy_module;
 mod dummy;
 
 /// Supported string encoding formats.
-#[derive(Default, Debug, Copy, Clone, PartialEq, Eq, Hash)]
+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
 pub enum StringEncoding {
     /// Strings are encoded with UTF-8.
-    #[default]
     UTF8,
     /// Strings are encoded with UTF-16.
     UTF16,
@@ -39,6 +36,12 @@ pub enum StringEncoding {
     CompactUTF16,
 }
 
+impl Default for StringEncoding {
+    fn default() -> Self {
+        StringEncoding::UTF8
+    }
+}
+
 impl Display for StringEncoding {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         match self {
diff --git a/crates/wit-component/src/metadata.rs b/crates/wit-component/src/metadata.rs
index bc703588..005e518f 100644
--- a/crates/wit-component/src/metadata.rs
+++ b/crates/wit-component/src/metadata.rs
@@ -39,9 +39,9 @@ use indexmap::IndexMap;
 use wasm_encoder::Encode;
 use wasm_metadata::Producers;
 use wasmparser::BinaryReader;
-use wit_parser::{Package, PackageName, Resolve, World, WorldId, WorldItem};
+use wit_parser::{Document, Package, Resolve, World, WorldId, WorldItem};
 
-const CURRENT_VERSION: u8 = 0x03;
+const CURRENT_VERSION: u8 = 0x02;
 
 /// The result of decoding binding information from a WebAssembly binary.
 ///
@@ -62,26 +62,25 @@ impl Default for Bindgen {
     fn default() -> Bindgen {
         let mut resolve = Resolve::default();
         let package = resolve.packages.alloc(Package {
-            name: PackageName {
-                namespace: "root".to_string(),
-                name: "root".to_string(),
-                version: None,
-            },
+            name: "root".to_string(),
+            url: None,
+            documents: Default::default(),
+        });
+        let document = resolve.documents.alloc(Document {
+            name: "root".to_string(),
             interfaces: Default::default(),
             worlds: Default::default(),
+            default_world: None,
+            default_interface: None,
+            package: Some(package),
         });
         let world = resolve.worlds.alloc(World {
             name: "root".to_string(),
             docs: Default::default(),
             imports: Default::default(),
             exports: Default::default(),
-            includes: Default::default(),
-            include_names: Default::default(),
-            package: Some(package),
+            document,
         });
-        resolve.packages[package]
-            .worlds
-            .insert("root".to_string(), world);
         Bindgen {
             resolve,
             world,
@@ -155,7 +154,8 @@ pub fn encode(
     producers: Option<&Producers>,
 ) -> Result<Vec<u8>> {
     let world = &resolve.worlds[world];
-    let pkg = &resolve.packages[world.package.unwrap()];
+    let doc = &resolve.documents[world.document];
+    let pkg = &resolve.packages[doc.package.unwrap()];
 
     assert!(
         resolve
@@ -173,9 +173,11 @@ pub fn encode(
         StringEncoding::UTF16 => 0x01,
         StringEncoding::CompactUTF16 => 0x02,
     });
+    pkg.name.encode(&mut ret);
+    doc.name.encode(&mut ret);
     world.name.encode(&mut ret);
     // This appends a wasm binary encoded Component to the ret:
-    let mut component_builder = crate::encoding::encode_component(resolve, world.package.unwrap())?;
+    let mut component_builder = crate::encoding::encode_component(resolve, doc.package.unwrap())?;
 
     if let Some(p) = producers {
         component_builder.add_producers(p);
@@ -197,13 +199,16 @@ impl Bindgen {
             0x02 => StringEncoding::CompactUTF16,
             byte => bail!("invalid string encoding {byte:#x}"),
         };
+        let pkg_name = reader.read_string()?;
+        let doc_name = reader.read_string()?;
         let world_name = reader.read_string()?;
 
-        let (resolve, pkg) = match crate::decode(&data[reader.original_position()..])? {
+        let (resolve, pkg) = match crate::decode(pkg_name, &data[reader.original_position()..])? {
             DecodedWasm::WitPackage(resolve, pkg) => (resolve, pkg),
             DecodedWasm::Component(..) => bail!("expected an encoded wit package"),
         };
-        let world = resolve.packages[pkg].worlds[world_name];
+        let doc = resolve.packages[pkg].documents[doc_name];
+        let world = resolve.documents[doc].worlds[world_name];
         let metadata = ModuleMetadata::new(&resolve, world, encoding);
         let producers = wasm_metadata::Producers::from_wasm(&data[reader.original_position()..])?;
         Ok(Bindgen {
@@ -223,7 +228,7 @@ impl Bindgen {
     ///
     /// Note that at this time there's no support for changing string encodings
     /// between metadata.
-    pub fn merge(&mut self, other: Bindgen) -> Result<WorldId> {
+    pub fn merge(&mut self, other: Bindgen) -> Result<()> {
         let Bindgen {
             resolve,
             world,
@@ -235,11 +240,7 @@ impl Bindgen {
             producers,
         } = other;
 
-        let world = self
-            .resolve
-            .merge(resolve)
-            .context("failed to merge WIT package sets together")?
-            .worlds[world.index()];
+        let world = self.resolve.merge(resolve).worlds[world.index()];
         self.resolve
             .merge_worlds(world, self.world)
             .context("failed to merge worlds from two documents")?;
@@ -274,7 +275,7 @@ impl Bindgen {
             }
         }
 
-        Ok(world)
+        Ok(())
     }
 }
 
@@ -286,7 +287,6 @@ impl ModuleMetadata {
 
         let world = &resolve.worlds[world];
         for (name, item) in world.imports.iter() {
-            let name = resolve.name_world_key(name);
             match item {
                 WorldItem::Function(_) => {
                     let prev = ret
@@ -307,16 +307,15 @@ impl ModuleMetadata {
         }
 
         for (name, item) in world.exports.iter() {
-            let name = resolve.name_world_key(name);
             match item {
                 WorldItem::Function(func) => {
                     let name = func.core_export_name(None).into_owned();
-                    let prev = ret.export_encodings.insert(name.clone(), encoding);
+                    let prev = ret.export_encodings.insert(name, encoding);
                     assert!(prev.is_none());
                 }
                 WorldItem::Interface(i) => {
                     for (_, func) in resolve.interfaces[*i].functions.iter() {
-                        let name = func.core_export_name(Some(&name)).into_owned();
+                        let name = func.core_export_name(Some(name)).into_owned();
                         let prev = ret.export_encodings.insert(name, encoding);
                         assert!(prev.is_none());
                     }
diff --git a/crates/wit-component/src/printing.rs b/crates/wit-component/src/printing.rs
index a93fb9be..72b84caf 100644
--- a/crates/wit-component/src/printing.rs
+++ b/crates/wit-component/src/printing.rs
@@ -1,32 +1,21 @@
 use anyhow::{anyhow, bail, Result};
-use std::collections::HashMap;
 use std::fmt::{self, Write};
-use std::mem;
 use wit_parser::*;
 
 /// A utility for printing WebAssembly interface definitions to a string.
 #[derive(Default)]
-pub struct WitPrinter {
+pub struct DocumentPrinter {
     output: Output,
-
-    // Count of how many items in this current block have been printed to print
-    // a blank line between each item, but not the first item.
-    any_items: bool,
 }
 
-impl WitPrinter {
-    /// Print the given WIT package to a string.
-    pub fn print(&mut self, resolve: &Resolve, pkgid: PackageId) -> Result<String> {
-        let pkg = &resolve.packages[pkgid];
-        self.output.push_str("package ");
-        self.print_name(&pkg.name.namespace);
-        self.output.push_str(":");
-        self.print_name(&pkg.name.name);
-        if let Some(version) = &pkg.name.version {
-            self.output.push_str(&format!("@{version}"));
-        }
-        self.output.push_str("\n\n");
-        for (name, id) in pkg.interfaces.iter() {
+impl DocumentPrinter {
+    /// Print the given `*.wit` document to a string.
+    pub fn print(&mut self, resolve: &Resolve, docid: DocumentId) -> Result<String> {
+        let doc = &resolve.documents[docid];
+        for (name, id) in doc.interfaces.iter() {
+            if Some(*id) == doc.default_interface {
+                self.output.push_str("default ");
+            }
             self.output.push_str("interface ");
             self.print_name(name);
             self.output.push_str(" {\n");
@@ -34,7 +23,10 @@ impl WitPrinter {
             writeln!(&mut self.output, "}}\n")?;
         }
 
-        for (name, id) in pkg.worlds.iter() {
+        for (name, id) in doc.worlds.iter() {
+            if Some(*id) == doc.default_world {
+                self.output.push_str("default ");
+            }
             self.output.push_str("world ");
             self.print_name(name);
             self.output.push_str(" {\n");
@@ -45,28 +37,10 @@ impl WitPrinter {
         Ok(std::mem::take(&mut self.output).into())
     }
 
-    fn new_item(&mut self) {
-        if self.any_items {
-            self.output.push_str("\n");
-        }
-        self.any_items = true;
-    }
-
     /// Print the given WebAssembly interface to a string.
     fn print_interface(&mut self, resolve: &Resolve, id: InterfaceId) -> Result<()> {
-        let prev_items = mem::replace(&mut self.any_items, false);
         let interface = &resolve.interfaces[id];
 
-        let mut resource_funcs = HashMap::new();
-        let mut freestanding = Vec::new();
-        for (name, func) in interface.functions.iter() {
-            if let Some(id) = resource_func(func) {
-                resource_funcs.entry(id).or_insert(Vec::new()).push(func);
-            } else {
-                freestanding.push((name, func));
-            }
-        }
-
         self.print_types(
             resolve,
             TypeOwner::Interface(id),
@@ -74,19 +48,18 @@ impl WitPrinter {
                 .types
                 .iter()
                 .map(|(name, id)| (name.as_str(), *id)),
-            &resource_funcs,
         )?;
 
-        for (name, func) in freestanding {
-            self.new_item();
+        for (i, (name, func)) in interface.functions.iter().enumerate() {
+            if i > 0 {
+                self.output.push_str("\n");
+            }
             self.print_name(name);
             self.output.push_str(": ");
             self.print_function(resolve, func)?;
             self.output.push_str("\n");
         }
 
-        self.any_items = prev_items;
-
         Ok(())
     }
 
@@ -95,7 +68,6 @@ impl WitPrinter {
         resolve: &Resolve,
         owner: TypeOwner,
         types: impl Iterator<Item = (&'a str, TypeId)>,
-        resource_funcs: &HashMap<TypeId, Vec<&Function>>,
     ) -> Result<()> {
         // Partition types defined in this interface into either those imported
         // from foreign interfaces or those defined locally.
@@ -129,13 +101,13 @@ impl WitPrinter {
         }
 
         // Generate a `use` statement for all imported types.
-        let my_pkg = match owner {
-            TypeOwner::Interface(id) => resolve.interfaces[id].package.unwrap(),
-            TypeOwner::World(id) => resolve.worlds[id].package.unwrap(),
+        let my_doc = match owner {
+            TypeOwner::Interface(id) => resolve.interfaces[id].document,
+            TypeOwner::World(id) => resolve.worlds[id].document,
             TypeOwner::None => unreachable!(),
         };
+        let amt_to_import = types_to_import.len();
         for (owner, tys) in types_to_import {
-            self.any_items = true;
             write!(&mut self.output, "use ")?;
             let id = match owner {
                 TypeOwner::Interface(id) => id,
@@ -143,7 +115,7 @@ impl WitPrinter {
                 // this time.
                 _ => unreachable!(),
             };
-            self.print_path_to_interface(resolve, id, my_pkg)?;
+            self.print_path_to_interface(resolve, id, my_doc)?;
             write!(&mut self.output, ".{{")?;
             for (i, (my_name, other_name)) in tys.into_iter().enumerate() {
                 if i > 0 {
@@ -160,65 +132,20 @@ impl WitPrinter {
             writeln!(&mut self.output, "}}")?;
         }
 
-        for id in types_to_declare {
-            self.new_item();
-            match resolve.types[id].kind {
-                TypeDefKind::Resource => self.print_resource(
-                    resolve,
-                    id,
-                    resource_funcs.get(&id).unwrap_or(&Vec::new()),
-                )?,
-                _ => self.declare_type(resolve, &Type::Id(id))?,
-            }
-        }
-
-        Ok(())
-    }
-
-    fn print_resource(&mut self, resolve: &Resolve, id: TypeId, funcs: &[&Function]) -> Result<()> {
-        let ty = &resolve.types[id];
-        self.output.push_str("resource ");
-        self.print_name(ty.name.as_ref().expect("resources must be named"));
-        if funcs.is_empty() {
+        if amt_to_import > 0 && types_to_declare.len() > 0 {
             self.output.push_str("\n");
-            return Ok(());
         }
-        self.output.push_str(" {\n");
-        for func in funcs {
-            match &func.kind {
-                FunctionKind::Constructor(_) => {}
-                FunctionKind::Method(_) => {
-                    self.print_name(func.item_name());
-                    self.output.push_str(": ");
-                }
-                FunctionKind::Static(_) => {
-                    self.print_name(func.item_name());
-                    self.output.push_str(": ");
-                    self.output.push_str("static ");
-                }
-                FunctionKind::Freestanding => unreachable!(),
-            }
-            self.print_function(resolve, func)?;
-            self.output.push_str("\n");
+
+        for id in types_to_declare {
+            self.declare_type(resolve, &Type::Id(id))?;
         }
-        self.output.push_str("}\n");
 
         Ok(())
     }
 
     fn print_function(&mut self, resolve: &Resolve, func: &Function) -> Result<()> {
-        // Constructors are named slightly differently.
-        match &func.kind {
-            FunctionKind::Constructor(_) => self.output.push_str("constructor("),
-            _ => self.output.push_str("func("),
-        }
-
-        // Methods don't print their `self` argument
-        let params_to_skip = match &func.kind {
-            FunctionKind::Method(_) => 1,
-            _ => 0,
-        };
-        for (i, (name, ty)) in func.params.iter().skip(params_to_skip).enumerate() {
+        self.output.push_str("func(");
+        for (i, (name, ty)) in func.params.iter().enumerate() {
             if i > 0 {
                 self.output.push_str(", ");
             }
@@ -228,11 +155,6 @@ impl WitPrinter {
         }
         self.output.push_str(")");
 
-        // constructors don't have their results printed
-        if let FunctionKind::Constructor(_) = func.kind {
-            return Ok(());
-        }
-
         match &func.results {
             Results::Named(rs) => match rs.len() {
                 0 => (),
@@ -258,85 +180,53 @@ impl WitPrinter {
     }
 
     fn print_world(&mut self, resolve: &Resolve, id: WorldId) -> Result<()> {
-        let prev_items = mem::replace(&mut self.any_items, false);
         let world = &resolve.worlds[id];
-        let pkgid = world.package.unwrap();
+        let docid = world.document;
         let mut types = Vec::new();
-        let mut resource_funcs = HashMap::new();
         for (name, import) in world.imports.iter() {
             match import {
-                WorldItem::Type(t) => match name {
-                    WorldKey::Name(s) => types.push((s.as_str(), *t)),
-                    WorldKey::Interface(_) => unreachable!(),
-                },
+                WorldItem::Type(t) => types.push((name.as_str(), *t)),
                 _ => {
-                    if let WorldItem::Function(f) = import {
-                        if let Some(id) = resource_func(f) {
-                            resource_funcs.entry(id).or_insert(Vec::new()).push(f);
-                            continue;
-                        }
-                    }
-                    self.print_world_item(resolve, name, import, pkgid, "import")?;
-                    // Don't put a blank line between imports, but count
-                    // imports as having printed something so if anything comes
-                    // after them then a blank line is printed after imports.
-                    self.any_items = true;
+                    self.print_world_item(resolve, name, import, docid, "import")?;
                 }
             }
         }
-        self.print_types(
-            resolve,
-            TypeOwner::World(id),
-            types.into_iter(),
-            &resource_funcs,
-        )?;
-        if !world.exports.is_empty() {
-            self.new_item();
-        }
+        self.print_types(resolve, TypeOwner::World(id), types.into_iter())?;
         for (name, export) in world.exports.iter() {
-            self.print_world_item(resolve, name, export, pkgid, "export")?;
+            self.print_world_item(resolve, name, export, docid, "export")?;
         }
-        self.any_items = prev_items;
         Ok(())
     }
 
     fn print_world_item(
         &mut self,
         resolve: &Resolve,
-        name: &WorldKey,
+        name: &str,
         item: &WorldItem,
-        cur_pkg: PackageId,
+        cur_doc: DocumentId,
         desc: &str,
     ) -> Result<()> {
         self.output.push_str(desc);
         self.output.push_str(" ");
-        match name {
-            WorldKey::Name(name) => {
-                self.print_name(name);
-                self.output.push_str(": ");
-                match item {
-                    WorldItem::Interface(id) => {
-                        assert!(resolve.interfaces[*id].name.is_none());
-                        writeln!(self.output, "interface {{")?;
-                        self.print_interface(resolve, *id)?;
-                        writeln!(self.output, "}}")?;
-                    }
-                    WorldItem::Function(f) => {
-                        self.print_function(resolve, f)?;
-                        self.output.push_str("\n");
-                    }
-                    // Types are handled separately
-                    WorldItem::Type(_) => unreachable!(),
+        self.print_name(name);
+        self.output.push_str(": ");
+        match item {
+            WorldItem::Interface(id) => {
+                if resolve.interfaces[*id].name.is_some() {
+                    self.print_path_to_interface(resolve, *id, cur_doc)?;
+                    self.output.push_str("\n");
+                } else {
+                    writeln!(self.output, "interface {{")?;
+                    self.print_interface(resolve, *id)?;
+                    writeln!(self.output, "}}")?;
                 }
             }
-            WorldKey::Interface(id) => {
-                match item {
-                    WorldItem::Interface(id2) => assert_eq!(id, id2),
-                    _ => unreachable!(),
-                }
-                self.print_path_to_interface(resolve, *id, cur_pkg)?;
+            WorldItem::Function(f) => {
+                self.print_function(resolve, f)?;
                 self.output.push_str("\n");
             }
+            // Types are handled separately
+            WorldItem::Type(_) => unreachable!(),
         }
         Ok(())
     }
@@ -345,22 +235,24 @@ impl WitPrinter {
         &mut self,
         resolve: &Resolve,
         interface: InterfaceId,
-        cur_pkg: PackageId,
+        cur_doc: DocumentId,
     ) -> Result<()> {
+        let cur_pkg = resolve.documents[cur_doc].package;
         let iface = &resolve.interfaces[interface];
-        if iface.package == Some(cur_pkg) {
-            self.print_name(iface.name.as_ref().unwrap());
+        let iface_doc = &resolve.documents[iface.document];
+        if iface.document == cur_doc {
+            self.output.push_str("self");
+        } else if cur_pkg == iface_doc.package {
+            self.output.push_str("pkg.");
+            self.print_name(&iface_doc.name);
         } else {
-            let pkg = &resolve.packages[iface.package.unwrap()].name;
-            self.print_name(&pkg.namespace);
-            self.output.push_str(":");
-            self.print_name(&pkg.name);
-            self.output.push_str("/");
-            self.print_name(iface.name.as_ref().unwrap());
-            if let Some(version) = &pkg.version {
-                self.output.push_str(&format!("@{version}"));
-            }
+            let iface_pkg = &resolve.packages[iface_doc.package.unwrap()];
+            self.print_name(&iface_pkg.name);
+            self.output.push_str(".");
+            self.print_name(&iface_doc.name);
         }
+        self.output.push_str(".");
+        self.print_name(iface.name.as_ref().unwrap());
         Ok(())
     }
 
@@ -388,12 +280,6 @@ impl WitPrinter {
                 }
 
                 match &ty.kind {
-                    TypeDefKind::Handle(h) => {
-                        self.print_handle_type(resolve, h, false)?;
-                    }
-                    TypeDefKind::Resource => {
-                        bail!("resolve has an unnamed resource type");
-                    }
                     TypeDefKind::Tuple(t) => {
                         self.print_tuple_type(resolve, t)?;
                     }
@@ -438,43 +324,6 @@ impl WitPrinter {
         Ok(())
     }
 
-    fn print_handle_type(
-        &mut self,
-        resolve: &Resolve,
-        handle: &Handle,
-        force_handle_type_printed: bool,
-    ) -> Result<()> {
-        match handle {
-            Handle::Own(ty) => {
-                let ty = &resolve.types[*ty];
-                if force_handle_type_printed {
-                    self.output.push_str("own<");
-                }
-                self.print_name(
-                    ty.name
-                        .as_ref()
-                        .ok_or_else(|| anyhow!("unnamed resource type"))?,
-                );
-                if force_handle_type_printed {
-                    self.output.push_str(">");
-                }
-            }
-
-            Handle::Borrow(ty) => {
-                self.output.push_str("borrow<");
-                let ty = &resolve.types[*ty];
-                self.print_name(
-                    ty.name
-                        .as_ref()
-                        .ok_or_else(|| anyhow!("unnamed resource type"))?,
-                );
-                self.output.push_str(">");
-            }
-        }
-
-        Ok(())
-    }
-
     fn print_tuple_type(&mut self, resolve: &Resolve, tuple: &Tuple) -> Result<()> {
         self.output.push_str("tuple<");
         for (i, ty) in tuple.types.iter().enumerate() {
@@ -552,10 +401,6 @@ impl WitPrinter {
             Type::Id(id) => {
                 let ty = &resolve.types[*id];
                 match &ty.kind {
-                    TypeDefKind::Handle(h) => {
-                        self.declare_handle(resolve, ty.name.as_deref(), h)?
-                    }
-                    TypeDefKind::Resource => panic!("resources should be processed separately"),
                     TypeDefKind::Record(r) => {
                         self.declare_record(resolve, ty.name.as_deref(), r)?
                     }
@@ -581,7 +426,7 @@ impl WitPrinter {
                             self.print_name(name);
                             self.output.push_str(" = ");
                             self.print_type_name(resolve, inner)?;
-                            self.output.push_str("\n");
+                            self.output.push_str("\n\n");
                         }
                         None => bail!("unnamed type in document"),
                     },
@@ -594,31 +439,6 @@ impl WitPrinter {
         Ok(())
     }
 
-    fn declare_handle(
-        &mut self,
-        resolve: &Resolve,
-        name: Option<&str>,
-        handle: &Handle,
-    ) -> Result<()> {
-        match name {
-            Some(name) => {
-                self.output.push_str("type ");
-                self.print_name(name);
-                self.output.push_str(" = ");
-                // Note that the `true` here forces owned handles to be printed
-                // as `own<T>`. The purpose of this is because `type a = b`, if
-                // `b` is a resource, is encoded differently as `type a =
-                // own<b>`. By forcing a handle to be printed here it's staying
-                // true to what's in the WIT document.
-                self.print_handle_type(resolve, handle, true)?;
-                self.output.push_str("\n");
-
-                Ok(())
-            }
-            None => bail!("document has unnamed handle type"),
-        }
-    }
-
     fn declare_record(
         &mut self,
         resolve: &Resolve,
@@ -636,7 +456,7 @@ impl WitPrinter {
                     self.print_type_name(resolve, &field.ty)?;
                     self.output.push_str(",\n");
                 }
-                self.output.push_str("}\n");
+                self.output.push_str("}\n\n");
                 Ok(())
             }
             None => bail!("document has unnamed record type"),
@@ -654,7 +474,7 @@ impl WitPrinter {
             self.print_name(name);
             self.output.push_str(" = ");
             self.print_tuple_type(resolve, tuple)?;
-            self.output.push_str("\n");
+            self.output.push_str("\n\n");
         }
         Ok(())
     }
@@ -669,7 +489,7 @@ impl WitPrinter {
                     self.print_name(&flag.name);
                     self.output.push_str(",\n");
                 }
-                self.output.push_str("}\n");
+                self.output.push_str("}\n\n");
             }
             None => bail!("document has unnamed flags type"),
         }
@@ -698,7 +518,7 @@ impl WitPrinter {
             }
             self.output.push_str(",\n");
         }
-        self.output.push_str("}\n");
+        self.output.push_str("}\n\n");
         Ok(())
     }
 
@@ -720,7 +540,7 @@ impl WitPrinter {
             self.print_type_name(resolve, &case.ty)?;
             self.output.push_str(",\n");
         }
-        self.output.push_str("}\n");
+        self.output.push_str("}\n\n");
         Ok(())
     }
 
@@ -735,7 +555,7 @@ impl WitPrinter {
             self.print_name(name);
             self.output.push_str(" = ");
             self.print_option_type(resolve, payload)?;
-            self.output.push_str("\n");
+            self.output.push_str("\n\n");
         }
         Ok(())
     }
@@ -751,7 +571,7 @@ impl WitPrinter {
             self.print_name(name);
             self.output.push_str(" = ");
             self.print_result_type(resolve, result)?;
-            self.output.push_str("\n");
+            self.output.push_str("\n\n");
         }
         Ok(())
     }
@@ -768,7 +588,7 @@ impl WitPrinter {
             self.print_name(&case.name);
             self.output.push_str(",\n");
         }
-        self.output.push_str("}\n");
+        self.output.push_str("}\n\n");
         Ok(())
     }
 
@@ -778,7 +598,7 @@ impl WitPrinter {
             self.print_name(name);
             self.output.push_str(" = list<");
             self.print_type_name(resolve, ty)?;
-            self.output.push_str(">\n");
+            self.output.push_str(">\n\n");
             return Ok(());
         }
 
@@ -793,61 +613,15 @@ impl WitPrinter {
     }
 }
 
-fn resource_func(f: &Function) -> Option<TypeId> {
-    match f.kind {
-        FunctionKind::Freestanding => None,
-        FunctionKind::Method(id) | FunctionKind::Constructor(id) | FunctionKind::Static(id) => {
-            Some(id)
-        }
-    }
-}
-
 fn is_keyword(name: &str) -> bool {
-    matches!(
-        name,
-        "use"
-            | "type"
-            | "func"
-            | "u8"
-            | "u16"
-            | "u32"
-            | "u64"
-            | "s8"
-            | "s16"
-            | "s32"
-            | "s64"
-            | "float32"
-            | "float64"
-            | "char"
-            | "resource"
-            | "record"
-            | "flags"
-            | "variant"
-            | "enum"
-            | "union"
-            | "bool"
-            | "string"
-            | "option"
-            | "result"
-            | "future"
-            | "stream"
-            | "list"
-            | "own"
-            | "borrow"
-            | "_"
-            | "as"
-            | "from"
-            | "static"
-            | "interface"
-            | "tuple"
-            | "world"
-            | "import"
-            | "export"
-            | "package"
-            | "with"
-            | "include"
-            | "constructor"
-    )
+    match name {
+        "use" | "type" | "func" | "u8" | "u16" | "u32" | "u64" | "s8" | "s16" | "s32" | "s64"
+        | "float32" | "float64" | "char" | "record" | "flags" | "variant" | "enum" | "union"
+        | "bool" | "string" | "option" | "result" | "future" | "stream" | "list" | "_" | "as"
+        | "from" | "static" | "interface" | "tuple" | "implements" | "world" | "import"
+        | "export" | "default" | "pkg" | "self" => true,
+        _ => false,
+    }
 }
 
 /// Helper structure to help maintain an indentation level when printing source,
diff --git a/crates/wit-component/src/targets.rs b/crates/wit-component/src/targets.rs
deleted file mode 100644
index 26d2168e..00000000
--- a/crates/wit-component/src/targets.rs
+++ /dev/null
@@ -1,47 +0,0 @@
-use crate::{builder::ComponentBuilder, encoding::encode_world};
-use anyhow::{Context, Result};
-use wasm_encoder::{ComponentExportKind, ComponentTypeRef};
-use wasmparser::{Validator, WasmFeatures};
-use wit_parser::{Resolve, WorldId};
-
-/// This function checks whether `component_to_test` correctly conforms to the world specified.
-/// It does so by instantiating a generated component that imports a component instance with
-/// the component type as described by the "target" world.
-pub fn targets(resolve: &Resolve, world: WorldId, component_to_test: &[u8]) -> Result<()> {
-    let mut root_component = ComponentBuilder::default();
-
-    // (1) Embed the component to test.
-    let component_to_test_idx = root_component.raw_component(component_to_test);
-
-    // (2) Encode the world to a component type and embed a new component which
-    // imports the encoded component type.
-    let test_component_idx = {
-        let component_ty = encode_world(resolve, world)?;
-        let mut component = ComponentBuilder::default();
-        let component_ty_idx = component.component_type(&component_ty);
-        component.import(
-            &resolve.worlds[world].name,
-            ComponentTypeRef::Component(component_ty_idx),
-        );
-        root_component.component(component)
-    };
-
-    // (3) Instantiate the component from (2) with the component to test from (1).
-    let args: Vec<(String, ComponentExportKind, u32)> = vec![(
-        resolve.worlds[world].name.clone(),
-        ComponentExportKind::Component,
-        component_to_test_idx,
-    )];
-    root_component.instantiate_component(test_component_idx, args);
-
-    let bytes = root_component.finish();
-
-    Validator::new_with_features(WasmFeatures {
-        component_model: true,
-        ..Default::default()
-    })
-    .validate_all(&bytes)
-    .context("failed to validate encoded bytes")?;
-
-    Ok(())
-}
diff --git a/crates/wit-component/src/validation.rs b/crates/wit-component/src/validation.rs
index 2ac456c2..89b04f7d 100644
--- a/crates/wit-component/src/validation.rs
+++ b/crates/wit-component/src/validation.rs
@@ -1,14 +1,13 @@
 use crate::metadata::{Bindgen, ModuleMetadata};
-use anyhow::{bail, Context, Result};
+use anyhow::{anyhow, bail, Context, Result};
 use indexmap::{map::Entry, IndexMap, IndexSet};
-use wasmparser::names::{KebabName, KebabNameKind};
 use wasmparser::{
-    types::Types, ComponentExternName, Encoding, ExternalKind, FuncType, Parser, Payload, TypeRef,
-    ValType, ValidPayload, Validator,
+    types::Types, Encoding, ExternalKind, FuncType, Parser, Payload, TypeRef, ValType,
+    ValidPayload, Validator,
 };
 use wit_parser::{
     abi::{AbiVariant, WasmSignature, WasmType},
-    Function, InterfaceId, PackageName, Resolve, TypeDefKind, TypeId, WorldId, WorldItem, WorldKey,
+    Function, InterfaceId, Resolve, WorldId, WorldItem,
 };
 
 fn is_canonical_function(name: &str) -> bool {
@@ -40,10 +39,6 @@ pub const MAIN_MODULE_IMPORT_NAME: &str = "__main_module__";
 /// turns into `env`.
 pub const BARE_FUNC_MODULE_NAME: &str = "$root";
 
-pub const RESOURCE_DROP: &str = "[resource-drop]";
-pub const RESOURCE_REP: &str = "[resource-rep]";
-pub const RESOURCE_NEW: &str = "[resource-new]";
-
 /// Metadata about a validated module and what was found internally.
 ///
 /// All imports to the module are described by the union of `required_imports`
@@ -58,7 +53,7 @@ pub struct ValidatedModule<'a> {
     /// from and the value is the set of functions required from that interface.
     /// This is used to generate an appropriate instance import in the generated
     /// component which imports only the set of required functions.
-    pub required_imports: IndexMap<&'a str, RequiredImports>,
+    pub required_imports: IndexMap<&'a str, IndexSet<&'a str>>,
 
     /// This is the set of imports into the module which were not satisfied by
     /// imported interfaces but are required to be satisfied by adapter modules.
@@ -70,42 +65,16 @@ pub struct ValidatedModule<'a> {
     /// export (and subsequently import) extraneous functions.
     pub adapters_required: IndexMap<&'a str, IndexMap<&'a str, FuncType>>,
 
-    /// Resource-related functions required and imported which work over
-    /// exported resources from the final component.
-    ///
-    /// Note that this is disjoint from `required_imports` which handles
-    /// imported resources and this is only for exported resources. Exported
-    /// resources still require intrinsics to be imported into the core module
-    /// itself.
-    pub required_resource_funcs: IndexMap<String, IndexMap<&'a str, ResourceInfo<'a>>>,
-
     /// Whether or not this module exported a linear memory.
     pub has_memory: bool,
 
     /// Whether or not this module exported a `cabi_realloc` function.
     pub realloc: Option<&'a str>,
 
-    /// Whether or not this module exported a `cabi_realloc_adapter` function.
-    pub adapter_realloc: Option<&'a str>,
-
     /// The original metadata specified for this module.
     pub metadata: &'a ModuleMetadata,
 }
 
-#[derive(Default)]
-pub struct RequiredImports {
-    pub funcs: IndexSet<String>,
-    pub resources: IndexSet<String>,
-}
-
-pub struct ResourceInfo<'a> {
-    pub drop_import: Option<&'a str>,
-    pub new_import: Option<&'a str>,
-    pub rep_import: Option<&'a str>,
-    pub dtor_export: Option<&'a str>,
-    pub id: TypeId,
-}
-
 /// This function validates the following:
 ///
 /// * The `bytes` represent a valid core WebAssembly module.
@@ -120,7 +89,6 @@ pub struct ResourceInfo<'a> {
 pub fn validate_module<'a>(
     bytes: &'a [u8],
     metadata: &'a Bindgen,
-    exports: &IndexSet<WorldKey>,
     adapters: &IndexSet<&str>,
 ) -> Result<ValidatedModule<'a>> {
     let mut validator = Validator::new();
@@ -132,9 +100,7 @@ pub fn validate_module<'a>(
         adapters_required: Default::default(),
         has_memory: false,
         realloc: None,
-        adapter_realloc: None,
         metadata: &metadata.metadata,
-        required_resource_funcs: Default::default(),
     };
 
     for payload in Parser::new(0).parse_all(bytes) {
@@ -178,9 +144,6 @@ pub fn validate_module<'a>(
                                 {
                                     ret.realloc = Some(export.name);
                                 }
-                                if export.name == "cabi_realloc_adapter" {
-                                    ret.adapter_realloc = Some(export.name);
-                                }
                                 continue;
                             }
 
@@ -201,112 +164,46 @@ pub fn validate_module<'a>(
 
     let types = types.unwrap();
     let world = &metadata.resolve.worlds[metadata.world];
-    let mut exported_resource_funcs = Vec::new();
 
     for (name, funcs) in &import_funcs {
         // An empty module name is indicative of the top-level import namespace,
         // so look for top-level functions here.
-        if *name == BARE_FUNC_MODULE_NAME {
-            let required =
-                validate_imports_top_level(&metadata.resolve, metadata.world, funcs, &types)?;
-            let prev = ret.required_imports.insert(BARE_FUNC_MODULE_NAME, required);
+        if *name == "$root" {
+            validate_imports_top_level(&metadata.resolve, metadata.world, funcs, &types)?;
+            let funcs = funcs.keys().cloned().collect();
+            let prev = ret.required_imports.insert(BARE_FUNC_MODULE_NAME, funcs);
             assert!(prev.is_none());
             continue;
         }
 
-        if let Some(interface_name) = name.strip_prefix("[export]") {
-            exported_resource_funcs.push((name, interface_name, &import_funcs[name]));
-            continue;
-        }
-
-        match world.imports.get(&world_key(&metadata.resolve, name)) {
+        match world.imports.get(*name) {
             Some(WorldItem::Interface(interface)) => {
-                let required =
+                let funcs =
                     validate_imported_interface(&metadata.resolve, *interface, name, funcs, &types)
                         .with_context(|| format!("failed to validate import interface `{name}`"))?;
-                let prev = ret.required_imports.insert(name, required);
+                let prev = ret.required_imports.insert(name, funcs);
                 assert!(prev.is_none());
             }
             None if adapters.contains(name) => {
                 let map = ret.adapters_required.entry(name).or_default();
                 for (func, ty) in funcs {
-                    let ty = types[types.core_type_at(*ty)].unwrap_func();
+                    let ty = types.func_type_at(*ty).unwrap();
                     map.insert(func, ty.clone());
                 }
             }
-            Some(WorldItem::Function(_) | WorldItem::Type(_)) => {
-                bail!("import `{}` is not an interface", name)
+            None | Some(WorldItem::Function(_) | WorldItem::Type(_)) => {
+                bail!("module requires an import interface named `{}`", name)
             }
-            None => bail!("module requires an import interface named `{name}`"),
         }
     }
 
-    for name in exports {
-        validate_exported_item(
-            &metadata.resolve,
-            &world.exports[name],
-            &metadata.resolve.name_world_key(name),
-            &export_funcs,
-            &types,
-            &mut ret,
-        )?;
-    }
-
-    for (name, interface_name, funcs) in exported_resource_funcs {
-        let world_key = world_key(&metadata.resolve, interface_name);
-        match world.exports.get(&world_key) {
-            Some(WorldItem::Interface(i)) => {
-                validate_exported_interface_resource_imports(
-                    &metadata.resolve,
-                    *i,
-                    name,
-                    funcs,
-                    &types,
-                    &mut ret,
-                )?;
-            }
-            _ => bail!("import from `{name}` does not correspond to exported interface"),
-        }
+    for (name, item) in world.exports.iter() {
+        validate_exported_item(&metadata.resolve, item, name, &export_funcs, &types)?;
     }
 
     Ok(ret)
 }
 
-fn validate_exported_interface_resource_imports<'a>(
-    resolve: &Resolve,
-    interface: InterfaceId,
-    import_module: &str,
-    funcs: &IndexMap<&'a str, u32>,
-    types: &Types,
-    info: &mut ValidatedModule<'a>,
-) -> Result<()> {
-    let is_resource = |name: &str| match resolve.interfaces[interface].types.get(name) {
-        Some(ty) => matches!(resolve.types[*ty].kind, TypeDefKind::Resource),
-        None => false,
-    };
-    for (func_name, ty) in funcs {
-        if valid_exported_resource_func(func_name, *ty, types, is_resource)?.is_none() {
-            bail!("import of `{func_name}` is not a valid resource function");
-        }
-        let info = info.required_resource_funcs.get_mut(import_module).unwrap();
-        if let Some(resource_name) = func_name.strip_prefix(RESOURCE_DROP) {
-            info[resource_name].drop_import = Some(func_name);
-            continue;
-        }
-        if let Some(resource_name) = func_name.strip_prefix(RESOURCE_NEW) {
-            info[resource_name].new_import = Some(func_name);
-            continue;
-        }
-        if let Some(resource_name) = func_name.strip_prefix(RESOURCE_REP) {
-            info[resource_name].rep_import = Some(func_name);
-            continue;
-        }
-
-        unreachable!();
-    }
-    Ok(())
-}
-
 /// Validation information from an "adapter module" which is distinct from a
 /// "main module" validated above.
 ///
@@ -315,7 +212,7 @@ pub struct ValidatedAdapter<'a> {
     /// If specified this is the list of required imports from the original set
     /// of possible imports along with the set of functions required from each
     /// imported interface.
-    pub required_imports: IndexMap<String, RequiredImports>,
+    pub required_imports: IndexMap<&'a str, IndexSet<&'a str>>,
 
     /// This is the module and field name of the memory import, if one is
     /// specified.
@@ -458,21 +355,35 @@ pub fn validate_adapter_module<'a>(
         // An empty module name is indicative of the top-level import namespace,
         // so look for top-level functions here.
         if name == BARE_FUNC_MODULE_NAME {
-            let required = validate_imports_top_level(resolve, world, &funcs, &types)?;
-            ret.required_imports
-                .insert(BARE_FUNC_MODULE_NAME.to_string(), required);
+            validate_imports_top_level(&resolve, world, &funcs, &types)?;
+            let funcs = resolve.worlds[world]
+                .imports
+                .iter()
+                .filter_map(|(name, item)| match item {
+                    WorldItem::Function(_) if funcs.contains_key(name.as_str()) => {
+                        Some(name.as_str())
+                    }
+                    _ => None,
+                })
+                .collect();
+            ret.required_imports.insert(BARE_FUNC_MODULE_NAME, funcs);
             continue;
         }
 
-        match resolve.worlds[world].imports.get(&world_key(resolve, name)) {
-            Some(WorldItem::Interface(interface)) => {
-                let required =
-                    validate_imported_interface(resolve, *interface, name, &funcs, &types)
-                        .with_context(|| format!("failed to validate import interface `{name}`"))?;
-                let prev = ret.required_imports.insert(name.to_string(), required);
+        match resolve.worlds[world].imports.get_full(name) {
+            Some((_, name, WorldItem::Interface(interface))) => {
+                validate_imported_interface(resolve, *interface, name, &funcs, &types)
+                    .with_context(|| format!("failed to validate import interface `{name}`"))?;
+                let funcs = resolve.interfaces[*interface]
+                    .functions
+                    .keys()
+                    .map(|s| s.as_str())
+                    .filter(|s| funcs.contains_key(s))
+                    .collect();
+                let prev = ret.required_imports.insert(name, funcs);
                 assert!(prev.is_none());
             }
-            None | Some(WorldItem::Function(_) | WorldItem::Type(_)) => {
+            None | Some((_, _, WorldItem::Function(_) | WorldItem::Type(_))) => {
                 bail!(
                     "adapter module requires an import interface named `{}`",
                     name
@@ -486,8 +397,7 @@ pub fn validate_adapter_module<'a>(
             Some(idx) => *idx,
             None => bail!("adapter module did not export `{name}`"),
         };
-        let id = types.function_at(idx);
-        let actual = types[id].unwrap_func();
+        let actual = types.function_at(idx).unwrap();
         if ty == actual {
             continue;
         }
@@ -506,149 +416,51 @@ pub fn validate_adapter_module<'a>(
     Ok(ret)
 }
 
-fn world_key(resolve: &Resolve, name: &str) -> WorldKey {
-    let name = if name.contains('/') {
-        ComponentExternName::Interface(name)
-    } else {
-        ComponentExternName::Kebab(name)
-    };
-    let kebab_name = KebabName::new(name, 0);
-    let (pkgname, interface) = match kebab_name.as_ref().map(|k| k.kind()) {
-        Ok(KebabNameKind::Id {
-            namespace,
-            package,
-            version,
-            interface,
-        }) => (
-            PackageName {
-                namespace: namespace.as_str().to_string(),
-                name: package.as_str().to_string(),
-                version,
-            },
-            interface.as_str(),
-        ),
-        _ => return WorldKey::Name(name.as_str().to_string()),
-    };
-    match resolve
-        .package_names
-        .get(&pkgname)
-        .and_then(|p| resolve.packages[*p].interfaces.get(interface))
-    {
-        Some(id) => WorldKey::Interface(*id),
-        None => WorldKey::Name(name.as_str().to_string()),
-    }
-}
-
-fn validate_imports_top_level(
+fn validate_imports_top_level<'a>(
     resolve: &Resolve,
     world: WorldId,
-    funcs: &IndexMap<&str, u32>,
+    funcs: &IndexMap<&'a str, u32>,
     types: &Types,
-) -> Result<RequiredImports> {
-    let is_resource = |name: &str| match resolve.worlds[world]
-        .imports
-        .get(&WorldKey::Name(name.to_string()))
-    {
-        Some(WorldItem::Type(r)) => {
-            matches!(resolve.types[*r].kind, TypeDefKind::Resource)
-        }
-        _ => false,
-    };
-    let mut required = RequiredImports::default();
+) -> Result<()> {
     for (name, ty) in funcs {
-        match resolve.worlds[world].imports.get(&world_key(resolve, name)) {
-            Some(WorldItem::Function(func)) => {
-                let ty = types[types.core_type_at(*ty)].unwrap_func();
-                validate_func(resolve, ty, func, AbiVariant::GuestImport)?;
-            }
+        let func = match resolve.worlds[world].imports.get(*name) {
+            Some(WorldItem::Function(func)) => func,
             Some(_) => bail!("expected world top-level import `{name}` to be a function"),
-            None => match valid_imported_resource_func(name, *ty, types, is_resource)? {
-                Some(name) => {
-                    required.resources.insert(name.to_string());
-                }
-                None => bail!("no top-level imported function `{name}` specified"),
-            },
-        }
-        required.funcs.insert(name.to_string());
-    }
-    Ok(required)
-}
-
-fn valid_imported_resource_func<'a>(
-    func_name: &'a str,
-    ty: u32,
-    types: &Types,
-    is_resource: impl Fn(&str) -> bool,
-) -> Result<Option<&'a str>> {
-    if let Some(resource_name) = func_name.strip_prefix(RESOURCE_DROP) {
-        if is_resource(resource_name) {
-            let ty = types[types.core_type_at(ty)].unwrap_func();
-            let expected = FuncType::new([ValType::I32], []);
-            validate_func_sig(func_name, &expected, ty)?;
-            return Ok(Some(resource_name));
-        }
-    }
-    Ok(None)
-}
-
-fn valid_exported_resource_func<'a>(
-    func_name: &'a str,
-    ty: u32,
-    types: &Types,
-    is_resource: impl Fn(&str) -> bool,
-) -> Result<Option<&'a str>> {
-    if let Some(name) = valid_imported_resource_func(func_name, ty, types, &is_resource)? {
-        return Ok(Some(name));
-    }
-    if let Some(resource_name) = func_name
-        .strip_prefix(RESOURCE_REP)
-        .or_else(|| func_name.strip_prefix(RESOURCE_NEW))
-    {
-        if is_resource(resource_name) {
-            let ty = types[types.core_type_at(ty)].unwrap_func();
-            let expected = FuncType::new([ValType::I32], [ValType::I32]);
-            validate_func_sig(func_name, &expected, ty)?;
-            return Ok(Some(resource_name));
-        }
+            None => bail!("no top-level imported function `{name}` specified"),
+        };
+        let ty = types.func_type_at(*ty).unwrap();
+        validate_func(resolve, ty, func, AbiVariant::GuestImport)?;
     }
-    Ok(None)
+    Ok(())
 }
 
-fn validate_imported_interface(
-    resolve: &Resolve,
+fn validate_imported_interface<'a>(
+    resolve: &'a Resolve,
     interface: InterfaceId,
     name: &str,
     imports: &IndexMap<&str, u32>,
     types: &Types,
-) -> Result<RequiredImports> {
-    let mut required = RequiredImports::default();
-    let is_resource = |name: &str| {
-        let ty = match resolve.interfaces[interface].types.get(name) {
-            Some(ty) => *ty,
-            None => return false,
-        };
-        matches!(resolve.types[ty].kind, TypeDefKind::Resource)
-    };
+) -> Result<IndexSet<&'a str>> {
+    let mut funcs = IndexSet::new();
     for (func_name, ty) in imports {
-        match resolve.interfaces[interface].functions.get(*func_name) {
-            Some(f) => {
-                let ty = types[types.core_type_at(*ty)].unwrap_func();
-                validate_func(resolve, ty, f, AbiVariant::GuestImport)?;
-            }
-            None => match valid_imported_resource_func(func_name, *ty, types, is_resource)? {
-                Some(name) => {
-                    required.resources.insert(name.to_string());
-                }
-                None => bail!(
-                    "import interface `{name}` is missing function \
-                         `{func_name}` that is required by the module",
-                ),
-            },
-        }
-        required.funcs.insert(func_name.to_string());
+        let f = resolve.interfaces[interface]
+            .functions
+            .get(*func_name)
+            .ok_or_else(|| {
+                anyhow!(
+                    "import interface `{}` is missing function `{}` that is required by the module",
+                    name,
+                    func_name,
+                )
+            })?;
+
+        let ty = types.func_type_at(*ty).unwrap();
+        validate_func(resolve, ty, f, AbiVariant::GuestImport)?;
+
+        funcs.insert(f.name.as_str());
     }
 
-    Ok(required)
+    Ok(funcs)
 }
 
 fn validate_func(
@@ -657,18 +469,11 @@ fn validate_func(
     func: &Function,
     abi: AbiVariant,
 ) -> Result<()> {
-    validate_func_sig(
-        &func.name,
-        &wasm_sig_to_func_type(resolve.wasm_signature(abi, func)),
-        ty,
-    )
-}
-
-fn validate_func_sig(name: &str, expected: &FuncType, ty: &wasmparser::FuncType) -> Result<()> {
-    if ty != expected {
+    let expected = wasm_sig_to_func_type(resolve.wasm_signature(abi, func));
+    if ty != &expected {
         bail!(
             "type mismatch for function `{}`: expected `{:?} -> {:?}` but found `{:?} -> {:?}`",
-            name,
+            func.name,
             expected.params(),
             expected.results(),
             ty.params(),
@@ -679,20 +484,18 @@ fn validate_func_sig(name: &str, expected: &FuncType, ty: &wasmparser::FuncType)
     Ok(())
 }
 
-fn validate_exported_item<'a>(
-    resolve: &'a Resolve,
-    item: &'a WorldItem,
+fn validate_exported_item(
+    resolve: &Resolve,
+    item: &WorldItem,
     export_name: &str,
-    exports: &IndexMap<&'a str, u32>,
+    exports: &IndexMap<&str, u32>,
     types: &Types,
-    info: &mut ValidatedModule<'a>,
 ) -> Result<()> {
     let validate = |func: &Function, name: Option<&str>| {
         let expected_export_name = func.core_export_name(name);
         match exports.get(expected_export_name.as_ref()) {
             Some(func_index) => {
-                let id = types.function_at(*func_index);
-                let ty = types[id].unwrap_func();
+                let ty = types.function_at(*func_index).unwrap();
                 validate_func(resolve, ty, func, AbiVariant::GuestExport)
             }
             None => bail!(
@@ -704,39 +507,11 @@ fn validate_exported_item<'a>(
     match item {
         WorldItem::Function(func) => validate(func, None)?,
         WorldItem::Interface(interface) => {
-            let interface = &resolve.interfaces[*interface];
-            for (_, f) in interface.functions.iter() {
+            for (_, f) in &resolve.interfaces[*interface].functions {
                 validate(f, Some(export_name)).with_context(|| {
                     format!("failed to validate exported interface `{export_name}`")
                 })?;
             }
-            let mut map = IndexMap::new();
-            for (name, id) in interface.types.iter() {
-                if !matches!(resolve.types[*id].kind, TypeDefKind::Resource) {
-                    continue;
-                }
-                let mut info = ResourceInfo {
-                    id: *id,
-                    dtor_export: None,
-                    drop_import: None,
-                    rep_import: None,
-                    new_import: None,
-                };
-                let dtor = format!("{export_name}#[dtor]{name}");
-                if let Some((_, name, func_idx)) = exports.get_full(dtor.as_str()) {
-                    let id = types.function_at(*func_idx);
-                    let ty = types[id].unwrap_func();
-                    let expected = FuncType::new([ValType::I32], []);
-                    validate_func_sig(name, &expected, ty)?;
-                    info.dtor_export = Some(name);
-                }
-                let prev = map.insert(name.as_str(), info);
-                assert!(prev.is_none());
-            }
-            let prev = info
-                .required_resource_funcs
-                .insert(format!("[export]{export_name}"), map);
-            assert!(prev.is_none());
         }
         // not required to have anything exported in the core wasm module
         WorldItem::Type(_) => {}
diff --git a/crates/wit-component/tests/components.rs b/crates/wit-component/tests/components.rs
index 694e67eb..c27988c2 100644
--- a/crates/wit-component/tests/components.rs
+++ b/crates/wit-component/tests/components.rs
@@ -1,9 +1,9 @@
-use anyhow::{bail, Context, Result};
+use anyhow::Result;
 use pretty_assertions::assert_eq;
-use std::{borrow::Cow, fs, path::Path};
+use std::{fs, path::Path};
 use wasm_encoder::{Encode, Section};
-use wit_component::{ComponentEncoder, DecodedWasm, StringEncoding, WitPrinter};
-use wit_parser::{PackageId, Resolve, UnresolvedPackage};
+use wit_component::{ComponentEncoder, DecodedWasm, DocumentPrinter, StringEncoding};
+use wit_parser::{Resolve, UnresolvedPackage};
 
 /// Tests the encoding of components.
 ///
@@ -48,28 +48,17 @@ fn component_encoding_via_flags() -> Result<()> {
         let test_case = path.file_stem().unwrap().to_str().unwrap();
         println!("testing {test_case}");
 
-        let mut resolve = Resolve::default();
-        let (pkg, _) = resolve.push_dir(&path)?;
-
         let module_path = path.join("module.wat");
-        let module = read_core_module(&module_path, &resolve, pkg)?;
+        let module = read_core_module(&module_path)?;
         let mut encoder = ComponentEncoder::default().module(&module)?.validate(true);
-        encoder = add_adapters(encoder, &path, &resolve, pkg)?;
+        encoder = add_adapters(encoder, &path)?;
         let component_path = path.join("component.wat");
-        let component_wit_path = path.join("component.wit.print");
+        let component_wit_path = path.join("component.wit");
         let error_path = path.join("error.txt");
 
         let bytes = match encoder.encode() {
-            Ok(bytes) => {
-                if test_case.starts_with("error-") {
-                    bail!("expected an error but got success");
-                }
-                bytes
-            }
+            Ok(bytes) => bytes,
             Err(err) => {
-                if !test_case.starts_with("error-") {
-                    return Err(err);
-                }
                 assert_output(&format!("{err:?}"), &error_path)?;
                 continue;
             }
@@ -77,18 +66,13 @@ fn component_encoding_via_flags() -> Result<()> {
 
         let wat = wasmprinter::print_bytes(&bytes)?;
         assert_output(&wat, &component_path)?;
-        let (pkg, resolve) = match wit_component::decode(&bytes)? {
+        let (doc, resolve) = match wit_component::decode("component", &bytes)? {
             DecodedWasm::WitPackage(..) => unreachable!(),
-            DecodedWasm::Component(resolve, world) => {
-                (resolve.worlds[world].package.unwrap(), resolve)
-            }
+            DecodedWasm::Component(resolve, world) => (resolve.worlds[world].document, resolve),
         };
-        let wit = WitPrinter::default().print(&resolve, pkg)?;
+        let wit = DocumentPrinter::default().print(&resolve, doc)?;
         assert_output(&wit, &component_wit_path)?;
 
-        UnresolvedPackage::parse(&component_wit_path, &wit)
-            .context("failed to parse printed WIT")?;
-
         // Check that the producer data got piped through properly
         let metadata = wasm_metadata::Metadata::from_binary(&bytes)?;
         match metadata {
@@ -121,33 +105,30 @@ fn component_encoding_via_flags() -> Result<()> {
     Ok(())
 }
 
-fn add_adapters(
-    mut encoder: ComponentEncoder,
-    path: &Path,
-    resolve: &Resolve,
-    pkg: PackageId,
-) -> Result<ComponentEncoder> {
+fn add_adapters(mut encoder: ComponentEncoder, path: &Path) -> Result<ComponentEncoder> {
     for adapter in glob::glob(path.join("adapt-*.wat").to_str().unwrap())? {
         let adapter = adapter?;
-        let wasm = read_core_module(&adapter, resolve, pkg)?;
+        let wasm = read_core_module(&adapter)?;
         let stem = adapter.file_stem().unwrap().to_str().unwrap();
         let name = stem.trim_start_matches("adapt-");
-        encoder = encoder.adapter(name, &wasm)?;
+        encoder = encoder.adapter(&name, &wasm)?;
     }
     Ok(encoder)
 }
 
 /// Parses the core wasm module at `path`, expected as a `*.wat` file.
 ///
-/// The `resolve` and `pkg` are the parsed WIT package from this test's
-/// directory and the `path`'s filename is used to find a WIT document of the
-/// corresponding name which should have a world that `path` ascribes to.
-fn read_core_module(path: &Path, resolve: &Resolve, pkg: PackageId) -> Result<Vec<u8>> {
+/// Additionally expects a sibling `*.wit` file which will be used to encode
+/// metadata into the binary returned here.
+fn read_core_module(path: &Path) -> Result<Vec<u8>> {
     let mut wasm = wat::parse_file(path)?;
-    let name = path.file_stem().and_then(|s| s.to_str()).unwrap();
-    let world = resolve
-        .select_world(pkg, Some(name))
-        .context("failed to select a world")?;
+    let interface = path.with_extension("wit");
+    let mut resolve = Resolve::default();
+    let pkg = resolve.push(
+        UnresolvedPackage::parse_file(&interface)?,
+        &Default::default(),
+    )?;
+    let world = resolve.select_world(pkg, None)?;
 
     // Add this producer data to the wit-component metadata so we can make sure it gets through the
     // translation:
@@ -155,11 +136,11 @@ fn read_core_module(path: &Path, resolve: &Resolve, pkg: PackageId) -> Result<Ve
     producers.add("processed-by", "my-fake-bindgen", "123.45");
 
     let encoded =
-        wit_component::metadata::encode(resolve, world, StringEncoding::UTF8, Some(&producers))?;
+        wit_component::metadata::encode(&resolve, world, StringEncoding::UTF8, Some(&producers))?;
 
     let section = wasm_encoder::CustomSection {
-        name: "component-type".into(),
-        data: Cow::Borrowed(&encoded),
+        name: "component-type",
+        data: &encoded,
     };
     wasm.push(section.id());
     section.encode(&mut wasm);
@@ -167,10 +148,7 @@ fn read_core_module(path: &Path, resolve: &Resolve, pkg: PackageId) -> Result<Ve
 }
 
 fn assert_output(contents: &str, path: &Path) -> Result<()> {
-    let contents = contents.replace("\r\n", "\n").replace(
-        concat!("\"", env!("CARGO_PKG_VERSION"), "\""),
-        "\"$CARGO_PKG_VERSION\"",
-    );
+    let contents = contents.replace("\r\n", "\n");
     if std::env::var_os("BLESS").is_some() {
         fs::write(path, contents)?;
     } else {
diff --git a/crates/wit-component/tests/components/adapt-empty-interface/adapt-old.wit b/crates/wit-component/tests/components/adapt-empty-interface/adapt-old.wit
index 3a1842c8..e38000c6 100644
--- a/crates/wit-component/tests/components/adapt-empty-interface/adapt-old.wit
+++ b/crates/wit-component/tests/components/adapt-empty-interface/adapt-old.wit
@@ -1,4 +1,4 @@
-world adapt-old {
+default world new {
   import new: interface {
     thunk-that-is-not-called: func()
   }
diff --git a/crates/wit-component/tests/components/adapt-empty-interface/component.wat b/crates/wit-component/tests/components/adapt-empty-interface/component.wat
index b9092467..f5b2b4e9 100644
--- a/crates/wit-component/tests/components/adapt-empty-interface/component.wat
+++ b/crates/wit-component/tests/components/adapt-empty-interface/component.wat
@@ -2,10 +2,6 @@
   (core module (;0;)
     (type (;0;) (func))
     (import "old" "thunk" (func (;0;) (type 0)))
-    (@producers
-      (processed-by "wit-component" "$CARGO_PKG_VERSION")
-      (processed-by "my-fake-bindgen" "123.45")
-    )
   )
   (core module (;1;)
     (type (;0;) (func))
@@ -21,18 +17,12 @@
     (table (;0;) 1 1 funcref)
     (export "0" (func $adapt-old-thunk))
     (export "$imports" (table 0))
-    (@producers
-      (processed-by "wit-component" "$CARGO_PKG_VERSION")
-    )
   )
   (core module (;3;)
     (type (;0;) (func))
     (import "" "0" (func (;0;) (type 0)))
     (import "" "$imports" (table (;0;) 1 1 funcref))
     (elem (;0;) (i32.const 0) func 0)
-    (@producers
-      (processed-by "wit-component" "$CARGO_PKG_VERSION")
-    )
   )
   (core instance (;0;) (instantiate 2))
   (alias core export 0 "0" (core func (;0;)))
@@ -46,9 +36,6 @@
   (core instance (;3;) (instantiate 1))
   (alias core export 0 "$imports" (core table (;0;)))
   (alias core export 3 "thunk" (core func (;1;)))
-  (@producers
-    (processed-by "wit-component" "$CARGO_PKG_VERSION")
-  )
   (core instance (;4;)
     (export "$imports" (table 0))
     (export "0" (func 1))
diff --git a/crates/wit-component/tests/components/adapt-empty-interface/component.wit b/crates/wit-component/tests/components/adapt-empty-interface/component.wit
new file mode 100644
index 00000000..da09ea6e
--- /dev/null
+++ b/crates/wit-component/tests/components/adapt-empty-interface/component.wit
@@ -0,0 +1,2 @@
+default world component {
+}
diff --git a/crates/wit-component/tests/components/adapt-empty-interface/component.wit.print b/crates/wit-component/tests/components/adapt-empty-interface/component.wit.print
deleted file mode 100644
index bcd860d3..00000000
--- a/crates/wit-component/tests/components/adapt-empty-interface/component.wit.print
+++ /dev/null
@@ -1,4 +0,0 @@
-package root:component
-
-world root {
-}
diff --git a/crates/wit-component/tests/components/adapt-empty-interface/module.wit b/crates/wit-component/tests/components/adapt-empty-interface/module.wit
index 65c2b792..1f99081f 100644
--- a/crates/wit-component/tests/components/adapt-empty-interface/module.wit
+++ b/crates/wit-component/tests/components/adapt-empty-interface/module.wit
@@ -1,2 +1 @@
-package foo:foo
-world module {}
+default world empty {}
diff --git a/crates/wit-component/tests/components/adapt-export-default/adapt-old.wit b/crates/wit-component/tests/components/adapt-export-default/adapt-old.wit
index 8e9934c7..ad8e6375 100644
--- a/crates/wit-component/tests/components/adapt-export-default/adapt-old.wit
+++ b/crates/wit-component/tests/components/adapt-export-default/adapt-old.wit
@@ -1,3 +1,3 @@
-world adapt-old {
+default world new {
   export entrypoint: func()
 }
diff --git a/crates/wit-component/tests/components/adapt-export-default/component.wat b/crates/wit-component/tests/components/adapt-export-default/component.wat
index cc474d9d..833335c7 100644
--- a/crates/wit-component/tests/components/adapt-export-default/component.wat
+++ b/crates/wit-component/tests/components/adapt-export-default/component.wat
@@ -3,10 +3,6 @@
     (type (;0;) (func))
     (func (;0;) (type 0))
     (export "the_entrypoint" (func 0))
-    (@producers
-      (processed-by "wit-component" "$CARGO_PKG_VERSION")
-      (processed-by "my-fake-bindgen" "123.45")
-    )
   )
   (core module (;1;)
     (type (;0;) (func))
@@ -25,8 +21,5 @@
   (type (;0;) (func))
   (alias core export 2 "entrypoint" (core func (;1;)))
   (func (;0;) (type 0) (canon lift (core func 1)))
-  (@producers
-    (processed-by "wit-component" "$CARGO_PKG_VERSION")
-  )
   (export (;1;) "entrypoint" (func 0))
 )
\ No newline at end of file
diff --git a/crates/wit-component/tests/components/adapt-export-default/component.wit b/crates/wit-component/tests/components/adapt-export-default/component.wit
new file mode 100644
index 00000000..9368d1d6
--- /dev/null
+++ b/crates/wit-component/tests/components/adapt-export-default/component.wit
@@ -0,0 +1,3 @@
+default world component {
+  export entrypoint: func()
+}
diff --git a/crates/wit-component/tests/components/adapt-export-default/component.wit.print b/crates/wit-component/tests/components/adapt-export-default/component.wit.print
deleted file mode 100644
index 3b698307..00000000
--- a/crates/wit-component/tests/components/adapt-export-default/component.wit.print
+++ /dev/null
@@ -1,5 +0,0 @@
-package root:component
-
-world root {
-  export entrypoint: func()
-}
diff --git a/crates/wit-component/tests/components/adapt-export-default/module.wit b/crates/wit-component/tests/components/adapt-export-default/module.wit
index 65c2b792..1f99081f 100644
--- a/crates/wit-component/tests/components/adapt-export-default/module.wit
+++ b/crates/wit-component/tests/components/adapt-export-default/module.wit
@@ -1,2 +1 @@
-package foo:foo
-world module {}
+default world empty {}
diff --git a/crates/wit-component/tests/components/adapt-export-namespaced/adapt-old.wat b/crates/wit-component/tests/components/adapt-export-namespaced/adapt-old.wat
index 0c4debd0..03a95369 100644
--- a/crates/wit-component/tests/components/adapt-export-namespaced/adapt-old.wat
+++ b/crates/wit-component/tests/components/adapt-export-namespaced/adapt-old.wat
@@ -1,4 +1,4 @@
 (module
   (import "__main_module__" "the_entrypoint" (func $entry))
-  (export "foo:foo/new#entrypoint" (func $entry))
+  (export "new#entrypoint" (func $entry))
 )
diff --git a/crates/wit-component/tests/components/adapt-export-namespaced/adapt-old.wit b/crates/wit-component/tests/components/adapt-export-namespaced/adapt-old.wit
index 177d5d17..4e4ff9c6 100644
--- a/crates/wit-component/tests/components/adapt-export-namespaced/adapt-old.wit
+++ b/crates/wit-component/tests/components/adapt-export-namespaced/adapt-old.wit
@@ -2,6 +2,6 @@ interface new {
   entrypoint: func()
 }
 
-world adapt-old {
-  export new
+default world brave-new-world {
+  export new: self.new
 }
diff --git a/crates/wit-component/tests/components/adapt-export-namespaced/component.wat b/crates/wit-component/tests/components/adapt-export-namespaced/component.wat
index 3d2f95a6..abe0b20f 100644
--- a/crates/wit-component/tests/components/adapt-export-namespaced/component.wat
+++ b/crates/wit-component/tests/components/adapt-export-namespaced/component.wat
@@ -3,15 +3,11 @@
     (type (;0;) (func))
     (func (;0;) (type 0))
     (export "the_entrypoint" (func 0))
-    (@producers
-      (processed-by "wit-component" "$CARGO_PKG_VERSION")
-      (processed-by "my-fake-bindgen" "123.45")
-    )
   )
   (core module (;1;)
     (type (;0;) (func))
     (import "__main_module__" "the_entrypoint" (func $entry (;0;) (type 0)))
-    (export "foo:foo/new#entrypoint" (func $entry))
+    (export "new#entrypoint" (func $entry))
   )
   (core instance (;0;) (instantiate 0))
   (alias core export 0 "the_entrypoint" (core func (;0;)))
@@ -23,20 +19,17 @@
     )
   )
   (type (;0;) (func))
-  (alias core export 2 "foo:foo/new#entrypoint" (core func (;1;)))
+  (alias core export 2 "new#entrypoint" (core func (;1;)))
   (func (;0;) (type 0) (canon lift (core func 1)))
   (component (;0;)
-    (type (;0;) (func))
-    (import "import-func-entrypoint" (func (;0;) (type 0)))
+    (alias outer 1 0 (type (;0;)))
+    (import "import-entrypoint" (func (;0;) (type 0)))
     (type (;1;) (func))
     (export (;1;) "entrypoint" (func 0) (func (type 1)))
   )
   (instance (;0;) (instantiate 0
-      (with "import-func-entrypoint" (func 0))
+      (with "import-entrypoint" (func 0))
     )
   )
-  (@producers
-    (processed-by "wit-component" "$CARGO_PKG_VERSION")
-  )
-  (export (;1;) (interface "foo:foo/new") (instance 0))
+  (export (;1;) "new" (instance 0))
 )
\ No newline at end of file
diff --git a/crates/wit-component/tests/components/adapt-export-namespaced/component.wit b/crates/wit-component/tests/components/adapt-export-namespaced/component.wit
new file mode 100644
index 00000000..90160cd8
--- /dev/null
+++ b/crates/wit-component/tests/components/adapt-export-namespaced/component.wit
@@ -0,0 +1,7 @@
+interface new {
+  entrypoint: func()
+}
+
+default world component {
+  export new: self.new
+}
diff --git a/crates/wit-component/tests/components/adapt-export-namespaced/component.wit.print b/crates/wit-component/tests/components/adapt-export-namespaced/component.wit.print
deleted file mode 100644
index d4d05432..00000000
--- a/crates/wit-component/tests/components/adapt-export-namespaced/component.wit.print
+++ /dev/null
@@ -1,5 +0,0 @@
-package root:component
-
-world root {
-  export foo:foo/new
-}
diff --git a/crates/wit-component/tests/components/adapt-export-namespaced/module.wit b/crates/wit-component/tests/components/adapt-export-namespaced/module.wit
index 3f66e96f..234a9191 100644
--- a/crates/wit-component/tests/components/adapt-export-namespaced/module.wit
+++ b/crates/wit-component/tests/components/adapt-export-namespaced/module.wit
@@ -1,3 +1 @@
-package foo:foo
-
-world module {}
+default world foo {}
diff --git a/crates/wit-component/tests/components/adapt-export-reallocs/adapt-old.wit b/crates/wit-component/tests/components/adapt-export-reallocs/adapt-old.wit
index 33ecfc28..d342fe79 100644
--- a/crates/wit-component/tests/components/adapt-export-reallocs/adapt-old.wit
+++ b/crates/wit-component/tests/components/adapt-export-reallocs/adapt-old.wit
@@ -1,4 +1,4 @@
-world adapt-old {
+default world brave-new-world {
   import new: interface {
     read: func(amt: u32) -> list<u8>
   }
diff --git a/crates/wit-component/tests/components/adapt-export-reallocs/component.wat b/crates/wit-component/tests/components/adapt-export-reallocs/component.wat
index ff68f3cf..aaa69c48 100644
--- a/crates/wit-component/tests/components/adapt-export-reallocs/component.wat
+++ b/crates/wit-component/tests/components/adapt-export-reallocs/component.wat
@@ -14,10 +14,6 @@
     (memory (;0;) 1)
     (export "main" (func 1))
     (export "memory" (memory 0))
-    (@producers
-      (processed-by "wit-component" "$CARGO_PKG_VERSION")
-      (processed-by "my-fake-bindgen" "123.45")
-    )
   )
   (core module (;1;)
     (type (;0;) (func (param i32 i32)))
@@ -72,9 +68,6 @@
     (export "0" (func $indirect-new-read))
     (export "1" (func $adapt-old-read))
     (export "$imports" (table 0))
-    (@producers
-      (processed-by "wit-component" "$CARGO_PKG_VERSION")
-    )
   )
   (core module (;3;)
     (type (;0;) (func (param i32 i32)))
@@ -83,9 +76,6 @@
     (import "" "1" (func (;1;) (type 1)))
     (import "" "$imports" (table (;0;) 2 2 funcref))
     (elem (;0;) (i32.const 0) func 0 1)
-    (@producers
-      (processed-by "wit-component" "$CARGO_PKG_VERSION")
-    )
   )
   (core instance (;0;) (instantiate 2))
   (alias core export 0 "1" (core func (;0;)))
@@ -124,8 +114,5 @@
   (type (;2;) (func (param "args" 1)))
   (alias core export 4 "entrypoint" (core func (;6;)))
   (func (;1;) (type 2) (canon lift (core func 6) (memory 0) (realloc 2) string-encoding=utf8))
-  (@producers
-    (processed-by "wit-component" "$CARGO_PKG_VERSION")
-  )
   (export (;2;) "entrypoint" (func 1))
 )
\ No newline at end of file
diff --git a/crates/wit-component/tests/components/adapt-export-reallocs/component.wit b/crates/wit-component/tests/components/adapt-export-reallocs/component.wit
new file mode 100644
index 00000000..49897fff
--- /dev/null
+++ b/crates/wit-component/tests/components/adapt-export-reallocs/component.wit
@@ -0,0 +1,8 @@
+interface new {
+  read: func(amt: u32) -> list<u8>
+}
+
+default world component {
+  import new: self.new
+  export entrypoint: func(args: list<string>)
+}
diff --git a/crates/wit-component/tests/components/adapt-export-reallocs/component.wit.print b/crates/wit-component/tests/components/adapt-export-reallocs/component.wit.print
deleted file mode 100644
index 183298fc..00000000
--- a/crates/wit-component/tests/components/adapt-export-reallocs/component.wit.print
+++ /dev/null
@@ -1,9 +0,0 @@
-package root:component
-
-world root {
-  import new: interface {
-    read: func(amt: u32) -> list<u8>
-  }
-
-  export entrypoint: func(args: list<string>)
-}
diff --git a/crates/wit-component/tests/components/adapt-export-reallocs/module.wit b/crates/wit-component/tests/components/adapt-export-reallocs/module.wit
index 3f66e96f..1f99081f 100644
--- a/crates/wit-component/tests/components/adapt-export-reallocs/module.wit
+++ b/crates/wit-component/tests/components/adapt-export-reallocs/module.wit
@@ -1,3 +1 @@
-package foo:foo
-
-world module {}
+default world empty {}
diff --git a/crates/wit-component/tests/components/adapt-export-save-args/adapt-old.wit b/crates/wit-component/tests/components/adapt-export-save-args/adapt-old.wit
index 2185e1f1..3f6bd6a2 100644
--- a/crates/wit-component/tests/components/adapt-export-save-args/adapt-old.wit
+++ b/crates/wit-component/tests/components/adapt-export-save-args/adapt-old.wit
@@ -1,3 +1,3 @@
-world adapt-old {
+default world brave-new-world {
   export entrypoint: func(nargs: u32)
 }
diff --git a/crates/wit-component/tests/components/adapt-export-save-args/component.wat b/crates/wit-component/tests/components/adapt-export-save-args/component.wat
index e13e3b94..c2f2da94 100644
--- a/crates/wit-component/tests/components/adapt-export-save-args/component.wat
+++ b/crates/wit-component/tests/components/adapt-export-save-args/component.wat
@@ -5,10 +5,6 @@
     (import "old" "nargs" (func (;0;) (type 0)))
     (func (;1;) (type 1))
     (export "the_entrypoint" (func 1))
-    (@producers
-      (processed-by "wit-component" "$CARGO_PKG_VERSION")
-      (processed-by "my-fake-bindgen" "123.45")
-    )
   )
   (core module (;1;)
     (type (;0;) (func))
@@ -36,18 +32,12 @@
     (table (;0;) 1 1 funcref)
     (export "0" (func $adapt-old-nargs))
     (export "$imports" (table 0))
-    (@producers
-      (processed-by "wit-component" "$CARGO_PKG_VERSION")
-    )
   )
   (core module (;3;)
     (type (;0;) (func (result i32)))
     (import "" "0" (func (;0;) (type 0)))
     (import "" "$imports" (table (;0;) 1 1 funcref))
     (elem (;0;) (i32.const 0) func 0)
-    (@producers
-      (processed-by "wit-component" "$CARGO_PKG_VERSION")
-    )
   )
   (core instance (;0;) (instantiate 2))
   (alias core export 0 "0" (core func (;0;)))
@@ -79,8 +69,5 @@
   (type (;0;) (func (param "nargs" u32)))
   (alias core export 4 "entrypoint" (core func (;3;)))
   (func (;0;) (type 0) (canon lift (core func 3)))
-  (@producers
-    (processed-by "wit-component" "$CARGO_PKG_VERSION")
-  )
   (export (;1;) "entrypoint" (func 0))
 )
\ No newline at end of file
diff --git a/crates/wit-component/tests/components/adapt-export-save-args/component.wit.print b/crates/wit-component/tests/components/adapt-export-save-args/component.wit
similarity index 51%
rename from crates/wit-component/tests/components/adapt-export-save-args/component.wit.print
rename to crates/wit-component/tests/components/adapt-export-save-args/component.wit
index 1946b9c0..e5a72119 100644
--- a/crates/wit-component/tests/components/adapt-export-save-args/component.wit.print
+++ b/crates/wit-component/tests/components/adapt-export-save-args/component.wit
@@ -1,5 +1,3 @@
-package root:component
-
-world root {
+default world component {
   export entrypoint: func(nargs: u32)
 }
diff --git a/crates/wit-component/tests/components/adapt-export-save-args/module.wit b/crates/wit-component/tests/components/adapt-export-save-args/module.wit
index 65c2b792..1f99081f 100644
--- a/crates/wit-component/tests/components/adapt-export-save-args/module.wit
+++ b/crates/wit-component/tests/components/adapt-export-save-args/module.wit
@@ -1,2 +1 @@
-package foo:foo
-world module {}
+default world empty {}
diff --git a/crates/wit-component/tests/components/adapt-export-with-post-return/adapt-old.wat b/crates/wit-component/tests/components/adapt-export-with-post-return/adapt-old.wat
index 197c7014..be58c401 100644
--- a/crates/wit-component/tests/components/adapt-export-with-post-return/adapt-old.wat
+++ b/crates/wit-component/tests/components/adapt-export-with-post-return/adapt-old.wat
@@ -13,7 +13,7 @@
   (global $__stack_pointer (mut i32) i32.const 0)
   (global $allocation_state (mut i32) i32.const 0)
 
-  (func (export "foo:foo/new#foo") (result i32)
+  (func (export "new#foo") (result i32)
     ;; This is a dummy, non-working implementation, just to make gc.rs do what
     ;; we want, which is to treat this adapter as if it uses the main module's
     ;; allocator to allocate and free memory.
@@ -24,7 +24,7 @@
     unreachable
   )
 
-  (func (export "cabi_post_foo:foo/new#foo") (param i32)
+  (func (export "cabi_post_new#foo") (param i32)
     ;; another dummy implementation
 
     (call $free (i32.const 0) (i32.const 0) (i32.const 0))
diff --git a/crates/wit-component/tests/components/adapt-export-with-post-return/adapt-old.wit b/crates/wit-component/tests/components/adapt-export-with-post-return/adapt-old.wit
index 5f8405e2..930847c5 100644
--- a/crates/wit-component/tests/components/adapt-export-with-post-return/adapt-old.wit
+++ b/crates/wit-component/tests/components/adapt-export-with-post-return/adapt-old.wit
@@ -2,6 +2,6 @@ interface new {
   foo: func() -> string
 }
 
-world adapt-old {
-  export new
+default world brave-new-world {
+  export new: self.new
 }
diff --git a/crates/wit-component/tests/components/adapt-export-with-post-return/component.wat b/crates/wit-component/tests/components/adapt-export-with-post-return/component.wat
index cfeff1cf..54d22ab1 100644
--- a/crates/wit-component/tests/components/adapt-export-with-post-return/component.wat
+++ b/crates/wit-component/tests/components/adapt-export-with-post-return/component.wat
@@ -12,10 +12,6 @@
     (export "canonical_abi_realloc" (func 0))
     (export "canonical_abi_free" (func 1))
     (export "memory" (memory 0))
-    (@producers
-      (processed-by "wit-component" "$CARGO_PKG_VERSION")
-      (processed-by "my-fake-bindgen" "123.45")
-    )
   )
   (core module (;1;)
     (type (;0;) (func (param i32 i32 i32 i32) (result i32)))
@@ -65,8 +61,8 @@
     )
     (global $__stack_pointer (;0;) (mut i32) i32.const 0)
     (global $allocation_state (;1;) (mut i32) i32.const 0)
-    (export "foo:foo/new#foo" (func 2))
-    (export "cabi_post_foo:foo/new#foo" (func 3))
+    (export "new#foo" (func 2))
+    (export "cabi_post_new#foo" (func 3))
   )
   (core instance (;0;) (instantiate 0))
   (alias core export 0 "memory" (core memory (;0;)))
@@ -82,21 +78,18 @@
     )
   )
   (type (;0;) (func (result string)))
-  (alias core export 2 "foo:foo/new#foo" (core func (;3;)))
-  (alias core export 2 "cabi_post_foo:foo/new#foo" (core func (;4;)))
+  (alias core export 2 "new#foo" (core func (;3;)))
+  (alias core export 2 "cabi_post_new#foo" (core func (;4;)))
   (func (;0;) (type 0) (canon lift (core func 3) (memory 0) string-encoding=utf8 (post-return 4)))
   (component (;0;)
-    (type (;0;) (func (result string)))
-    (import "import-func-foo" (func (;0;) (type 0)))
+    (alias outer 1 0 (type (;0;)))
+    (import "import-foo" (func (;0;) (type 0)))
     (type (;1;) (func (result string)))
     (export (;1;) "foo" (func 0) (func (type 1)))
   )
   (instance (;0;) (instantiate 0
-      (with "import-func-foo" (func 0))
+      (with "import-foo" (func 0))
     )
   )
-  (@producers
-    (processed-by "wit-component" "$CARGO_PKG_VERSION")
-  )
-  (export (;1;) (interface "foo:foo/new") (instance 0))
+  (export (;1;) "new" (instance 0))
 )
\ No newline at end of file
diff --git a/crates/wit-component/tests/components/adapt-export-with-post-return/component.wit b/crates/wit-component/tests/components/adapt-export-with-post-return/component.wit
new file mode 100644
index 00000000..380b11b0
--- /dev/null
+++ b/crates/wit-component/tests/components/adapt-export-with-post-return/component.wit
@@ -0,0 +1,7 @@
+interface new {
+  foo: func() -> string
+}
+
+default world component {
+  export new: self.new
+}
diff --git a/crates/wit-component/tests/components/adapt-export-with-post-return/component.wit.print b/crates/wit-component/tests/components/adapt-export-with-post-return/component.wit.print
deleted file mode 100644
index d4d05432..00000000
--- a/crates/wit-component/tests/components/adapt-export-with-post-return/component.wit.print
+++ /dev/null
@@ -1,5 +0,0 @@
-package root:component
-
-world root {
-  export foo:foo/new
-}
diff --git a/crates/wit-component/tests/components/adapt-export-with-post-return/module.wit b/crates/wit-component/tests/components/adapt-export-with-post-return/module.wit
index 3f66e96f..234a9191 100644
--- a/crates/wit-component/tests/components/adapt-export-with-post-return/module.wit
+++ b/crates/wit-component/tests/components/adapt-export-with-post-return/module.wit
@@ -1,3 +1 @@
-package foo:foo
-
-world module {}
+default world foo {}
diff --git a/crates/wit-component/tests/components/adapt-import-only-used-in-adapter/adapt-unused.wat b/crates/wit-component/tests/components/adapt-import-only-used-in-adapter/adapt-unused.wat
index ea9a0b70..75fac022 100644
--- a/crates/wit-component/tests/components/adapt-import-only-used-in-adapter/adapt-unused.wat
+++ b/crates/wit-component/tests/components/adapt-import-only-used-in-adapter/adapt-unused.wat
@@ -1,5 +1,5 @@
 (module
-  (import "foo:foo/adapter-imports" "foo" (func $foo (param i32 i32)))
+  (import "adapter-imports" "foo" (func $foo (param i32 i32)))
   (func (export "adapter-bar") (param i32 i32)
     (call $foo (i32.const 0) (i32.const 0))
   )
diff --git a/crates/wit-component/tests/components/adapt-import-only-used-in-adapter/adapt-unused.wit b/crates/wit-component/tests/components/adapt-import-only-used-in-adapter/adapt-unused.wit
index a434c40e..72f5cdc4 100644
--- a/crates/wit-component/tests/components/adapt-import-only-used-in-adapter/adapt-unused.wit
+++ b/crates/wit-component/tests/components/adapt-import-only-used-in-adapter/adapt-unused.wit
@@ -2,8 +2,8 @@ interface adapter-imports {
   foo: func(x: string)
 }
 
-world adapt-unused {
-  import adapter-imports
+default world the-world {
+  import adapter-imports: self.adapter-imports
 
   export adapter-bar: func(x: string)
 }
diff --git a/crates/wit-component/tests/components/adapt-import-only-used-in-adapter/component.wat b/crates/wit-component/tests/components/adapt-import-only-used-in-adapter/component.wat
index 9f084cf6..72e5d82f 100644
--- a/crates/wit-component/tests/components/adapt-import-only-used-in-adapter/component.wat
+++ b/crates/wit-component/tests/components/adapt-import-only-used-in-adapter/component.wat
@@ -5,7 +5,7 @@
       (export (;0;) "foo" (func (type 0)))
     )
   )
-  (import (interface "foo:foo/adapter-imports") (instance (;0;) (type 0)))
+  (import "adapter-imports" (instance (;0;) (type 0)))
   (type (;1;) (func (param "x" string)))
   (import "foo" (func (;0;) (type 1)))
   (core module (;0;)
@@ -18,15 +18,11 @@
     (memory (;0;) 1)
     (export "bar" (func 1))
     (export "memory" (memory 0))
-    (@producers
-      (processed-by "wit-component" "$CARGO_PKG_VERSION")
-      (processed-by "my-fake-bindgen" "123.45")
-    )
   )
   (core module (;1;)
     (type (;0;) (func (param i32 i32)))
     (type (;1;) (func (param i32 i32 i32 i32) (result i32)))
-    (import "foo:foo/adapter-imports" "foo" (func $foo (;0;) (type 0)))
+    (import "adapter-imports" "foo" (func $foo (;0;) (type 0)))
     (func (;1;) (type 0) (param i32 i32)
       i32.const 0
       i32.const 0
@@ -46,7 +42,7 @@
       i32.const 0
       call_indirect (type 0)
     )
-    (func $indirect-foo:foo/adapter-imports-foo (;1;) (type 0) (param i32 i32)
+    (func $indirect-adapter-imports-foo (;1;) (type 0) (param i32 i32)
       local.get 0
       local.get 1
       i32.const 1
@@ -54,11 +50,8 @@
     )
     (table (;0;) 2 2 funcref)
     (export "0" (func $indirect-$root-foo))
-    (export "1" (func $indirect-foo:foo/adapter-imports-foo))
+    (export "1" (func $indirect-adapter-imports-foo))
     (export "$imports" (table 0))
-    (@producers
-      (processed-by "wit-component" "$CARGO_PKG_VERSION")
-    )
   )
   (core module (;3;)
     (type (;0;) (func (param i32 i32)))
@@ -66,9 +59,6 @@
     (import "" "1" (func (;1;) (type 0)))
     (import "" "$imports" (table (;0;) 2 2 funcref))
     (elem (;0;) (i32.const 0) func 0 1)
-    (@producers
-      (processed-by "wit-component" "$CARGO_PKG_VERSION")
-    )
   )
   (core instance (;0;) (instantiate 2))
   (alias core export 0 "0" (core func (;0;)))
@@ -85,7 +75,7 @@
     (export "foo" (func 1))
   )
   (core instance (;4;) (instantiate 1
-      (with "foo:foo/adapter-imports" (instance 3))
+      (with "adapter-imports" (instance 3))
     )
   )
   (alias core export 4 "cabi_export_realloc" (core func (;2;)))
@@ -108,8 +98,5 @@
   (export (;3;) "bar" (func 2))
   (alias core export 4 "adapter-bar" (core func (;6;)))
   (func (;4;) (type 1) (canon lift (core func 6) (memory 0) (realloc 2) string-encoding=utf8))
-  (@producers
-    (processed-by "wit-component" "$CARGO_PKG_VERSION")
-  )
   (export (;5;) "adapter-bar" (func 4))
 )
\ No newline at end of file
diff --git a/crates/wit-component/tests/components/adapt-import-only-used-in-adapter/component.wit b/crates/wit-component/tests/components/adapt-import-only-used-in-adapter/component.wit
new file mode 100644
index 00000000..cc54d71d
--- /dev/null
+++ b/crates/wit-component/tests/components/adapt-import-only-used-in-adapter/component.wit
@@ -0,0 +1,10 @@
+interface adapter-imports {
+  foo: func(x: string)
+}
+
+default world component {
+  import adapter-imports: self.adapter-imports
+  import foo: func(x: string)
+  export bar: func()
+  export adapter-bar: func(x: string)
+}
diff --git a/crates/wit-component/tests/components/adapt-import-only-used-in-adapter/component.wit.print b/crates/wit-component/tests/components/adapt-import-only-used-in-adapter/component.wit.print
deleted file mode 100644
index 5d06bd34..00000000
--- a/crates/wit-component/tests/components/adapt-import-only-used-in-adapter/component.wit.print
+++ /dev/null
@@ -1,9 +0,0 @@
-package root:component
-
-world root {
-  import foo:foo/adapter-imports
-  import foo: func(x: string)
-
-  export bar: func()
-  export adapter-bar: func(x: string)
-}
diff --git a/crates/wit-component/tests/components/adapt-import-only-used-in-adapter/module.wit b/crates/wit-component/tests/components/adapt-import-only-used-in-adapter/module.wit
index 25ed69fa..c5a59c14 100644
--- a/crates/wit-component/tests/components/adapt-import-only-used-in-adapter/module.wit
+++ b/crates/wit-component/tests/components/adapt-import-only-used-in-adapter/module.wit
@@ -1,6 +1,4 @@
-package foo:foo
-
-world module {
+default world foo {
   import foo: func(x: string)
   export bar: func()
 }
diff --git a/crates/wit-component/tests/components/adapt-inject-stack-with-adapt-realloc/adapt-old.wat b/crates/wit-component/tests/components/adapt-inject-stack-with-adapt-realloc/adapt-old.wat
deleted file mode 100644
index 5fc81bcb..00000000
--- a/crates/wit-component/tests/components/adapt-inject-stack-with-adapt-realloc/adapt-old.wat
+++ /dev/null
@@ -1,76 +0,0 @@
-(module
-  (import "new" "get-two" (func $get_two (param i32)))
-  (import "__main_module__" "cabi_realloc" (func $cabi_realloc (param i32 i32 i32 i32) (result i32)))
-  (import "env" "memory" (memory 0))
-
-  (global $__stack_pointer (mut i32) i32.const 0)
-  (global $some_other_mutable_global (mut i32) i32.const 0)
-
-  ;; `wit-component` should use this to track the status of a lazy stack
-  ;; allocation:
-  (global $allocation_state (mut i32) i32.const 0)
-
-  ;; This is a sample adapter which is adapting between ABI. This exact function
-  ;; signature is imported by `module.wat` and we're implementing it here with a
-  ;; canonical-abi function that returns two integers. The canonical ABI for
-  ;; returning two integers is different than the ABI of this function, hence
-  ;; the adapter here.
-  ;;
-  ;; The purpose of this test case is to exercise the `$__stack_pointer` global.
-  ;; The stack pointer here needs to be initialized to something valid for
-  ;; this adapter module which is done with an injected `start` function into
-  ;; this adapter module when it's bundled into a component.
-  (func (export "get_sum") (result i32)
-    (local i32 i32)
-
-    ;; `wit-component` should have injected a call to a function that allocates
-    ;; the stack and sets $allocation_state to 2
-    (if (i32.ne (global.get $allocation_state) (i32.const 2)) (unreachable))
-
-    ;; First, allocate a page using $cabi_realloc and write to it.  This tests
-    ;; that we can use the main module's allocator if present (or else a
-    ;; substitute synthesized by `wit-component`).
-    (local.set 0
-      (call $cabi_realloc
-        (i32.const 0)
-        (i32.const 0)
-        (i32.const 8)
-        (i32.const 65536)))
-
-    (i32.store (local.get 0) (i32.const 42))
-    (i32.store offset=65532 (local.get 0) (i32.const 42))
-
-    ;; Allocate 8 bytes of stack space for the two u32 return values. The
-    ;; original stack pointer is saved in local 0 and the stack frame for this
-    ;; function is saved in local 1.
-    global.get $__stack_pointer
-    local.tee 0
-    i32.const 8
-    i32.sub
-    local.tee 1
-    global.set $__stack_pointer
-
-    ;; Call the imported function which will return two u32 values into the
-    ;; return pointer specified here, our stack frame.
-    local.get 1
-    call $get_two
-
-    ;; Compute the result of this function by adding together the two return
-    ;; values.
-    (i32.add
-      (i32.load (local.get 1))
-      (i32.load offset=4 (local.get 1)))
-
-    ;; Test that if there is another mutable global in this module that it
-    ;; doesn't affect the detection of the stack pointer. This extra mutable
-    ;; global should not be initialized or tampered with as part of the
-    ;; initialize-the-stack-pointer injected function
-    (global.set $some_other_mutable_global (global.get $some_other_mutable_global))
-
-    ;; Restore the stack pointer to the value it was at prior to entering this
-    ;; function.
-    local.get 0
-    global.set $__stack_pointer
-  )
-
-)
diff --git a/crates/wit-component/tests/components/adapt-inject-stack-with-adapt-realloc/adapt-old.wit b/crates/wit-component/tests/components/adapt-inject-stack-with-adapt-realloc/adapt-old.wit
deleted file mode 100644
index dab8bec0..00000000
--- a/crates/wit-component/tests/components/adapt-inject-stack-with-adapt-realloc/adapt-old.wit
+++ /dev/null
@@ -1,5 +0,0 @@
-world adapt-old {
-  import new: interface {
-    get-two: func() -> (a: u32, b: u32)
-  }
-}
diff --git a/crates/wit-component/tests/components/adapt-inject-stack-with-adapt-realloc/component.wat b/crates/wit-component/tests/components/adapt-inject-stack-with-adapt-realloc/component.wat
deleted file mode 100644
index 021cbdaa..00000000
--- a/crates/wit-component/tests/components/adapt-inject-stack-with-adapt-realloc/component.wat
+++ /dev/null
@@ -1,174 +0,0 @@
-(component
-  (type (;0;)
-    (instance
-      (type (;0;) (func (result "a" u32) (result "b" u32)))
-      (export (;0;) "get-two" (func (type 0)))
-    )
-  )
-  (import "new" (instance (;0;) (type 0)))
-  (core module (;0;)
-    (type (;0;) (func (result i32)))
-    (type (;1;) (func (param i32 i32 i32 i32) (result i32)))
-    (import "old" "get_sum" (func (;0;) (type 0)))
-    (func $cabi_realloc (;1;) (type 1) (param i32 i32 i32 i32) (result i32)
-      i32.const 123456789
-    )
-    (func $cabi_realloc_adapter (;2;) (type 1) (param i32 i32 i32 i32) (result i32)
-      i32.const 987654321
-    )
-    (memory (;0;) 1)
-    (export "memory" (memory 0))
-    (export "cabi_realloc" (func $cabi_realloc))
-    (export "cabi_realloc_adapter" (func $cabi_realloc_adapter))
-    (@producers
-      (processed-by "wit-component" "$CARGO_PKG_VERSION")
-      (processed-by "my-fake-bindgen" "123.45")
-    )
-  )
-  (core module (;1;)
-    (type (;0;) (func (param i32)))
-    (type (;1;) (func (param i32 i32 i32 i32) (result i32)))
-    (type (;2;) (func (result i32)))
-    (type (;3;) (func))
-    (import "env" "memory" (memory (;0;) 0))
-    (import "new" "get-two" (func $get_two (;0;) (type 0)))
-    (import "__main_module__" "cabi_realloc" (func $cabi_realloc (;1;) (type 1)))
-    (func (;2;) (type 2) (result i32)
-      (local i32 i32)
-      call $allocate_stack
-      global.get $allocation_state
-      i32.const 2
-      i32.ne
-      if ;; label = @1
-        unreachable
-      end
-      i32.const 0
-      i32.const 0
-      i32.const 8
-      i32.const 65536
-      call $cabi_realloc
-      local.set 0
-      local.get 0
-      i32.const 42
-      i32.store
-      local.get 0
-      i32.const 42
-      i32.store offset=65532
-      global.get $__stack_pointer
-      local.tee 0
-      i32.const 8
-      i32.sub
-      local.tee 1
-      global.set $__stack_pointer
-      local.get 1
-      call $get_two
-      local.get 1
-      i32.load
-      local.get 1
-      i32.load offset=4
-      i32.add
-      global.get $some_other_mutable_global
-      global.set $some_other_mutable_global
-      local.get 0
-      global.set $__stack_pointer
-    )
-    (func $allocate_stack (;3;) (type 3)
-      global.get $allocation_state
-      i32.const 0
-      i32.eq
-      if ;; label = @1
-        i32.const 1
-        global.set $allocation_state
-        i32.const 0
-        i32.const 0
-        i32.const 8
-        i32.const 65536
-        call $cabi_realloc
-        i32.const 65536
-        i32.add
-        global.set $__stack_pointer
-        i32.const 2
-        global.set $allocation_state
-      end
-    )
-    (global $__stack_pointer (;0;) (mut i32) i32.const 0)
-    (global $some_other_mutable_global (;1;) (mut i32) i32.const 0)
-    (global $allocation_state (;2;) (mut i32) i32.const 0)
-    (export "get_sum" (func 2))
-  )
-  (core module (;2;)
-    (type (;0;) (func (param i32)))
-    (type (;1;) (func (result i32)))
-    (func $indirect-new-get-two (;0;) (type 0) (param i32)
-      local.get 0
-      i32.const 0
-      call_indirect (type 0)
-    )
-    (func $adapt-old-get_sum (;1;) (type 1) (result i32)
-      i32.const 1
-      call_indirect (type 1)
-    )
-    (table (;0;) 2 2 funcref)
-    (export "0" (func $indirect-new-get-two))
-    (export "1" (func $adapt-old-get_sum))
-    (export "$imports" (table 0))
-    (@producers
-      (processed-by "wit-component" "$CARGO_PKG_VERSION")
-    )
-  )
-  (core module (;3;)
-    (type (;0;) (func (param i32)))
-    (type (;1;) (func (result i32)))
-    (import "" "0" (func (;0;) (type 0)))
-    (import "" "1" (func (;1;) (type 1)))
-    (import "" "$imports" (table (;0;) 2 2 funcref))
-    (elem (;0;) (i32.const 0) func 0 1)
-    (@producers
-      (processed-by "wit-component" "$CARGO_PKG_VERSION")
-    )
-  )
-  (core instance (;0;) (instantiate 2))
-  (alias core export 0 "1" (core func (;0;)))
-  (core instance (;1;)
-    (export "get_sum" (func 0))
-  )
-  (core instance (;2;) (instantiate 0
-      (with "old" (instance 1))
-    )
-  )
-  (alias core export 2 "memory" (core memory (;0;)))
-  (alias core export 2 "cabi_realloc" (core func (;1;)))
-  (alias core export 2 "cabi_realloc_adapter" (core func (;2;)))
-  (core instance (;3;)
-    (export "cabi_realloc" (func 2))
-  )
-  (core instance (;4;)
-    (export "memory" (memory 0))
-  )
-  (alias core export 0 "0" (core func (;3;)))
-  (core instance (;5;)
-    (export "get-two" (func 3))
-  )
-  (core instance (;6;) (instantiate 1
-      (with "__main_module__" (instance 3))
-      (with "env" (instance 4))
-      (with "new" (instance 5))
-    )
-  )
-  (alias core export 0 "$imports" (core table (;0;)))
-  (alias export 0 "get-two" (func (;0;)))
-  (core func (;4;) (canon lower (func 0) (memory 0)))
-  (alias core export 6 "get_sum" (core func (;5;)))
-  (@producers
-    (processed-by "wit-component" "$CARGO_PKG_VERSION")
-  )
-  (core instance (;7;)
-    (export "$imports" (table 0))
-    (export "0" (func 4))
-    (export "1" (func 5))
-  )
-  (core instance (;8;) (instantiate 3
-      (with "" (instance 7))
-    )
-  )
-)
\ No newline at end of file
diff --git a/crates/wit-component/tests/components/adapt-inject-stack-with-adapt-realloc/component.wit.print b/crates/wit-component/tests/components/adapt-inject-stack-with-adapt-realloc/component.wit.print
deleted file mode 100644
index b1f18351..00000000
--- a/crates/wit-component/tests/components/adapt-inject-stack-with-adapt-realloc/component.wit.print
+++ /dev/null
@@ -1,7 +0,0 @@
-package root:component
-
-world root {
-  import new: interface {
-    get-two: func() -> (a: u32, b: u32)
-  }
-}
diff --git a/crates/wit-component/tests/components/adapt-inject-stack-with-adapt-realloc/module.wat b/crates/wit-component/tests/components/adapt-inject-stack-with-adapt-realloc/module.wat
deleted file mode 100644
index 20941bb5..00000000
--- a/crates/wit-component/tests/components/adapt-inject-stack-with-adapt-realloc/module.wat
+++ /dev/null
@@ -1,12 +0,0 @@
-(module
-  (import "old" "get_sum" (func (result i32)))
-  (func $cabi_realloc (param i32 i32 i32 i32) (result i32)
-    (i32.const 123456789)
-  )
-  (func $cabi_realloc_adapter (param i32 i32 i32 i32) (result i32)
-    (i32.const 987654321)
-  )
-  (memory (export "memory") 1)
-  (export "cabi_realloc" (func $cabi_realloc))
-  (export "cabi_realloc_adapter" (func $cabi_realloc_adapter))
-)
diff --git a/crates/wit-component/tests/components/adapt-inject-stack-with-adapt-realloc/module.wit b/crates/wit-component/tests/components/adapt-inject-stack-with-adapt-realloc/module.wit
deleted file mode 100644
index 65c2b792..00000000
--- a/crates/wit-component/tests/components/adapt-inject-stack-with-adapt-realloc/module.wit
+++ /dev/null
@@ -1,2 +0,0 @@
-package foo:foo
-world module {}
diff --git a/crates/wit-component/tests/components/adapt-inject-stack-with-realloc-no-state/adapt-old.wit b/crates/wit-component/tests/components/adapt-inject-stack-with-realloc-no-state/adapt-old.wit
index dab8bec0..7a56eb16 100644
--- a/crates/wit-component/tests/components/adapt-inject-stack-with-realloc-no-state/adapt-old.wit
+++ b/crates/wit-component/tests/components/adapt-inject-stack-with-realloc-no-state/adapt-old.wit
@@ -1,4 +1,4 @@
-world adapt-old {
+default world brave-new-world {
   import new: interface {
     get-two: func() -> (a: u32, b: u32)
   }
diff --git a/crates/wit-component/tests/components/adapt-inject-stack-with-realloc-no-state/component.wat b/crates/wit-component/tests/components/adapt-inject-stack-with-realloc-no-state/component.wat
index 6caf0e82..67039c94 100644
--- a/crates/wit-component/tests/components/adapt-inject-stack-with-realloc-no-state/component.wat
+++ b/crates/wit-component/tests/components/adapt-inject-stack-with-realloc-no-state/component.wat
@@ -45,10 +45,6 @@
     (memory (;0;) 1)
     (export "memory" (memory 0))
     (export "cabi_realloc" (func $cabi_realloc))
-    (@producers
-      (processed-by "wit-component" "$CARGO_PKG_VERSION")
-      (processed-by "my-fake-bindgen" "123.45")
-    )
   )
   (core module (;1;)
     (type (;0;) (func (param i32)))
@@ -154,9 +150,6 @@
     (export "0" (func $indirect-new-get-two))
     (export "1" (func $adapt-old-get_sum))
     (export "$imports" (table 0))
-    (@producers
-      (processed-by "wit-component" "$CARGO_PKG_VERSION")
-    )
   )
   (core module (;3;)
     (type (;0;) (func (param i32)))
@@ -165,9 +158,6 @@
     (import "" "1" (func (;1;) (type 1)))
     (import "" "$imports" (table (;0;) 2 2 funcref))
     (elem (;0;) (i32.const 0) func 0 1)
-    (@producers
-      (processed-by "wit-component" "$CARGO_PKG_VERSION")
-    )
   )
   (core instance (;0;) (instantiate 2))
   (alias core export 0 "1" (core func (;0;)))
@@ -201,9 +191,6 @@
   (alias export 0 "get-two" (func (;0;)))
   (core func (;4;) (canon lower (func 0) (memory 0)))
   (alias core export 6 "get_sum" (core func (;5;)))
-  (@producers
-    (processed-by "wit-component" "$CARGO_PKG_VERSION")
-  )
   (core instance (;7;)
     (export "$imports" (table 0))
     (export "0" (func 4))
diff --git a/crates/wit-component/tests/components/adapt-inject-stack-with-realloc-no-state/component.wit b/crates/wit-component/tests/components/adapt-inject-stack-with-realloc-no-state/component.wit
new file mode 100644
index 00000000..d570b292
--- /dev/null
+++ b/crates/wit-component/tests/components/adapt-inject-stack-with-realloc-no-state/component.wit
@@ -0,0 +1,7 @@
+interface new {
+  get-two: func() -> (a: u32, b: u32)
+}
+
+default world component {
+  import new: self.new
+}
diff --git a/crates/wit-component/tests/components/adapt-inject-stack-with-realloc-no-state/component.wit.print b/crates/wit-component/tests/components/adapt-inject-stack-with-realloc-no-state/component.wit.print
deleted file mode 100644
index b1f18351..00000000
--- a/crates/wit-component/tests/components/adapt-inject-stack-with-realloc-no-state/component.wit.print
+++ /dev/null
@@ -1,7 +0,0 @@
-package root:component
-
-world root {
-  import new: interface {
-    get-two: func() -> (a: u32, b: u32)
-  }
-}
diff --git a/crates/wit-component/tests/components/adapt-inject-stack-with-realloc-no-state/module.wit b/crates/wit-component/tests/components/adapt-inject-stack-with-realloc-no-state/module.wit
index 3f66e96f..1f99081f 100644
--- a/crates/wit-component/tests/components/adapt-inject-stack-with-realloc-no-state/module.wit
+++ b/crates/wit-component/tests/components/adapt-inject-stack-with-realloc-no-state/module.wit
@@ -1,3 +1 @@
-package foo:foo
-
-world module {}
+default world empty {}
diff --git a/crates/wit-component/tests/components/adapt-inject-stack-with-realloc/adapt-old.wit b/crates/wit-component/tests/components/adapt-inject-stack-with-realloc/adapt-old.wit
index dab8bec0..7a56eb16 100644
--- a/crates/wit-component/tests/components/adapt-inject-stack-with-realloc/adapt-old.wit
+++ b/crates/wit-component/tests/components/adapt-inject-stack-with-realloc/adapt-old.wit
@@ -1,4 +1,4 @@
-world adapt-old {
+default world brave-new-world {
   import new: interface {
     get-two: func() -> (a: u32, b: u32)
   }
diff --git a/crates/wit-component/tests/components/adapt-inject-stack-with-realloc/component.wat b/crates/wit-component/tests/components/adapt-inject-stack-with-realloc/component.wat
index ec95f526..a83fd41f 100644
--- a/crates/wit-component/tests/components/adapt-inject-stack-with-realloc/component.wat
+++ b/crates/wit-component/tests/components/adapt-inject-stack-with-realloc/component.wat
@@ -45,10 +45,6 @@
     (memory (;0;) 1)
     (export "memory" (memory 0))
     (export "cabi_realloc" (func $cabi_realloc))
-    (@producers
-      (processed-by "wit-component" "$CARGO_PKG_VERSION")
-      (processed-by "my-fake-bindgen" "123.45")
-    )
   )
   (core module (;1;)
     (type (;0;) (func (param i32)))
@@ -137,9 +133,6 @@
     (export "0" (func $indirect-new-get-two))
     (export "1" (func $adapt-old-get_sum))
     (export "$imports" (table 0))
-    (@producers
-      (processed-by "wit-component" "$CARGO_PKG_VERSION")
-    )
   )
   (core module (;3;)
     (type (;0;) (func (param i32)))
@@ -148,9 +141,6 @@
     (import "" "1" (func (;1;) (type 1)))
     (import "" "$imports" (table (;0;) 2 2 funcref))
     (elem (;0;) (i32.const 0) func 0 1)
-    (@producers
-      (processed-by "wit-component" "$CARGO_PKG_VERSION")
-    )
   )
   (core instance (;0;) (instantiate 2))
   (alias core export 0 "1" (core func (;0;)))
@@ -184,9 +174,6 @@
   (alias export 0 "get-two" (func (;0;)))
   (core func (;4;) (canon lower (func 0) (memory 0)))
   (alias core export 6 "get_sum" (core func (;5;)))
-  (@producers
-    (processed-by "wit-component" "$CARGO_PKG_VERSION")
-  )
   (core instance (;7;)
     (export "$imports" (table 0))
     (export "0" (func 4))
diff --git a/crates/wit-component/tests/components/adapt-inject-stack-with-realloc/component.wit b/crates/wit-component/tests/components/adapt-inject-stack-with-realloc/component.wit
new file mode 100644
index 00000000..d570b292
--- /dev/null
+++ b/crates/wit-component/tests/components/adapt-inject-stack-with-realloc/component.wit
@@ -0,0 +1,7 @@
+interface new {
+  get-two: func() -> (a: u32, b: u32)
+}
+
+default world component {
+  import new: self.new
+}
diff --git a/crates/wit-component/tests/components/adapt-inject-stack-with-realloc/component.wit.print b/crates/wit-component/tests/components/adapt-inject-stack-with-realloc/component.wit.print
deleted file mode 100644
index b1f18351..00000000
--- a/crates/wit-component/tests/components/adapt-inject-stack-with-realloc/component.wit.print
+++ /dev/null
@@ -1,7 +0,0 @@
-package root:component
-
-world root {
-  import new: interface {
-    get-two: func() -> (a: u32, b: u32)
-  }
-}
diff --git a/crates/wit-component/tests/components/adapt-inject-stack-with-realloc/module.wit b/crates/wit-component/tests/components/adapt-inject-stack-with-realloc/module.wit
index 3f66e96f..1f99081f 100644
--- a/crates/wit-component/tests/components/adapt-inject-stack-with-realloc/module.wit
+++ b/crates/wit-component/tests/components/adapt-inject-stack-with-realloc/module.wit
@@ -1,3 +1 @@
-package foo:foo
-
-world module {}
+default world empty {}
diff --git a/crates/wit-component/tests/components/adapt-inject-stack-with-reallocing-adapter/adapt-old.wit b/crates/wit-component/tests/components/adapt-inject-stack-with-reallocing-adapter/adapt-old.wit
index dab8bec0..7a56eb16 100644
--- a/crates/wit-component/tests/components/adapt-inject-stack-with-reallocing-adapter/adapt-old.wit
+++ b/crates/wit-component/tests/components/adapt-inject-stack-with-reallocing-adapter/adapt-old.wit
@@ -1,4 +1,4 @@
-world adapt-old {
+default world brave-new-world {
   import new: interface {
     get-two: func() -> (a: u32, b: u32)
   }
diff --git a/crates/wit-component/tests/components/adapt-inject-stack-with-reallocing-adapter/component.wat b/crates/wit-component/tests/components/adapt-inject-stack-with-reallocing-adapter/component.wat
index d66e3d9f..06e920de 100644
--- a/crates/wit-component/tests/components/adapt-inject-stack-with-reallocing-adapter/component.wat
+++ b/crates/wit-component/tests/components/adapt-inject-stack-with-reallocing-adapter/component.wat
@@ -45,10 +45,6 @@
     (memory (;0;) 1)
     (export "memory" (memory 0))
     (export "cabi_realloc" (func $cabi_realloc))
-    (@producers
-      (processed-by "wit-component" "$CARGO_PKG_VERSION")
-      (processed-by "my-fake-bindgen" "123.45")
-    )
   )
   (core module (;1;)
     (type (;0;) (func (param i32)))
@@ -125,9 +121,6 @@
     (export "0" (func $indirect-new-get-two))
     (export "1" (func $adapt-old-get_sum))
     (export "$imports" (table 0))
-    (@producers
-      (processed-by "wit-component" "$CARGO_PKG_VERSION")
-    )
   )
   (core module (;3;)
     (type (;0;) (func (param i32)))
@@ -136,9 +129,6 @@
     (import "" "1" (func (;1;) (type 1)))
     (import "" "$imports" (table (;0;) 2 2 funcref))
     (elem (;0;) (i32.const 0) func 0 1)
-    (@producers
-      (processed-by "wit-component" "$CARGO_PKG_VERSION")
-    )
   )
   (core instance (;0;) (instantiate 2))
   (alias core export 0 "1" (core func (;0;)))
@@ -172,9 +162,6 @@
   (alias export 0 "get-two" (func (;0;)))
   (core func (;4;) (canon lower (func 0) (memory 0)))
   (alias core export 6 "get_sum" (core func (;5;)))
-  (@producers
-    (processed-by "wit-component" "$CARGO_PKG_VERSION")
-  )
   (core instance (;7;)
     (export "$imports" (table 0))
     (export "0" (func 4))
diff --git a/crates/wit-component/tests/components/adapt-inject-stack-with-reallocing-adapter/component.wit b/crates/wit-component/tests/components/adapt-inject-stack-with-reallocing-adapter/component.wit
new file mode 100644
index 00000000..d570b292
--- /dev/null
+++ b/crates/wit-component/tests/components/adapt-inject-stack-with-reallocing-adapter/component.wit
@@ -0,0 +1,7 @@
+interface new {
+  get-two: func() -> (a: u32, b: u32)
+}
+
+default world component {
+  import new: self.new
+}
diff --git a/crates/wit-component/tests/components/adapt-inject-stack-with-reallocing-adapter/component.wit.print b/crates/wit-component/tests/components/adapt-inject-stack-with-reallocing-adapter/component.wit.print
deleted file mode 100644
index b1f18351..00000000
--- a/crates/wit-component/tests/components/adapt-inject-stack-with-reallocing-adapter/component.wit.print
+++ /dev/null
@@ -1,7 +0,0 @@
-package root:component
-
-world root {
-  import new: interface {
-    get-two: func() -> (a: u32, b: u32)
-  }
-}
diff --git a/crates/wit-component/tests/components/adapt-inject-stack-with-reallocing-adapter/module.wit b/crates/wit-component/tests/components/adapt-inject-stack-with-reallocing-adapter/module.wit
index 65c2b792..1f99081f 100644
--- a/crates/wit-component/tests/components/adapt-inject-stack-with-reallocing-adapter/module.wit
+++ b/crates/wit-component/tests/components/adapt-inject-stack-with-reallocing-adapter/module.wit
@@ -1,2 +1 @@
-package foo:foo
-world module {}
+default world empty {}
diff --git a/crates/wit-component/tests/components/adapt-inject-stack/adapt-old.wit b/crates/wit-component/tests/components/adapt-inject-stack/adapt-old.wit
index dab8bec0..7a56eb16 100644
--- a/crates/wit-component/tests/components/adapt-inject-stack/adapt-old.wit
+++ b/crates/wit-component/tests/components/adapt-inject-stack/adapt-old.wit
@@ -1,4 +1,4 @@
-world adapt-old {
+default world brave-new-world {
   import new: interface {
     get-two: func() -> (a: u32, b: u32)
   }
diff --git a/crates/wit-component/tests/components/adapt-inject-stack/component.wat b/crates/wit-component/tests/components/adapt-inject-stack/component.wat
index f2c1e51c..63edee40 100644
--- a/crates/wit-component/tests/components/adapt-inject-stack/component.wat
+++ b/crates/wit-component/tests/components/adapt-inject-stack/component.wat
@@ -11,10 +11,6 @@
     (import "old" "get_sum" (func (;0;) (type 0)))
     (memory (;0;) 1)
     (export "memory" (memory 0))
-    (@producers
-      (processed-by "wit-component" "$CARGO_PKG_VERSION")
-      (processed-by "my-fake-bindgen" "123.45")
-    )
   )
   (core module (;1;)
     (type (;0;) (func (param i32)))
@@ -106,9 +102,6 @@
     (export "0" (func $indirect-new-get-two))
     (export "1" (func $adapt-old-get_sum))
     (export "$imports" (table 0))
-    (@producers
-      (processed-by "wit-component" "$CARGO_PKG_VERSION")
-    )
   )
   (core module (;3;)
     (type (;0;) (func (param i32)))
@@ -117,9 +110,6 @@
     (import "" "1" (func (;1;) (type 1)))
     (import "" "$imports" (table (;0;) 2 2 funcref))
     (elem (;0;) (i32.const 0) func 0 1)
-    (@producers
-      (processed-by "wit-component" "$CARGO_PKG_VERSION")
-    )
   )
   (core instance (;0;) (instantiate 2))
   (alias core export 0 "1" (core func (;0;)))
@@ -147,9 +137,6 @@
   (alias export 0 "get-two" (func (;0;)))
   (core func (;2;) (canon lower (func 0) (memory 0)))
   (alias core export 5 "get_sum" (core func (;3;)))
-  (@producers
-    (processed-by "wit-component" "$CARGO_PKG_VERSION")
-  )
   (core instance (;6;)
     (export "$imports" (table 0))
     (export "0" (func 2))
diff --git a/crates/wit-component/tests/components/adapt-inject-stack/component.wit b/crates/wit-component/tests/components/adapt-inject-stack/component.wit
new file mode 100644
index 00000000..d570b292
--- /dev/null
+++ b/crates/wit-component/tests/components/adapt-inject-stack/component.wit
@@ -0,0 +1,7 @@
+interface new {
+  get-two: func() -> (a: u32, b: u32)
+}
+
+default world component {
+  import new: self.new
+}
diff --git a/crates/wit-component/tests/components/adapt-inject-stack/component.wit.print b/crates/wit-component/tests/components/adapt-inject-stack/component.wit.print
deleted file mode 100644
index b1f18351..00000000
--- a/crates/wit-component/tests/components/adapt-inject-stack/component.wit.print
+++ /dev/null
@@ -1,7 +0,0 @@
-package root:component
-
-world root {
-  import new: interface {
-    get-two: func() -> (a: u32, b: u32)
-  }
-}
diff --git a/crates/wit-component/tests/components/adapt-inject-stack/module.wit b/crates/wit-component/tests/components/adapt-inject-stack/module.wit
index 65c2b792..1f99081f 100644
--- a/crates/wit-component/tests/components/adapt-inject-stack/module.wit
+++ b/crates/wit-component/tests/components/adapt-inject-stack/module.wit
@@ -1,2 +1 @@
-package foo:foo
-world module {}
+default world empty {}
diff --git a/crates/wit-component/tests/components/adapt-list-return/adapt-old.wit b/crates/wit-component/tests/components/adapt-list-return/adapt-old.wit
index 35bcef4a..d321768c 100644
--- a/crates/wit-component/tests/components/adapt-list-return/adapt-old.wit
+++ b/crates/wit-component/tests/components/adapt-list-return/adapt-old.wit
@@ -1,4 +1,4 @@
-world adapt-old {
+default world brave-new-world {
   import new: interface {
     read: func() -> list<u8>
   }
diff --git a/crates/wit-component/tests/components/adapt-list-return/component.wat b/crates/wit-component/tests/components/adapt-list-return/component.wat
index 66e7eb09..4217c311 100644
--- a/crates/wit-component/tests/components/adapt-list-return/component.wat
+++ b/crates/wit-component/tests/components/adapt-list-return/component.wat
@@ -12,10 +12,6 @@
     (import "old" "read" (func (;0;) (type 0)))
     (memory (;0;) 1)
     (export "memory" (memory 0))
-    (@producers
-      (processed-by "wit-component" "$CARGO_PKG_VERSION")
-      (processed-by "my-fake-bindgen" "123.45")
-    )
   )
   (core module (;1;)
     (type (;0;) (func (param i32)))
@@ -51,9 +47,6 @@
     (export "0" (func $indirect-new-read))
     (export "1" (func $adapt-old-read))
     (export "$imports" (table 0))
-    (@producers
-      (processed-by "wit-component" "$CARGO_PKG_VERSION")
-    )
   )
   (core module (;3;)
     (type (;0;) (func (param i32)))
@@ -62,9 +55,6 @@
     (import "" "1" (func (;1;) (type 1)))
     (import "" "$imports" (table (;0;) 2 2 funcref))
     (elem (;0;) (i32.const 0) func 0 1)
-    (@producers
-      (processed-by "wit-component" "$CARGO_PKG_VERSION")
-    )
   )
   (core instance (;0;) (instantiate 2))
   (alias core export 0 "1" (core func (;0;)))
@@ -89,9 +79,6 @@
   (alias export 0 "read" (func (;0;)))
   (core func (;3;) (canon lower (func 0) (memory 0) (realloc 2)))
   (alias core export 4 "read" (core func (;4;)))
-  (@producers
-    (processed-by "wit-component" "$CARGO_PKG_VERSION")
-  )
   (core instance (;5;)
     (export "$imports" (table 0))
     (export "0" (func 3))
diff --git a/crates/wit-component/tests/components/adapt-list-return/component.wit b/crates/wit-component/tests/components/adapt-list-return/component.wit
new file mode 100644
index 00000000..cdcc7691
--- /dev/null
+++ b/crates/wit-component/tests/components/adapt-list-return/component.wit
@@ -0,0 +1,7 @@
+interface new {
+  read: func() -> list<u8>
+}
+
+default world component {
+  import new: self.new
+}
diff --git a/crates/wit-component/tests/components/adapt-list-return/component.wit.print b/crates/wit-component/tests/components/adapt-list-return/component.wit.print
deleted file mode 100644
index 6a5d7c87..00000000
--- a/crates/wit-component/tests/components/adapt-list-return/component.wit.print
+++ /dev/null
@@ -1,7 +0,0 @@
-package root:component
-
-world root {
-  import new: interface {
-    read: func() -> list<u8>
-  }
-}
diff --git a/crates/wit-component/tests/components/adapt-list-return/module.wit b/crates/wit-component/tests/components/adapt-list-return/module.wit
index 3f66e96f..1f99081f 100644
--- a/crates/wit-component/tests/components/adapt-list-return/module.wit
+++ b/crates/wit-component/tests/components/adapt-list-return/module.wit
@@ -1,3 +1 @@
-package foo:foo
-
-world module {}
+default world empty {}
diff --git a/crates/wit-component/tests/components/adapt-memory-simple/adapt-old.wit b/crates/wit-component/tests/components/adapt-memory-simple/adapt-old.wit
index 5dd4f661..5a86aec1 100644
--- a/crates/wit-component/tests/components/adapt-memory-simple/adapt-old.wit
+++ b/crates/wit-component/tests/components/adapt-memory-simple/adapt-old.wit
@@ -1,4 +1,4 @@
-world adapt-old {
+default world brave-new-world {
   import new: interface {
     log: func(s: string)
   }
diff --git a/crates/wit-component/tests/components/adapt-memory-simple/component.wat b/crates/wit-component/tests/components/adapt-memory-simple/component.wat
index 4ba6b597..5c1751f6 100644
--- a/crates/wit-component/tests/components/adapt-memory-simple/component.wat
+++ b/crates/wit-component/tests/components/adapt-memory-simple/component.wat
@@ -11,10 +11,6 @@
     (import "old" "log" (func (;0;) (type 0)))
     (memory (;0;) 1)
     (export "memory" (memory 0))
-    (@producers
-      (processed-by "wit-component" "$CARGO_PKG_VERSION")
-      (processed-by "my-fake-bindgen" "123.45")
-    )
   )
   (core module (;1;)
     (type (;0;) (func (param i32 i32)))
@@ -39,9 +35,6 @@
     (export "0" (func $indirect-new-log))
     (export "1" (func $adapt-old-log))
     (export "$imports" (table 0))
-    (@producers
-      (processed-by "wit-component" "$CARGO_PKG_VERSION")
-    )
   )
   (core module (;3;)
     (type (;0;) (func (param i32 i32)))
@@ -49,9 +42,6 @@
     (import "" "1" (func (;1;) (type 0)))
     (import "" "$imports" (table (;0;) 2 2 funcref))
     (elem (;0;) (i32.const 0) func 0 1)
-    (@producers
-      (processed-by "wit-component" "$CARGO_PKG_VERSION")
-    )
   )
   (core instance (;0;) (instantiate 2))
   (alias core export 0 "1" (core func (;0;)))
@@ -75,9 +65,6 @@
   (alias export 0 "log" (func (;0;)))
   (core func (;2;) (canon lower (func 0) (memory 0) string-encoding=utf8))
   (alias core export 4 "log" (core func (;3;)))
-  (@producers
-    (processed-by "wit-component" "$CARGO_PKG_VERSION")
-  )
   (core instance (;5;)
     (export "$imports" (table 0))
     (export "0" (func 2))
diff --git a/crates/wit-component/tests/components/adapt-memory-simple/component.wit b/crates/wit-component/tests/components/adapt-memory-simple/component.wit
new file mode 100644
index 00000000..dc408de3
--- /dev/null
+++ b/crates/wit-component/tests/components/adapt-memory-simple/component.wit
@@ -0,0 +1,7 @@
+interface new {
+  log: func(s: string)
+}
+
+default world component {
+  import new: self.new
+}
diff --git a/crates/wit-component/tests/components/adapt-memory-simple/component.wit.print b/crates/wit-component/tests/components/adapt-memory-simple/component.wit.print
deleted file mode 100644
index e7996e6e..00000000
--- a/crates/wit-component/tests/components/adapt-memory-simple/component.wit.print
+++ /dev/null
@@ -1,7 +0,0 @@
-package root:component
-
-world root {
-  import new: interface {
-    log: func(s: string)
-  }
-}
diff --git a/crates/wit-component/tests/components/adapt-memory-simple/module.wit b/crates/wit-component/tests/components/adapt-memory-simple/module.wit
index 65c2b792..1f99081f 100644
--- a/crates/wit-component/tests/components/adapt-memory-simple/module.wit
+++ b/crates/wit-component/tests/components/adapt-memory-simple/module.wit
@@ -1,2 +1 @@
-package foo:foo
-world module {}
+default world empty {}
diff --git a/crates/wit-component/tests/components/error-adapt-missing-memory/adapt-old.wat b/crates/wit-component/tests/components/adapt-missing-memory/adapt-old.wat
similarity index 100%
rename from crates/wit-component/tests/components/error-adapt-missing-memory/adapt-old.wat
rename to crates/wit-component/tests/components/adapt-missing-memory/adapt-old.wat
diff --git a/crates/wit-component/tests/components/error-adapt-missing-memory/adapt-old.wit b/crates/wit-component/tests/components/adapt-missing-memory/adapt-old.wit
similarity index 64%
rename from crates/wit-component/tests/components/error-adapt-missing-memory/adapt-old.wit
rename to crates/wit-component/tests/components/adapt-missing-memory/adapt-old.wit
index 5dd4f661..5a86aec1 100644
--- a/crates/wit-component/tests/components/error-adapt-missing-memory/adapt-old.wit
+++ b/crates/wit-component/tests/components/adapt-missing-memory/adapt-old.wit
@@ -1,4 +1,4 @@
-world adapt-old {
+default world brave-new-world {
   import new: interface {
     log: func(s: string)
   }
diff --git a/crates/wit-component/tests/components/error-adapt-missing-memory/error.txt b/crates/wit-component/tests/components/adapt-missing-memory/error.txt
similarity index 100%
rename from crates/wit-component/tests/components/error-adapt-missing-memory/error.txt
rename to crates/wit-component/tests/components/adapt-missing-memory/error.txt
diff --git a/crates/wit-component/tests/components/error-adapt-missing-memory/module.wat b/crates/wit-component/tests/components/adapt-missing-memory/module.wat
similarity index 100%
rename from crates/wit-component/tests/components/error-adapt-missing-memory/module.wat
rename to crates/wit-component/tests/components/adapt-missing-memory/module.wat
diff --git a/crates/wit-component/tests/components/adapt-missing-memory/module.wit b/crates/wit-component/tests/components/adapt-missing-memory/module.wit
new file mode 100644
index 00000000..1f99081f
--- /dev/null
+++ b/crates/wit-component/tests/components/adapt-missing-memory/module.wit
@@ -0,0 +1 @@
+default world empty {}
diff --git a/crates/wit-component/tests/components/adapt-multiple/adapt-foo.wit b/crates/wit-component/tests/components/adapt-multiple/adapt-foo.wit
index 20e46ac8..bf449c18 100644
--- a/crates/wit-component/tests/components/adapt-multiple/adapt-foo.wit
+++ b/crates/wit-component/tests/components/adapt-multiple/adapt-foo.wit
@@ -1,4 +1,4 @@
-world adapt-foo {
+default world new-foo-world {
   import other1: interface {
     foo: func()
   }
diff --git a/crates/wit-component/tests/components/adapt-multiple/component.wat b/crates/wit-component/tests/components/adapt-multiple/component.wat
index f10d1ec6..88c38bf3 100644
--- a/crates/wit-component/tests/components/adapt-multiple/component.wat
+++ b/crates/wit-component/tests/components/adapt-multiple/component.wat
@@ -17,10 +17,6 @@
     (type (;0;) (func))
     (import "foo" "foo" (func (;0;) (type 0)))
     (import "foo" "bar" (func (;1;) (type 0)))
-    (@producers
-      (processed-by "wit-component" "$CARGO_PKG_VERSION")
-      (processed-by "my-fake-bindgen" "123.45")
-    )
   )
   (core module (;1;)
     (type (;0;) (func))
@@ -49,9 +45,6 @@
     (export "0" (func $adapt-foo-foo))
     (export "1" (func $adapt-foo-bar))
     (export "$imports" (table 0))
-    (@producers
-      (processed-by "wit-component" "$CARGO_PKG_VERSION")
-    )
   )
   (core module (;3;)
     (type (;0;) (func))
@@ -59,9 +52,6 @@
     (import "" "1" (func (;1;) (type 0)))
     (import "" "$imports" (table (;0;) 2 2 funcref))
     (elem (;0;) (i32.const 0) func 0 1)
-    (@producers
-      (processed-by "wit-component" "$CARGO_PKG_VERSION")
-    )
   )
   (core instance (;0;) (instantiate 2))
   (alias core export 0 "0" (core func (;0;)))
@@ -92,9 +82,6 @@
   (alias core export 0 "$imports" (core table (;0;)))
   (alias core export 5 "foo" (core func (;4;)))
   (alias core export 5 "bar" (core func (;5;)))
-  (@producers
-    (processed-by "wit-component" "$CARGO_PKG_VERSION")
-  )
   (core instance (;6;)
     (export "$imports" (table 0))
     (export "0" (func 4))
diff --git a/crates/wit-component/tests/components/adapt-multiple/component.wit b/crates/wit-component/tests/components/adapt-multiple/component.wit
new file mode 100644
index 00000000..5b111ba2
--- /dev/null
+++ b/crates/wit-component/tests/components/adapt-multiple/component.wit
@@ -0,0 +1,12 @@
+interface other1 {
+  foo: func()
+}
+
+interface other2 {
+  bar: func()
+}
+
+default world component {
+  import other1: self.other1
+  import other2: self.other2
+}
diff --git a/crates/wit-component/tests/components/adapt-multiple/component.wit.print b/crates/wit-component/tests/components/adapt-multiple/component.wit.print
deleted file mode 100644
index bfdb507a..00000000
--- a/crates/wit-component/tests/components/adapt-multiple/component.wit.print
+++ /dev/null
@@ -1,10 +0,0 @@
-package root:component
-
-world root {
-  import other1: interface {
-    foo: func()
-  }
-  import other2: interface {
-    bar: func()
-  }
-}
diff --git a/crates/wit-component/tests/components/adapt-multiple/module.wit b/crates/wit-component/tests/components/adapt-multiple/module.wit
index 65c2b792..1f99081f 100644
--- a/crates/wit-component/tests/components/adapt-multiple/module.wit
+++ b/crates/wit-component/tests/components/adapt-multiple/module.wit
@@ -1,2 +1 @@
-package foo:foo
-world module {}
+default world empty {}
diff --git a/crates/wit-component/tests/components/adapt-preview1/adapt-wasi-snapshot-preview1.wat b/crates/wit-component/tests/components/adapt-preview1/adapt-wasi-snapshot-preview1.wat
index 0b9abe3a..f568306e 100644
--- a/crates/wit-component/tests/components/adapt-preview1/adapt-wasi-snapshot-preview1.wat
+++ b/crates/wit-component/tests/components/adapt-preview1/adapt-wasi-snapshot-preview1.wat
@@ -2,7 +2,7 @@
 ;; interface
 
 (module
-  (import "foo:foo/my-wasi" "proc-exit" (func $proc_exit (param i32)))
+  (import "my-wasi" "proc-exit" (func $proc_exit (param i32)))
   (func (export "proc_exit") (param i32)
     local.get 0
     call $proc_exit
diff --git a/crates/wit-component/tests/components/adapt-preview1/adapt-wasi-snapshot-preview1.wit b/crates/wit-component/tests/components/adapt-preview1/adapt-wasi-snapshot-preview1.wit
index c1ffe08a..65035733 100644
--- a/crates/wit-component/tests/components/adapt-preview1/adapt-wasi-snapshot-preview1.wit
+++ b/crates/wit-component/tests/components/adapt-preview1/adapt-wasi-snapshot-preview1.wit
@@ -7,6 +7,6 @@ interface my-wasi {
   something-not-used: func()
 }
 
-world adapt-wasi-snapshot-preview1 {
-  import my-wasi
+default world adapter {
+  import my-wasi: self.my-wasi
 }
diff --git a/crates/wit-component/tests/components/adapt-preview1/component.wat b/crates/wit-component/tests/components/adapt-preview1/component.wat
index cecd5386..8b961de7 100644
--- a/crates/wit-component/tests/components/adapt-preview1/component.wat
+++ b/crates/wit-component/tests/components/adapt-preview1/component.wat
@@ -12,7 +12,7 @@
       (export (;0;) "proc-exit" (func (type 0)))
     )
   )
-  (import (interface "foo:foo/my-wasi") (instance (;1;) (type 1)))
+  (import "my-wasi" (instance (;1;) (type 1)))
   (core module (;0;)
     (type (;0;) (func))
     (type (;1;) (func (param i32)))
@@ -22,15 +22,11 @@
     (import "wasi-snapshot-preview1" "random_get" (func (;2;) (type 2)))
     (memory (;0;) 1)
     (export "memory" (memory 0))
-    (@producers
-      (processed-by "wit-component" "$CARGO_PKG_VERSION")
-      (processed-by "my-fake-bindgen" "123.45")
-    )
   )
   (core module (;1;)
     (type (;0;) (func (param i32)))
     (type (;1;) (func (param i32 i32) (result i32)))
-    (import "foo:foo/my-wasi" "proc-exit" (func $proc_exit (;0;) (type 0)))
+    (import "my-wasi" "proc-exit" (func $proc_exit (;0;) (type 0)))
     (func (;1;) (type 0) (param i32)
       local.get 0
       call $proc_exit
@@ -59,9 +55,6 @@
     (export "0" (func $adapt-wasi-snapshot-preview1-proc_exit))
     (export "1" (func $adapt-wasi-snapshot-preview1-random_get))
     (export "$imports" (table 0))
-    (@producers
-      (processed-by "wit-component" "$CARGO_PKG_VERSION")
-    )
   )
   (core module (;3;)
     (type (;0;) (func (param i32)))
@@ -70,9 +63,6 @@
     (import "" "1" (func (;1;) (type 1)))
     (import "" "$imports" (table (;0;) 2 2 funcref))
     (elem (;0;) (i32.const 0) func 0 1)
-    (@producers
-      (processed-by "wit-component" "$CARGO_PKG_VERSION")
-    )
   )
   (core instance (;0;) (instantiate 2))
   (alias export 0 "foo" (func (;0;)))
@@ -98,15 +88,12 @@
     (export "proc-exit" (func 3))
   )
   (core instance (;5;) (instantiate 1
-      (with "foo:foo/my-wasi" (instance 4))
+      (with "my-wasi" (instance 4))
     )
   )
   (alias core export 0 "$imports" (core table (;0;)))
   (alias core export 5 "proc_exit" (core func (;4;)))
   (alias core export 5 "random_get" (core func (;5;)))
-  (@producers
-    (processed-by "wit-component" "$CARGO_PKG_VERSION")
-  )
   (core instance (;6;)
     (export "$imports" (table 0))
     (export "0" (func 4))
diff --git a/crates/wit-component/tests/components/adapt-preview1/component.wit b/crates/wit-component/tests/components/adapt-preview1/component.wit
new file mode 100644
index 00000000..25d767a1
--- /dev/null
+++ b/crates/wit-component/tests/components/adapt-preview1/component.wit
@@ -0,0 +1,12 @@
+interface foo {
+  foo: func()
+}
+
+interface my-wasi {
+  proc-exit: func(code: u32)
+}
+
+default world component {
+  import foo: self.foo
+  import my-wasi: self.my-wasi
+}
diff --git a/crates/wit-component/tests/components/adapt-preview1/component.wit.print b/crates/wit-component/tests/components/adapt-preview1/component.wit.print
deleted file mode 100644
index 617992bb..00000000
--- a/crates/wit-component/tests/components/adapt-preview1/component.wit.print
+++ /dev/null
@@ -1,8 +0,0 @@
-package root:component
-
-world root {
-  import foo: interface {
-    foo: func()
-  }
-  import foo:foo/my-wasi
-}
diff --git a/crates/wit-component/tests/components/adapt-preview1/module.wit b/crates/wit-component/tests/components/adapt-preview1/module.wit
index 419a16cf..b35cf9a1 100644
--- a/crates/wit-component/tests/components/adapt-preview1/module.wit
+++ b/crates/wit-component/tests/components/adapt-preview1/module.wit
@@ -1,6 +1,4 @@
-package foo:foo
-
-world module {
+default world my-world {
   import foo: interface {
     foo: func()
   }
diff --git a/crates/wit-component/tests/components/adapt-unused/adapt-old.wit b/crates/wit-component/tests/components/adapt-unused/adapt-old.wit
index 5dd4f661..5a86aec1 100644
--- a/crates/wit-component/tests/components/adapt-unused/adapt-old.wit
+++ b/crates/wit-component/tests/components/adapt-unused/adapt-old.wit
@@ -1,4 +1,4 @@
-world adapt-old {
+default world brave-new-world {
   import new: interface {
     log: func(s: string)
   }
diff --git a/crates/wit-component/tests/components/adapt-unused/component.wat b/crates/wit-component/tests/components/adapt-unused/component.wat
index 202d5031..3f194a21 100644
--- a/crates/wit-component/tests/components/adapt-unused/component.wat
+++ b/crates/wit-component/tests/components/adapt-unused/component.wat
@@ -1,12 +1,4 @@
 (component
-  (core module (;0;)
-    (@producers
-      (processed-by "wit-component" "$CARGO_PKG_VERSION")
-      (processed-by "my-fake-bindgen" "123.45")
-    )
-  )
-  (@producers
-    (processed-by "wit-component" "$CARGO_PKG_VERSION")
-  )
+  (core module (;0;))
   (core instance (;0;) (instantiate 0))
 )
\ No newline at end of file
diff --git a/crates/wit-component/tests/components/adapt-unused/component.wit b/crates/wit-component/tests/components/adapt-unused/component.wit
new file mode 100644
index 00000000..da09ea6e
--- /dev/null
+++ b/crates/wit-component/tests/components/adapt-unused/component.wit
@@ -0,0 +1,2 @@
+default world component {
+}
diff --git a/crates/wit-component/tests/components/adapt-unused/component.wit.print b/crates/wit-component/tests/components/adapt-unused/component.wit.print
deleted file mode 100644
index bcd860d3..00000000
--- a/crates/wit-component/tests/components/adapt-unused/component.wit.print
+++ /dev/null
@@ -1,4 +0,0 @@
-package root:component
-
-world root {
-}
diff --git a/crates/wit-component/tests/components/adapt-unused/module.wit b/crates/wit-component/tests/components/adapt-unused/module.wit
index 65c2b792..1f99081f 100644
--- a/crates/wit-component/tests/components/adapt-unused/module.wit
+++ b/crates/wit-component/tests/components/adapt-unused/module.wit
@@ -1,2 +1 @@
-package foo:foo
-world module {}
+default world empty {}
diff --git a/crates/wit-component/tests/components/bare-funcs/component.wat b/crates/wit-component/tests/components/bare-funcs/component.wat
index 7c081962..d2a8557b 100644
--- a/crates/wit-component/tests/components/bare-funcs/component.wat
+++ b/crates/wit-component/tests/components/bare-funcs/component.wat
@@ -26,10 +26,6 @@
     (export "cabi_post_foo2" (func 4))
     (export "cabi_realloc" (func 5))
     (export "memory" (memory 0))
-    (@producers
-      (processed-by "wit-component" "$CARGO_PKG_VERSION")
-      (processed-by "my-fake-bindgen" "123.45")
-    )
   )
   (core module (;1;)
     (type (;0;) (func (param i32)))
@@ -41,25 +37,19 @@
     (table (;0;) 1 1 funcref)
     (export "0" (func $indirect-$root-bar))
     (export "$imports" (table 0))
-    (@producers
-      (processed-by "wit-component" "$CARGO_PKG_VERSION")
-    )
   )
   (core module (;2;)
     (type (;0;) (func (param i32)))
     (import "" "0" (func (;0;) (type 0)))
     (import "" "$imports" (table (;0;) 1 1 funcref))
     (elem (;0;) (i32.const 0) func 0)
-    (@producers
-      (processed-by "wit-component" "$CARGO_PKG_VERSION")
-    )
   )
   (core instance (;0;) (instantiate 1))
-  (core func (;0;) (canon lower (func 0)))
-  (alias core export 0 "0" (core func (;1;)))
+  (alias core export 0 "0" (core func (;0;)))
+  (core func (;1;) (canon lower (func 0)))
   (core instance (;1;)
-    (export "foo" (func 0))
-    (export "bar" (func 1))
+    (export "bar" (func 0))
+    (export "foo" (func 1))
   )
   (core instance (;2;) (instantiate 0
       (with "$root" (instance 1))
@@ -86,8 +76,5 @@
   (alias core export 2 "foo2" (core func (;5;)))
   (alias core export 2 "cabi_post_foo2" (core func (;6;)))
   (func (;4;) (type 4) (canon lift (core func 5) (memory 0) (realloc 2) string-encoding=utf8 (post-return 6)))
-  (@producers
-    (processed-by "wit-component" "$CARGO_PKG_VERSION")
-  )
   (export (;5;) "foo2" (func 4))
 )
\ No newline at end of file
diff --git a/crates/wit-component/tests/components/bare-funcs/component.wit.print b/crates/wit-component/tests/components/bare-funcs/component.wit
similarity index 76%
rename from crates/wit-component/tests/components/bare-funcs/component.wit.print
rename to crates/wit-component/tests/components/bare-funcs/component.wit
index 34767c7e..82350270 100644
--- a/crates/wit-component/tests/components/bare-funcs/component.wit.print
+++ b/crates/wit-component/tests/components/bare-funcs/component.wit
@@ -1,9 +1,6 @@
-package root:component
-
-world root {
+default world component {
   import foo: func()
   import bar: func() -> string
-
   export baz: func()
   export foo2: func(x: string) -> option<list<u8>>
 }
diff --git a/crates/wit-component/tests/components/bare-funcs/module.wit b/crates/wit-component/tests/components/bare-funcs/module.wit
index 3796acf5..4875567e 100644
--- a/crates/wit-component/tests/components/bare-funcs/module.wit
+++ b/crates/wit-component/tests/components/bare-funcs/module.wit
@@ -1,5 +1,4 @@
-package foo:foo
-world module {
+default world foo {
   import foo: func()
   import bar: func() -> string
   export baz: func()
diff --git a/crates/wit-component/tests/components/error-default-export-sig-mismatch/error.txt b/crates/wit-component/tests/components/default-export-sig-mismatch/error.txt
similarity index 100%
rename from crates/wit-component/tests/components/error-default-export-sig-mismatch/error.txt
rename to crates/wit-component/tests/components/default-export-sig-mismatch/error.txt
diff --git a/crates/wit-component/tests/components/error-default-export-sig-mismatch/module.wat b/crates/wit-component/tests/components/default-export-sig-mismatch/module.wat
similarity index 100%
rename from crates/wit-component/tests/components/error-default-export-sig-mismatch/module.wat
rename to crates/wit-component/tests/components/default-export-sig-mismatch/module.wat
diff --git a/crates/wit-component/tests/components/error-default-export-sig-mismatch/module.wit b/crates/wit-component/tests/components/default-export-sig-mismatch/module.wit
similarity index 55%
rename from crates/wit-component/tests/components/error-default-export-sig-mismatch/module.wit
rename to crates/wit-component/tests/components/default-export-sig-mismatch/module.wit
index e1370a6e..b8fa3e13 100644
--- a/crates/wit-component/tests/components/error-default-export-sig-mismatch/module.wit
+++ b/crates/wit-component/tests/components/default-export-sig-mismatch/module.wit
@@ -1,5 +1,3 @@
-package foo:foo
-
-world module {
+default world my-world {
   export a: func(x: string) -> string
 }
diff --git a/crates/wit-component/tests/components/error-empty-module-import/error.txt b/crates/wit-component/tests/components/empty-module-import/error.txt
similarity index 100%
rename from crates/wit-component/tests/components/error-empty-module-import/error.txt
rename to crates/wit-component/tests/components/empty-module-import/error.txt
diff --git a/crates/wit-component/tests/components/error-empty-module-import/module.wat b/crates/wit-component/tests/components/empty-module-import/module.wat
similarity index 100%
rename from crates/wit-component/tests/components/error-empty-module-import/module.wat
rename to crates/wit-component/tests/components/empty-module-import/module.wat
diff --git a/crates/wit-component/tests/components/empty-module-import/module.wit b/crates/wit-component/tests/components/empty-module-import/module.wit
new file mode 100644
index 00000000..1f99081f
--- /dev/null
+++ b/crates/wit-component/tests/components/empty-module-import/module.wit
@@ -0,0 +1 @@
+default world empty {}
diff --git a/crates/wit-component/tests/components/empty/component.wat b/crates/wit-component/tests/components/empty/component.wat
index 202d5031..3f194a21 100644
--- a/crates/wit-component/tests/components/empty/component.wat
+++ b/crates/wit-component/tests/components/empty/component.wat
@@ -1,12 +1,4 @@
 (component
-  (core module (;0;)
-    (@producers
-      (processed-by "wit-component" "$CARGO_PKG_VERSION")
-      (processed-by "my-fake-bindgen" "123.45")
-    )
-  )
-  (@producers
-    (processed-by "wit-component" "$CARGO_PKG_VERSION")
-  )
+  (core module (;0;))
   (core instance (;0;) (instantiate 0))
 )
\ No newline at end of file
diff --git a/crates/wit-component/tests/components/empty/component.wit b/crates/wit-component/tests/components/empty/component.wit
new file mode 100644
index 00000000..da09ea6e
--- /dev/null
+++ b/crates/wit-component/tests/components/empty/component.wit
@@ -0,0 +1,2 @@
+default world component {
+}
diff --git a/crates/wit-component/tests/components/empty/component.wit.print b/crates/wit-component/tests/components/empty/component.wit.print
deleted file mode 100644
index bcd860d3..00000000
--- a/crates/wit-component/tests/components/empty/component.wit.print
+++ /dev/null
@@ -1,4 +0,0 @@
-package root:component
-
-world root {
-}
diff --git a/crates/wit-component/tests/components/empty/module.wit b/crates/wit-component/tests/components/empty/module.wit
index 65c2b792..1f99081f 100644
--- a/crates/wit-component/tests/components/empty/module.wit
+++ b/crates/wit-component/tests/components/empty/module.wit
@@ -1,2 +1 @@
-package foo:foo
-world module {}
+default world empty {}
diff --git a/crates/wit-component/tests/components/ensure-default-type-exports/component.wat b/crates/wit-component/tests/components/ensure-default-type-exports/component.wat
index e67d3da2..f603758a 100644
--- a/crates/wit-component/tests/components/ensure-default-type-exports/component.wat
+++ b/crates/wit-component/tests/components/ensure-default-type-exports/component.wat
@@ -9,11 +9,11 @@
       (export (;0;) "a" (func (type 4)))
     )
   )
-  (import (interface "foo:foo/foo") (instance (;0;) (type 0)))
+  (import "foo" (instance (;0;) (type 0)))
   (core module (;0;)
     (type (;0;) (func (param i32)))
     (type (;1;) (func (param i32 i32 i32 i32) (result i32)))
-    (import "foo:foo/foo" "a" (func (;0;) (type 0)))
+    (import "foo" "a" (func (;0;) (type 0)))
     (func (;1;) (type 1) (param i32 i32 i32 i32) (result i32)
       unreachable
     )
@@ -24,10 +24,6 @@
     (export "memory" (memory 0))
     (export "cabi_realloc" (func 1))
     (export "a" (func 2))
-    (@producers
-      (processed-by "wit-component" "$CARGO_PKG_VERSION")
-      (processed-by "my-fake-bindgen" "123.45")
-    )
   )
   (alias export 0 "a" (func (;0;)))
   (core func (;0;) (canon lower (func 0)))
@@ -35,7 +31,7 @@
     (export "a" (func 0))
   )
   (core instance (;1;) (instantiate 0
-      (with "foo:foo/foo" (instance 0))
+      (with "foo" (instance 0))
     )
   )
   (alias core export 1 "memory" (core memory (;0;)))
@@ -43,8 +39,5 @@
   (type (;1;) (func (param "b" u8)))
   (alias core export 1 "a" (core func (;2;)))
   (func (;1;) (type 1) (canon lift (core func 2)))
-  (@producers
-    (processed-by "wit-component" "$CARGO_PKG_VERSION")
-  )
   (export (;2;) "a" (func 1))
 )
\ No newline at end of file
diff --git a/crates/wit-component/tests/components/ensure-default-type-exports/component.wit b/crates/wit-component/tests/components/ensure-default-type-exports/component.wit
new file mode 100644
index 00000000..a7b39a50
--- /dev/null
+++ b/crates/wit-component/tests/components/ensure-default-type-exports/component.wit
@@ -0,0 +1,14 @@
+interface foo {
+  type foo = u8
+
+  record bar {
+    x: foo,
+  }
+
+  a: func(b: bar)
+}
+
+default world component {
+  import foo: self.foo
+  export a: func(b: u8)
+}
diff --git a/crates/wit-component/tests/components/ensure-default-type-exports/component.wit.print b/crates/wit-component/tests/components/ensure-default-type-exports/component.wit.print
deleted file mode 100644
index f207bfb8..00000000
--- a/crates/wit-component/tests/components/ensure-default-type-exports/component.wit.print
+++ /dev/null
@@ -1,7 +0,0 @@
-package root:component
-
-world root {
-  import foo:foo/foo
-
-  export a: func(b: u8)
-}
diff --git a/crates/wit-component/tests/components/ensure-default-type-exports/module.wat b/crates/wit-component/tests/components/ensure-default-type-exports/module.wat
index 711b2a14..4ddbbd47 100644
--- a/crates/wit-component/tests/components/ensure-default-type-exports/module.wat
+++ b/crates/wit-component/tests/components/ensure-default-type-exports/module.wat
@@ -1,5 +1,5 @@
 (module
-  (import "foo:foo/foo" "a" (func (param i32)))
+  (import "foo" "a" (func (param i32)))
   (memory (export "memory") 1)
   (func (export "cabi_realloc") (param i32 i32 i32 i32) (result i32) unreachable)
   (func (export "a") (param i32) unreachable)
diff --git a/crates/wit-component/tests/components/ensure-default-type-exports/module.wit b/crates/wit-component/tests/components/ensure-default-type-exports/module.wit
index a206eb9c..c66cd9c4 100644
--- a/crates/wit-component/tests/components/ensure-default-type-exports/module.wit
+++ b/crates/wit-component/tests/components/ensure-default-type-exports/module.wit
@@ -1,5 +1,3 @@
-package foo:foo
-
 interface foo {
   type foo = u8
 
@@ -10,8 +8,8 @@ interface foo {
   a: func(b: bar)
 }
 
-world module {
-  import foo
+default world my-world {
+  import foo: self.foo
 
   export a: func(b: u8)
 }
diff --git a/crates/wit-component/tests/components/error-adapt-missing-memory/module.wit b/crates/wit-component/tests/components/error-adapt-missing-memory/module.wit
deleted file mode 100644
index 65c2b792..00000000
--- a/crates/wit-component/tests/components/error-adapt-missing-memory/module.wit
+++ /dev/null
@@ -1,2 +0,0 @@
-package foo:foo
-world module {}
diff --git a/crates/wit-component/tests/components/error-empty-module-import/module.wit b/crates/wit-component/tests/components/error-empty-module-import/module.wit
deleted file mode 100644
index 65c2b792..00000000
--- a/crates/wit-component/tests/components/error-empty-module-import/module.wit
+++ /dev/null
@@ -1,2 +0,0 @@
-package foo:foo
-world module {}
diff --git a/crates/wit-component/tests/components/error-import-resource-rep/error.txt b/crates/wit-component/tests/components/error-import-resource-rep/error.txt
deleted file mode 100644
index 5a9a5e18..00000000
--- a/crates/wit-component/tests/components/error-import-resource-rep/error.txt
+++ /dev/null
@@ -1 +0,0 @@
-no top-level imported function `[resource-rep]a` specified
\ No newline at end of file
diff --git a/crates/wit-component/tests/components/error-import-resource-rep/module.wat b/crates/wit-component/tests/components/error-import-resource-rep/module.wat
deleted file mode 100644
index 791c84cf..00000000
--- a/crates/wit-component/tests/components/error-import-resource-rep/module.wat
+++ /dev/null
@@ -1,3 +0,0 @@
-(module
-  (import "$root" "[resource-rep]a" (func (param i32) (result i32)))
-)
diff --git a/crates/wit-component/tests/components/error-import-resource-rep/module.wit b/crates/wit-component/tests/components/error-import-resource-rep/module.wit
deleted file mode 100644
index 142cbde3..00000000
--- a/crates/wit-component/tests/components/error-import-resource-rep/module.wit
+++ /dev/null
@@ -1,5 +0,0 @@
-package foo:bar
-
-world module {
-  resource a
-}
diff --git a/crates/wit-component/tests/components/error-import-resource-wrong-signature/error.txt b/crates/wit-component/tests/components/error-import-resource-wrong-signature/error.txt
deleted file mode 100644
index 205e848e..00000000
--- a/crates/wit-component/tests/components/error-import-resource-wrong-signature/error.txt
+++ /dev/null
@@ -1 +0,0 @@
-type mismatch for function `[resource-drop]a`: expected `[I32] -> []` but found `[I32] -> [I32]`
\ No newline at end of file
diff --git a/crates/wit-component/tests/components/error-import-resource-wrong-signature/module.wat b/crates/wit-component/tests/components/error-import-resource-wrong-signature/module.wat
deleted file mode 100644
index c4423f75..00000000
--- a/crates/wit-component/tests/components/error-import-resource-wrong-signature/module.wat
+++ /dev/null
@@ -1,3 +0,0 @@
-(module
-  (import "$root" "[resource-drop]a" (func (param i32) (result i32)))
-)
diff --git a/crates/wit-component/tests/components/error-import-resource-wrong-signature/module.wit b/crates/wit-component/tests/components/error-import-resource-wrong-signature/module.wit
deleted file mode 100644
index 142cbde3..00000000
--- a/crates/wit-component/tests/components/error-import-resource-wrong-signature/module.wit
+++ /dev/null
@@ -1,5 +0,0 @@
-package foo:bar
-
-world module {
-  resource a
-}
diff --git a/crates/wit-component/tests/components/error-invalid-module-import/module.wit b/crates/wit-component/tests/components/error-invalid-module-import/module.wit
deleted file mode 100644
index 65c2b792..00000000
--- a/crates/wit-component/tests/components/error-invalid-module-import/module.wit
+++ /dev/null
@@ -1,2 +0,0 @@
-package foo:foo
-world module {}
diff --git a/crates/wit-component/tests/components/error-missing-default-export/module.wit b/crates/wit-component/tests/components/error-missing-default-export/module.wit
deleted file mode 100644
index 4ae9b6cf..00000000
--- a/crates/wit-component/tests/components/error-missing-default-export/module.wit
+++ /dev/null
@@ -1,4 +0,0 @@
-package foo:foo
-world module {
-  export a: func()
-}
diff --git a/crates/wit-component/tests/components/error-missing-import-func/module.wit b/crates/wit-component/tests/components/error-missing-import-func/module.wit
deleted file mode 100644
index 38300fed..00000000
--- a/crates/wit-component/tests/components/error-missing-import-func/module.wit
+++ /dev/null
@@ -1,9 +0,0 @@
-package foo:foo
-
-interface foo {
-  a: func()
-}
-
-world module {
-  import foo
-}
diff --git a/crates/wit-component/tests/components/error-missing-import/error.txt b/crates/wit-component/tests/components/error-missing-import/error.txt
deleted file mode 100644
index b4d2327f..00000000
--- a/crates/wit-component/tests/components/error-missing-import/error.txt
+++ /dev/null
@@ -1 +0,0 @@
-module requires an import interface named `foo`
\ No newline at end of file
diff --git a/crates/wit-component/tests/components/error-missing-import/module.wit b/crates/wit-component/tests/components/error-missing-import/module.wit
deleted file mode 100644
index 65c2b792..00000000
--- a/crates/wit-component/tests/components/error-missing-import/module.wit
+++ /dev/null
@@ -1,2 +0,0 @@
-package foo:foo
-world module {}
diff --git a/crates/wit-component/tests/components/export-interface-using-import/component.wat b/crates/wit-component/tests/components/export-interface-using-import/component.wat
deleted file mode 100644
index 73aef302..00000000
--- a/crates/wit-component/tests/components/export-interface-using-import/component.wat
+++ /dev/null
@@ -1,36 +0,0 @@
-(component
-  (type (;0;)
-    (instance
-      (type (;0;) (record))
-      (export (;1;) "f" (type (eq 0)))
-      (type (;2;) (record (field "f" 1)))
-      (export (;3;) "r" (type (eq 2)))
-    )
-  )
-  (import (interface "foo:foo/foo") (instance (;0;) (type 0)))
-  (core module (;0;)
-    (@producers
-      (processed-by "wit-component" "$CARGO_PKG_VERSION")
-      (processed-by "my-fake-bindgen" "123.45")
-    )
-  )
-  (core instance (;0;) (instantiate 0))
-  (alias export 0 "f" (type (;1;)))
-  (alias export 0 "r" (type (;2;)))
-  (component (;0;)
-    (type (;0;) (record))
-    (import "import-type-f" (type (;1;) (eq 0)))
-    (type (;2;) (record (field "f" 1)))
-    (import "import-type-r" (type (;3;) (eq 2)))
-    (export (;4;) "r" (type 3))
-  )
-  (instance (;1;) (instantiate 0
-      (with "import-type-f" (type 1))
-      (with "import-type-r" (type 2))
-    )
-  )
-  (@producers
-    (processed-by "wit-component" "$CARGO_PKG_VERSION")
-  )
-  (export (;2;) "x" (instance 1))
-)
\ No newline at end of file
diff --git a/crates/wit-component/tests/components/export-interface-using-import/component.wit.print b/crates/wit-component/tests/components/export-interface-using-import/component.wit.print
deleted file mode 100644
index 7e05cc1d..00000000
--- a/crates/wit-component/tests/components/export-interface-using-import/component.wit.print
+++ /dev/null
@@ -1,9 +0,0 @@
-package root:component
-
-world root {
-  import foo:foo/foo
-
-  export x: interface {
-    use foo:foo/foo.{r}
-  }
-}
diff --git a/crates/wit-component/tests/components/export-interface-using-import/module.wat b/crates/wit-component/tests/components/export-interface-using-import/module.wat
deleted file mode 100644
index 3af8f254..00000000
--- a/crates/wit-component/tests/components/export-interface-using-import/module.wat
+++ /dev/null
@@ -1 +0,0 @@
-(module)
diff --git a/crates/wit-component/tests/components/export-interface-using-import/module.wit b/crates/wit-component/tests/components/export-interface-using-import/module.wit
deleted file mode 100644
index 6918380a..00000000
--- a/crates/wit-component/tests/components/export-interface-using-import/module.wit
+++ /dev/null
@@ -1,15 +0,0 @@
-package foo:foo
-
-interface foo {
-  record f {}
-
-  record r {
-    f: f,
-  }
-}
-
-world module {
-  export x: interface {
-    use foo.{r}
-  }
-}
diff --git a/crates/wit-component/tests/components/export-name-shuffling/component.wat b/crates/wit-component/tests/components/export-name-shuffling/component.wat
index 527fd011..103adb5c 100644
--- a/crates/wit-component/tests/components/export-name-shuffling/component.wat
+++ b/crates/wit-component/tests/components/export-name-shuffling/component.wat
@@ -3,10 +3,6 @@
     (type (;0;) (func))
     (func (;0;) (type 0))
     (export "name#a" (func 0))
-    (@producers
-      (processed-by "wit-component" "$CARGO_PKG_VERSION")
-      (processed-by "my-fake-bindgen" "123.45")
-    )
   )
   (core instance (;0;) (instantiate 0))
   (component (;0;)
@@ -14,29 +10,23 @@
     (export (;1;) "foo" (type 0))
   )
   (instance (;0;) (instantiate 0))
-  (export (;1;) (interface "foo:foo/name") (instance 0))
+  (export (;1;) "other-name" (instance 0))
   (alias export 1 "foo" (type (;0;)))
   (type (;1;) (func (param "f" 0)))
   (alias core export 0 "name#a" (core func (;0;)))
   (func (;0;) (type 1) (canon lift (core func 0)))
+  (alias export 1 "foo" (type (;2;)))
   (component (;1;)
-    (type (;0;) (record))
-    (import "import-type-foo" (type (;1;) (eq 0)))
-    (import "import-type-foo0" (type (;2;) (eq 1)))
+    (alias outer 1 1 (type (;0;)))
+    (import "import-a" (func (;0;) (type 0)))
+    (alias outer 1 2 (type (;1;)))
+    (export (;2;) "foo" (type 1))
     (type (;3;) (func (param "f" 2)))
-    (import "import-func-a" (func (;0;) (type 3)))
-    (export (;4;) "foo" (type 1))
-    (type (;5;) (func (param "f" 4)))
-    (export (;1;) "a" (func 0) (func (type 5)))
+    (export (;1;) "a" (func 0) (func (type 3)))
   )
   (instance (;2;) (instantiate 1
-      (with "import-func-a" (func 0))
-      (with "import-type-foo" (type 0))
-      (with "import-type-foo0" (type 0))
+      (with "import-a" (func 0))
     )
   )
-  (@producers
-    (processed-by "wit-component" "$CARGO_PKG_VERSION")
-  )
   (export (;3;) "name" (instance 2))
 )
\ No newline at end of file
diff --git a/crates/wit-component/tests/components/export-name-shuffling/component.wit b/crates/wit-component/tests/components/export-name-shuffling/component.wit
new file mode 100644
index 00000000..8b2fb6ea
--- /dev/null
+++ b/crates/wit-component/tests/components/export-name-shuffling/component.wit
@@ -0,0 +1,15 @@
+interface other-name {
+  record foo {
+  }
+
+}
+
+interface name {
+  use self.other-name.{foo}
+  a: func(f: foo)
+}
+
+default world component {
+  export other-name: self.other-name
+  export name: self.name
+}
diff --git a/crates/wit-component/tests/components/export-name-shuffling/component.wit.print b/crates/wit-component/tests/components/export-name-shuffling/component.wit.print
deleted file mode 100644
index 801ed922..00000000
--- a/crates/wit-component/tests/components/export-name-shuffling/component.wit.print
+++ /dev/null
@@ -1,10 +0,0 @@
-package root:component
-
-world root {
-  export foo:foo/name
-  export name: interface {
-    use foo:foo/name.{foo}
-
-    a: func(f: foo)
-  }
-}
diff --git a/crates/wit-component/tests/components/export-name-shuffling/module.wit b/crates/wit-component/tests/components/export-name-shuffling/module.wit
index 77a6ae69..d2e1fea8 100644
--- a/crates/wit-component/tests/components/export-name-shuffling/module.wit
+++ b/crates/wit-component/tests/components/export-name-shuffling/module.wit
@@ -1,14 +1,11 @@
-package foo:foo
-
 interface name {
   record foo {}
 }
 
-world module {
-  export name
-
+default world foo {
+  export other-name: self.name
   export name: interface {
-    use name.{foo}
+    use self.name.{foo}
 
     a: func(f: foo)
   }
diff --git a/crates/wit-component/tests/components/export-resource/component.wat b/crates/wit-component/tests/components/export-resource/component.wat
deleted file mode 100644
index a3b781a1..00000000
--- a/crates/wit-component/tests/components/export-resource/component.wat
+++ /dev/null
@@ -1,102 +0,0 @@
-(component
-  (core module (;0;)
-    (type (;0;) (func (param i32) (result i32)))
-    (type (;1;) (func (param i32)))
-    (type (;2;) (func (result i32)))
-    (import "[export]foo" "[resource-new]a" (func $new (;0;) (type 0)))
-    (import "[export]foo" "[resource-rep]a" (func (;1;) (type 0)))
-    (import "[export]foo" "[resource-drop]a" (func (;2;) (type 1)))
-    (func (;3;) (type 2) (result i32)
-      i32.const 100
-      call $new
-    )
-    (func (;4;) (type 2) (result i32)
-      i32.const 200
-      call $new
-    )
-    (func (;5;) (type 1) (param i32))
-    (export "foo#[constructor]a" (func 3))
-    (export "foo#[static]a.other-new" (func 4))
-    (export "foo#[dtor]a" (func 5))
-    (@producers
-      (processed-by "wit-component" "$CARGO_PKG_VERSION")
-      (processed-by "my-fake-bindgen" "123.45")
-    )
-  )
-  (core module (;1;)
-    (type (;0;) (func (param i32)))
-    (func $#func0<dtor-_export_foo-a> (@name "dtor-[export]foo-a") (;0;) (type 0) (param i32)
-      local.get 0
-      i32.const 0
-      call_indirect (type 0)
-    )
-    (table (;0;) 1 1 funcref)
-    (export "0" (func $#func0<dtor-_export_foo-a>))
-    (export "$imports" (table 0))
-    (@producers
-      (processed-by "wit-component" "$CARGO_PKG_VERSION")
-    )
-  )
-  (core module (;2;)
-    (type (;0;) (func (param i32)))
-    (import "" "0" (func (;0;) (type 0)))
-    (import "" "$imports" (table (;0;) 1 1 funcref))
-    (elem (;0;) (i32.const 0) func 0)
-    (@producers
-      (processed-by "wit-component" "$CARGO_PKG_VERSION")
-    )
-  )
-  (core instance (;0;) (instantiate 1))
-  (alias core export 0 "0" (core func (;0;)))
-  (type (;0;) (resource (rep i32) (dtor (func 0))))
-  (core func (;1;) (canon resource.drop 0))
-  (core func (;2;) (canon resource.rep 0))
-  (core func (;3;) (canon resource.new 0))
-  (core instance (;1;)
-    (export "[resource-drop]a" (func 1))
-    (export "[resource-rep]a" (func 2))
-    (export "[resource-new]a" (func 3))
-  )
-  (core instance (;2;) (instantiate 0
-      (with "[export]foo" (instance 1))
-    )
-  )
-  (alias core export 0 "$imports" (core table (;0;)))
-  (alias core export 2 "foo#[dtor]a" (core func (;4;)))
-  (core instance (;3;)
-    (export "$imports" (table 0))
-    (export "0" (func 4))
-  )
-  (core instance (;4;) (instantiate 2
-      (with "" (instance 3))
-    )
-  )
-  (type (;1;) (own 0))
-  (type (;2;) (func (result 1)))
-  (alias core export 2 "foo#[constructor]a" (core func (;5;)))
-  (func (;0;) (type 2) (canon lift (core func 5)))
-  (alias core export 2 "foo#[static]a.other-new" (core func (;6;)))
-  (func (;1;) (type 2) (canon lift (core func 6)))
-  (component (;0;)
-    (import "import-type-a" (type (;0;) (sub resource)))
-    (type (;1;) (own 0))
-    (type (;2;) (func (result 1)))
-    (import "import-constructor-a" (func (;0;) (type 2)))
-    (import "import-static-a-other-new" (func (;1;) (type 2)))
-    (export (;3;) "a" (type 0))
-    (type (;4;) (own 3))
-    (type (;5;) (func (result 4)))
-    (export (;2;) "[constructor]a" (func 0) (func (type 5)))
-    (export (;3;) "[static]a.other-new" (func 1) (func (type 5)))
-  )
-  (instance (;0;) (instantiate 0
-      (with "import-constructor-a" (func 0))
-      (with "import-static-a-other-new" (func 1))
-      (with "import-type-a" (type 0))
-    )
-  )
-  (@producers
-    (processed-by "wit-component" "$CARGO_PKG_VERSION")
-  )
-  (export (;1;) "foo" (instance 0))
-)
\ No newline at end of file
diff --git a/crates/wit-component/tests/components/export-resource/component.wit.print b/crates/wit-component/tests/components/export-resource/component.wit.print
deleted file mode 100644
index 2c9acee6..00000000
--- a/crates/wit-component/tests/components/export-resource/component.wit.print
+++ /dev/null
@@ -1,10 +0,0 @@
-package root:component
-
-world root {
-  export foo: interface {
-    resource a {
-      constructor()
-      other-new: static func() -> a
-    }
-  }
-}
diff --git a/crates/wit-component/tests/components/export-resource/module.wat b/crates/wit-component/tests/components/export-resource/module.wat
deleted file mode 100644
index d2f641c7..00000000
--- a/crates/wit-component/tests/components/export-resource/module.wat
+++ /dev/null
@@ -1,15 +0,0 @@
-(module
-  (import "[export]foo" "[resource-new]a" (func $new (param i32) (result i32)))
-  (import "[export]foo" "[resource-rep]a" (func (param i32) (result i32)))
-  (import "[export]foo" "[resource-drop]a" (func (param i32)))
-
-  (func (export "foo#[constructor]a") (result i32)
-    (call $new (i32.const 100))
-  )
-  (func (export "foo#[static]a.other-new") (result i32)
-    (call $new (i32.const 200))
-  )
-  (func (export "foo#[dtor]a") (param i32)
-    ;; ...
-  )
-)
diff --git a/crates/wit-component/tests/components/export-resource/module.wit b/crates/wit-component/tests/components/export-resource/module.wit
deleted file mode 100644
index 1ee91cdc..00000000
--- a/crates/wit-component/tests/components/export-resource/module.wit
+++ /dev/null
@@ -1,11 +0,0 @@
-package foo:bar
-
-world module {
-  export foo: interface {
-    resource a {
-      constructor()
-
-      other-new: static func() -> a
-    }
-  }
-}
diff --git a/crates/wit-component/tests/components/error-export-sig-mismatch/error.txt b/crates/wit-component/tests/components/export-sig-mismatch/error.txt
similarity index 100%
rename from crates/wit-component/tests/components/error-export-sig-mismatch/error.txt
rename to crates/wit-component/tests/components/export-sig-mismatch/error.txt
diff --git a/crates/wit-component/tests/components/error-export-sig-mismatch/module.wat b/crates/wit-component/tests/components/export-sig-mismatch/module.wat
similarity index 100%
rename from crates/wit-component/tests/components/error-export-sig-mismatch/module.wat
rename to crates/wit-component/tests/components/export-sig-mismatch/module.wat
diff --git a/crates/wit-component/tests/components/error-export-sig-mismatch/module.wit b/crates/wit-component/tests/components/export-sig-mismatch/module.wit
similarity index 67%
rename from crates/wit-component/tests/components/error-export-sig-mismatch/module.wit
rename to crates/wit-component/tests/components/export-sig-mismatch/module.wit
index 99c485e5..8e7ef0bb 100644
--- a/crates/wit-component/tests/components/error-export-sig-mismatch/module.wit
+++ b/crates/wit-component/tests/components/export-sig-mismatch/module.wit
@@ -1,6 +1,4 @@
-package foo:foo
-
-world module {
+default world foo {
   export foo: interface {
     a: func(x: string) -> string
   }
diff --git a/crates/wit-component/tests/components/export-type-name-conflict/component.wat b/crates/wit-component/tests/components/export-type-name-conflict/component.wat
deleted file mode 100644
index 27563527..00000000
--- a/crates/wit-component/tests/components/export-type-name-conflict/component.wat
+++ /dev/null
@@ -1,44 +0,0 @@
-(component
-  (type (;0;)
-    (instance
-      (type (;0;) (record))
-      (export (;1;) "foo" (type (eq 0)))
-    )
-  )
-  (import (interface "foo:foo/foo") (instance (;0;) (type 0)))
-  (core module (;0;)
-    (type (;0;) (func))
-    (func (;0;) (type 0))
-    (export "bar#foo" (func 0))
-    (@producers
-      (processed-by "wit-component" "$CARGO_PKG_VERSION")
-      (processed-by "my-fake-bindgen" "123.45")
-    )
-  )
-  (core instance (;0;) (instantiate 0))
-  (alias export 0 "foo" (type (;1;)))
-  (type (;2;) (func (result 1)))
-  (alias core export 0 "bar#foo" (core func (;0;)))
-  (func (;0;) (type 2) (canon lift (core func 0)))
-  (alias export 0 "foo" (type (;3;)))
-  (component (;0;)
-    (type (;0;) (record))
-    (import "import-type-foo" (type (;1;) (eq 0)))
-    (import "import-type-bar" (type (;2;) (eq 1)))
-    (type (;3;) (func (result 2)))
-    (import "import-func-foo" (func (;0;) (type 3)))
-    (export (;4;) "bar" (type 1))
-    (type (;5;) (func (result 4)))
-    (export (;1;) "foo" (func 0) (func (type 5)))
-  )
-  (instance (;1;) (instantiate 0
-      (with "import-func-foo" (func 0))
-      (with "import-type-foo" (type 3))
-      (with "import-type-bar" (type 1))
-    )
-  )
-  (@producers
-    (processed-by "wit-component" "$CARGO_PKG_VERSION")
-  )
-  (export (;2;) "bar" (instance 1))
-)
\ No newline at end of file
diff --git a/crates/wit-component/tests/components/export-type-name-conflict/component.wit.print b/crates/wit-component/tests/components/export-type-name-conflict/component.wit.print
deleted file mode 100644
index 6622505e..00000000
--- a/crates/wit-component/tests/components/export-type-name-conflict/component.wit.print
+++ /dev/null
@@ -1,11 +0,0 @@
-package root:component
-
-world root {
-  import foo:foo/foo
-
-  export bar: interface {
-    use foo:foo/foo.{foo as bar}
-
-    foo: func() -> bar
-  }
-}
diff --git a/crates/wit-component/tests/components/export-type-name-conflict/module.wat b/crates/wit-component/tests/components/export-type-name-conflict/module.wat
deleted file mode 100644
index 42693095..00000000
--- a/crates/wit-component/tests/components/export-type-name-conflict/module.wat
+++ /dev/null
@@ -1,3 +0,0 @@
-(module
-  (func (export "bar#foo"))
-)
diff --git a/crates/wit-component/tests/components/export-type-name-conflict/module.wit b/crates/wit-component/tests/components/export-type-name-conflict/module.wit
deleted file mode 100644
index d1990cf8..00000000
--- a/crates/wit-component/tests/components/export-type-name-conflict/module.wit
+++ /dev/null
@@ -1,13 +0,0 @@
-package foo:foo
-
-interface foo {
-  record foo {}
-}
-
-world module {
-  export bar: interface {
-    use foo.{foo as bar}
-
-    foo: func() -> bar
-  }
-}
diff --git a/crates/wit-component/tests/components/export-with-type-alias/component.wat b/crates/wit-component/tests/components/export-with-type-alias/component.wat
index 1ac1e8ca..b10d9ec6 100644
--- a/crates/wit-component/tests/components/export-with-type-alias/component.wat
+++ b/crates/wit-component/tests/components/export-with-type-alias/component.wat
@@ -4,37 +4,25 @@
     (func (;0;) (type 0) (param i32) (result i32)
       unreachable
     )
-    (export "foo:foo/foo#c" (func 0))
-    (@producers
-      (processed-by "wit-component" "$CARGO_PKG_VERSION")
-      (processed-by "my-fake-bindgen" "123.45")
-    )
+    (export "foo#c" (func 0))
   )
   (core instance (;0;) (instantiate 0))
   (type (;0;) u8)
   (type (;1;) (func (param "a" 0) (result 0)))
-  (alias core export 0 "foo:foo/foo#c" (core func (;0;)))
+  (alias core export 0 "foo#c" (core func (;0;)))
   (func (;0;) (type 1) (canon lift (core func 0)))
   (component (;0;)
-    (type (;0;) u8)
-    (import "import-type-a" (type (;1;) (eq 0)))
-    (import "import-type-b" (type (;2;) (eq 1)))
-    (type (;3;) (func (param "a" 1) (result 2)))
-    (import "import-func-c" (func (;0;) (type 3)))
-    (type (;4;) u8)
-    (export (;5;) "a" (type 4))
-    (export (;6;) "b" (type 5))
-    (type (;7;) (func (param "a" 5) (result 6)))
-    (export (;1;) "c" (func 0) (func (type 7)))
+    (alias outer 1 1 (type (;0;)))
+    (import "import-c" (func (;0;) (type 0)))
+    (type (;1;) u8)
+    (export (;2;) "a" (type 1))
+    (export (;3;) "b" (type 2))
+    (type (;4;) (func (param "a" 2) (result 3)))
+    (export (;1;) "c" (func 0) (func (type 4)))
   )
   (instance (;0;) (instantiate 0
-      (with "import-func-c" (func 0))
-      (with "import-type-a" (type 0))
-      (with "import-type-b" (type 0))
+      (with "import-c" (func 0))
     )
   )
-  (@producers
-    (processed-by "wit-component" "$CARGO_PKG_VERSION")
-  )
-  (export (;1;) (interface "foo:foo/foo") (instance 0))
+  (export (;1;) "foo" (instance 0))
 )
\ No newline at end of file
diff --git a/crates/wit-component/tests/components/export-with-type-alias/component.wit b/crates/wit-component/tests/components/export-with-type-alias/component.wit
new file mode 100644
index 00000000..c0cce279
--- /dev/null
+++ b/crates/wit-component/tests/components/export-with-type-alias/component.wit
@@ -0,0 +1,11 @@
+interface foo {
+  type a = u8
+
+  type b = a
+
+  c: func(a: a) -> b
+}
+
+default world component {
+  export foo: self.foo
+}
diff --git a/crates/wit-component/tests/components/export-with-type-alias/component.wit.print b/crates/wit-component/tests/components/export-with-type-alias/component.wit.print
deleted file mode 100644
index 62a65899..00000000
--- a/crates/wit-component/tests/components/export-with-type-alias/component.wit.print
+++ /dev/null
@@ -1,5 +0,0 @@
-package root:component
-
-world root {
-  export foo:foo/foo
-}
diff --git a/crates/wit-component/tests/components/export-with-type-alias/module.wat b/crates/wit-component/tests/components/export-with-type-alias/module.wat
index 196f9c95..994b1546 100644
--- a/crates/wit-component/tests/components/export-with-type-alias/module.wat
+++ b/crates/wit-component/tests/components/export-with-type-alias/module.wat
@@ -1,3 +1,3 @@
 (module
-  (func (export "foo:foo/foo#c") (param i32) (result i32) unreachable)
+  (func (export "foo#c") (param i32) (result i32) unreachable)
 )
diff --git a/crates/wit-component/tests/components/export-with-type-alias/module.wit b/crates/wit-component/tests/components/export-with-type-alias/module.wit
index ad5e636c..87e91a8d 100644
--- a/crates/wit-component/tests/components/export-with-type-alias/module.wit
+++ b/crates/wit-component/tests/components/export-with-type-alias/module.wit
@@ -1,11 +1,9 @@
-package foo:foo
-
 interface foo {
   type a = u8
   type b = a
   c: func(a: a) -> b
 }
 
-world module {
-  export foo
+default world the-world {
+  export foo: self.foo
 }
diff --git a/crates/wit-component/tests/components/exports/component.wat b/crates/wit-component/tests/components/exports/component.wat
index b172c02f..ef0e428a 100644
--- a/crates/wit-component/tests/components/exports/component.wat
+++ b/crates/wit-component/tests/components/exports/component.wat
@@ -53,10 +53,6 @@
     (export "foo#c" (func 8))
     (export "cabi_post_foo#c" (func 9))
     (export "bar#a" (func 10))
-    (@producers
-      (processed-by "wit-component" "$CARGO_PKG_VERSION")
-      (processed-by "my-fake-bindgen" "123.45")
-    )
   )
   (core instance (;0;) (instantiate 0))
   (alias core export 0 "memory" (core memory (;0;)))
@@ -66,18 +62,15 @@
   (alias core export 0 "bar#a" (core func (;1;)))
   (func (;0;) (type 1) (canon lift (core func 1)))
   (component (;0;)
-    (type (;0;) (flags "a" "b" "c"))
-    (import "import-type-x" (type (;1;) (eq 0)))
-    (type (;2;) (func (param "x" 1)))
-    (import "import-func-a" (func (;0;) (type 2)))
-    (type (;3;) (flags "a" "b" "c"))
-    (export (;4;) "x" (type 3))
-    (type (;5;) (func (param "x" 4)))
-    (export (;1;) "a" (func 0) (func (type 5)))
+    (alias outer 1 1 (type (;0;)))
+    (import "import-a" (func (;0;) (type 0)))
+    (type (;1;) (flags "a" "b" "c"))
+    (export (;2;) "x" (type 1))
+    (type (;3;) (func (param "x" 2)))
+    (export (;1;) "a" (func 0) (func (type 3)))
   )
   (instance (;0;) (instantiate 0
-      (with "import-func-a" (func 0))
-      (with "import-type-x" (type 0))
+      (with "import-a" (func 0))
     )
   )
   (export (;1;) "bar" (instance 0))
@@ -94,28 +87,25 @@
   (alias core export 0 "cabi_post_foo#c" (core func (;6;)))
   (func (;3;) (type 5) (canon lift (core func 5) (memory 0) (realloc 0) string-encoding=utf8 (post-return 6)))
   (component (;1;)
-    (type (;0;) (func))
-    (import "import-func-a" (func (;0;) (type 0)))
-    (type (;1;) (variant (case "a") (case "b" string) (case "c" s64)))
-    (import "import-type-x" (type (;2;) (eq 1)))
-    (type (;3;) (func (param "x" string) (result 2)))
-    (import "import-func-b" (func (;1;) (type 3)))
-    (type (;4;) (func (param "x" 2) (result string)))
-    (import "import-func-c" (func (;2;) (type 4)))
-    (type (;5;) (variant (case "a") (case "b" string) (case "c" s64)))
-    (export (;6;) "x" (type 5))
-    (type (;7;) (func))
-    (export (;3;) "a" (func 0) (func (type 7)))
-    (type (;8;) (func (param "x" string) (result 6)))
-    (export (;4;) "b" (func 1) (func (type 8)))
-    (type (;9;) (func (param "x" 6) (result string)))
-    (export (;5;) "c" (func 2) (func (type 9)))
+    (alias outer 1 2 (type (;0;)))
+    (import "import-a" (func (;0;) (type 0)))
+    (alias outer 1 4 (type (;1;)))
+    (import "import-b" (func (;1;) (type 1)))
+    (alias outer 1 5 (type (;2;)))
+    (import "import-c" (func (;2;) (type 2)))
+    (type (;3;) (func))
+    (export (;3;) "a" (func 0) (func (type 3)))
+    (type (;4;) (variant (case "a") (case "b" string) (case "c" s64)))
+    (export (;5;) "x" (type 4))
+    (type (;6;) (func (param "x" string) (result 5)))
+    (export (;4;) "b" (func 1) (func (type 6)))
+    (type (;7;) (func (param "x" 5) (result string)))
+    (export (;5;) "c" (func 2) (func (type 7)))
   )
   (instance (;2;) (instantiate 1
-      (with "import-func-a" (func 1))
-      (with "import-func-b" (func 2))
-      (with "import-func-c" (func 3))
-      (with "import-type-x" (type 3))
+      (with "import-a" (func 1))
+      (with "import-b" (func 2))
+      (with "import-c" (func 3))
     )
   )
   (export (;3;) "foo" (instance 2))
@@ -132,8 +122,5 @@
   (type (;9;) (func (result 8)))
   (alias core export 0 "c" (core func (;10;)))
   (func (;8;) (type 9) (canon lift (core func 10) (memory 0)))
-  (@producers
-    (processed-by "wit-component" "$CARGO_PKG_VERSION")
-  )
   (export (;9;) "c" (func 8))
 )
\ No newline at end of file
diff --git a/crates/wit-component/tests/components/exports/component.wit b/crates/wit-component/tests/components/exports/component.wit
new file mode 100644
index 00000000..1e3cf130
--- /dev/null
+++ b/crates/wit-component/tests/components/exports/component.wit
@@ -0,0 +1,31 @@
+interface bar {
+  flags x {
+    a,
+    b,
+    c,
+  }
+
+  a: func(x: x)
+}
+
+interface foo {
+  variant x {
+    a,
+    b(string),
+    c(s64),
+  }
+
+  a: func()
+
+  b: func(x: string) -> x
+
+  c: func(x: x) -> string
+}
+
+default world component {
+  export bar: self.bar
+  export foo: self.foo
+  export a: func()
+  export b: func(a: s8, b: s16, c: s32, d: s64) -> string
+  export c: func() -> tuple<s8, s16, s32, s64>
+}
diff --git a/crates/wit-component/tests/components/exports/component.wit.print b/crates/wit-component/tests/components/exports/component.wit.print
deleted file mode 100644
index 832dcb39..00000000
--- a/crates/wit-component/tests/components/exports/component.wit.print
+++ /dev/null
@@ -1,29 +0,0 @@
-package root:component
-
-world root {
-  export bar: interface {
-    flags x {
-      a,
-      b,
-      c,
-    }
-
-    a: func(x: x)
-  }
-  export foo: interface {
-    variant x {
-      a,
-      b(string),
-      c(s64),
-    }
-
-    a: func()
-
-    b: func(x: string) -> x
-
-    c: func(x: x) -> string
-  }
-  export a: func()
-  export b: func(a: s8, b: s16, c: s32, d: s64) -> string
-  export c: func() -> tuple<s8, s16, s32, s64>
-}
diff --git a/crates/wit-component/tests/components/exports/module.wit b/crates/wit-component/tests/components/exports/module.wit
index 922df002..478e6876 100644
--- a/crates/wit-component/tests/components/exports/module.wit
+++ b/crates/wit-component/tests/components/exports/module.wit
@@ -1,6 +1,4 @@
-package foo:foo
-
-world module {
+default world my-world {
   export a: func()
   export b: func(a: s8, b: s16, c: s32, d: s64) -> string
   export c: func() -> tuple<s8, s16, s32, s64>
diff --git a/crates/wit-component/tests/components/import-and-export-resource/component.wat b/crates/wit-component/tests/components/import-and-export-resource/component.wat
deleted file mode 100644
index bc74f956..00000000
--- a/crates/wit-component/tests/components/import-and-export-resource/component.wat
+++ /dev/null
@@ -1,53 +0,0 @@
-(component
-  (type (;0;)
-    (instance
-      (export (;0;) "a" (type (sub resource)))
-    )
-  )
-  (import (interface "foo:bar/foo") (instance (;0;) (type 0)))
-  (alias export 0 "a" (type (;1;)))
-  (import "a" (type (;2;) (eq 1)))
-  (core module (;0;)
-    (type (;0;) (func (param i32)))
-    (type (;1;) (func (param i32) (result i32)))
-    (import "foo:bar/foo" "[resource-drop]a" (func (;0;) (type 0)))
-    (import "[export]foo:bar/foo" "[resource-drop]a" (func (;1;) (type 0)))
-    (import "[export]foo:bar/foo" "[resource-rep]a" (func (;2;) (type 1)))
-    (import "[export]foo:bar/foo" "[resource-new]a" (func (;3;) (type 1)))
-    (@producers
-      (processed-by "wit-component" "$CARGO_PKG_VERSION")
-      (processed-by "my-fake-bindgen" "123.45")
-    )
-  )
-  (alias export 0 "a" (type (;3;)))
-  (core func (;0;) (canon resource.drop 3))
-  (core instance (;0;)
-    (export "[resource-drop]a" (func 0))
-  )
-  (type (;4;) (resource (rep i32)))
-  (core func (;1;) (canon resource.drop 4))
-  (core func (;2;) (canon resource.rep 4))
-  (core func (;3;) (canon resource.new 4))
-  (core instance (;1;)
-    (export "[resource-drop]a" (func 1))
-    (export "[resource-rep]a" (func 2))
-    (export "[resource-new]a" (func 3))
-  )
-  (core instance (;2;) (instantiate 0
-      (with "foo:bar/foo" (instance 0))
-      (with "[export]foo:bar/foo" (instance 1))
-    )
-  )
-  (component (;0;)
-    (import "import-type-a" (type (;0;) (sub resource)))
-    (export (;1;) "a" (type 0))
-  )
-  (instance (;1;) (instantiate 0
-      (with "import-type-a" (type 4))
-    )
-  )
-  (@producers
-    (processed-by "wit-component" "$CARGO_PKG_VERSION")
-  )
-  (export (;2;) (interface "foo:bar/foo") (instance 1))
-)
\ No newline at end of file
diff --git a/crates/wit-component/tests/components/import-and-export-resource/component.wit.print b/crates/wit-component/tests/components/import-and-export-resource/component.wit.print
deleted file mode 100644
index 3714cd57..00000000
--- a/crates/wit-component/tests/components/import-and-export-resource/component.wit.print
+++ /dev/null
@@ -1,8 +0,0 @@
-package root:component
-
-world root {
-  import foo:bar/foo
-  use foo:bar/foo.{a}
-
-  export foo:bar/foo
-}
diff --git a/crates/wit-component/tests/components/import-and-export-resource/module.wat b/crates/wit-component/tests/components/import-and-export-resource/module.wat
deleted file mode 100644
index a764f164..00000000
--- a/crates/wit-component/tests/components/import-and-export-resource/module.wat
+++ /dev/null
@@ -1,6 +0,0 @@
-(module
-  (import "foo:bar/foo" "[resource-drop]a" (func (param i32)))
-  (import "[export]foo:bar/foo" "[resource-drop]a" (func (param i32)))
-  (import "[export]foo:bar/foo" "[resource-rep]a" (func (param i32) (result i32)))
-  (import "[export]foo:bar/foo" "[resource-new]a" (func (param i32) (result i32)))
-)
diff --git a/crates/wit-component/tests/components/import-and-export-resource/module.wit b/crates/wit-component/tests/components/import-and-export-resource/module.wit
deleted file mode 100644
index 03e55351..00000000
--- a/crates/wit-component/tests/components/import-and-export-resource/module.wit
+++ /dev/null
@@ -1,12 +0,0 @@
-package foo:bar
-
-interface foo {
-  resource a
-}
-
-world module {
-  import foo
-  use foo.{a}
-
-  export foo
-}
diff --git a/crates/wit-component/tests/components/import-conflict/component.wat b/crates/wit-component/tests/components/import-conflict/component.wat
index 15306e9b..c0f216f2 100644
--- a/crates/wit-component/tests/components/import-conflict/component.wat
+++ b/crates/wit-component/tests/components/import-conflict/component.wat
@@ -5,7 +5,7 @@
       (export (;0;) "a" (func (type 0)))
     )
   )
-  (import (interface "foo:foo/bar") (instance (;0;) (type 0)))
+  (import "bar" (instance (;0;) (type 0)))
   (type (;1;)
     (instance
       (type (;0;) (list u8))
@@ -13,44 +13,40 @@
       (export (;0;) "baz" (func (type 1)))
     )
   )
-  (import (interface "foo:foo/baz") (instance (;1;) (type 1)))
+  (import "baz" (instance (;1;) (type 1)))
   (type (;2;)
     (instance
       (type (;0;) (func))
       (export (;0;) "a" (func (type 0)))
     )
   )
-  (import (interface "foo:foo/foo") (instance (;2;) (type 2)))
+  (import "foo" (instance (;2;) (type 2)))
   (core module (;0;)
     (type (;0;) (func))
     (type (;1;) (func (param i64 i32 i32)))
     (type (;2;) (func (param i32 i32 i32)))
     (type (;3;) (func (param i32 i32 i32 i32) (result i32)))
-    (import "foo:foo/foo" "a" (func (;0;) (type 0)))
-    (import "foo:foo/bar" "a" (func (;1;) (type 1)))
-    (import "foo:foo/baz" "baz" (func (;2;) (type 2)))
+    (import "foo" "a" (func (;0;) (type 0)))
+    (import "bar" "a" (func (;1;) (type 1)))
+    (import "baz" "baz" (func (;2;) (type 2)))
     (func (;3;) (type 3) (param i32 i32 i32 i32) (result i32)
       unreachable
     )
     (memory (;0;) 1)
     (export "memory" (memory 0))
     (export "cabi_realloc" (func 3))
-    (@producers
-      (processed-by "wit-component" "$CARGO_PKG_VERSION")
-      (processed-by "my-fake-bindgen" "123.45")
-    )
   )
   (core module (;1;)
     (type (;0;) (func (param i64 i32 i32)))
     (type (;1;) (func (param i32 i32 i32)))
-    (func $indirect-foo:foo/bar-a (;0;) (type 0) (param i64 i32 i32)
+    (func $indirect-bar-a (;0;) (type 0) (param i64 i32 i32)
       local.get 0
       local.get 1
       local.get 2
       i32.const 0
       call_indirect (type 0)
     )
-    (func $indirect-foo:foo/baz-baz (;1;) (type 1) (param i32 i32 i32)
+    (func $indirect-baz-baz (;1;) (type 1) (param i32 i32 i32)
       local.get 0
       local.get 1
       local.get 2
@@ -58,12 +54,9 @@
       call_indirect (type 1)
     )
     (table (;0;) 2 2 funcref)
-    (export "0" (func $indirect-foo:foo/bar-a))
-    (export "1" (func $indirect-foo:foo/baz-baz))
+    (export "0" (func $indirect-bar-a))
+    (export "1" (func $indirect-baz-baz))
     (export "$imports" (table 0))
-    (@producers
-      (processed-by "wit-component" "$CARGO_PKG_VERSION")
-    )
   )
   (core module (;2;)
     (type (;0;) (func (param i64 i32 i32)))
@@ -72,9 +65,6 @@
     (import "" "1" (func (;1;) (type 1)))
     (import "" "$imports" (table (;0;) 2 2 funcref))
     (elem (;0;) (i32.const 0) func 0 1)
-    (@producers
-      (processed-by "wit-component" "$CARGO_PKG_VERSION")
-    )
   )
   (core instance (;0;) (instantiate 1))
   (alias export 2 "a" (func (;0;)))
@@ -91,9 +81,9 @@
     (export "baz" (func 2))
   )
   (core instance (;4;) (instantiate 0
-      (with "foo:foo/foo" (instance 1))
-      (with "foo:foo/bar" (instance 2))
-      (with "foo:foo/baz" (instance 3))
+      (with "foo" (instance 1))
+      (with "bar" (instance 2))
+      (with "baz" (instance 3))
     )
   )
   (alias core export 4 "memory" (core memory (;0;)))
@@ -103,9 +93,6 @@
   (core func (;4;) (canon lower (func 1) (memory 0) string-encoding=utf8))
   (alias export 1 "baz" (func (;2;)))
   (core func (;5;) (canon lower (func 2) (memory 0) (realloc 3)))
-  (@producers
-    (processed-by "wit-component" "$CARGO_PKG_VERSION")
-  )
   (core instance (;5;)
     (export "$imports" (table 0))
     (export "0" (func 4))
diff --git a/crates/wit-component/tests/components/import-conflict/component.wit b/crates/wit-component/tests/components/import-conflict/component.wit
new file mode 100644
index 00000000..d2726dc7
--- /dev/null
+++ b/crates/wit-component/tests/components/import-conflict/component.wit
@@ -0,0 +1,17 @@
+interface bar {
+  a: func(x: u64, y: string)
+}
+
+interface baz {
+  baz: func(x: list<u8>) -> list<u8>
+}
+
+interface foo {
+  a: func()
+}
+
+default world component {
+  import bar: self.bar
+  import baz: self.baz
+  import foo: self.foo
+}
diff --git a/crates/wit-component/tests/components/import-conflict/component.wit.print b/crates/wit-component/tests/components/import-conflict/component.wit.print
deleted file mode 100644
index 40cd5d91..00000000
--- a/crates/wit-component/tests/components/import-conflict/component.wit.print
+++ /dev/null
@@ -1,7 +0,0 @@
-package root:component
-
-world root {
-  import foo:foo/bar
-  import foo:foo/baz
-  import foo:foo/foo
-}
diff --git a/crates/wit-component/tests/components/import-conflict/module.wat b/crates/wit-component/tests/components/import-conflict/module.wat
index b0b2aa64..b7cacf1a 100644
--- a/crates/wit-component/tests/components/import-conflict/module.wat
+++ b/crates/wit-component/tests/components/import-conflict/module.wat
@@ -1,7 +1,7 @@
 (module
-  (import "foo:foo/foo" "a" (func))
-  (import "foo:foo/bar" "a" (func (param i64 i32 i32)))
-  (import "foo:foo/baz" "baz" (func (param i32 i32 i32)))
+  (import "foo" "a" (func))
+  (import "bar" "a" (func (param i64 i32 i32)))
+  (import "baz" "baz" (func (param i32 i32 i32)))
   (memory (export "memory") 1)
   (func (export "cabi_realloc") (param i32 i32 i32 i32) (result i32) unreachable)
-)
+)
\ No newline at end of file
diff --git a/crates/wit-component/tests/components/import-conflict/module.wit b/crates/wit-component/tests/components/import-conflict/module.wit
index bb1345b3..4c23d0a2 100644
--- a/crates/wit-component/tests/components/import-conflict/module.wit
+++ b/crates/wit-component/tests/components/import-conflict/module.wit
@@ -1,5 +1,3 @@
-package foo:foo
-
 interface foo {
   a: func()
 }
@@ -12,8 +10,8 @@ interface baz {
   baz: func(x: list<u8>) -> list<u8>
 }
 
-world module {
-  import bar
-  import baz
-  import foo
+default world my-world {
+  import bar: self.bar
+  import baz: self.baz
+  import foo: self.foo
 }
diff --git a/crates/wit-component/tests/components/import-empty-interface/component.wat b/crates/wit-component/tests/components/import-empty-interface/component.wat
index 202d5031..3f194a21 100644
--- a/crates/wit-component/tests/components/import-empty-interface/component.wat
+++ b/crates/wit-component/tests/components/import-empty-interface/component.wat
@@ -1,12 +1,4 @@
 (component
-  (core module (;0;)
-    (@producers
-      (processed-by "wit-component" "$CARGO_PKG_VERSION")
-      (processed-by "my-fake-bindgen" "123.45")
-    )
-  )
-  (@producers
-    (processed-by "wit-component" "$CARGO_PKG_VERSION")
-  )
+  (core module (;0;))
   (core instance (;0;) (instantiate 0))
 )
\ No newline at end of file
diff --git a/crates/wit-component/tests/components/import-empty-interface/component.wit b/crates/wit-component/tests/components/import-empty-interface/component.wit
new file mode 100644
index 00000000..da09ea6e
--- /dev/null
+++ b/crates/wit-component/tests/components/import-empty-interface/component.wit
@@ -0,0 +1,2 @@
+default world component {
+}
diff --git a/crates/wit-component/tests/components/import-empty-interface/component.wit.print b/crates/wit-component/tests/components/import-empty-interface/component.wit.print
deleted file mode 100644
index bcd860d3..00000000
--- a/crates/wit-component/tests/components/import-empty-interface/component.wit.print
+++ /dev/null
@@ -1,4 +0,0 @@
-package root:component
-
-world root {
-}
diff --git a/crates/wit-component/tests/components/import-empty-interface/module.wit b/crates/wit-component/tests/components/import-empty-interface/module.wit
index 02b6a5dc..b92bce2a 100644
--- a/crates/wit-component/tests/components/import-empty-interface/module.wit
+++ b/crates/wit-component/tests/components/import-empty-interface/module.wit
@@ -1,5 +1,3 @@
-package foo:foo
-
-world module {
+default world foo {
   import foo: interface {}
 }
diff --git a/crates/wit-component/tests/components/import-export-same-iface-name/component.wat b/crates/wit-component/tests/components/import-export-same-iface-name/component.wat
deleted file mode 100644
index e2f80931..00000000
--- a/crates/wit-component/tests/components/import-export-same-iface-name/component.wat
+++ /dev/null
@@ -1,59 +0,0 @@
-(component
-  (type (;0;)
-    (instance
-      (type (;0;) (func))
-      (export (;0;) "a" (func (type 0)))
-    )
-  )
-  (import (interface "foo:dep/the-name") (instance (;0;) (type 0)))
-  (type (;1;)
-    (instance
-      (type (;0;) (func))
-      (export (;0;) "a" (func (type 0)))
-    )
-  )
-  (import (interface "foo:foo/the-name") (instance (;1;) (type 1)))
-  (core module (;0;)
-    (type (;0;) (func))
-    (import "foo:dep/the-name" "a" (func (;0;) (type 0)))
-    (import "foo:foo/the-name" "a" (func (;1;) (type 0)))
-    (func (;2;) (type 0))
-    (export "foo:foo/the-name#a" (func 2))
-    (@producers
-      (processed-by "wit-component" "$CARGO_PKG_VERSION")
-      (processed-by "my-fake-bindgen" "123.45")
-    )
-  )
-  (alias export 0 "a" (func (;0;)))
-  (core func (;0;) (canon lower (func 0)))
-  (core instance (;0;)
-    (export "a" (func 0))
-  )
-  (alias export 1 "a" (func (;1;)))
-  (core func (;1;) (canon lower (func 1)))
-  (core instance (;1;)
-    (export "a" (func 1))
-  )
-  (core instance (;2;) (instantiate 0
-      (with "foo:dep/the-name" (instance 0))
-      (with "foo:foo/the-name" (instance 1))
-    )
-  )
-  (type (;2;) (func))
-  (alias core export 2 "foo:foo/the-name#a" (core func (;2;)))
-  (func (;2;) (type 2) (canon lift (core func 2)))
-  (component (;0;)
-    (type (;0;) (func))
-    (import "import-func-a" (func (;0;) (type 0)))
-    (type (;1;) (func))
-    (export (;1;) "a" (func 0) (func (type 1)))
-  )
-  (instance (;2;) (instantiate 0
-      (with "import-func-a" (func 2))
-    )
-  )
-  (@producers
-    (processed-by "wit-component" "$CARGO_PKG_VERSION")
-  )
-  (export (;3;) (interface "foo:foo/the-name") (instance 2))
-)
\ No newline at end of file
diff --git a/crates/wit-component/tests/components/import-export-same-iface-name/component.wit.print b/crates/wit-component/tests/components/import-export-same-iface-name/component.wit.print
deleted file mode 100644
index 2841ebd4..00000000
--- a/crates/wit-component/tests/components/import-export-same-iface-name/component.wit.print
+++ /dev/null
@@ -1,8 +0,0 @@
-package root:component
-
-world root {
-  import foo:dep/the-name
-  import foo:foo/the-name
-
-  export foo:foo/the-name
-}
diff --git a/crates/wit-component/tests/components/import-export-same-iface-name/deps/dep/foo.wit b/crates/wit-component/tests/components/import-export-same-iface-name/deps/dep/foo.wit
deleted file mode 100644
index c315c9fc..00000000
--- a/crates/wit-component/tests/components/import-export-same-iface-name/deps/dep/foo.wit
+++ /dev/null
@@ -1,5 +0,0 @@
-package foo:dep
-
-interface the-name {
-  a: func()
-}
diff --git a/crates/wit-component/tests/components/import-export-same-iface-name/module.wat b/crates/wit-component/tests/components/import-export-same-iface-name/module.wat
deleted file mode 100644
index 4e9ece50..00000000
--- a/crates/wit-component/tests/components/import-export-same-iface-name/module.wat
+++ /dev/null
@@ -1,5 +0,0 @@
-(module
-  (import "foo:dep/the-name" "a" (func))
-  (import "foo:foo/the-name" "a" (func))
-  (func (export "foo:foo/the-name#a"))
-)
diff --git a/crates/wit-component/tests/components/import-export-same-iface-name/module.wit b/crates/wit-component/tests/components/import-export-same-iface-name/module.wit
deleted file mode 100644
index ce27d8cb..00000000
--- a/crates/wit-component/tests/components/import-export-same-iface-name/module.wit
+++ /dev/null
@@ -1,11 +0,0 @@
-package foo:foo
-
-interface the-name {
-  a: func()
-}
-
-world module {
-  import foo:dep/the-name
-  import the-name
-  export the-name
-}
diff --git a/crates/wit-component/tests/components/import-export/component.wat b/crates/wit-component/tests/components/import-export/component.wat
index 65e1fb1f..f533a510 100644
--- a/crates/wit-component/tests/components/import-export/component.wat
+++ b/crates/wit-component/tests/components/import-export/component.wat
@@ -39,10 +39,6 @@
     (export "bar#a" (func 4))
     (export "bar#b" (func 5))
     (export "cabi_post_bar#b" (func 6))
-    (@producers
-      (processed-by "wit-component" "$CARGO_PKG_VERSION")
-      (processed-by "my-fake-bindgen" "123.45")
-    )
   )
   (core module (;1;)
     (type (;0;) (func (param i32)))
@@ -54,18 +50,12 @@
     (table (;0;) 1 1 funcref)
     (export "0" (func $indirect-foo-a))
     (export "$imports" (table 0))
-    (@producers
-      (processed-by "wit-component" "$CARGO_PKG_VERSION")
-    )
   )
   (core module (;2;)
     (type (;0;) (func (param i32)))
     (import "" "0" (func (;0;) (type 0)))
     (import "" "$imports" (table (;0;) 1 1 funcref))
     (elem (;0;) (i32.const 0) func 0)
-    (@producers
-      (processed-by "wit-component" "$CARGO_PKG_VERSION")
-    )
   )
   (core instance (;0;) (instantiate 1))
   (alias core export 0 "0" (core func (;0;)))
@@ -97,18 +87,18 @@
   (alias core export 2 "cabi_post_bar#b" (core func (;5;)))
   (func (;2;) (type 2) (canon lift (core func 4) (memory 0) string-encoding=utf8 (post-return 5)))
   (component (;0;)
-    (type (;0;) (func))
-    (import "import-func-a" (func (;0;) (type 0)))
-    (type (;1;) (func (result string)))
-    (import "import-func-b" (func (;1;) (type 1)))
+    (alias outer 1 1 (type (;0;)))
+    (import "import-a" (func (;0;) (type 0)))
+    (alias outer 1 2 (type (;1;)))
+    (import "import-b" (func (;1;) (type 1)))
     (type (;2;) (func))
     (export (;2;) "a" (func 0) (func (type 2)))
     (type (;3;) (func (result string)))
     (export (;3;) "b" (func 1) (func (type 3)))
   )
   (instance (;1;) (instantiate 0
-      (with "import-func-a" (func 1))
-      (with "import-func-b" (func 2))
+      (with "import-a" (func 1))
+      (with "import-b" (func 2))
     )
   )
   (export (;2;) "bar" (instance 1))
@@ -117,8 +107,5 @@
   (alias core export 2 "a" (core func (;6;)))
   (alias core export 2 "cabi_post_a" (core func (;7;)))
   (func (;3;) (type 4) (canon lift (core func 6) (memory 0) (realloc 1) string-encoding=utf8 (post-return 7)))
-  (@producers
-    (processed-by "wit-component" "$CARGO_PKG_VERSION")
-  )
   (export (;4;) "a" (func 3))
 )
\ No newline at end of file
diff --git a/crates/wit-component/tests/components/import-export/component.wit b/crates/wit-component/tests/components/import-export/component.wit
new file mode 100644
index 00000000..04294f3d
--- /dev/null
+++ b/crates/wit-component/tests/components/import-export/component.wit
@@ -0,0 +1,15 @@
+interface foo {
+  a: func() -> string
+}
+
+interface bar {
+  a: func()
+
+  b: func() -> string
+}
+
+default world component {
+  import foo: self.foo
+  export bar: self.bar
+  export a: func(x: string) -> tuple<string, u32, string>
+}
diff --git a/crates/wit-component/tests/components/import-export/component.wit.print b/crates/wit-component/tests/components/import-export/component.wit.print
deleted file mode 100644
index 8121619d..00000000
--- a/crates/wit-component/tests/components/import-export/component.wit.print
+++ /dev/null
@@ -1,14 +0,0 @@
-package root:component
-
-world root {
-  import foo: interface {
-    a: func() -> string
-  }
-
-  export bar: interface {
-    a: func()
-
-    b: func() -> string
-  }
-  export a: func(x: string) -> tuple<string, u32, string>
-}
diff --git a/crates/wit-component/tests/components/import-export/module.wit b/crates/wit-component/tests/components/import-export/module.wit
index d90fee1f..3b29a2b8 100644
--- a/crates/wit-component/tests/components/import-export/module.wit
+++ b/crates/wit-component/tests/components/import-export/module.wit
@@ -1,6 +1,4 @@
-package foo:foo
-
-world module {
+default world my-world {
   import foo: interface {
     a: func() -> string
   }
diff --git a/crates/wit-component/tests/components/import-in-adapter-and-main-module/adapt-old.wat b/crates/wit-component/tests/components/import-in-adapter-and-main-module/adapt-old.wat
deleted file mode 100644
index 56db4f55..00000000
--- a/crates/wit-component/tests/components/import-in-adapter-and-main-module/adapt-old.wat
+++ /dev/null
@@ -1,23 +0,0 @@
-(module
-  (import "foo:shared-dependency/doc" "f1" (func $f1))
-  (import "foo:shared-dependency/doc" "f3" (func $f3))
-
-  (import "foo:shared-dependency/doc" "g1" (func $g1 (param i32)))
-  (import "foo:shared-dependency/doc" "g3" (func $g3 (param i32)))
-
-  (import "foo:shared-dependency/doc" "unused-in-adapter" (func))
-  (import "env" "memory" (memory 0))
-
-  (import "adapter-dep" "foo" (func $foo (result i32)))
-
-  (func (export "adapter-f1")
-    call $f1
-    call $f3
-    (call $g1 (i32.const 0))
-    (call $g3 (i32.const 0))
-    (drop (call $foo))
-  )
-
-  (func (export "cabi_import_realloc") (param i32 i32 i32 i32) (result i32)
-    unreachable)
-)
diff --git a/crates/wit-component/tests/components/import-in-adapter-and-main-module/adapt-old.wit b/crates/wit-component/tests/components/import-in-adapter-and-main-module/adapt-old.wit
deleted file mode 100644
index 904c79ea..00000000
--- a/crates/wit-component/tests/components/import-in-adapter-and-main-module/adapt-old.wit
+++ /dev/null
@@ -1,9 +0,0 @@
-world adapt-old {
-  import foo:shared-dependency/doc
-
-  import adapter-dep: interface {
-    use foo:shared-dependency/types.{a-typedef}
-
-    foo: func() -> a-typedef
-  }
-}
diff --git a/crates/wit-component/tests/components/import-in-adapter-and-main-module/component.wat b/crates/wit-component/tests/components/import-in-adapter-and-main-module/component.wat
deleted file mode 100644
index 08809249..00000000
--- a/crates/wit-component/tests/components/import-in-adapter-and-main-module/component.wat
+++ /dev/null
@@ -1,220 +0,0 @@
-(component
-  (type (;0;)
-    (instance
-      (type (;0;) (func))
-      (export (;0;) "f1" (func (type 0)))
-      (export (;1;) "f2" (func (type 0)))
-      (export (;2;) "f3" (func (type 0)))
-      (type (;1;) (func (result string)))
-      (export (;3;) "g1" (func (type 1)))
-      (export (;4;) "g2" (func (type 1)))
-      (export (;5;) "g3" (func (type 1)))
-    )
-  )
-  (import (interface "foo:shared-dependency/doc") (instance (;0;) (type 0)))
-  (type (;1;)
-    (instance
-      (type (;0;) u32)
-      (export (;1;) "a-typedef" (type (eq 0)))
-    )
-  )
-  (import (interface "foo:shared-dependency/types") (instance (;1;) (type 1)))
-  (alias export 1 "a-typedef" (type (;2;)))
-  (type (;3;)
-    (instance
-      (alias outer 1 2 (type (;0;)))
-      (export (;1;) "a-typedef" (type (eq 0)))
-      (type (;2;) (func (result 1)))
-      (export (;0;) "foo" (func (type 2)))
-    )
-  )
-  (import "main-dep" (instance (;2;) (type 3)))
-  (alias export 1 "a-typedef" (type (;4;)))
-  (type (;5;)
-    (instance
-      (alias outer 1 4 (type (;0;)))
-      (export (;1;) "a-typedef" (type (eq 0)))
-      (type (;2;) (func (result 1)))
-      (export (;0;) "foo" (func (type 2)))
-    )
-  )
-  (import "adapter-dep" (instance (;3;) (type 5)))
-  (core module (;0;)
-    (type (;0;) (func))
-    (type (;1;) (func (param i32)))
-    (type (;2;) (func (result i32)))
-    (type (;3;) (func (param i32 i32 i32 i32) (result i32)))
-    (import "foo:shared-dependency/doc" "f1" (func (;0;) (type 0)))
-    (import "foo:shared-dependency/doc" "f2" (func (;1;) (type 0)))
-    (import "foo:shared-dependency/doc" "g1" (func (;2;) (type 1)))
-    (import "foo:shared-dependency/doc" "g2" (func (;3;) (type 1)))
-    (import "old" "adapter-f1" (func (;4;) (type 0)))
-    (import "main-dep" "foo" (func (;5;) (type 2)))
-    (func (;6;) (type 3) (param i32 i32 i32 i32) (result i32)
-      unreachable
-    )
-    (memory (;0;) 1)
-    (export "memory" (memory 0))
-    (export "cabi_realloc" (func 6))
-    (@producers
-      (processed-by "wit-component" "$CARGO_PKG_VERSION")
-      (processed-by "my-fake-bindgen" "123.45")
-    )
-  )
-  (core module (;1;)
-    (type (;0;) (func))
-    (type (;1;) (func (param i32)))
-    (type (;2;) (func (result i32)))
-    (type (;3;) (func (param i32 i32 i32 i32) (result i32)))
-    (import "foo:shared-dependency/doc" "f1" (func $f1 (;0;) (type 0)))
-    (import "foo:shared-dependency/doc" "f3" (func $f3 (;1;) (type 0)))
-    (import "foo:shared-dependency/doc" "g1" (func $g1 (;2;) (type 1)))
-    (import "foo:shared-dependency/doc" "g3" (func $g3 (;3;) (type 1)))
-    (import "adapter-dep" "foo" (func $foo (;4;) (type 2)))
-    (func (;5;) (type 0)
-      call $f1
-      call $f3
-      i32.const 0
-      call $g1
-      i32.const 0
-      call $g3
-      call $foo
-      drop
-    )
-    (func (;6;) (type 3) (param i32 i32 i32 i32) (result i32)
-      unreachable
-    )
-    (export "adapter-f1" (func 5))
-    (export "cabi_import_realloc" (func 6))
-  )
-  (core module (;2;)
-    (type (;0;) (func (param i32)))
-    (type (;1;) (func))
-    (func $indirect-foo:shared-dependency/doc-g1 (;0;) (type 0) (param i32)
-      local.get 0
-      i32.const 0
-      call_indirect (type 0)
-    )
-    (func $indirect-foo:shared-dependency/doc-g2 (;1;) (type 0) (param i32)
-      local.get 0
-      i32.const 1
-      call_indirect (type 0)
-    )
-    (func $#func2<indirect-foo:shared-dependency/doc-g1> (@name "indirect-foo:shared-dependency/doc-g1") (;2;) (type 0) (param i32)
-      local.get 0
-      i32.const 2
-      call_indirect (type 0)
-    )
-    (func $indirect-foo:shared-dependency/doc-g3 (;3;) (type 0) (param i32)
-      local.get 0
-      i32.const 3
-      call_indirect (type 0)
-    )
-    (func $adapt-old-adapter-f1 (;4;) (type 1)
-      i32.const 4
-      call_indirect (type 1)
-    )
-    (table (;0;) 5 5 funcref)
-    (export "0" (func $indirect-foo:shared-dependency/doc-g1))
-    (export "1" (func $indirect-foo:shared-dependency/doc-g2))
-    (export "2" (func $#func2<indirect-foo:shared-dependency/doc-g1>))
-    (export "3" (func $indirect-foo:shared-dependency/doc-g3))
-    (export "4" (func $adapt-old-adapter-f1))
-    (export "$imports" (table 0))
-    (@producers
-      (processed-by "wit-component" "$CARGO_PKG_VERSION")
-    )
-  )
-  (core module (;3;)
-    (type (;0;) (func (param i32)))
-    (type (;1;) (func))
-    (import "" "0" (func (;0;) (type 0)))
-    (import "" "1" (func (;1;) (type 0)))
-    (import "" "2" (func (;2;) (type 0)))
-    (import "" "3" (func (;3;) (type 0)))
-    (import "" "4" (func (;4;) (type 1)))
-    (import "" "$imports" (table (;0;) 5 5 funcref))
-    (elem (;0;) (i32.const 0) func 0 1 2 3 4)
-    (@producers
-      (processed-by "wit-component" "$CARGO_PKG_VERSION")
-    )
-  )
-  (core instance (;0;) (instantiate 2))
-  (alias export 0 "f1" (func (;0;)))
-  (core func (;0;) (canon lower (func 0)))
-  (alias export 0 "f2" (func (;1;)))
-  (core func (;1;) (canon lower (func 1)))
-  (alias core export 0 "0" (core func (;2;)))
-  (alias core export 0 "1" (core func (;3;)))
-  (core instance (;1;)
-    (export "f1" (func 0))
-    (export "f2" (func 1))
-    (export "g1" (func 2))
-    (export "g2" (func 3))
-  )
-  (alias export 2 "foo" (func (;2;)))
-  (core func (;4;) (canon lower (func 2)))
-  (core instance (;2;)
-    (export "foo" (func 4))
-  )
-  (alias core export 0 "4" (core func (;5;)))
-  (core instance (;3;)
-    (export "adapter-f1" (func 5))
-  )
-  (core instance (;4;) (instantiate 0
-      (with "foo:shared-dependency/doc" (instance 1))
-      (with "main-dep" (instance 2))
-      (with "old" (instance 3))
-    )
-  )
-  (alias core export 4 "memory" (core memory (;0;)))
-  (alias core export 4 "cabi_realloc" (core func (;6;)))
-  (alias export 0 "f1" (func (;3;)))
-  (core func (;7;) (canon lower (func 3)))
-  (alias export 0 "f3" (func (;4;)))
-  (core func (;8;) (canon lower (func 4)))
-  (alias core export 0 "2" (core func (;9;)))
-  (alias core export 0 "3" (core func (;10;)))
-  (core instance (;5;)
-    (export "f1" (func 7))
-    (export "f3" (func 8))
-    (export "g1" (func 9))
-    (export "g3" (func 10))
-  )
-  (alias export 3 "foo" (func (;5;)))
-  (core func (;11;) (canon lower (func 5)))
-  (core instance (;6;)
-    (export "foo" (func 11))
-  )
-  (core instance (;7;) (instantiate 1
-      (with "foo:shared-dependency/doc" (instance 5))
-      (with "adapter-dep" (instance 6))
-    )
-  )
-  (alias core export 7 "cabi_import_realloc" (core func (;12;)))
-  (alias core export 0 "$imports" (core table (;0;)))
-  (alias export 0 "g1" (func (;6;)))
-  (core func (;13;) (canon lower (func 6) (memory 0) (realloc 6) string-encoding=utf8))
-  (alias export 0 "g2" (func (;7;)))
-  (core func (;14;) (canon lower (func 7) (memory 0) (realloc 6) string-encoding=utf8))
-  (alias export 0 "g1" (func (;8;)))
-  (core func (;15;) (canon lower (func 8) (memory 0) (realloc 12) string-encoding=utf8))
-  (alias export 0 "g3" (func (;9;)))
-  (core func (;16;) (canon lower (func 9) (memory 0) (realloc 12) string-encoding=utf8))
-  (alias core export 7 "adapter-f1" (core func (;17;)))
-  (@producers
-    (processed-by "wit-component" "$CARGO_PKG_VERSION")
-  )
-  (core instance (;8;)
-    (export "$imports" (table 0))
-    (export "0" (func 13))
-    (export "1" (func 14))
-    (export "2" (func 15))
-    (export "3" (func 16))
-    (export "4" (func 17))
-  )
-  (core instance (;9;) (instantiate 3
-      (with "" (instance 8))
-    )
-  )
-)
\ No newline at end of file
diff --git a/crates/wit-component/tests/components/import-in-adapter-and-main-module/component.wit.print b/crates/wit-component/tests/components/import-in-adapter-and-main-module/component.wit.print
deleted file mode 100644
index f4c5c50a..00000000
--- a/crates/wit-component/tests/components/import-in-adapter-and-main-module/component.wit.print
+++ /dev/null
@@ -1,16 +0,0 @@
-package root:component
-
-world root {
-  import foo:shared-dependency/doc
-  import foo:shared-dependency/types
-  import main-dep: interface {
-    use foo:shared-dependency/types.{a-typedef}
-
-    foo: func() -> a-typedef
-  }
-  import adapter-dep: interface {
-    use foo:shared-dependency/types.{a-typedef}
-
-    foo: func() -> a-typedef
-  }
-}
diff --git a/crates/wit-component/tests/components/import-in-adapter-and-main-module/deps/shared-dependency/doc.wit b/crates/wit-component/tests/components/import-in-adapter-and-main-module/deps/shared-dependency/doc.wit
deleted file mode 100644
index ad3cbdc5..00000000
--- a/crates/wit-component/tests/components/import-in-adapter-and-main-module/deps/shared-dependency/doc.wit
+++ /dev/null
@@ -1,13 +0,0 @@
-package foo:shared-dependency
-
-interface doc {
-  f1: func()
-  f2: func()
-  f3: func()
-
-  g1: func() -> string
-  g2: func() -> string
-  g3: func() -> string
-
-  unused-in-adapter: func()
-}
diff --git a/crates/wit-component/tests/components/import-in-adapter-and-main-module/deps/shared-dependency/types.wit b/crates/wit-component/tests/components/import-in-adapter-and-main-module/deps/shared-dependency/types.wit
deleted file mode 100644
index 4119e948..00000000
--- a/crates/wit-component/tests/components/import-in-adapter-and-main-module/deps/shared-dependency/types.wit
+++ /dev/null
@@ -1,3 +0,0 @@
-interface types {
-  type a-typedef = u32
-}
diff --git a/crates/wit-component/tests/components/import-in-adapter-and-main-module/module.wat b/crates/wit-component/tests/components/import-in-adapter-and-main-module/module.wat
deleted file mode 100644
index 1f175654..00000000
--- a/crates/wit-component/tests/components/import-in-adapter-and-main-module/module.wat
+++ /dev/null
@@ -1,15 +0,0 @@
-(module
-  (import "foo:shared-dependency/doc" "f1" (func))
-  (import "foo:shared-dependency/doc" "f2" (func))
-
-  (import "foo:shared-dependency/doc" "g1" (func (param i32)))
-  (import "foo:shared-dependency/doc" "g2" (func (param i32)))
-
-  (import "old" "adapter-f1" (func))
-
-  (import "main-dep" "foo" (func (result i32)))
-
-  (memory (export "memory") 1)
-  (func (export "cabi_realloc") (param i32 i32 i32 i32) (result i32)
-    unreachable)
-)
diff --git a/crates/wit-component/tests/components/import-in-adapter-and-main-module/module.wit b/crates/wit-component/tests/components/import-in-adapter-and-main-module/module.wit
deleted file mode 100644
index 2df745b5..00000000
--- a/crates/wit-component/tests/components/import-in-adapter-and-main-module/module.wit
+++ /dev/null
@@ -1,11 +0,0 @@
-package foo:foo
-
-world module {
-  import foo:shared-dependency/doc
-
-  import main-dep: interface {
-    use foo:shared-dependency/types.{a-typedef}
-
-    foo: func() -> a-typedef
-  }
-}
diff --git a/crates/wit-component/tests/components/import-resource-in-interface/component.wat b/crates/wit-component/tests/components/import-resource-in-interface/component.wat
deleted file mode 100644
index df85bad0..00000000
--- a/crates/wit-component/tests/components/import-resource-in-interface/component.wat
+++ /dev/null
@@ -1,41 +0,0 @@
-(component
-  (type (;0;)
-    (instance
-      (export (;0;) "a" (type (sub resource)))
-      (type (;1;) (own 0))
-      (type (;2;) (func (result 1)))
-      (export (;0;) "[constructor]a" (func (type 2)))
-      (export (;1;) "[static]a.other-new" (func (type 2)))
-    )
-  )
-  (import "foo" (instance (;0;) (type 0)))
-  (core module (;0;)
-    (type (;0;) (func (result i32)))
-    (type (;1;) (func (param i32)))
-    (import "foo" "[constructor]a" (func (;0;) (type 0)))
-    (import "foo" "[static]a.other-new" (func (;1;) (type 0)))
-    (import "foo" "[resource-drop]a" (func (;2;) (type 1)))
-    (@producers
-      (processed-by "wit-component" "$CARGO_PKG_VERSION")
-      (processed-by "my-fake-bindgen" "123.45")
-    )
-  )
-  (alias export 0 "a" (type (;1;)))
-  (core func (;0;) (canon resource.drop 1))
-  (alias export 0 "[constructor]a" (func (;0;)))
-  (core func (;1;) (canon lower (func 0)))
-  (alias export 0 "[static]a.other-new" (func (;1;)))
-  (core func (;2;) (canon lower (func 1)))
-  (@producers
-    (processed-by "wit-component" "$CARGO_PKG_VERSION")
-  )
-  (core instance (;0;)
-    (export "[resource-drop]a" (func 0))
-    (export "[constructor]a" (func 1))
-    (export "[static]a.other-new" (func 2))
-  )
-  (core instance (;1;) (instantiate 0
-      (with "foo" (instance 0))
-    )
-  )
-)
\ No newline at end of file
diff --git a/crates/wit-component/tests/components/import-resource-in-interface/component.wit.print b/crates/wit-component/tests/components/import-resource-in-interface/component.wit.print
deleted file mode 100644
index 7192a217..00000000
--- a/crates/wit-component/tests/components/import-resource-in-interface/component.wit.print
+++ /dev/null
@@ -1,10 +0,0 @@
-package root:component
-
-world root {
-  import foo: interface {
-    resource a {
-      constructor()
-      other-new: static func() -> a
-    }
-  }
-}
diff --git a/crates/wit-component/tests/components/import-resource-in-interface/module.wat b/crates/wit-component/tests/components/import-resource-in-interface/module.wat
deleted file mode 100644
index e0bba54b..00000000
--- a/crates/wit-component/tests/components/import-resource-in-interface/module.wat
+++ /dev/null
@@ -1,5 +0,0 @@
-(module
-  (import "foo" "[constructor]a" (func (result i32)))
-  (import "foo" "[static]a.other-new" (func (result i32)))
-  (import "foo" "[resource-drop]a" (func (param i32)))
-)
diff --git a/crates/wit-component/tests/components/import-resource-in-interface/module.wit b/crates/wit-component/tests/components/import-resource-in-interface/module.wit
deleted file mode 100644
index d8f184d4..00000000
--- a/crates/wit-component/tests/components/import-resource-in-interface/module.wit
+++ /dev/null
@@ -1,11 +0,0 @@
-package foo:bar
-
-world module {
-  import foo: interface {
-    resource a {
-      constructor()
-
-      other-new: static func() -> a
-    }
-  }
-}
diff --git a/crates/wit-component/tests/components/import-resource-simple/component.wat b/crates/wit-component/tests/components/import-resource-simple/component.wat
deleted file mode 100644
index 2994ff07..00000000
--- a/crates/wit-component/tests/components/import-resource-simple/component.wat
+++ /dev/null
@@ -1,33 +0,0 @@
-(component
-  (import "a" (type (;0;) (sub resource)))
-  (type (;1;) (own 0))
-  (type (;2;) (func (result 1)))
-  (import "[constructor]a" (func (;0;) (type 2)))
-  (import "[static]a.other-new" (func (;1;) (type 2)))
-  (core module (;0;)
-    (type (;0;) (func (result i32)))
-    (type (;1;) (func (param i32)))
-    (import "$root" "[constructor]a" (func (;0;) (type 0)))
-    (import "$root" "[static]a.other-new" (func (;1;) (type 0)))
-    (import "$root" "[resource-drop]a" (func (;2;) (type 1)))
-    (@producers
-      (processed-by "wit-component" "$CARGO_PKG_VERSION")
-      (processed-by "my-fake-bindgen" "123.45")
-    )
-  )
-  (core func (;0;) (canon resource.drop 0))
-  (core func (;1;) (canon lower (func 0)))
-  (core func (;2;) (canon lower (func 1)))
-  (@producers
-    (processed-by "wit-component" "$CARGO_PKG_VERSION")
-  )
-  (core instance (;0;)
-    (export "[resource-drop]a" (func 0))
-    (export "[constructor]a" (func 1))
-    (export "[static]a.other-new" (func 2))
-  )
-  (core instance (;1;) (instantiate 0
-      (with "$root" (instance 0))
-    )
-  )
-)
\ No newline at end of file
diff --git a/crates/wit-component/tests/components/import-resource-simple/component.wit.print b/crates/wit-component/tests/components/import-resource-simple/component.wit.print
deleted file mode 100644
index 04086257..00000000
--- a/crates/wit-component/tests/components/import-resource-simple/component.wit.print
+++ /dev/null
@@ -1,8 +0,0 @@
-package root:component
-
-world root {
-  resource a {
-    constructor()
-    other-new: static func() -> a
-  }
-}
diff --git a/crates/wit-component/tests/components/import-resource-simple/module.wat b/crates/wit-component/tests/components/import-resource-simple/module.wat
deleted file mode 100644
index 640aa632..00000000
--- a/crates/wit-component/tests/components/import-resource-simple/module.wat
+++ /dev/null
@@ -1,5 +0,0 @@
-(module
-  (import "$root" "[constructor]a" (func (result i32)))
-  (import "$root" "[static]a.other-new" (func (result i32)))
-  (import "$root" "[resource-drop]a" (func (param i32)))
-)
diff --git a/crates/wit-component/tests/components/import-resource-simple/module.wit b/crates/wit-component/tests/components/import-resource-simple/module.wit
deleted file mode 100644
index bf927dc0..00000000
--- a/crates/wit-component/tests/components/import-resource-simple/module.wit
+++ /dev/null
@@ -1,9 +0,0 @@
-package foo:bar
-
-world module {
-  resource a {
-    constructor()
-
-    other-new: static func() -> a
-  }
-}
diff --git a/crates/wit-component/tests/components/error-import-sig-mismatch/error.txt b/crates/wit-component/tests/components/import-sig-mismatch/error.txt
similarity index 100%
rename from crates/wit-component/tests/components/error-import-sig-mismatch/error.txt
rename to crates/wit-component/tests/components/import-sig-mismatch/error.txt
diff --git a/crates/wit-component/tests/components/error-import-sig-mismatch/module.wat b/crates/wit-component/tests/components/import-sig-mismatch/module.wat
similarity index 100%
rename from crates/wit-component/tests/components/error-import-sig-mismatch/module.wat
rename to crates/wit-component/tests/components/import-sig-mismatch/module.wat
diff --git a/crates/wit-component/tests/components/error-import-sig-mismatch/module.wit b/crates/wit-component/tests/components/import-sig-mismatch/module.wit
similarity index 64%
rename from crates/wit-component/tests/components/error-import-sig-mismatch/module.wit
rename to crates/wit-component/tests/components/import-sig-mismatch/module.wit
index cc3a41c5..3e06ced9 100644
--- a/crates/wit-component/tests/components/error-import-sig-mismatch/module.wit
+++ b/crates/wit-component/tests/components/import-sig-mismatch/module.wit
@@ -1,6 +1,4 @@
-package foo:foo
-
-world module {
+default world foo {
   import foo: interface {
     bar: func(s: string)
   }
diff --git a/crates/wit-component/tests/components/imports/component.wat b/crates/wit-component/tests/components/imports/component.wat
index 303edc9f..422b2d7c 100644
--- a/crates/wit-component/tests/components/imports/component.wat
+++ b/crates/wit-component/tests/components/imports/component.wat
@@ -1,25 +1,25 @@
 (component
   (type (;0;)
     (instance
-      (type (;0;) (record (field "a" u8)))
-      (export (;1;) "x" (type (eq 0)))
-      (type (;2;) (func (param "x" string)))
-      (export (;0;) "bar1" (func (type 2)))
-      (type (;3;) (func (param "x" 1)))
+      (type (;0;) (func (param "x" string)))
+      (export (;0;) "bar1" (func (type 0)))
+      (type (;1;) (record (field "a" u8)))
+      (export (;2;) "x" (type (eq 1)))
+      (type (;3;) (func (param "x" 2)))
       (export (;1;) "bar2" (func (type 3)))
     )
   )
   (import "bar" (instance (;0;) (type 0)))
   (type (;1;)
     (instance
-      (type (;0;) s8)
-      (export (;1;) "x" (type (eq 0)))
-      (type (;2;) (list string))
-      (type (;3;) (func (param "x" 2)))
-      (export (;0;) "baz1" (func (type 3)))
-      (type (;4;) (func))
-      (export (;1;) "baz2" (func (type 4)))
-      (type (;5;) (func (param "x" 1)))
+      (type (;0;) (list string))
+      (type (;1;) (func (param "x" 0)))
+      (export (;0;) "baz1" (func (type 1)))
+      (type (;2;) (func))
+      (export (;1;) "baz2" (func (type 2)))
+      (type (;3;) s8)
+      (export (;4;) "x" (type (eq 3)))
+      (type (;5;) (func (param "x" 4)))
       (export (;2;) "baz3" (func (type 5)))
     )
   )
@@ -55,10 +55,6 @@
     (memory (;0;) 1)
     (export "memory" (memory 0))
     (export "cabi_realloc" (func 8))
-    (@producers
-      (processed-by "wit-component" "$CARGO_PKG_VERSION")
-      (processed-by "my-fake-bindgen" "123.45")
-    )
   )
   (core module (;1;)
     (type (;0;) (func (param i32 i32)))
@@ -78,9 +74,6 @@
     (export "0" (func $indirect-bar-bar1))
     (export "1" (func $indirect-baz-baz1))
     (export "$imports" (table 0))
-    (@producers
-      (processed-by "wit-component" "$CARGO_PKG_VERSION")
-    )
   )
   (core module (;2;)
     (type (;0;) (func (param i32 i32)))
@@ -88,9 +81,6 @@
     (import "" "1" (func (;1;) (type 0)))
     (import "" "$imports" (table (;0;) 2 2 funcref))
     (elem (;0;) (i32.const 0) func 0 1)
-    (@producers
-      (processed-by "wit-component" "$CARGO_PKG_VERSION")
-    )
   )
   (core instance (;0;) (instantiate 1))
   (alias export 2 "foo1" (func (;0;)))
@@ -134,9 +124,6 @@
   (core func (;9;) (canon lower (func 6) (memory 0) string-encoding=utf8))
   (alias export 1 "baz1" (func (;7;)))
   (core func (;10;) (canon lower (func 7) (memory 0) string-encoding=utf8))
-  (@producers
-    (processed-by "wit-component" "$CARGO_PKG_VERSION")
-  )
   (core instance (;5;)
     (export "$imports" (table 0))
     (export "0" (func 9))
diff --git a/crates/wit-component/tests/components/imports/component.wit b/crates/wit-component/tests/components/imports/component.wit
new file mode 100644
index 00000000..cbb6b2de
--- /dev/null
+++ b/crates/wit-component/tests/components/imports/component.wit
@@ -0,0 +1,33 @@
+interface bar {
+  record x {
+    a: u8,
+  }
+
+  bar1: func(x: string)
+
+  bar2: func(x: x)
+}
+
+interface baz {
+  type x = s8
+
+  baz1: func(x: list<string>)
+
+  baz2: func()
+
+  baz3: func(x: x)
+}
+
+interface foo {
+  foo1: func()
+
+  foo2: func(x: u8)
+
+  foo3: func(x: float32)
+}
+
+default world component {
+  import bar: self.bar
+  import baz: self.baz
+  import foo: self.foo
+}
diff --git a/crates/wit-component/tests/components/imports/component.wit.print b/crates/wit-component/tests/components/imports/component.wit.print
deleted file mode 100644
index 4ca4e774..00000000
--- a/crates/wit-component/tests/components/imports/component.wit.print
+++ /dev/null
@@ -1,29 +0,0 @@
-package root:component
-
-world root {
-  import bar: interface {
-    record x {
-      a: u8,
-    }
-
-    bar1: func(x: string)
-
-    bar2: func(x: x)
-  }
-  import baz: interface {
-    type x = s8
-
-    baz1: func(x: list<string>)
-
-    baz2: func()
-
-    baz3: func(x: x)
-  }
-  import foo: interface {
-    foo1: func()
-
-    foo2: func(x: u8)
-
-    foo3: func(x: float32)
-  }
-}
diff --git a/crates/wit-component/tests/components/imports/module.wit b/crates/wit-component/tests/components/imports/module.wit
index a6fcd7a1..c5fad1d3 100644
--- a/crates/wit-component/tests/components/imports/module.wit
+++ b/crates/wit-component/tests/components/imports/module.wit
@@ -1,6 +1,4 @@
-package foo:foo
-
-world module {
+default world my-world {
   import bar: interface {
     record x {
         a: u8
diff --git a/crates/wit-component/tests/components/error-invalid-module-import/error.txt b/crates/wit-component/tests/components/invalid-module-import/error.txt
similarity index 100%
rename from crates/wit-component/tests/components/error-invalid-module-import/error.txt
rename to crates/wit-component/tests/components/invalid-module-import/error.txt
diff --git a/crates/wit-component/tests/components/error-invalid-module-import/module.wat b/crates/wit-component/tests/components/invalid-module-import/module.wat
similarity index 100%
rename from crates/wit-component/tests/components/error-invalid-module-import/module.wat
rename to crates/wit-component/tests/components/invalid-module-import/module.wat
diff --git a/crates/wit-component/tests/components/invalid-module-import/module.wit b/crates/wit-component/tests/components/invalid-module-import/module.wit
new file mode 100644
index 00000000..234a9191
--- /dev/null
+++ b/crates/wit-component/tests/components/invalid-module-import/module.wit
@@ -0,0 +1 @@
+default world foo {}
diff --git a/crates/wit-component/tests/components/lift-options/component.wat b/crates/wit-component/tests/components/lift-options/component.wat
index ffa1ede9..12972e3a 100644
--- a/crates/wit-component/tests/components/lift-options/component.wat
+++ b/crates/wit-component/tests/components/lift-options/component.wat
@@ -72,215 +72,190 @@
     (memory (;0;) 1)
     (export "memory" (memory 0))
     (export "cabi_realloc" (func 0))
-    (export "foo:foo/my-default#a" (func 1))
-    (export "foo:foo/my-default#b" (func 2))
-    (export "foo:foo/my-default#c" (func 3))
-    (export "foo:foo/my-default#d" (func 4))
-    (export "foo:foo/my-default#e" (func 5))
-    (export "foo:foo/my-default#f" (func 6))
-    (export "foo:foo/my-default#g" (func 7))
-    (export "foo:foo/my-default#h" (func 8))
-    (export "foo:foo/my-default#i" (func 9))
-    (export "foo:foo/my-default#j" (func 10))
-    (export "foo:foo/my-default#k" (func 11))
-    (export "foo:foo/my-default#l" (func 12))
-    (export "cabi_post_foo:foo/my-default#l" (func 13))
-    (export "foo:foo/my-default#m" (func 14))
-    (export "cabi_post_foo:foo/my-default#m" (func 15))
-    (export "foo:foo/my-default#n" (func 16))
-    (export "foo:foo/my-default#o" (func 17))
-    (export "cabi_post_foo:foo/my-default#o" (func 18))
-    (export "foo:foo/my-default#p" (func 19))
-    (export "cabi_post_foo:foo/my-default#p" (func 20))
-    (@producers
-      (processed-by "wit-component" "$CARGO_PKG_VERSION")
-      (processed-by "my-fake-bindgen" "123.45")
-    )
+    (export "foo#a" (func 1))
+    (export "foo#b" (func 2))
+    (export "foo#c" (func 3))
+    (export "foo#d" (func 4))
+    (export "foo#e" (func 5))
+    (export "foo#f" (func 6))
+    (export "foo#g" (func 7))
+    (export "foo#h" (func 8))
+    (export "foo#i" (func 9))
+    (export "foo#j" (func 10))
+    (export "foo#k" (func 11))
+    (export "foo#l" (func 12))
+    (export "cabi_post_foo#l" (func 13))
+    (export "foo#m" (func 14))
+    (export "cabi_post_foo#m" (func 15))
+    (export "foo#n" (func 16))
+    (export "foo#o" (func 17))
+    (export "cabi_post_foo#o" (func 18))
+    (export "foo#p" (func 19))
+    (export "cabi_post_foo#p" (func 20))
   )
   (core instance (;0;) (instantiate 0))
   (alias core export 0 "memory" (core memory (;0;)))
   (alias core export 0 "cabi_realloc" (core func (;0;)))
   (type (;0;) (func))
-  (alias core export 0 "foo:foo/my-default#a" (core func (;1;)))
+  (alias core export 0 "foo#a" (core func (;1;)))
   (func (;0;) (type 0) (canon lift (core func 1)))
   (type (;1;) (list string))
   (type (;2;) (func (param "x" 1)))
-  (alias core export 0 "foo:foo/my-default#b" (core func (;2;)))
+  (alias core export 0 "foo#b" (core func (;2;)))
   (func (;1;) (type 2) (canon lift (core func 2) (memory 0) (realloc 0) string-encoding=utf8))
   (type (;3;) (record (field "s" string)))
   (type (;4;) (func (param "x" 3)))
-  (alias core export 0 "foo:foo/my-default#c" (core func (;3;)))
+  (alias core export 0 "foo#c" (core func (;3;)))
   (func (;2;) (type 4) (canon lift (core func 3) (memory 0) (realloc 0) string-encoding=utf8))
   (type (;5;) (variant (case "s" string)))
   (type (;6;) (func (param "x" 5)))
-  (alias core export 0 "foo:foo/my-default#d" (core func (;4;)))
+  (alias core export 0 "foo#d" (core func (;4;)))
   (func (;3;) (type 6) (canon lift (core func 4) (memory 0) (realloc 0) string-encoding=utf8))
   (type (;7;) (record (field "s" u32)))
   (type (;8;) (func (param "x" 7)))
-  (alias core export 0 "foo:foo/my-default#e" (core func (;5;)))
+  (alias core export 0 "foo#e" (core func (;5;)))
   (func (;4;) (type 8) (canon lift (core func 5)))
   (type (;9;) (variant (case "s" u32)))
   (type (;10;) (func (param "x" 9)))
-  (alias core export 0 "foo:foo/my-default#f" (core func (;6;)))
+  (alias core export 0 "foo#f" (core func (;6;)))
   (func (;5;) (type 10) (canon lift (core func 6)))
   (type (;11;) (list 3))
   (type (;12;) (func (param "x" 11)))
-  (alias core export 0 "foo:foo/my-default#g" (core func (;7;)))
+  (alias core export 0 "foo#g" (core func (;7;)))
   (func (;6;) (type 12) (canon lift (core func 7) (memory 0) (realloc 0) string-encoding=utf8))
   (type (;13;) (list 5))
   (type (;14;) (func (param "x" 13)))
-  (alias core export 0 "foo:foo/my-default#h" (core func (;8;)))
+  (alias core export 0 "foo#h" (core func (;8;)))
   (func (;7;) (type 14) (canon lift (core func 8) (memory 0) (realloc 0) string-encoding=utf8))
   (type (;15;) (list u32))
   (type (;16;) (func (param "x" 15)))
-  (alias core export 0 "foo:foo/my-default#i" (core func (;9;)))
+  (alias core export 0 "foo#i" (core func (;9;)))
   (func (;8;) (type 16) (canon lift (core func 9) (memory 0) (realloc 0)))
   (type (;17;) (func (param "x" u32)))
-  (alias core export 0 "foo:foo/my-default#j" (core func (;10;)))
+  (alias core export 0 "foo#j" (core func (;10;)))
   (func (;9;) (type 17) (canon lift (core func 10)))
   (type (;18;) (tuple u32 u32))
   (type (;19;) (func (result 18)))
-  (alias core export 0 "foo:foo/my-default#k" (core func (;11;)))
+  (alias core export 0 "foo#k" (core func (;11;)))
   (func (;10;) (type 19) (canon lift (core func 11) (memory 0)))
   (type (;20;) (func (result string)))
-  (alias core export 0 "foo:foo/my-default#l" (core func (;12;)))
-  (alias core export 0 "cabi_post_foo:foo/my-default#l" (core func (;13;)))
+  (alias core export 0 "foo#l" (core func (;12;)))
+  (alias core export 0 "cabi_post_foo#l" (core func (;13;)))
   (func (;11;) (type 20) (canon lift (core func 12) (memory 0) string-encoding=utf8 (post-return 13)))
   (type (;21;) (func (result 15)))
-  (alias core export 0 "foo:foo/my-default#m" (core func (;14;)))
-  (alias core export 0 "cabi_post_foo:foo/my-default#m" (core func (;15;)))
+  (alias core export 0 "foo#m" (core func (;14;)))
+  (alias core export 0 "cabi_post_foo#m" (core func (;15;)))
   (func (;12;) (type 21) (canon lift (core func 14) (memory 0) (post-return 15)))
   (type (;22;) (func (result u32)))
-  (alias core export 0 "foo:foo/my-default#n" (core func (;16;)))
+  (alias core export 0 "foo#n" (core func (;16;)))
   (func (;13;) (type 22) (canon lift (core func 16)))
   (type (;23;) (func (result 5)))
-  (alias core export 0 "foo:foo/my-default#o" (core func (;17;)))
-  (alias core export 0 "cabi_post_foo:foo/my-default#o" (core func (;18;)))
+  (alias core export 0 "foo#o" (core func (;17;)))
+  (alias core export 0 "cabi_post_foo#o" (core func (;18;)))
   (func (;14;) (type 23) (canon lift (core func 17) (memory 0) string-encoding=utf8 (post-return 18)))
   (type (;24;) (list 9))
   (type (;25;) (func (result 24)))
-  (alias core export 0 "foo:foo/my-default#p" (core func (;19;)))
-  (alias core export 0 "cabi_post_foo:foo/my-default#p" (core func (;20;)))
+  (alias core export 0 "foo#p" (core func (;19;)))
+  (alias core export 0 "cabi_post_foo#p" (core func (;20;)))
   (func (;15;) (type 25) (canon lift (core func 19) (memory 0) (post-return 20)))
   (component (;0;)
-    (type (;0;) (func))
-    (import "import-func-a" (func (;0;) (type 0)))
-    (type (;1;) (list string))
-    (type (;2;) (func (param "x" 1)))
-    (import "import-func-b" (func (;1;) (type 2)))
-    (type (;3;) (record (field "s" string)))
-    (import "import-type-r" (type (;4;) (eq 3)))
-    (type (;5;) (func (param "x" 4)))
-    (import "import-func-c" (func (;2;) (type 5)))
-    (type (;6;) (variant (case "s" string)))
-    (import "import-type-v" (type (;7;) (eq 6)))
-    (type (;8;) (func (param "x" 7)))
-    (import "import-func-d" (func (;3;) (type 8)))
-    (type (;9;) (record (field "s" u32)))
-    (import "import-type-r-no-string" (type (;10;) (eq 9)))
-    (type (;11;) (func (param "x" 10)))
-    (import "import-func-e" (func (;4;) (type 11)))
-    (type (;12;) (variant (case "s" u32)))
-    (import "import-type-v-no-string" (type (;13;) (eq 12)))
-    (type (;14;) (func (param "x" 13)))
-    (import "import-func-f" (func (;5;) (type 14)))
-    (type (;15;) (list 4))
-    (type (;16;) (func (param "x" 15)))
-    (import "import-func-g" (func (;6;) (type 16)))
-    (type (;17;) (list 7))
+    (alias outer 1 0 (type (;0;)))
+    (import "import-a" (func (;0;) (type 0)))
+    (alias outer 1 2 (type (;1;)))
+    (import "import-b" (func (;1;) (type 1)))
+    (alias outer 1 4 (type (;2;)))
+    (import "import-c" (func (;2;) (type 2)))
+    (alias outer 1 6 (type (;3;)))
+    (import "import-d" (func (;3;) (type 3)))
+    (alias outer 1 8 (type (;4;)))
+    (import "import-e" (func (;4;) (type 4)))
+    (alias outer 1 10 (type (;5;)))
+    (import "import-f" (func (;5;) (type 5)))
+    (alias outer 1 12 (type (;6;)))
+    (import "import-g" (func (;6;) (type 6)))
+    (alias outer 1 14 (type (;7;)))
+    (import "import-h" (func (;7;) (type 7)))
+    (alias outer 1 16 (type (;8;)))
+    (import "import-i" (func (;8;) (type 8)))
+    (alias outer 1 17 (type (;9;)))
+    (import "import-j" (func (;9;) (type 9)))
+    (alias outer 1 19 (type (;10;)))
+    (import "import-k" (func (;10;) (type 10)))
+    (alias outer 1 20 (type (;11;)))
+    (import "import-l" (func (;11;) (type 11)))
+    (alias outer 1 21 (type (;12;)))
+    (import "import-m" (func (;12;) (type 12)))
+    (alias outer 1 22 (type (;13;)))
+    (import "import-n" (func (;13;) (type 13)))
+    (alias outer 1 23 (type (;14;)))
+    (import "import-o" (func (;14;) (type 14)))
+    (alias outer 1 25 (type (;15;)))
+    (import "import-p" (func (;15;) (type 15)))
+    (type (;16;) (func))
+    (export (;16;) "a" (func 0) (func (type 16)))
+    (type (;17;) (list string))
     (type (;18;) (func (param "x" 17)))
-    (import "import-func-h" (func (;7;) (type 18)))
-    (type (;19;) (list u32))
-    (type (;20;) (func (param "x" 19)))
-    (import "import-func-i" (func (;8;) (type 20)))
-    (type (;21;) (func (param "x" u32)))
-    (import "import-func-j" (func (;9;) (type 21)))
-    (type (;22;) (tuple u32 u32))
-    (type (;23;) (func (result 22)))
-    (import "import-func-k" (func (;10;) (type 23)))
-    (type (;24;) (func (result string)))
-    (import "import-func-l" (func (;11;) (type 24)))
-    (type (;25;) (func (result 19)))
-    (import "import-func-m" (func (;12;) (type 25)))
-    (type (;26;) (func (result u32)))
-    (import "import-func-n" (func (;13;) (type 26)))
-    (type (;27;) (func (result 7)))
-    (import "import-func-o" (func (;14;) (type 27)))
-    (type (;28;) (list 13))
-    (type (;29;) (func (result 28)))
-    (import "import-func-p" (func (;15;) (type 29)))
-    (type (;30;) (record (field "s" string)))
-    (export (;31;) "r" (type 30))
-    (type (;32;) (record (field "s" u32)))
-    (export (;33;) "r-no-string" (type 32))
-    (type (;34;) (variant (case "s" string)))
-    (export (;35;) "v" (type 34))
-    (type (;36;) (variant (case "s" u32)))
-    (export (;37;) "v-no-string" (type 36))
-    (type (;38;) (func))
-    (export (;16;) "a" (func 0) (func (type 38)))
-    (type (;39;) (list string))
-    (type (;40;) (func (param "x" 39)))
-    (export (;17;) "b" (func 1) (func (type 40)))
-    (type (;41;) (func (param "x" 31)))
-    (export (;18;) "c" (func 2) (func (type 41)))
-    (type (;42;) (func (param "x" 35)))
-    (export (;19;) "d" (func 3) (func (type 42)))
-    (type (;43;) (func (param "x" 33)))
-    (export (;20;) "e" (func 4) (func (type 43)))
-    (type (;44;) (func (param "x" 37)))
-    (export (;21;) "f" (func 5) (func (type 44)))
-    (type (;45;) (list 31))
-    (type (;46;) (func (param "x" 45)))
-    (export (;22;) "g" (func 6) (func (type 46)))
-    (type (;47;) (list 35))
-    (type (;48;) (func (param "x" 47)))
-    (export (;23;) "h" (func 7) (func (type 48)))
-    (type (;49;) (list u32))
-    (type (;50;) (func (param "x" 49)))
-    (export (;24;) "i" (func 8) (func (type 50)))
-    (type (;51;) (func (param "x" u32)))
-    (export (;25;) "j" (func 9) (func (type 51)))
-    (type (;52;) (tuple u32 u32))
-    (type (;53;) (func (result 52)))
-    (export (;26;) "k" (func 10) (func (type 53)))
-    (type (;54;) (func (result string)))
-    (export (;27;) "l" (func 11) (func (type 54)))
-    (type (;55;) (func (result 49)))
-    (export (;28;) "m" (func 12) (func (type 55)))
-    (type (;56;) (func (result u32)))
-    (export (;29;) "n" (func 13) (func (type 56)))
-    (type (;57;) (func (result 35)))
-    (export (;30;) "o" (func 14) (func (type 57)))
-    (type (;58;) (list 37))
-    (type (;59;) (func (result 58)))
-    (export (;31;) "p" (func 15) (func (type 59)))
+    (export (;17;) "b" (func 1) (func (type 18)))
+    (type (;19;) (record (field "s" string)))
+    (export (;20;) "r" (type 19))
+    (type (;21;) (func (param "x" 20)))
+    (export (;18;) "c" (func 2) (func (type 21)))
+    (type (;22;) (variant (case "s" string)))
+    (export (;23;) "v" (type 22))
+    (type (;24;) (func (param "x" 23)))
+    (export (;19;) "d" (func 3) (func (type 24)))
+    (type (;25;) (record (field "s" u32)))
+    (export (;26;) "r-no-string" (type 25))
+    (type (;27;) (func (param "x" 26)))
+    (export (;20;) "e" (func 4) (func (type 27)))
+    (type (;28;) (variant (case "s" u32)))
+    (export (;29;) "v-no-string" (type 28))
+    (type (;30;) (func (param "x" 29)))
+    (export (;21;) "f" (func 5) (func (type 30)))
+    (type (;31;) (list 20))
+    (type (;32;) (func (param "x" 31)))
+    (export (;22;) "g" (func 6) (func (type 32)))
+    (type (;33;) (list 23))
+    (type (;34;) (func (param "x" 33)))
+    (export (;23;) "h" (func 7) (func (type 34)))
+    (type (;35;) (list u32))
+    (type (;36;) (func (param "x" 35)))
+    (export (;24;) "i" (func 8) (func (type 36)))
+    (type (;37;) (func (param "x" u32)))
+    (export (;25;) "j" (func 9) (func (type 37)))
+    (type (;38;) (tuple u32 u32))
+    (type (;39;) (func (result 38)))
+    (export (;26;) "k" (func 10) (func (type 39)))
+    (type (;40;) (func (result string)))
+    (export (;27;) "l" (func 11) (func (type 40)))
+    (type (;41;) (func (result 35)))
+    (export (;28;) "m" (func 12) (func (type 41)))
+    (type (;42;) (func (result u32)))
+    (export (;29;) "n" (func 13) (func (type 42)))
+    (type (;43;) (func (result 23)))
+    (export (;30;) "o" (func 14) (func (type 43)))
+    (type (;44;) (list 29))
+    (type (;45;) (func (result 44)))
+    (export (;31;) "p" (func 15) (func (type 45)))
   )
   (instance (;0;) (instantiate 0
-      (with "import-func-a" (func 0))
-      (with "import-func-b" (func 1))
-      (with "import-func-c" (func 2))
-      (with "import-func-d" (func 3))
-      (with "import-func-e" (func 4))
-      (with "import-func-f" (func 5))
-      (with "import-func-g" (func 6))
-      (with "import-func-h" (func 7))
-      (with "import-func-i" (func 8))
-      (with "import-func-j" (func 9))
-      (with "import-func-k" (func 10))
-      (with "import-func-l" (func 11))
-      (with "import-func-m" (func 12))
-      (with "import-func-n" (func 13))
-      (with "import-func-o" (func 14))
-      (with "import-func-p" (func 15))
-      (with "import-type-r" (type 3))
-      (with "import-type-v" (type 5))
-      (with "import-type-r-no-string" (type 7))
-      (with "import-type-v-no-string" (type 9))
+      (with "import-a" (func 0))
+      (with "import-b" (func 1))
+      (with "import-c" (func 2))
+      (with "import-d" (func 3))
+      (with "import-e" (func 4))
+      (with "import-f" (func 5))
+      (with "import-g" (func 6))
+      (with "import-h" (func 7))
+      (with "import-i" (func 8))
+      (with "import-j" (func 9))
+      (with "import-k" (func 10))
+      (with "import-l" (func 11))
+      (with "import-m" (func 12))
+      (with "import-n" (func 13))
+      (with "import-o" (func 14))
+      (with "import-p" (func 15))
     )
   )
-  (@producers
-    (processed-by "wit-component" "$CARGO_PKG_VERSION")
-  )
-  (export (;1;) (interface "foo:foo/my-default") (instance 0))
+  (export (;1;) "foo" (instance 0))
 )
\ No newline at end of file
diff --git a/crates/wit-component/tests/components/lift-options/component.wit b/crates/wit-component/tests/components/lift-options/component.wit
new file mode 100644
index 00000000..ef941fcf
--- /dev/null
+++ b/crates/wit-component/tests/components/lift-options/component.wit
@@ -0,0 +1,53 @@
+interface foo {
+  record r {
+    s: string,
+  }
+
+  variant v {
+    s(string),
+  }
+
+  record r-no-string {
+    s: u32,
+  }
+
+  variant v-no-string {
+    s(u32),
+  }
+
+  a: func()
+
+  b: func(x: list<string>)
+
+  c: func(x: r)
+
+  d: func(x: v)
+
+  e: func(x: r-no-string)
+
+  f: func(x: v-no-string)
+
+  g: func(x: list<r>)
+
+  h: func(x: list<v>)
+
+  i: func(x: list<u32>)
+
+  j: func(x: u32)
+
+  k: func() -> tuple<u32, u32>
+
+  l: func() -> string
+
+  m: func() -> list<u32>
+
+  n: func() -> u32
+
+  o: func() -> v
+
+  p: func() -> list<v-no-string>
+}
+
+default world component {
+  export foo: self.foo
+}
diff --git a/crates/wit-component/tests/components/lift-options/component.wit.print b/crates/wit-component/tests/components/lift-options/component.wit.print
deleted file mode 100644
index eef89f13..00000000
--- a/crates/wit-component/tests/components/lift-options/component.wit.print
+++ /dev/null
@@ -1,5 +0,0 @@
-package root:component
-
-world root {
-  export foo:foo/my-default
-}
diff --git a/crates/wit-component/tests/components/lift-options/module.wat b/crates/wit-component/tests/components/lift-options/module.wat
index 242c2057..aa6a7acb 100644
--- a/crates/wit-component/tests/components/lift-options/module.wat
+++ b/crates/wit-component/tests/components/lift-options/module.wat
@@ -1,24 +1,24 @@
 (module
   (memory (export "memory") 1)
   (func (export "cabi_realloc") (param i32 i32 i32 i32) (result i32) unreachable)
-  (func (export "foo:foo/my-default#a") unreachable)
-  (func (export "foo:foo/my-default#b") (param i32 i32) unreachable)
-  (func (export "foo:foo/my-default#c") (param i32 i32) unreachable)
-  (func (export "foo:foo/my-default#d") (param i32 i32 i32) unreachable)
-  (func (export "foo:foo/my-default#e") (param i32) unreachable)
-  (func (export "foo:foo/my-default#f") (param i32 i32) unreachable)
-  (func (export "foo:foo/my-default#g") (param i32 i32) unreachable)
-  (func (export "foo:foo/my-default#h") (param i32 i32) unreachable)
-  (func (export "foo:foo/my-default#i") (param i32 i32) unreachable)
-  (func (export "foo:foo/my-default#j") (param i32) unreachable)
-  (func (export "foo:foo/my-default#k") (result i32) unreachable)
-  (func (export "foo:foo/my-default#l") (result i32) unreachable)
-  (func (export "cabi_post_foo:foo/my-default#l") (param i32) unreachable)
-  (func (export "foo:foo/my-default#m") (result i32) unreachable)
-  (func (export "cabi_post_foo:foo/my-default#m") (param i32) unreachable)
-  (func (export "foo:foo/my-default#n") (result i32) unreachable)
-  (func (export "foo:foo/my-default#o") (result i32) unreachable)
-  (func (export "cabi_post_foo:foo/my-default#o") (param i32) unreachable)
-  (func (export "foo:foo/my-default#p") (result i32) unreachable)
-  (func (export "cabi_post_foo:foo/my-default#p") (param i32) unreachable)
+  (func (export "foo#a") unreachable)
+  (func (export "foo#b") (param i32 i32) unreachable)
+  (func (export "foo#c") (param i32 i32) unreachable)
+  (func (export "foo#d") (param i32 i32 i32) unreachable)
+  (func (export "foo#e") (param i32) unreachable)
+  (func (export "foo#f") (param i32 i32) unreachable)
+  (func (export "foo#g") (param i32 i32) unreachable)
+  (func (export "foo#h") (param i32 i32) unreachable)
+  (func (export "foo#i") (param i32 i32) unreachable)
+  (func (export "foo#j") (param i32) unreachable)
+  (func (export "foo#k") (result i32) unreachable)
+  (func (export "foo#l") (result i32) unreachable)
+  (func (export "cabi_post_foo#l") (param i32) unreachable)
+  (func (export "foo#m") (result i32) unreachable)
+  (func (export "cabi_post_foo#m") (param i32) unreachable)
+  (func (export "foo#n") (result i32) unreachable)
+  (func (export "foo#o") (result i32) unreachable)
+  (func (export "cabi_post_foo#o") (param i32) unreachable)
+  (func (export "foo#p") (result i32) unreachable)
+  (func (export "cabi_post_foo#p") (param i32) unreachable)
 )
diff --git a/crates/wit-component/tests/components/lift-options/module.wit b/crates/wit-component/tests/components/lift-options/module.wit
index a491d67e..b1d4b6db 100644
--- a/crates/wit-component/tests/components/lift-options/module.wit
+++ b/crates/wit-component/tests/components/lift-options/module.wit
@@ -1,5 +1,3 @@
-package foo:foo
-
 interface my-default {
   record r {
       s: string
@@ -35,6 +33,6 @@ interface my-default {
   p: func() -> list<v-no-string>
 }
 
-world module {
-  export my-default
+default world my-world {
+  export foo: self.my-default
 }
diff --git a/crates/wit-component/tests/components/lower-options/component.wat b/crates/wit-component/tests/components/lower-options/component.wat
index 2848a900..a629dedf 100644
--- a/crates/wit-component/tests/components/lower-options/component.wat
+++ b/crates/wit-component/tests/components/lower-options/component.wat
@@ -1,31 +1,31 @@
 (component
   (type (;0;)
     (instance
-      (type (;0;) (record (field "s" string)))
-      (export (;1;) "r" (type (eq 0)))
-      (type (;2;) (variant (case "s" string)))
-      (export (;3;) "v" (type (eq 2)))
-      (type (;4;) (record (field "s" u32)))
-      (export (;5;) "r-no-string" (type (eq 4)))
-      (type (;6;) (variant (case "s" u32)))
-      (export (;7;) "v-no-string" (type (eq 6)))
-      (type (;8;) (func))
-      (export (;0;) "a" (func (type 8)))
-      (type (;9;) (list string))
-      (type (;10;) (func (param "x" 9)))
-      (export (;1;) "b" (func (type 10)))
-      (type (;11;) (func (param "x" 1)))
-      (export (;2;) "c" (func (type 11)))
-      (type (;12;) (func (param "x" 3)))
-      (export (;3;) "d" (func (type 12)))
-      (type (;13;) (func (param "x" 5)))
-      (export (;4;) "e" (func (type 13)))
-      (type (;14;) (func (param "x" 7)))
+      (type (;0;) (func))
+      (export (;0;) "a" (func (type 0)))
+      (type (;1;) (list string))
+      (type (;2;) (func (param "x" 1)))
+      (export (;1;) "b" (func (type 2)))
+      (type (;3;) (record (field "s" string)))
+      (export (;4;) "r" (type (eq 3)))
+      (type (;5;) (func (param "x" 4)))
+      (export (;2;) "c" (func (type 5)))
+      (type (;6;) (variant (case "s" string)))
+      (export (;7;) "v" (type (eq 6)))
+      (type (;8;) (func (param "x" 7)))
+      (export (;3;) "d" (func (type 8)))
+      (type (;9;) (record (field "s" u32)))
+      (export (;10;) "r-no-string" (type (eq 9)))
+      (type (;11;) (func (param "x" 10)))
+      (export (;4;) "e" (func (type 11)))
+      (type (;12;) (variant (case "s" u32)))
+      (export (;13;) "v-no-string" (type (eq 12)))
+      (type (;14;) (func (param "x" 13)))
       (export (;5;) "f" (func (type 14)))
-      (type (;15;) (list 1))
+      (type (;15;) (list 4))
       (type (;16;) (func (param "x" 15)))
       (export (;6;) "g" (func (type 16)))
-      (type (;17;) (list 3))
+      (type (;17;) (list 7))
       (type (;18;) (func (param "x" 17)))
       (export (;7;) "h" (func (type 18)))
       (type (;19;) (list u32))
@@ -42,14 +42,14 @@
       (export (;12;) "m" (func (type 25)))
       (type (;26;) (func (result u32)))
       (export (;13;) "n" (func (type 26)))
-      (type (;27;) (func (result 3)))
+      (type (;27;) (func (result 7)))
       (export (;14;) "o" (func (type 27)))
-      (type (;28;) (list 7))
+      (type (;28;) (list 13))
       (type (;29;) (func (result 28)))
       (export (;15;) "p" (func (type 29)))
     )
   )
-  (import (interface "foo:foo/foo") (instance (;0;) (type 0)))
+  (import "foo" (instance (;0;) (type 0)))
   (core module (;0;)
     (type (;0;) (func))
     (type (;1;) (func (param i32 i32)))
@@ -57,115 +57,108 @@
     (type (;3;) (func (param i32)))
     (type (;4;) (func (result i32)))
     (type (;5;) (func (param i32 i32 i32 i32) (result i32)))
-    (import "foo:foo/foo" "a" (func (;0;) (type 0)))
-    (import "foo:foo/foo" "b" (func (;1;) (type 1)))
-    (import "foo:foo/foo" "c" (func (;2;) (type 1)))
-    (import "foo:foo/foo" "d" (func (;3;) (type 2)))
-    (import "foo:foo/foo" "e" (func (;4;) (type 3)))
-    (import "foo:foo/foo" "f" (func (;5;) (type 1)))
-    (import "foo:foo/foo" "g" (func (;6;) (type 1)))
-    (import "foo:foo/foo" "h" (func (;7;) (type 1)))
-    (import "foo:foo/foo" "i" (func (;8;) (type 1)))
-    (import "foo:foo/foo" "j" (func (;9;) (type 3)))
-    (import "foo:foo/foo" "k" (func (;10;) (type 3)))
-    (import "foo:foo/foo" "l" (func (;11;) (type 3)))
-    (import "foo:foo/foo" "m" (func (;12;) (type 3)))
-    (import "foo:foo/foo" "n" (func (;13;) (type 4)))
-    (import "foo:foo/foo" "o" (func (;14;) (type 3)))
-    (import "foo:foo/foo" "p" (func (;15;) (type 3)))
+    (import "foo" "a" (func (;0;) (type 0)))
+    (import "foo" "b" (func (;1;) (type 1)))
+    (import "foo" "c" (func (;2;) (type 1)))
+    (import "foo" "d" (func (;3;) (type 2)))
+    (import "foo" "e" (func (;4;) (type 3)))
+    (import "foo" "f" (func (;5;) (type 1)))
+    (import "foo" "g" (func (;6;) (type 1)))
+    (import "foo" "h" (func (;7;) (type 1)))
+    (import "foo" "i" (func (;8;) (type 1)))
+    (import "foo" "j" (func (;9;) (type 3)))
+    (import "foo" "k" (func (;10;) (type 3)))
+    (import "foo" "l" (func (;11;) (type 3)))
+    (import "foo" "m" (func (;12;) (type 3)))
+    (import "foo" "n" (func (;13;) (type 4)))
+    (import "foo" "o" (func (;14;) (type 3)))
+    (import "foo" "p" (func (;15;) (type 3)))
     (func (;16;) (type 5) (param i32 i32 i32 i32) (result i32)
       unreachable
     )
     (memory (;0;) 1)
     (export "memory" (memory 0))
     (export "cabi_realloc" (func 16))
-    (@producers
-      (processed-by "wit-component" "$CARGO_PKG_VERSION")
-      (processed-by "my-fake-bindgen" "123.45")
-    )
   )
   (core module (;1;)
     (type (;0;) (func (param i32 i32)))
     (type (;1;) (func (param i32 i32 i32)))
     (type (;2;) (func (param i32)))
-    (func $indirect-foo:foo/foo-b (;0;) (type 0) (param i32 i32)
+    (func $indirect-foo-b (;0;) (type 0) (param i32 i32)
       local.get 0
       local.get 1
       i32.const 0
       call_indirect (type 0)
     )
-    (func $indirect-foo:foo/foo-c (;1;) (type 0) (param i32 i32)
+    (func $indirect-foo-c (;1;) (type 0) (param i32 i32)
       local.get 0
       local.get 1
       i32.const 1
       call_indirect (type 0)
     )
-    (func $indirect-foo:foo/foo-d (;2;) (type 1) (param i32 i32 i32)
+    (func $indirect-foo-d (;2;) (type 1) (param i32 i32 i32)
       local.get 0
       local.get 1
       local.get 2
       i32.const 2
       call_indirect (type 1)
     )
-    (func $indirect-foo:foo/foo-g (;3;) (type 0) (param i32 i32)
+    (func $indirect-foo-g (;3;) (type 0) (param i32 i32)
       local.get 0
       local.get 1
       i32.const 3
       call_indirect (type 0)
     )
-    (func $indirect-foo:foo/foo-h (;4;) (type 0) (param i32 i32)
+    (func $indirect-foo-h (;4;) (type 0) (param i32 i32)
       local.get 0
       local.get 1
       i32.const 4
       call_indirect (type 0)
     )
-    (func $indirect-foo:foo/foo-i (;5;) (type 0) (param i32 i32)
+    (func $indirect-foo-i (;5;) (type 0) (param i32 i32)
       local.get 0
       local.get 1
       i32.const 5
       call_indirect (type 0)
     )
-    (func $indirect-foo:foo/foo-k (;6;) (type 2) (param i32)
+    (func $indirect-foo-k (;6;) (type 2) (param i32)
       local.get 0
       i32.const 6
       call_indirect (type 2)
     )
-    (func $indirect-foo:foo/foo-l (;7;) (type 2) (param i32)
+    (func $indirect-foo-l (;7;) (type 2) (param i32)
       local.get 0
       i32.const 7
       call_indirect (type 2)
     )
-    (func $indirect-foo:foo/foo-m (;8;) (type 2) (param i32)
+    (func $indirect-foo-m (;8;) (type 2) (param i32)
       local.get 0
       i32.const 8
       call_indirect (type 2)
     )
-    (func $indirect-foo:foo/foo-o (;9;) (type 2) (param i32)
+    (func $indirect-foo-o (;9;) (type 2) (param i32)
       local.get 0
       i32.const 9
       call_indirect (type 2)
     )
-    (func $indirect-foo:foo/foo-p (;10;) (type 2) (param i32)
+    (func $indirect-foo-p (;10;) (type 2) (param i32)
       local.get 0
       i32.const 10
       call_indirect (type 2)
     )
     (table (;0;) 11 11 funcref)
-    (export "0" (func $indirect-foo:foo/foo-b))
-    (export "1" (func $indirect-foo:foo/foo-c))
-    (export "2" (func $indirect-foo:foo/foo-d))
-    (export "3" (func $indirect-foo:foo/foo-g))
-    (export "4" (func $indirect-foo:foo/foo-h))
-    (export "5" (func $indirect-foo:foo/foo-i))
-    (export "6" (func $indirect-foo:foo/foo-k))
-    (export "7" (func $indirect-foo:foo/foo-l))
-    (export "8" (func $indirect-foo:foo/foo-m))
-    (export "9" (func $indirect-foo:foo/foo-o))
-    (export "10" (func $indirect-foo:foo/foo-p))
+    (export "0" (func $indirect-foo-b))
+    (export "1" (func $indirect-foo-c))
+    (export "2" (func $indirect-foo-d))
+    (export "3" (func $indirect-foo-g))
+    (export "4" (func $indirect-foo-h))
+    (export "5" (func $indirect-foo-i))
+    (export "6" (func $indirect-foo-k))
+    (export "7" (func $indirect-foo-l))
+    (export "8" (func $indirect-foo-m))
+    (export "9" (func $indirect-foo-o))
+    (export "10" (func $indirect-foo-p))
     (export "$imports" (table 0))
-    (@producers
-      (processed-by "wit-component" "$CARGO_PKG_VERSION")
-    )
   )
   (core module (;2;)
     (type (;0;) (func (param i32 i32)))
@@ -184,52 +177,49 @@
     (import "" "10" (func (;10;) (type 2)))
     (import "" "$imports" (table (;0;) 11 11 funcref))
     (elem (;0;) (i32.const 0) func 0 1 2 3 4 5 6 7 8 9 10)
-    (@producers
-      (processed-by "wit-component" "$CARGO_PKG_VERSION")
-    )
   )
   (core instance (;0;) (instantiate 1))
+  (alias core export 0 "0" (core func (;0;)))
+  (alias core export 0 "1" (core func (;1;)))
+  (alias core export 0 "2" (core func (;2;)))
+  (alias core export 0 "3" (core func (;3;)))
+  (alias core export 0 "4" (core func (;4;)))
+  (alias core export 0 "5" (core func (;5;)))
+  (alias core export 0 "6" (core func (;6;)))
+  (alias core export 0 "7" (core func (;7;)))
+  (alias core export 0 "8" (core func (;8;)))
+  (alias core export 0 "9" (core func (;9;)))
+  (alias core export 0 "10" (core func (;10;)))
   (alias export 0 "a" (func (;0;)))
-  (core func (;0;) (canon lower (func 0)))
-  (alias core export 0 "0" (core func (;1;)))
-  (alias core export 0 "1" (core func (;2;)))
-  (alias core export 0 "2" (core func (;3;)))
+  (core func (;11;) (canon lower (func 0)))
   (alias export 0 "e" (func (;1;)))
-  (core func (;4;) (canon lower (func 1)))
+  (core func (;12;) (canon lower (func 1)))
   (alias export 0 "f" (func (;2;)))
-  (core func (;5;) (canon lower (func 2)))
-  (alias core export 0 "3" (core func (;6;)))
-  (alias core export 0 "4" (core func (;7;)))
-  (alias core export 0 "5" (core func (;8;)))
+  (core func (;13;) (canon lower (func 2)))
   (alias export 0 "j" (func (;3;)))
-  (core func (;9;) (canon lower (func 3)))
-  (alias core export 0 "6" (core func (;10;)))
-  (alias core export 0 "7" (core func (;11;)))
-  (alias core export 0 "8" (core func (;12;)))
+  (core func (;14;) (canon lower (func 3)))
   (alias export 0 "n" (func (;4;)))
-  (core func (;13;) (canon lower (func 4)))
-  (alias core export 0 "9" (core func (;14;)))
-  (alias core export 0 "10" (core func (;15;)))
+  (core func (;15;) (canon lower (func 4)))
   (core instance (;1;)
-    (export "a" (func 0))
-    (export "b" (func 1))
-    (export "c" (func 2))
-    (export "d" (func 3))
-    (export "e" (func 4))
-    (export "f" (func 5))
-    (export "g" (func 6))
-    (export "h" (func 7))
-    (export "i" (func 8))
-    (export "j" (func 9))
-    (export "k" (func 10))
-    (export "l" (func 11))
-    (export "m" (func 12))
-    (export "n" (func 13))
-    (export "o" (func 14))
-    (export "p" (func 15))
+    (export "b" (func 0))
+    (export "c" (func 1))
+    (export "d" (func 2))
+    (export "g" (func 3))
+    (export "h" (func 4))
+    (export "i" (func 5))
+    (export "k" (func 6))
+    (export "l" (func 7))
+    (export "m" (func 8))
+    (export "o" (func 9))
+    (export "p" (func 10))
+    (export "a" (func 11))
+    (export "e" (func 12))
+    (export "f" (func 13))
+    (export "j" (func 14))
+    (export "n" (func 15))
   )
   (core instance (;2;) (instantiate 0
-      (with "foo:foo/foo" (instance 1))
+      (with "foo" (instance 1))
     )
   )
   (alias core export 2 "memory" (core memory (;0;)))
@@ -257,9 +247,6 @@
   (core func (;26;) (canon lower (func 14) (memory 0) (realloc 16) string-encoding=utf8))
   (alias export 0 "p" (func (;15;)))
   (core func (;27;) (canon lower (func 15) (memory 0) (realloc 16)))
-  (@producers
-    (processed-by "wit-component" "$CARGO_PKG_VERSION")
-  )
   (core instance (;3;)
     (export "$imports" (table 0))
     (export "0" (func 17))
diff --git a/crates/wit-component/tests/components/lower-options/component.wit b/crates/wit-component/tests/components/lower-options/component.wit
new file mode 100644
index 00000000..b16a0310
--- /dev/null
+++ b/crates/wit-component/tests/components/lower-options/component.wit
@@ -0,0 +1,53 @@
+interface foo {
+  record r {
+    s: string,
+  }
+
+  variant v {
+    s(string),
+  }
+
+  record r-no-string {
+    s: u32,
+  }
+
+  variant v-no-string {
+    s(u32),
+  }
+
+  a: func()
+
+  b: func(x: list<string>)
+
+  c: func(x: r)
+
+  d: func(x: v)
+
+  e: func(x: r-no-string)
+
+  f: func(x: v-no-string)
+
+  g: func(x: list<r>)
+
+  h: func(x: list<v>)
+
+  i: func(x: list<u32>)
+
+  j: func(x: u32)
+
+  k: func() -> tuple<u32, u32>
+
+  l: func() -> string
+
+  m: func() -> list<u32>
+
+  n: func() -> u32
+
+  o: func() -> v
+
+  p: func() -> list<v-no-string>
+}
+
+default world component {
+  import foo: self.foo
+}
diff --git a/crates/wit-component/tests/components/lower-options/component.wit.print b/crates/wit-component/tests/components/lower-options/component.wit.print
deleted file mode 100644
index 7ef7c78b..00000000
--- a/crates/wit-component/tests/components/lower-options/component.wit.print
+++ /dev/null
@@ -1,5 +0,0 @@
-package root:component
-
-world root {
-  import foo:foo/foo
-}
diff --git a/crates/wit-component/tests/components/lower-options/module.wat b/crates/wit-component/tests/components/lower-options/module.wat
index a0a9f132..4a44c57b 100644
--- a/crates/wit-component/tests/components/lower-options/module.wat
+++ b/crates/wit-component/tests/components/lower-options/module.wat
@@ -1,20 +1,20 @@
 (module
-  (import "foo:foo/foo" "a" (func))
-  (import "foo:foo/foo" "b" (func (param i32 i32)))
-  (import "foo:foo/foo" "c" (func (param i32 i32)))
-  (import "foo:foo/foo" "d" (func (param i32 i32 i32)))
-  (import "foo:foo/foo" "e" (func (param i32)))
-  (import "foo:foo/foo" "f" (func (param i32 i32)))
-  (import "foo:foo/foo" "g" (func (param i32 i32)))
-  (import "foo:foo/foo" "h" (func (param i32 i32)))
-  (import "foo:foo/foo" "i" (func (param i32 i32)))
-  (import "foo:foo/foo" "j" (func (param i32)))
-  (import "foo:foo/foo" "k" (func (param i32)))
-  (import "foo:foo/foo" "l" (func (param i32)))
-  (import "foo:foo/foo" "m" (func (param i32)))
-  (import "foo:foo/foo" "n" (func (result i32)))
-  (import "foo:foo/foo" "o" (func (param i32)))
-  (import "foo:foo/foo" "p" (func (param i32)))
+  (import "foo" "a" (func))
+  (import "foo" "b" (func (param i32 i32)))
+  (import "foo" "c" (func (param i32 i32)))
+  (import "foo" "d" (func (param i32 i32 i32)))
+  (import "foo" "e" (func (param i32)))
+  (import "foo" "f" (func (param i32 i32)))
+  (import "foo" "g" (func (param i32 i32)))
+  (import "foo" "h" (func (param i32 i32)))
+  (import "foo" "i" (func (param i32 i32)))
+  (import "foo" "j" (func (param i32)))
+  (import "foo" "k" (func (param i32)))
+  (import "foo" "l" (func (param i32)))
+  (import "foo" "m" (func (param i32)))
+  (import "foo" "n" (func (result i32)))
+  (import "foo" "o" (func (param i32)))
+  (import "foo" "p" (func (param i32)))
   (memory (export "memory") 1)
   (func (export "cabi_realloc") (param i32 i32 i32 i32) (result i32) unreachable)
-)
+)
\ No newline at end of file
diff --git a/crates/wit-component/tests/components/lower-options/module.wit b/crates/wit-component/tests/components/lower-options/module.wit
index f39ea6b6..d4dae943 100644
--- a/crates/wit-component/tests/components/lower-options/module.wit
+++ b/crates/wit-component/tests/components/lower-options/module.wit
@@ -1,5 +1,3 @@
-package foo:foo
-
 interface foo {
   record r {
       s: string
@@ -35,6 +33,6 @@ interface foo {
   p: func() -> list<v-no-string>
 }
 
-world module {
-  import foo
+default world my-world {
+  import foo: self.foo
 }
diff --git a/crates/wit-component/tests/components/many-same-names/component.wat b/crates/wit-component/tests/components/many-same-names/component.wat
deleted file mode 100644
index f233822f..00000000
--- a/crates/wit-component/tests/components/many-same-names/component.wat
+++ /dev/null
@@ -1,55 +0,0 @@
-(component
-  (type (;0;)
-    (instance
-      (type (;0;) (record))
-      (export (;1;) "r1" (type (eq 0)))
-      (type (;2;) (record (field "x" 1)))
-      (export (;3;) "r2" (type (eq 2)))
-    )
-  )
-  (import (interface "foo:foo/name") (instance (;0;) (type 0)))
-  (core module (;0;)
-    (type (;0;) (func))
-    (func (;0;) (type 0))
-    (export "name#a" (func 0))
-    (@producers
-      (processed-by "wit-component" "$CARGO_PKG_VERSION")
-      (processed-by "my-fake-bindgen" "123.45")
-    )
-  )
-  (core instance (;0;) (instantiate 0))
-  (component (;0;)
-    (type (;0;) (record))
-    (export (;1;) "r1" (type 0))
-    (type (;2;) (record (field "x" 1)))
-    (export (;3;) "r2" (type 2))
-  )
-  (instance (;1;) (instantiate 0))
-  (export (;2;) (interface "foo:foo/name") (instance 1))
-  (type (;1;) (func))
-  (alias core export 0 "name#a" (core func (;0;)))
-  (func (;0;) (type 1) (canon lift (core func 0)))
-  (alias export 2 "r1" (type (;2;)))
-  (alias export 2 "r2" (type (;3;)))
-  (component (;1;)
-    (type (;0;) (record))
-    (import "import-type-r1" (type (;1;) (eq 0)))
-    (type (;2;) (record (field "x" 1)))
-    (import "import-type-r2" (type (;3;) (eq 2)))
-    (type (;4;) (func))
-    (import "import-func-a" (func (;0;) (type 4)))
-    (export (;5;) "r2" (type 3))
-    (type (;6;) (func))
-    (export (;1;) "a" (func 0) (func (type 6)))
-  )
-  (instance (;3;) (instantiate 1
-      (with "import-func-a" (func 0))
-      (with "import-type-r1" (type 2))
-      (with "import-type-r2" (type 3))
-    )
-  )
-  (@producers
-    (processed-by "wit-component" "$CARGO_PKG_VERSION")
-  )
-  (export (;4;) "name" (instance 3))
-)
\ No newline at end of file
diff --git a/crates/wit-component/tests/components/many-same-names/component.wit.print b/crates/wit-component/tests/components/many-same-names/component.wit.print
deleted file mode 100644
index 91dc87f9..00000000
--- a/crates/wit-component/tests/components/many-same-names/component.wit.print
+++ /dev/null
@@ -1,12 +0,0 @@
-package root:component
-
-world root {
-  import foo:foo/name
-
-  export foo:foo/name
-  export name: interface {
-    use foo:foo/name.{r2}
-
-    a: func()
-  }
-}
diff --git a/crates/wit-component/tests/components/many-same-names/module.wat b/crates/wit-component/tests/components/many-same-names/module.wat
deleted file mode 100644
index 1cb58c5b..00000000
--- a/crates/wit-component/tests/components/many-same-names/module.wat
+++ /dev/null
@@ -1,3 +0,0 @@
-(module
-  (func (export "name#a"))
-)
diff --git a/crates/wit-component/tests/components/many-same-names/module.wit b/crates/wit-component/tests/components/many-same-names/module.wit
deleted file mode 100644
index 8fc8a4f9..00000000
--- a/crates/wit-component/tests/components/many-same-names/module.wit
+++ /dev/null
@@ -1,19 +0,0 @@
-package foo:foo
-
-interface name {
-  record r1 {}
-
-  record r2 {
-    x: r1
-  }
-}
-
-world module {
-  import name
-  export name
-
-  export name: interface {
-    use name.{r2}
-    a: func()
-  }
-}
diff --git a/crates/wit-component/tests/components/error-missing-default-export/error.txt b/crates/wit-component/tests/components/missing-default-export/error.txt
similarity index 100%
rename from crates/wit-component/tests/components/error-missing-default-export/error.txt
rename to crates/wit-component/tests/components/missing-default-export/error.txt
diff --git a/crates/wit-component/tests/components/error-missing-default-export/module.wat b/crates/wit-component/tests/components/missing-default-export/module.wat
similarity index 100%
rename from crates/wit-component/tests/components/error-missing-default-export/module.wat
rename to crates/wit-component/tests/components/missing-default-export/module.wat
diff --git a/crates/wit-component/tests/components/missing-default-export/module.wit b/crates/wit-component/tests/components/missing-default-export/module.wit
new file mode 100644
index 00000000..4e607cdb
--- /dev/null
+++ b/crates/wit-component/tests/components/missing-default-export/module.wit
@@ -0,0 +1,3 @@
+default world my-world {
+  export a: func()
+}
diff --git a/crates/wit-component/tests/components/error-missing-export/error.txt b/crates/wit-component/tests/components/missing-export/error.txt
similarity index 100%
rename from crates/wit-component/tests/components/error-missing-export/error.txt
rename to crates/wit-component/tests/components/missing-export/error.txt
diff --git a/crates/wit-component/tests/components/error-missing-export/module.wat b/crates/wit-component/tests/components/missing-export/module.wat
similarity index 100%
rename from crates/wit-component/tests/components/error-missing-export/module.wat
rename to crates/wit-component/tests/components/missing-export/module.wat
diff --git a/crates/wit-component/tests/components/error-missing-export/module.wit b/crates/wit-component/tests/components/missing-export/module.wit
similarity index 58%
rename from crates/wit-component/tests/components/error-missing-export/module.wit
rename to crates/wit-component/tests/components/missing-export/module.wit
index 9ea114f4..6b1871ae 100644
--- a/crates/wit-component/tests/components/error-missing-export/module.wit
+++ b/crates/wit-component/tests/components/missing-export/module.wit
@@ -1,6 +1,4 @@
-package foo:foo
-
-world module {
+default world my-world {
   export foo: interface {
     a: func()
   }
diff --git a/crates/wit-component/tests/components/missing-import-func/error.txt b/crates/wit-component/tests/components/missing-import-func/error.txt
new file mode 100644
index 00000000..ea9b1427
--- /dev/null
+++ b/crates/wit-component/tests/components/missing-import-func/error.txt
@@ -0,0 +1,4 @@
+failed to validate import interface `foo`
+
+Caused by:
+    import interface `foo` is missing function `bar` that is required by the module
\ No newline at end of file
diff --git a/crates/wit-component/tests/components/error-missing-import-func/module.wat b/crates/wit-component/tests/components/missing-import-func/module.wat
similarity index 100%
rename from crates/wit-component/tests/components/error-missing-import-func/module.wat
rename to crates/wit-component/tests/components/missing-import-func/module.wat
diff --git a/crates/wit-component/tests/components/missing-import-func/module.wit b/crates/wit-component/tests/components/missing-import-func/module.wit
new file mode 100644
index 00000000..d0e79165
--- /dev/null
+++ b/crates/wit-component/tests/components/missing-import-func/module.wit
@@ -0,0 +1,7 @@
+interface foo {
+  a: func()
+}
+
+default world my-world {
+  import foo: self.foo
+}
diff --git a/crates/wit-component/tests/components/error-missing-import-func/error.txt b/crates/wit-component/tests/components/missing-import/error.txt
similarity index 100%
rename from crates/wit-component/tests/components/error-missing-import-func/error.txt
rename to crates/wit-component/tests/components/missing-import/error.txt
diff --git a/crates/wit-component/tests/components/error-missing-import/module.wat b/crates/wit-component/tests/components/missing-import/module.wat
similarity index 100%
rename from crates/wit-component/tests/components/error-missing-import/module.wat
rename to crates/wit-component/tests/components/missing-import/module.wat
diff --git a/crates/wit-component/tests/components/missing-import/module.wit b/crates/wit-component/tests/components/missing-import/module.wit
new file mode 100644
index 00000000..1f99081f
--- /dev/null
+++ b/crates/wit-component/tests/components/missing-import/module.wit
@@ -0,0 +1 @@
+default world empty {}
diff --git a/crates/wit-component/tests/components/no-realloc-required/component.wat b/crates/wit-component/tests/components/no-realloc-required/component.wat
index 630b2250..007bdc78 100644
--- a/crates/wit-component/tests/components/no-realloc-required/component.wat
+++ b/crates/wit-component/tests/components/no-realloc-required/component.wat
@@ -11,10 +11,6 @@
     (import "foo" "log" (func (;0;) (type 0)))
     (memory (;0;) 1)
     (export "memory" (memory 0))
-    (@producers
-      (processed-by "wit-component" "$CARGO_PKG_VERSION")
-      (processed-by "my-fake-bindgen" "123.45")
-    )
   )
   (core module (;1;)
     (type (;0;) (func (param i32 i32)))
@@ -27,18 +23,12 @@
     (table (;0;) 1 1 funcref)
     (export "0" (func $indirect-foo-log))
     (export "$imports" (table 0))
-    (@producers
-      (processed-by "wit-component" "$CARGO_PKG_VERSION")
-    )
   )
   (core module (;2;)
     (type (;0;) (func (param i32 i32)))
     (import "" "0" (func (;0;) (type 0)))
     (import "" "$imports" (table (;0;) 1 1 funcref))
     (elem (;0;) (i32.const 0) func 0)
-    (@producers
-      (processed-by "wit-component" "$CARGO_PKG_VERSION")
-    )
   )
   (core instance (;0;) (instantiate 1))
   (alias core export 0 "0" (core func (;0;)))
@@ -53,9 +43,6 @@
   (alias core export 0 "$imports" (core table (;0;)))
   (alias export 0 "log" (func (;0;)))
   (core func (;1;) (canon lower (func 0) (memory 0) string-encoding=utf8))
-  (@producers
-    (processed-by "wit-component" "$CARGO_PKG_VERSION")
-  )
   (core instance (;3;)
     (export "$imports" (table 0))
     (export "0" (func 1))
diff --git a/crates/wit-component/tests/components/no-realloc-required/component.wit b/crates/wit-component/tests/components/no-realloc-required/component.wit
new file mode 100644
index 00000000..eddb9f98
--- /dev/null
+++ b/crates/wit-component/tests/components/no-realloc-required/component.wit
@@ -0,0 +1,7 @@
+interface foo {
+  log: func(s: string)
+}
+
+default world component {
+  import foo: self.foo
+}
diff --git a/crates/wit-component/tests/components/no-realloc-required/component.wit.print b/crates/wit-component/tests/components/no-realloc-required/component.wit.print
deleted file mode 100644
index f1fc2527..00000000
--- a/crates/wit-component/tests/components/no-realloc-required/component.wit.print
+++ /dev/null
@@ -1,7 +0,0 @@
-package root:component
-
-world root {
-  import foo: interface {
-    log: func(s: string)
-  }
-}
diff --git a/crates/wit-component/tests/components/no-realloc-required/module.wit b/crates/wit-component/tests/components/no-realloc-required/module.wit
index 5c8d4124..558f5ac8 100644
--- a/crates/wit-component/tests/components/no-realloc-required/module.wit
+++ b/crates/wit-component/tests/components/no-realloc-required/module.wit
@@ -1,6 +1,4 @@
-package foo:foo
-
-world module {
+default world foo {
   import foo: interface {
     log: func(s: string)
   }
diff --git a/crates/wit-component/tests/components/post-return/component.wat b/crates/wit-component/tests/components/post-return/component.wat
index 9f7ead5a..d4f20690 100644
--- a/crates/wit-component/tests/components/post-return/component.wat
+++ b/crates/wit-component/tests/components/post-return/component.wat
@@ -17,10 +17,6 @@
     (export "cabi_realloc" (func 0))
     (export "a" (func 1))
     (export "cabi_post_a" (func 2))
-    (@producers
-      (processed-by "wit-component" "$CARGO_PKG_VERSION")
-      (processed-by "my-fake-bindgen" "123.45")
-    )
   )
   (core instance (;0;) (instantiate 0))
   (alias core export 0 "memory" (core memory (;0;)))
@@ -29,8 +25,5 @@
   (alias core export 0 "a" (core func (;1;)))
   (alias core export 0 "cabi_post_a" (core func (;2;)))
   (func (;0;) (type 0) (canon lift (core func 1) (memory 0) string-encoding=utf8 (post-return 2)))
-  (@producers
-    (processed-by "wit-component" "$CARGO_PKG_VERSION")
-  )
   (export (;1;) "a" (func 0))
 )
\ No newline at end of file
diff --git a/crates/wit-component/tests/components/post-return/component.wit b/crates/wit-component/tests/components/post-return/component.wit
new file mode 100644
index 00000000..5fb868d1
--- /dev/null
+++ b/crates/wit-component/tests/components/post-return/component.wit
@@ -0,0 +1,3 @@
+default world component {
+  export a: func() -> string
+}
diff --git a/crates/wit-component/tests/components/post-return/component.wit.print b/crates/wit-component/tests/components/post-return/component.wit.print
deleted file mode 100644
index a1d34262..00000000
--- a/crates/wit-component/tests/components/post-return/component.wit.print
+++ /dev/null
@@ -1,5 +0,0 @@
-package root:component
-
-world root {
-  export a: func() -> string
-}
diff --git a/crates/wit-component/tests/components/post-return/module.wit b/crates/wit-component/tests/components/post-return/module.wit
index 0d0580fa..1d99c422 100644
--- a/crates/wit-component/tests/components/post-return/module.wit
+++ b/crates/wit-component/tests/components/post-return/module.wit
@@ -1,5 +1,3 @@
-package foo:foo
-
-world module {
+default world foo {
   export a: func() -> string
 }
diff --git a/crates/wit-component/tests/components/rename-import-interface/component.wat b/crates/wit-component/tests/components/rename-import-interface/component.wat
index d9da64c0..cc9b4875 100644
--- a/crates/wit-component/tests/components/rename-import-interface/component.wat
+++ b/crates/wit-component/tests/components/rename-import-interface/component.wat
@@ -5,25 +5,18 @@
       (export (;0;) "the-func" (func (type 0)))
     )
   )
-  (import (interface "foo:foo/foo") (instance (;0;) (type 0)))
+  (import "bar" (instance (;0;) (type 0)))
   (core module (;0;)
     (type (;0;) (func))
-    (import "foo:foo/foo" "the-func" (func (;0;) (type 0)))
-    (@producers
-      (processed-by "wit-component" "$CARGO_PKG_VERSION")
-      (processed-by "my-fake-bindgen" "123.45")
-    )
+    (import "bar" "the-func" (func (;0;) (type 0)))
   )
   (alias export 0 "the-func" (func (;0;)))
   (core func (;0;) (canon lower (func 0)))
-  (@producers
-    (processed-by "wit-component" "$CARGO_PKG_VERSION")
-  )
   (core instance (;0;)
     (export "the-func" (func 0))
   )
   (core instance (;1;) (instantiate 0
-      (with "foo:foo/foo" (instance 0))
+      (with "bar" (instance 0))
     )
   )
 )
\ No newline at end of file
diff --git a/crates/wit-component/tests/components/rename-import-interface/component.wit b/crates/wit-component/tests/components/rename-import-interface/component.wit
new file mode 100644
index 00000000..d2808cbc
--- /dev/null
+++ b/crates/wit-component/tests/components/rename-import-interface/component.wit
@@ -0,0 +1,7 @@
+interface bar {
+  the-func: func()
+}
+
+default world component {
+  import bar: self.bar
+}
diff --git a/crates/wit-component/tests/components/rename-import-interface/component.wit.print b/crates/wit-component/tests/components/rename-import-interface/component.wit.print
deleted file mode 100644
index 7ef7c78b..00000000
--- a/crates/wit-component/tests/components/rename-import-interface/component.wit.print
+++ /dev/null
@@ -1,5 +0,0 @@
-package root:component
-
-world root {
-  import foo:foo/foo
-}
diff --git a/crates/wit-component/tests/components/rename-import-interface/module.wat b/crates/wit-component/tests/components/rename-import-interface/module.wat
index 3a09d29a..e639cf37 100644
--- a/crates/wit-component/tests/components/rename-import-interface/module.wat
+++ b/crates/wit-component/tests/components/rename-import-interface/module.wat
@@ -1,3 +1,3 @@
 (module
-  (import "foo:foo/foo" "the-func" (func))
+  (import "bar" "the-func" (func))
 )
diff --git a/crates/wit-component/tests/components/rename-import-interface/module.wit b/crates/wit-component/tests/components/rename-import-interface/module.wit
index fc1e9373..15eee29f 100644
--- a/crates/wit-component/tests/components/rename-import-interface/module.wit
+++ b/crates/wit-component/tests/components/rename-import-interface/module.wit
@@ -1,9 +1,7 @@
-package foo:foo
-
 interface foo {
   the-func: func()
 }
 
-world module {
-  import foo
+default world the-world {
+  import bar: self.foo
 }
diff --git a/crates/wit-component/tests/components/rename-interface/component.wat b/crates/wit-component/tests/components/rename-interface/component.wat
index 737f3476..dd856f2f 100644
--- a/crates/wit-component/tests/components/rename-interface/component.wat
+++ b/crates/wit-component/tests/components/rename-interface/component.wat
@@ -5,7 +5,7 @@
       (export (;1;) "bar" (type (eq 0)))
     )
   )
-  (import (interface "foo:foo/foo") (instance (;0;) (type 0)))
+  (import "different-name" (instance (;0;) (type 0)))
   (alias export 0 "bar" (type (;1;)))
   (type (;2;)
     (instance
@@ -19,16 +19,9 @@
   (core module (;0;)
     (type (;0;) (func))
     (import "other-name" "a" (func (;0;) (type 0)))
-    (@producers
-      (processed-by "wit-component" "$CARGO_PKG_VERSION")
-      (processed-by "my-fake-bindgen" "123.45")
-    )
   )
   (alias export 1 "a" (func (;0;)))
   (core func (;0;) (canon lower (func 0)))
-  (@producers
-    (processed-by "wit-component" "$CARGO_PKG_VERSION")
-  )
   (core instance (;0;)
     (export "a" (func 0))
   )
diff --git a/crates/wit-component/tests/components/rename-interface/component.wit b/crates/wit-component/tests/components/rename-interface/component.wit
new file mode 100644
index 00000000..4246a1fb
--- /dev/null
+++ b/crates/wit-component/tests/components/rename-interface/component.wit
@@ -0,0 +1,15 @@
+interface different-name {
+  record bar {
+  }
+
+}
+
+interface other-name {
+  use self.different-name.{bar}
+  a: func() -> bar
+}
+
+default world component {
+  import different-name: self.different-name
+  import other-name: self.other-name
+}
diff --git a/crates/wit-component/tests/components/rename-interface/component.wit.print b/crates/wit-component/tests/components/rename-interface/component.wit.print
deleted file mode 100644
index 8687ef18..00000000
--- a/crates/wit-component/tests/components/rename-interface/component.wit.print
+++ /dev/null
@@ -1,10 +0,0 @@
-package root:component
-
-world root {
-  import foo:foo/foo
-  import other-name: interface {
-    use foo:foo/foo.{bar}
-
-    a: func() -> bar
-  }
-}
diff --git a/crates/wit-component/tests/components/rename-interface/module.wit b/crates/wit-component/tests/components/rename-interface/module.wit
index 468e6f0f..889deb59 100644
--- a/crates/wit-component/tests/components/rename-interface/module.wit
+++ b/crates/wit-component/tests/components/rename-interface/module.wit
@@ -1,15 +1,13 @@
-package foo:foo
-
 interface foo {
   record bar {}
 
   a: func() -> bar
 }
 
-world module {
-  import foo
+default world the-world {
+  import different-name: self.foo
   import other-name: interface {
-    use foo.{bar}
+    use self.foo.{bar}
 
     a: func() -> bar
   }
diff --git a/crates/wit-component/tests/components/resource-intrinsics-with-just-import/component.wat b/crates/wit-component/tests/components/resource-intrinsics-with-just-import/component.wat
deleted file mode 100644
index 59a6a1cc..00000000
--- a/crates/wit-component/tests/components/resource-intrinsics-with-just-import/component.wat
+++ /dev/null
@@ -1,28 +0,0 @@
-(component
-  (type (;0;)
-    (instance
-      (export (;0;) "a" (type (sub resource)))
-    )
-  )
-  (import "foo" (instance (;0;) (type 0)))
-  (core module (;0;)
-    (type (;0;) (func (param i32)))
-    (import "foo" "[resource-drop]a" (func (;0;) (type 0)))
-    (@producers
-      (processed-by "wit-component" "$CARGO_PKG_VERSION")
-      (processed-by "my-fake-bindgen" "123.45")
-    )
-  )
-  (alias export 0 "a" (type (;1;)))
-  (core func (;0;) (canon resource.drop 1))
-  (@producers
-    (processed-by "wit-component" "$CARGO_PKG_VERSION")
-  )
-  (core instance (;0;)
-    (export "[resource-drop]a" (func 0))
-  )
-  (core instance (;1;) (instantiate 0
-      (with "foo" (instance 0))
-    )
-  )
-)
\ No newline at end of file
diff --git a/crates/wit-component/tests/components/resource-intrinsics-with-just-import/component.wit.print b/crates/wit-component/tests/components/resource-intrinsics-with-just-import/component.wit.print
deleted file mode 100644
index 8cc7cfa7..00000000
--- a/crates/wit-component/tests/components/resource-intrinsics-with-just-import/component.wit.print
+++ /dev/null
@@ -1,7 +0,0 @@
-package root:component
-
-world root {
-  import foo: interface {
-    resource a
-  }
-}
diff --git a/crates/wit-component/tests/components/resource-intrinsics-with-just-import/module.wat b/crates/wit-component/tests/components/resource-intrinsics-with-just-import/module.wat
deleted file mode 100644
index 1f989c22..00000000
--- a/crates/wit-component/tests/components/resource-intrinsics-with-just-import/module.wat
+++ /dev/null
@@ -1,3 +0,0 @@
-(module
-  (import "foo" "[resource-drop]a" (func (param i32)))
-)
diff --git a/crates/wit-component/tests/components/resource-intrinsics-with-just-import/module.wit b/crates/wit-component/tests/components/resource-intrinsics-with-just-import/module.wit
deleted file mode 100644
index 850aec0a..00000000
--- a/crates/wit-component/tests/components/resource-intrinsics-with-just-import/module.wit
+++ /dev/null
@@ -1,7 +0,0 @@
-package foo:bar
-
-world module {
-  import foo: interface {
-    resource a
-  }
-}
diff --git a/crates/wit-component/tests/components/resource-used-through-import/component.wat b/crates/wit-component/tests/components/resource-used-through-import/component.wat
deleted file mode 100644
index 642c063a..00000000
--- a/crates/wit-component/tests/components/resource-used-through-import/component.wat
+++ /dev/null
@@ -1,57 +0,0 @@
-(component
-  (type (;0;)
-    (instance
-      (export (;0;) "r" (type (sub resource)))
-    )
-  )
-  (import (interface "foo:bar/a") (instance (;0;) (type 0)))
-  (core module (;0;)
-    (type (;0;) (func (param i32)))
-    (type (;1;) (func (result i32)))
-    (import "foo:bar/a" "[resource-drop]r" (func (;0;) (type 0)))
-    (func (;1;) (type 1) (result i32)
-      i32.const 0
-    )
-    (export "b#foo" (func 1))
-    (@producers
-      (processed-by "wit-component" "$CARGO_PKG_VERSION")
-      (processed-by "my-fake-bindgen" "123.45")
-    )
-  )
-  (alias export 0 "r" (type (;1;)))
-  (core func (;0;) (canon resource.drop 1))
-  (core instance (;0;)
-    (export "[resource-drop]r" (func 0))
-  )
-  (core instance (;1;) (instantiate 0
-      (with "foo:bar/a" (instance 0))
-    )
-  )
-  (alias export 0 "r" (type (;2;)))
-  (type (;3;) (own 2))
-  (type (;4;) (func (result 3)))
-  (alias core export 1 "b#foo" (core func (;1;)))
-  (func (;0;) (type 4) (canon lift (core func 1)))
-  (alias export 0 "r" (type (;5;)))
-  (component (;0;)
-    (import "import-type-r" (type (;0;) (sub resource)))
-    (import "import-type-r0" (type (;1;) (eq 0)))
-    (type (;2;) (own 1))
-    (type (;3;) (func (result 2)))
-    (import "import-func-foo" (func (;0;) (type 3)))
-    (export (;4;) "r" (type 0))
-    (type (;5;) (own 4))
-    (type (;6;) (func (result 5)))
-    (export (;1;) "foo" (func 0) (func (type 6)))
-  )
-  (instance (;1;) (instantiate 0
-      (with "import-func-foo" (func 0))
-      (with "import-type-r" (type 5))
-      (with "import-type-r0" (type 2))
-    )
-  )
-  (@producers
-    (processed-by "wit-component" "$CARGO_PKG_VERSION")
-  )
-  (export (;2;) "b" (instance 1))
-)
\ No newline at end of file
diff --git a/crates/wit-component/tests/components/resource-used-through-import/component.wit.print b/crates/wit-component/tests/components/resource-used-through-import/component.wit.print
deleted file mode 100644
index 33604827..00000000
--- a/crates/wit-component/tests/components/resource-used-through-import/component.wit.print
+++ /dev/null
@@ -1,11 +0,0 @@
-package root:component
-
-world root {
-  import foo:bar/a
-
-  export b: interface {
-    use foo:bar/a.{r}
-
-    foo: func() -> r
-  }
-}
diff --git a/crates/wit-component/tests/components/resource-used-through-import/module.wat b/crates/wit-component/tests/components/resource-used-through-import/module.wat
deleted file mode 100644
index 45428e22..00000000
--- a/crates/wit-component/tests/components/resource-used-through-import/module.wat
+++ /dev/null
@@ -1,6 +0,0 @@
-(module
-  (import "foo:bar/a" "[resource-drop]r" (func (param i32)))
-  (func (export "b#foo") (result i32)
-    (i32.const 0)
-  )
-)
diff --git a/crates/wit-component/tests/components/resource-used-through-import/module.wit b/crates/wit-component/tests/components/resource-used-through-import/module.wit
deleted file mode 100644
index 789eeee3..00000000
--- a/crates/wit-component/tests/components/resource-used-through-import/module.wit
+++ /dev/null
@@ -1,13 +0,0 @@
-package foo:bar
-
-interface a {
-  resource r
-}
-
-world module {
-  export b: interface {
-    use a.{r}
-
-    foo: func() -> r
-  }
-}
diff --git a/crates/wit-component/tests/components/resource-using-export/component.wat b/crates/wit-component/tests/components/resource-using-export/component.wat
deleted file mode 100644
index 0cf7ec12..00000000
--- a/crates/wit-component/tests/components/resource-using-export/component.wat
+++ /dev/null
@@ -1,63 +0,0 @@
-(component
-  (core module (;0;)
-    (type (;0;) (func (param i32) (result i32)))
-    (type (;1;) (func (result i32)))
-    (import "[export]foo:bar/foo" "[resource-new]r" (func $new (;0;) (type 0)))
-    (func (;1;) (type 1) (result i32)
-      i32.const 100
-      call $new
-    )
-    (export "anon#f" (func 1))
-    (@producers
-      (processed-by "wit-component" "$CARGO_PKG_VERSION")
-      (processed-by "my-fake-bindgen" "123.45")
-    )
-  )
-  (type (;0;) (resource (rep i32)))
-  (core func (;0;) (canon resource.new 0))
-  (core instance (;0;)
-    (export "[resource-new]r" (func 0))
-  )
-  (core instance (;1;) (instantiate 0
-      (with "[export]foo:bar/foo" (instance 0))
-    )
-  )
-  (component (;0;)
-    (import "import-type-r" (type (;0;) (sub resource)))
-    (export (;1;) "r" (type 0))
-    (type (;2;) (own 1))
-    (export (;3;) "handle" (type 2))
-  )
-  (instance (;0;) (instantiate 0
-      (with "import-type-r" (type 0))
-    )
-  )
-  (export (;1;) (interface "foo:bar/foo") (instance 0))
-  (alias export 1 "handle" (type (;1;)))
-  (type (;2;) (func (result 1)))
-  (alias core export 1 "anon#f" (core func (;1;)))
-  (func (;0;) (type 2) (canon lift (core func 1)))
-  (alias export 1 "r" (type (;3;)))
-  (component (;1;)
-    (import "import-type-r" (type (;0;) (sub resource)))
-    (type (;1;) (own 0))
-    (import "import-type-handle" (type (;2;) (eq 1)))
-    (import "import-type-handle0" (type (;3;) (eq 2)))
-    (type (;4;) (func (result 3)))
-    (import "import-func-f" (func (;0;) (type 4)))
-    (export (;5;) "handle" (type 2))
-    (type (;6;) (func (result 5)))
-    (export (;1;) "f" (func 0) (func (type 6)))
-  )
-  (instance (;2;) (instantiate 1
-      (with "import-func-f" (func 0))
-      (with "import-type-r" (type 3))
-      (with "import-type-handle" (type 1))
-      (with "import-type-handle0" (type 1))
-    )
-  )
-  (@producers
-    (processed-by "wit-component" "$CARGO_PKG_VERSION")
-  )
-  (export (;3;) "anon" (instance 2))
-)
\ No newline at end of file
diff --git a/crates/wit-component/tests/components/resource-using-export/component.wit.print b/crates/wit-component/tests/components/resource-using-export/component.wit.print
deleted file mode 100644
index 3de04399..00000000
--- a/crates/wit-component/tests/components/resource-using-export/component.wit.print
+++ /dev/null
@@ -1,10 +0,0 @@
-package root:component
-
-world root {
-  export foo:bar/foo
-  export anon: interface {
-    use foo:bar/foo.{handle}
-
-    f: func() -> handle
-  }
-}
diff --git a/crates/wit-component/tests/components/resource-using-export/module.wat b/crates/wit-component/tests/components/resource-using-export/module.wat
deleted file mode 100644
index 38c372c8..00000000
--- a/crates/wit-component/tests/components/resource-using-export/module.wat
+++ /dev/null
@@ -1,6 +0,0 @@
-(module
-  (import "[export]foo:bar/foo" "[resource-new]r" (func $new (param i32) (result i32)))
-  (func (export "anon#f") (result i32)
-    (call $new (i32.const 100))
-  )
-)
diff --git a/crates/wit-component/tests/components/resource-using-export/module.wit b/crates/wit-component/tests/components/resource-using-export/module.wit
deleted file mode 100644
index de8c41bf..00000000
--- a/crates/wit-component/tests/components/resource-using-export/module.wit
+++ /dev/null
@@ -1,16 +0,0 @@
-package foo:bar
-
-interface foo {
-  resource r
-
-  type handle = own<r>
-}
-
-world module {
-  export foo
-  export anon: interface {
-    use foo.{handle}
-    f: func() -> handle
-  }
-}
-
diff --git a/crates/wit-component/tests/components/simple/component.wat b/crates/wit-component/tests/components/simple/component.wat
index 86ba50f2..940bda28 100644
--- a/crates/wit-component/tests/components/simple/component.wat
+++ b/crates/wit-component/tests/components/simple/component.wat
@@ -36,10 +36,6 @@
     (export "c" (func $c))
     (export "cabi_post_c" (func 5))
     (export "d" (func $d))
-    (@producers
-      (processed-by "wit-component" "$CARGO_PKG_VERSION")
-      (processed-by "my-fake-bindgen" "123.45")
-    )
   )
   (core instance (;0;) (instantiate 0))
   (alias core export 0 "memory" (core memory (;0;)))
@@ -57,8 +53,5 @@
   (alias core export 0 "c" (core func (;4;)))
   (alias core export 0 "cabi_post_c" (core func (;5;)))
   (func (;4;) (type 2) (canon lift (core func 4) (memory 0) (realloc 0) string-encoding=utf8 (post-return 5)))
-  (@producers
-    (processed-by "wit-component" "$CARGO_PKG_VERSION")
-  )
   (export (;5;) "c" (func 4))
 )
\ No newline at end of file
diff --git a/crates/wit-component/tests/components/simple/component.wit.print b/crates/wit-component/tests/components/simple/component.wit
similarity index 70%
rename from crates/wit-component/tests/components/simple/component.wit.print
rename to crates/wit-component/tests/components/simple/component.wit
index 5c7dcae2..be8388ec 100644
--- a/crates/wit-component/tests/components/simple/component.wit.print
+++ b/crates/wit-component/tests/components/simple/component.wit
@@ -1,6 +1,4 @@
-package root:component
-
-world root {
+default world component {
   export a: func()
   export b: func() -> string
   export c: func(x: string) -> string
diff --git a/crates/wit-component/tests/components/simple/module.wit b/crates/wit-component/tests/components/simple/module.wit
index 38d41e86..af939cdb 100644
--- a/crates/wit-component/tests/components/simple/module.wit
+++ b/crates/wit-component/tests/components/simple/module.wit
@@ -1,6 +1,4 @@
-package foo:foo
-
-world module {
+default world foo {
   export a: func()
   export b: func() -> string
   export c: func(x: string) -> string
diff --git a/crates/wit-component/tests/components/tricky-order/component.wat b/crates/wit-component/tests/components/tricky-order/component.wat
deleted file mode 100644
index b5b5de07..00000000
--- a/crates/wit-component/tests/components/tricky-order/component.wat
+++ /dev/null
@@ -1,42 +0,0 @@
-(component
-  (type (;0;)
-    (instance
-      (type (;0;) (record))
-      (export (;1;) "name" (type (eq 0)))
-    )
-  )
-  (import (interface "foo:foo/name1") (instance (;0;) (type 0)))
-  (alias export 0 "name" (type (;1;)))
-  (type (;2;)
-    (instance
-      (alias outer 1 1 (type (;0;)))
-      (export (;1;) "name" (type (eq 0)))
-    )
-  )
-  (import (interface "foo:foo/name2") (instance (;1;) (type 2)))
-  (core module (;0;)
-    (@producers
-      (processed-by "wit-component" "$CARGO_PKG_VERSION")
-      (processed-by "my-fake-bindgen" "123.45")
-    )
-  )
-  (core instance (;0;) (instantiate 0))
-  (alias export 0 "name" (type (;3;)))
-  (alias export 1 "name" (type (;4;)))
-  (component (;0;)
-    (type (;0;) (record))
-    (import "import-type-name" (type (;1;) (eq 0)))
-    (import "import-type-name0" (type (;2;) (eq 1)))
-    (export (;3;) "name" (type 1))
-    (export (;4;) "name1" (type 2))
-  )
-  (instance (;2;) (instantiate 0
-      (with "import-type-name" (type 3))
-      (with "import-type-name0" (type 4))
-    )
-  )
-  (@producers
-    (processed-by "wit-component" "$CARGO_PKG_VERSION")
-  )
-  (export (;3;) "name" (instance 2))
-)
\ No newline at end of file
diff --git a/crates/wit-component/tests/components/tricky-order/component.wit.print b/crates/wit-component/tests/components/tricky-order/component.wit.print
deleted file mode 100644
index 53365cc6..00000000
--- a/crates/wit-component/tests/components/tricky-order/component.wit.print
+++ /dev/null
@@ -1,11 +0,0 @@
-package root:component
-
-world root {
-  import foo:foo/name1
-  import foo:foo/name2
-
-  export name: interface {
-    use foo:foo/name1.{name}
-    use foo:foo/name2.{name as name1}
-  }
-}
diff --git a/crates/wit-component/tests/components/tricky-order/module.wat b/crates/wit-component/tests/components/tricky-order/module.wat
deleted file mode 100644
index 3af8f254..00000000
--- a/crates/wit-component/tests/components/tricky-order/module.wat
+++ /dev/null
@@ -1 +0,0 @@
-(module)
diff --git a/crates/wit-component/tests/components/tricky-order/module.wit b/crates/wit-component/tests/components/tricky-order/module.wit
deleted file mode 100644
index 045d2bf1..00000000
--- a/crates/wit-component/tests/components/tricky-order/module.wit
+++ /dev/null
@@ -1,18 +0,0 @@
-package foo:foo
-
-interface name1 {
-  record name {}
-}
-
-interface name2 {
-  use name1.{name}
-}
-
-world module {
-  import name1
-  import name2
-  export name: interface {
-    use name1.{name}
-    use name2.{name as name1}
-  }
-}
diff --git a/crates/wit-component/tests/components/tricky-resources/component.wat b/crates/wit-component/tests/components/tricky-resources/component.wat
deleted file mode 100644
index 5b7fa8e5..00000000
--- a/crates/wit-component/tests/components/tricky-resources/component.wat
+++ /dev/null
@@ -1,75 +0,0 @@
-(component
-  (core module (;0;)
-    (type (;0;) (func (param i32)))
-    (type (;1;) (func (param i32) (result i32)))
-    (type (;2;) (func (result i32)))
-    (import "[export]foo:bar/a" "[resource-drop]r" (func (;0;) (type 0)))
-    (import "[export]foo:bar/a" "[resource-rep]r" (func (;1;) (type 1)))
-    (func (;2;) (type 2) (result i32)
-      unreachable
-    )
-    (export "some-name#f" (func 2))
-    (@producers
-      (processed-by "wit-component" "$CARGO_PKG_VERSION")
-      (processed-by "my-fake-bindgen" "123.45")
-    )
-  )
-  (type (;0;) (resource (rep i32)))
-  (core func (;0;) (canon resource.drop 0))
-  (core func (;1;) (canon resource.rep 0))
-  (core instance (;0;)
-    (export "[resource-drop]r" (func 0))
-    (export "[resource-rep]r" (func 1))
-  )
-  (core instance (;1;) (instantiate 0
-      (with "[export]foo:bar/a" (instance 0))
-    )
-  )
-  (component (;0;)
-    (import "import-type-r" (type (;0;) (sub resource)))
-    (export (;1;) "r" (type 0))
-  )
-  (instance (;0;) (instantiate 0
-      (with "import-type-r" (type 0))
-    )
-  )
-  (export (;1;) (interface "foo:bar/a") (instance 0))
-  (alias export 1 "r" (type (;1;)))
-  (component (;1;)
-    (import "import-type-r" (type (;0;) (sub resource)))
-    (export (;1;) "r" (type 0))
-  )
-  (instance (;2;) (instantiate 1
-      (with "import-type-r" (type 1))
-    )
-  )
-  (export (;3;) (interface "foo:bar/b") (instance 2))
-  (alias export 3 "r" (type (;2;)))
-  (type (;3;) (own 2))
-  (type (;4;) (func (result 3)))
-  (alias core export 1 "some-name#f" (core func (;2;)))
-  (func (;0;) (type 4) (canon lift (core func 2)))
-  (component (;2;)
-    (import "import-type-r" (type (;0;) (sub resource)))
-    (import "import-type-r0" (type (;1;) (eq 0)))
-    (import "import-type-r01" (type (;2;) (eq 1)))
-    (type (;3;) (own 2))
-    (type (;4;) (func (result 3)))
-    (import "import-func-f" (func (;0;) (type 4)))
-    (export (;5;) "r" (type 1))
-    (type (;6;) (own 5))
-    (type (;7;) (func (result 6)))
-    (export (;1;) "f" (func 0) (func (type 7)))
-  )
-  (instance (;4;) (instantiate 2
-      (with "import-func-f" (func 0))
-      (with "import-type-r" (type 1))
-      (with "import-type-r0" (type 2))
-      (with "import-type-r01" (type 2))
-    )
-  )
-  (@producers
-    (processed-by "wit-component" "$CARGO_PKG_VERSION")
-  )
-  (export (;5;) "some-name" (instance 4))
-)
\ No newline at end of file
diff --git a/crates/wit-component/tests/components/tricky-resources/component.wit.print b/crates/wit-component/tests/components/tricky-resources/component.wit.print
deleted file mode 100644
index d400c254..00000000
--- a/crates/wit-component/tests/components/tricky-resources/component.wit.print
+++ /dev/null
@@ -1,11 +0,0 @@
-package root:component
-
-world root {
-  export foo:bar/a
-  export foo:bar/b
-  export some-name: interface {
-    use foo:bar/b.{r}
-
-    f: func() -> r
-  }
-}
diff --git a/crates/wit-component/tests/components/tricky-resources/module.wat b/crates/wit-component/tests/components/tricky-resources/module.wat
deleted file mode 100644
index 788821cd..00000000
--- a/crates/wit-component/tests/components/tricky-resources/module.wat
+++ /dev/null
@@ -1,7 +0,0 @@
-(module
-  (import "[export]foo:bar/a" "[resource-drop]r" (func (param i32)))
-  (import "[export]foo:bar/a" "[resource-rep]r" (func (param i32) (result i32)))
-
-  (func (export "some-name#f") (result i32)
-    unreachable)
-)
diff --git a/crates/wit-component/tests/components/tricky-resources/module.wit b/crates/wit-component/tests/components/tricky-resources/module.wit
deleted file mode 100644
index c6e16e3d..00000000
--- a/crates/wit-component/tests/components/tricky-resources/module.wit
+++ /dev/null
@@ -1,19 +0,0 @@
-package foo:bar
-
-interface a {
-  resource r
-}
-
-interface b {
-  use a.{r}
-}
-
-world module {
-  export b
-  export some-name: interface {
-    use b.{r}
-
-    f: func() -> r
-  }
-  export a
-}
diff --git a/crates/wit-component/tests/components/tricky-resources2/component.wat b/crates/wit-component/tests/components/tricky-resources2/component.wat
deleted file mode 100644
index 8f51a710..00000000
--- a/crates/wit-component/tests/components/tricky-resources2/component.wat
+++ /dev/null
@@ -1,50 +0,0 @@
-(component
-  (core module (;0;)
-    (type (;0;) (func (result i32)))
-    (func (;0;) (type 0) (result i32)
-      unreachable
-    )
-    (export "anon#foo" (func 0))
-    (@producers
-      (processed-by "wit-component" "$CARGO_PKG_VERSION")
-      (processed-by "my-fake-bindgen" "123.45")
-    )
-  )
-  (type (;0;) (resource (rep i32)))
-  (core instance (;0;) (instantiate 0))
-  (component (;0;)
-    (import "import-type-r" (type (;0;) (sub resource)))
-    (export (;1;) "r" (type 0))
-  )
-  (instance (;0;) (instantiate 0
-      (with "import-type-r" (type 0))
-    )
-  )
-  (export (;1;) (interface "foo:bar/a") (instance 0))
-  (alias export 1 "r" (type (;1;)))
-  (type (;2;) (own 1))
-  (type (;3;) (func (result 2)))
-  (alias core export 0 "anon#foo" (core func (;0;)))
-  (func (;0;) (type 3) (canon lift (core func 0)))
-  (component (;1;)
-    (import "import-type-r" (type (;0;) (sub resource)))
-    (import "import-type-r0" (type (;1;) (eq 0)))
-    (type (;2;) (own 1))
-    (type (;3;) (func (result 2)))
-    (import "import-func-foo" (func (;0;) (type 3)))
-    (export (;4;) "r" (type 0))
-    (type (;5;) (own 4))
-    (type (;6;) (func (result 5)))
-    (export (;1;) "foo" (func 0) (func (type 6)))
-  )
-  (instance (;2;) (instantiate 1
-      (with "import-func-foo" (func 0))
-      (with "import-type-r" (type 1))
-      (with "import-type-r0" (type 1))
-    )
-  )
-  (@producers
-    (processed-by "wit-component" "$CARGO_PKG_VERSION")
-  )
-  (export (;3;) "anon" (instance 2))
-)
\ No newline at end of file
diff --git a/crates/wit-component/tests/components/tricky-resources2/component.wit.print b/crates/wit-component/tests/components/tricky-resources2/component.wit.print
deleted file mode 100644
index ababf1db..00000000
--- a/crates/wit-component/tests/components/tricky-resources2/component.wit.print
+++ /dev/null
@@ -1,10 +0,0 @@
-package root:component
-
-world root {
-  export foo:bar/a
-  export anon: interface {
-    use foo:bar/a.{r}
-
-    foo: func() -> r
-  }
-}
diff --git a/crates/wit-component/tests/components/tricky-resources2/module.wat b/crates/wit-component/tests/components/tricky-resources2/module.wat
deleted file mode 100644
index bb3630ce..00000000
--- a/crates/wit-component/tests/components/tricky-resources2/module.wat
+++ /dev/null
@@ -1,4 +0,0 @@
-(module
-  (func (export "anon#foo") (result i32)
-    unreachable)
-)
diff --git a/crates/wit-component/tests/components/tricky-resources2/module.wit b/crates/wit-component/tests/components/tricky-resources2/module.wit
deleted file mode 100644
index 90519061..00000000
--- a/crates/wit-component/tests/components/tricky-resources2/module.wit
+++ /dev/null
@@ -1,14 +0,0 @@
-package foo:bar
-
-interface a {
-  resource r
-}
-
-world module {
-  export anon: interface {
-    use a.{r}
-
-    foo: func() -> r
-  }
-  export a
-}
diff --git a/crates/wit-component/tests/components/tricky-resources3/component.wat b/crates/wit-component/tests/components/tricky-resources3/component.wat
deleted file mode 100644
index d0a3d160..00000000
--- a/crates/wit-component/tests/components/tricky-resources3/component.wat
+++ /dev/null
@@ -1,44 +0,0 @@
-(component
-  (core module (;0;)
-    (@producers
-      (processed-by "wit-component" "$CARGO_PKG_VERSION")
-      (processed-by "my-fake-bindgen" "123.45")
-    )
-  )
-  (type (;0;) (resource (rep i32)))
-  (core instance (;0;) (instantiate 0))
-  (component (;0;)
-    (import "import-type-name" (type (;0;) (sub resource)))
-    (export (;1;) "name" (type 0))
-  )
-  (instance (;0;) (instantiate 0
-      (with "import-type-name" (type 0))
-    )
-  )
-  (export (;1;) (interface "foo:bar/foo") (instance 0))
-  (alias export 1 "name" (type (;1;)))
-  (component (;1;)
-    (import "import-type-name" (type (;0;) (sub resource)))
-    (export (;1;) "name" (type 0))
-  )
-  (instance (;2;) (instantiate 1
-      (with "import-type-name" (type 1))
-    )
-  )
-  (export (;3;) (interface "foo:bar/name") (instance 2))
-  (alias export 3 "name" (type (;2;)))
-  (component (;2;)
-    (import "import-type-name" (type (;0;) (sub resource)))
-    (import "import-type-name0" (type (;1;) (eq 0)))
-    (export (;2;) "name" (type 1))
-  )
-  (instance (;4;) (instantiate 2
-      (with "import-type-name" (type 1))
-      (with "import-type-name0" (type 2))
-    )
-  )
-  (@producers
-    (processed-by "wit-component" "$CARGO_PKG_VERSION")
-  )
-  (export (;5;) "name" (instance 4))
-)
\ No newline at end of file
diff --git a/crates/wit-component/tests/components/tricky-resources3/component.wit.print b/crates/wit-component/tests/components/tricky-resources3/component.wit.print
deleted file mode 100644
index 082f52f8..00000000
--- a/crates/wit-component/tests/components/tricky-resources3/component.wit.print
+++ /dev/null
@@ -1,9 +0,0 @@
-package root:component
-
-world root {
-  export foo:bar/foo
-  export foo:bar/name
-  export name: interface {
-    use foo:bar/name.{name}
-  }
-}
diff --git a/crates/wit-component/tests/components/tricky-resources3/module.wat b/crates/wit-component/tests/components/tricky-resources3/module.wat
deleted file mode 100644
index 3af8f254..00000000
--- a/crates/wit-component/tests/components/tricky-resources3/module.wat
+++ /dev/null
@@ -1 +0,0 @@
-(module)
diff --git a/crates/wit-component/tests/components/tricky-resources3/module.wit b/crates/wit-component/tests/components/tricky-resources3/module.wit
deleted file mode 100644
index 23fd7ce8..00000000
--- a/crates/wit-component/tests/components/tricky-resources3/module.wit
+++ /dev/null
@@ -1,17 +0,0 @@
-package foo:bar
-
-interface foo {
-  resource name
-}
-
-interface name {
-  use foo.{name}
-}
-
-world module {
-  export foo
-  export name
-  export name: interface {
-    use name.{name}
-  }
-}
diff --git a/crates/wit-component/tests/components/tricky-resources4/component.wat b/crates/wit-component/tests/components/tricky-resources4/component.wat
deleted file mode 100644
index b89f516d..00000000
--- a/crates/wit-component/tests/components/tricky-resources4/component.wat
+++ /dev/null
@@ -1,64 +0,0 @@
-(component
-  (core module (;0;)
-    (type (;0;) (func (param i32) (result i32)))
-    (type (;1;) (func (result i32)))
-    (import "[export]foo:bar/name" "[resource-new]name" (func $new (;0;) (type 0)))
-    (func (;1;) (type 1) (result i32)
-      i32.const 100
-      call $new
-    )
-    (export "foo:bar/name#foo" (func 1))
-    (@producers
-      (processed-by "wit-component" "$CARGO_PKG_VERSION")
-      (processed-by "my-fake-bindgen" "123.45")
-    )
-  )
-  (type (;0;) (resource (rep i32)))
-  (core func (;0;) (canon resource.new 0))
-  (core instance (;0;)
-    (export "[resource-new]name" (func 0))
-  )
-  (core instance (;1;) (instantiate 0
-      (with "[export]foo:bar/name" (instance 0))
-    )
-  )
-  (type (;1;) (own 0))
-  (type (;2;) (func (result 1)))
-  (alias core export 1 "foo:bar/name#foo" (core func (;1;)))
-  (func (;0;) (type 2) (canon lift (core func 1)))
-  (component (;0;)
-    (import "import-type-name" (type (;0;) (sub resource)))
-    (import "import-type-handle" (type (;1;) (eq 0)))
-    (type (;2;) (own 1))
-    (type (;3;) (func (result 2)))
-    (import "import-func-foo" (func (;0;) (type 3)))
-    (export (;4;) "name" (type 0))
-    (export (;5;) "handle" (type 4))
-    (type (;6;) (own 5))
-    (type (;7;) (func (result 6)))
-    (export (;1;) "foo" (func 0) (func (type 7)))
-  )
-  (instance (;0;) (instantiate 0
-      (with "import-func-foo" (func 0))
-      (with "import-type-name" (type 0))
-      (with "import-type-handle" (type 0))
-    )
-  )
-  (export (;1;) (interface "foo:bar/name") (instance 0))
-  (alias export 1 "name" (type (;3;)))
-  (alias export 1 "handle" (type (;4;)))
-  (component (;1;)
-    (import "import-type-name" (type (;0;) (sub resource)))
-    (import "import-type-handle" (type (;1;) (eq 0)))
-    (export (;2;) "handle" (type 1))
-  )
-  (instance (;2;) (instantiate 1
-      (with "import-type-name" (type 3))
-      (with "import-type-handle" (type 4))
-    )
-  )
-  (@producers
-    (processed-by "wit-component" "$CARGO_PKG_VERSION")
-  )
-  (export (;3;) "name" (instance 2))
-)
\ No newline at end of file
diff --git a/crates/wit-component/tests/components/tricky-resources4/component.wit.print b/crates/wit-component/tests/components/tricky-resources4/component.wit.print
deleted file mode 100644
index 5bc85770..00000000
--- a/crates/wit-component/tests/components/tricky-resources4/component.wit.print
+++ /dev/null
@@ -1,8 +0,0 @@
-package root:component
-
-world root {
-  export foo:bar/name
-  export name: interface {
-    use foo:bar/name.{handle}
-  }
-}
diff --git a/crates/wit-component/tests/components/tricky-resources4/module.wat b/crates/wit-component/tests/components/tricky-resources4/module.wat
deleted file mode 100644
index bb3ade49..00000000
--- a/crates/wit-component/tests/components/tricky-resources4/module.wat
+++ /dev/null
@@ -1,6 +0,0 @@
-(module
-  (import "[export]foo:bar/name" "[resource-new]name"
-    (func $new (param i32) (result i32)))
-  (func (export "foo:bar/name#foo") (result i32)
-    (call $new (i32.const 100)))
-)
diff --git a/crates/wit-component/tests/components/tricky-resources4/module.wit b/crates/wit-component/tests/components/tricky-resources4/module.wit
deleted file mode 100644
index 5dbeb191..00000000
--- a/crates/wit-component/tests/components/tricky-resources4/module.wit
+++ /dev/null
@@ -1,16 +0,0 @@
-package foo:bar
-
-interface name {
-  resource name
-
-  type handle = name
-
-  foo: func() -> handle
-}
-
-world module {
-  export name
-  export name: interface {
-    use name.{handle}
-  }
-}
diff --git a/crates/wit-component/tests/components/unused-import/component.wat b/crates/wit-component/tests/components/unused-import/component.wat
index 291ae8f7..588d2d74 100644
--- a/crates/wit-component/tests/components/unused-import/component.wat
+++ b/crates/wit-component/tests/components/unused-import/component.wat
@@ -5,25 +5,18 @@
       (export (;0;) "name" (func (type 0)))
     )
   )
-  (import (interface "foo:foo/foo") (instance (;0;) (type 0)))
+  (import "foo" (instance (;0;) (type 0)))
   (core module (;0;)
     (type (;0;) (func (param i32)))
-    (import "foo:foo/foo" "name" (func (;0;) (type 0)))
-    (@producers
-      (processed-by "wit-component" "$CARGO_PKG_VERSION")
-      (processed-by "my-fake-bindgen" "123.45")
-    )
+    (import "foo" "name" (func (;0;) (type 0)))
   )
   (alias export 0 "name" (func (;0;)))
   (core func (;0;) (canon lower (func 0)))
-  (@producers
-    (processed-by "wit-component" "$CARGO_PKG_VERSION")
-  )
   (core instance (;0;)
     (export "name" (func 0))
   )
   (core instance (;1;) (instantiate 0
-      (with "foo:foo/foo" (instance 0))
+      (with "foo" (instance 0))
     )
   )
 )
\ No newline at end of file
diff --git a/crates/wit-component/tests/components/unused-import/component.wit b/crates/wit-component/tests/components/unused-import/component.wit
new file mode 100644
index 00000000..6ad8ced6
--- /dev/null
+++ b/crates/wit-component/tests/components/unused-import/component.wit
@@ -0,0 +1,7 @@
+interface foo {
+  name: func(x: bool)
+}
+
+default world component {
+  import foo: self.foo
+}
diff --git a/crates/wit-component/tests/components/unused-import/component.wit.print b/crates/wit-component/tests/components/unused-import/component.wit.print
deleted file mode 100644
index 7ef7c78b..00000000
--- a/crates/wit-component/tests/components/unused-import/component.wit.print
+++ /dev/null
@@ -1,5 +0,0 @@
-package root:component
-
-world root {
-  import foo:foo/foo
-}
diff --git a/crates/wit-component/tests/components/unused-import/module.wat b/crates/wit-component/tests/components/unused-import/module.wat
index eede8e1a..8fbe7d00 100644
--- a/crates/wit-component/tests/components/unused-import/module.wat
+++ b/crates/wit-component/tests/components/unused-import/module.wat
@@ -1,3 +1,3 @@
 (module
-  (import "foo:foo/foo" "name" (func (param i32)))
+  (import "foo" "name" (func (param i32)))
 )
diff --git a/crates/wit-component/tests/components/unused-import/module.wit b/crates/wit-component/tests/components/unused-import/module.wit
index 770ec45c..1d978499 100644
--- a/crates/wit-component/tests/components/unused-import/module.wit
+++ b/crates/wit-component/tests/components/unused-import/module.wit
@@ -1,12 +1,10 @@
-package foo:foo
-
 interface bar {}
 
 interface foo {
   name: func(x: bool)
 }
 
-world module {
-  import bar // unused
-  import foo
+default world my-world {
+  import unused: self.bar
+  import foo: self.foo
 }
diff --git a/crates/wit-component/tests/components/worlds-with-type-renamings/component.wat b/crates/wit-component/tests/components/worlds-with-type-renamings/component.wat
index 396e1084..65092ed9 100644
--- a/crates/wit-component/tests/components/worlds-with-type-renamings/component.wat
+++ b/crates/wit-component/tests/components/worlds-with-type-renamings/component.wat
@@ -7,14 +7,14 @@
       (export (;0;) "the-func" (func (type 2)))
     )
   )
-  (import (interface "foo:foo/i") (instance (;0;) (type 0)))
+  (import "i1" (instance (;0;) (type 0)))
   (alias export 0 "some-type" (type (;1;)))
-  (import "other-name" (type (;2;) (eq 1)))
+  (import "other-name" (type (eq 1)))
   (core module (;0;)
     (type (;0;) (func (param i32 i64 i32)))
     (type (;1;) (func (param i32 i32 i32 i32) (result i32)))
     (type (;2;) (func))
-    (import "foo:foo/i" "the-func" (func (;0;) (type 2)))
+    (import "i1" "the-func" (func (;0;) (type 2)))
     (func (;1;) (type 2)
       unreachable
     )
@@ -22,13 +22,9 @@
       unreachable
     )
     (memory (;0;) 0)
-    (export "foo:foo/i#the-func" (func 1))
+    (export "i2#the-func" (func 1))
     (export "cabi_realloc" (func 2))
     (export "memory" (memory 0))
-    (@producers
-      (processed-by "wit-component" "$CARGO_PKG_VERSION")
-      (processed-by "my-fake-bindgen" "123.45")
-    )
   )
   (alias export 0 "the-func" (func (;0;)))
   (core func (;0;) (canon lower (func 0)))
@@ -36,32 +32,26 @@
     (export "the-func" (func 0))
   )
   (core instance (;1;) (instantiate 0
-      (with "foo:foo/i" (instance 0))
+      (with "i1" (instance 0))
     )
   )
   (alias core export 1 "memory" (core memory (;0;)))
   (alias core export 1 "cabi_realloc" (core func (;1;)))
   (type (;3;) (record))
   (type (;4;) (func (result 3)))
-  (alias core export 1 "foo:foo/i#the-func" (core func (;2;)))
+  (alias core export 1 "i2#the-func" (core func (;2;)))
   (func (;1;) (type 4) (canon lift (core func 2)))
   (component (;0;)
-    (type (;0;) (record))
-    (import "import-type-some-type" (type (;1;) (eq 0)))
-    (type (;2;) (func (result 1)))
-    (import "import-func-the-func" (func (;0;) (type 2)))
-    (type (;3;) (record))
-    (export (;4;) "some-type" (type 3))
-    (type (;5;) (func (result 4)))
-    (export (;1;) "the-func" (func 0) (func (type 5)))
+    (alias outer 1 4 (type (;0;)))
+    (import "import-the-func" (func (;0;) (type 0)))
+    (type (;1;) (record))
+    (export (;2;) "some-type" (type 1))
+    (type (;3;) (func (result 2)))
+    (export (;1;) "the-func" (func 0) (func (type 3)))
   )
   (instance (;1;) (instantiate 0
-      (with "import-func-the-func" (func 1))
-      (with "import-type-some-type" (type 3))
+      (with "import-the-func" (func 1))
     )
   )
-  (@producers
-    (processed-by "wit-component" "$CARGO_PKG_VERSION")
-  )
-  (export (;2;) (interface "foo:foo/i") (instance 1))
+  (export (;2;) "i2" (instance 1))
 )
\ No newline at end of file
diff --git a/crates/wit-component/tests/components/worlds-with-type-renamings/component.wit b/crates/wit-component/tests/components/worlds-with-type-renamings/component.wit
new file mode 100644
index 00000000..f12875dc
--- /dev/null
+++ b/crates/wit-component/tests/components/worlds-with-type-renamings/component.wit
@@ -0,0 +1,19 @@
+interface i1 {
+  record some-type {
+  }
+
+  the-func: func() -> some-type
+}
+
+interface i2 {
+  record some-type {
+  }
+
+  the-func: func() -> some-type
+}
+
+default world component {
+  import i1: self.i1
+  use self.i1.{some-type as other-name}
+  export i2: self.i2
+}
diff --git a/crates/wit-component/tests/components/worlds-with-type-renamings/component.wit.print b/crates/wit-component/tests/components/worlds-with-type-renamings/component.wit.print
deleted file mode 100644
index b87bb226..00000000
--- a/crates/wit-component/tests/components/worlds-with-type-renamings/component.wit.print
+++ /dev/null
@@ -1,8 +0,0 @@
-package root:component
-
-world root {
-  import foo:foo/i
-  use foo:foo/i.{some-type as other-name}
-
-  export foo:foo/i
-}
diff --git a/crates/wit-component/tests/components/worlds-with-type-renamings/module.wat b/crates/wit-component/tests/components/worlds-with-type-renamings/module.wat
index 441a99dd..21754128 100644
--- a/crates/wit-component/tests/components/worlds-with-type-renamings/module.wat
+++ b/crates/wit-component/tests/components/worlds-with-type-renamings/module.wat
@@ -1,8 +1,8 @@
 (module
   (type (;0;) (func (param i32 i64 i32)))
   (type (;1;) (func (param i32 i32 i32 i32) (result i32)))
-  (import "foo:foo/i" "the-func" (func (;0;)))
-  (func (export "foo:foo/i#the-func")
+  (import "i1" "the-func" (func (;0;)))
+  (func (export "i2#the-func")
     unreachable
   )
   (func (;2;) (export "cabi_realloc") (param i32 i32 i32 i32) (result i32)
diff --git a/crates/wit-component/tests/components/worlds-with-type-renamings/module.wit b/crates/wit-component/tests/components/worlds-with-type-renamings/module.wit
index 5d8b65fb..cbc0633d 100644
--- a/crates/wit-component/tests/components/worlds-with-type-renamings/module.wit
+++ b/crates/wit-component/tests/components/worlds-with-type-renamings/module.wit
@@ -1,5 +1,3 @@
-package foo:foo
-
 interface i {
   record some-type {
   }
@@ -8,9 +6,9 @@ interface i {
 }
 
 
-world module {
-  use i.{some-type as other-name}
+default world the-world {
+  use self.i.{some-type as other-name}
 
-  import i
-  export i
+  import i1: self.i
+  export i2: self.i
 }
diff --git a/crates/wit-component/tests/components/worlds-with-types/component.wat b/crates/wit-component/tests/components/worlds-with-types/component.wat
index 83febe74..38e9fe38 100644
--- a/crates/wit-component/tests/components/worlds-with-types/component.wat
+++ b/crates/wit-component/tests/components/worlds-with-types/component.wat
@@ -1,25 +1,16 @@
 (component
   (type (;0;) u32)
-  (import "t" (type (;1;) (eq 0)))
-  (type (;2;) (record (field "x" 1)))
-  (import "r" (type (;3;) (eq 2)))
+  (import "t" (type (eq 0)))
   (core module (;0;)
-    (type (;0;) (func (param i32) (result i32)))
-    (func (;0;) (type 0) (param i32) (result i32)
+    (type (;0;) (func (result i32)))
+    (func (;0;) (type 0) (result i32)
       i32.const 1
     )
     (export "a" (func 0))
-    (@producers
-      (processed-by "wit-component" "$CARGO_PKG_VERSION")
-      (processed-by "my-fake-bindgen" "123.45")
-    )
   )
   (core instance (;0;) (instantiate 0))
-  (type (;4;) (func (param "r" 3) (result 1)))
+  (type (;2;) (func (result 1)))
   (alias core export 0 "a" (core func (;0;)))
-  (func (;0;) (type 4) (canon lift (core func 0)))
-  (@producers
-    (processed-by "wit-component" "$CARGO_PKG_VERSION")
-  )
+  (func (;0;) (type 2) (canon lift (core func 0)))
   (export (;1;) "a" (func 0))
 )
\ No newline at end of file
diff --git a/crates/wit-component/tests/components/worlds-with-types/component.wit b/crates/wit-component/tests/components/worlds-with-types/component.wit
new file mode 100644
index 00000000..bfc03b1f
--- /dev/null
+++ b/crates/wit-component/tests/components/worlds-with-types/component.wit
@@ -0,0 +1,5 @@
+default world component {
+  type t = u32
+
+  export a: func() -> t
+}
diff --git a/crates/wit-component/tests/components/worlds-with-types/component.wit.print b/crates/wit-component/tests/components/worlds-with-types/component.wit.print
deleted file mode 100644
index e68a8215..00000000
--- a/crates/wit-component/tests/components/worlds-with-types/component.wit.print
+++ /dev/null
@@ -1,11 +0,0 @@
-package root:component
-
-world root {
-  type t = u32
-
-  record r {
-    x: t,
-  }
-
-  export a: func(r: r) -> t
-}
diff --git a/crates/wit-component/tests/components/worlds-with-types/module.wat b/crates/wit-component/tests/components/worlds-with-types/module.wat
index c25e92bc..f529e8d3 100644
--- a/crates/wit-component/tests/components/worlds-with-types/module.wat
+++ b/crates/wit-component/tests/components/worlds-with-types/module.wat
@@ -1,3 +1,3 @@
 (module
-  (func (export "a") (param i32) (result i32) (i32.const 1))
+  (func (export "a") (result i32) (i32.const 1))
 )
diff --git a/crates/wit-component/tests/components/worlds-with-types/module.wit b/crates/wit-component/tests/components/worlds-with-types/module.wit
index 44177ec9..07155ae8 100644
--- a/crates/wit-component/tests/components/worlds-with-types/module.wit
+++ b/crates/wit-component/tests/components/worlds-with-types/module.wit
@@ -1,10 +1,5 @@
-package foo:foo
-
-world module {
+default world foo {
   type t = u32
-  record r {
-    x: t
-  }
 
-  export a: func(r: r) -> t
+  export a: func() -> t
 }
diff --git a/crates/wit-component/tests/interfaces.rs b/crates/wit-component/tests/interfaces.rs
index 9327d60a..76dbbbb8 100644
--- a/crates/wit-component/tests/interfaces.rs
+++ b/crates/wit-component/tests/interfaces.rs
@@ -2,8 +2,8 @@ use anyhow::{Context, Result};
 use pretty_assertions::assert_eq;
 use std::fs;
 use std::path::Path;
-use wit_component::WitPrinter;
-use wit_parser::{PackageId, Resolve, UnresolvedPackage};
+use wit_component::DocumentPrinter;
+use wit_parser::{Resolve, UnresolvedPackage};
 
 /// Tests the encoding of a WIT package as a WebAssembly binary.
 ///
@@ -18,8 +18,6 @@ use wit_parser::{PackageId, Resolve, UnresolvedPackage};
 /// the baseline files.
 #[test]
 fn interface_encoding() -> Result<()> {
-    env_logger::init();
-
     for entry in fs::read_dir("tests/interfaces")? {
         let path = entry?.path();
         let name = match path.file_name().and_then(|s| s.to_str()) {
@@ -42,11 +40,9 @@ fn run_test(path: &Path, is_dir: bool) -> Result<()> {
     let package = if is_dir {
         resolve.push_dir(path)?.0
     } else {
-        resolve.push(UnresolvedPackage::parse_file(path)?)?
+        resolve.push(UnresolvedPackage::parse_file(path)?, &Default::default())?
     };
 
-    assert_print(&resolve, package, path, is_dir)?;
-
     let features = wasmparser::WasmFeatures {
         component_model: true,
         ..Default::default()
@@ -64,10 +60,26 @@ fn run_test(path: &Path, is_dir: bool) -> Result<()> {
 
     // Next decode a fresh WIT package from the WebAssembly generated. Print
     // this package's documents and assert they all match the expectations.
-    let decoded = wit_component::decode(&wasm)?;
+    let name = &resolve.packages[package].name;
+    let decoded = wit_component::decode(name, &wasm)?;
     let resolve = decoded.resolve();
 
-    assert_print(resolve, decoded.package(), path, is_dir)?;
+    for (id, pkg) in resolve.packages.iter() {
+        for (name, doc) in pkg.documents.iter() {
+            let root = if id == decoded.package() {
+                path.to_path_buf()
+            } else {
+                path.join("deps").join(&pkg.name)
+            };
+            let expected = if is_dir {
+                root.join(format!("{name}.wit.print"))
+            } else {
+                root.with_extension("wit.print")
+            };
+            let output = DocumentPrinter::default().print(&resolve, *doc)?;
+            assert_output(&expected, &output)?;
+        }
+    }
 
     // Finally convert the decoded package to wasm again and make sure it
     // matches the prior wasm.
@@ -80,31 +92,12 @@ fn run_test(path: &Path, is_dir: bool) -> Result<()> {
     Ok(())
 }
 
-fn assert_print(resolve: &Resolve, package: PackageId, path: &Path, is_dir: bool) -> Result<()> {
-    let pkg = &resolve.packages[package];
-    let expected = if is_dir {
-        path.join(format!("{}.wit.print", &pkg.name.name))
-    } else {
-        path.with_extension("wit.print")
-    };
-    let output = WitPrinter::default().print(resolve, package)?;
-    assert_output(&expected, &output)?;
-
-    UnresolvedPackage::parse("foo.wit".as_ref(), &output)
-        .context("failed to parse printed output")?;
-    Ok(())
-}
-
 fn assert_output(expected: &Path, actual: &str) -> Result<()> {
-    let actual = actual.replace(
-        concat!("\"", env!("CARGO_PKG_VERSION"), "\""),
-        "\"$CARGO_PKG_VERSION\"",
-    );
     if std::env::var_os("BLESS").is_some() {
-        fs::write(expected, actual).with_context(|| format!("failed to write {expected:?}"))?;
+        fs::write(&expected, actual).with_context(|| format!("failed to write {expected:?}"))?;
     } else {
         assert_eq!(
-            fs::read_to_string(expected)
+            fs::read_to_string(&expected)
                 .with_context(|| format!("failed to read {expected:?}"))?
                 .replace("\r\n", "\n"),
             actual,
diff --git a/crates/wit-component/tests/interfaces/console.wat b/crates/wit-component/tests/interfaces/console.wat
index 088d0d69..61b1f312 100644
--- a/crates/wit-component/tests/interfaces/console.wat
+++ b/crates/wit-component/tests/interfaces/console.wat
@@ -7,11 +7,8 @@
           (export (;0;) "log" (func (type 0)))
         )
       )
-      (export (;0;) (interface "foo:console/console") (instance (type 0)))
+      (export (;0;) "console" "pkg:/console/console" (instance (type 0)))
     )
   )
-  (@producers
-    (processed-by "wit-component" "$CARGO_PKG_VERSION")
-  )
-  (export (;1;) (interface "foo:console/wit") (type 0))
+  (export (;1;) "console" "pkg:/console" (type 0))
 )
\ No newline at end of file
diff --git a/crates/wit-component/tests/interfaces/console.wit b/crates/wit-component/tests/interfaces/console.wit
index 655e2517..f558b2b3 100644
--- a/crates/wit-component/tests/interfaces/console.wit
+++ b/crates/wit-component/tests/interfaces/console.wit
@@ -1,5 +1,3 @@
-package foo:console
-
 interface console {
   log: func(arg: string)
 }
diff --git a/crates/wit-component/tests/interfaces/console.wit.print b/crates/wit-component/tests/interfaces/console.wit.print
index 73a5363d..81a8066f 100644
--- a/crates/wit-component/tests/interfaces/console.wit.print
+++ b/crates/wit-component/tests/interfaces/console.wit.print
@@ -1,5 +1,3 @@
-package foo:console
-
 interface console {
   log: func(arg: string)
 }
diff --git a/crates/wit-component/tests/interfaces/diamond-disambiguate.wat b/crates/wit-component/tests/interfaces/diamond-disambiguate.wat
index 7179e7bc..cf1edfdd 100644
--- a/crates/wit-component/tests/interfaces/diamond-disambiguate.wat
+++ b/crates/wit-component/tests/interfaces/diamond-disambiguate.wat
@@ -4,18 +4,28 @@
       (type (;0;)
         (instance
           (type (;0;) u8)
-          (export (;1;) "t1" (type (eq 0)))
+          (export (;1;) "t2" (type (eq 0)))
         )
       )
-      (export (;0;) (interface "foo:foo/shared1") (instance (type 0)))
-      (type (;1;)
+      (export (;0;) "shared" "pkg:/shared2/shared" (instance (type 0)))
+    )
+  )
+  (export (;1;) "shared2" "pkg:/shared2" (type 0))
+  (type (;2;)
+    (component
+      (type (;0;)
         (instance
           (type (;0;) u8)
-          (export (;1;) "t2" (type (eq 0)))
+          (export (;1;) "t1" (type (eq 0)))
         )
       )
-      (export (;1;) (interface "foo:foo/shared2") (instance (type 1)))
-      (type (;2;)
+      (export (;0;) "shared" "pkg:/shared1/shared" (instance (type 0)))
+    )
+  )
+  (export (;3;) "shared1" "pkg:/shared1" (type 2))
+  (type (;4;)
+    (component
+      (type (;0;)
         (component
           (type (;0;)
             (instance
@@ -23,7 +33,7 @@
               (export (;1;) "t1" (type (eq 0)))
             )
           )
-          (import (interface "foo:foo/shared1") (instance (;0;) (type 0)))
+          (import "shared1" "pkg:/shared1/shared" (instance (type 0)))
           (alias export 0 "t1" (type (;1;)))
           (type (;2;)
             (instance
@@ -31,14 +41,14 @@
               (export (;1;) "t1" (type (eq 0)))
             )
           )
-          (import "foo" (instance (;1;) (type 2)))
+          (import "foo" (instance (type 2)))
           (type (;3;)
             (instance
               (type (;0;) u8)
               (export (;1;) "t2" (type (eq 0)))
             )
           )
-          (import (interface "foo:foo/shared2") (instance (;2;) (type 3)))
+          (import "shared" "pkg:/shared2/shared" (instance (type 3)))
           (alias export 2 "t2" (type (;4;)))
           (type (;5;)
             (instance
@@ -46,14 +56,11 @@
               (export (;1;) "t2" (type (eq 0)))
             )
           )
-          (import "bar" (instance (;3;) (type 5)))
+          (import "bar" (instance (type 5)))
         )
       )
-      (export (;0;) (interface "foo:foo/w1") (component (type 2)))
+      (export (;0;) "w1" "pkg:/join/w1" (component (type 0)))
     )
   )
-  (@producers
-    (processed-by "wit-component" "$CARGO_PKG_VERSION")
-  )
-  (export (;1;) (interface "foo:foo/wit") (type 0))
+  (export (;5;) "join" "pkg:/join" (type 4))
 )
\ No newline at end of file
diff --git a/crates/wit-component/tests/interfaces/diamond-disambiguate/foo.wit.print b/crates/wit-component/tests/interfaces/diamond-disambiguate/foo.wit.print
deleted file mode 100644
index b1268c26..00000000
--- a/crates/wit-component/tests/interfaces/diamond-disambiguate/foo.wit.print
+++ /dev/null
@@ -1,20 +0,0 @@
-package foo:foo
-
-interface shared1 {
-  type t1 = u8
-}
-
-interface shared2 {
-  type t2 = u8
-}
-
-world w1 {
-  import shared1
-  import foo: interface {
-    use shared1.{t1}
-  }
-  import shared2
-  import bar: interface {
-    use shared2.{t2}
-  }
-}
diff --git a/crates/wit-component/tests/interfaces/diamond-disambiguate/join.wit b/crates/wit-component/tests/interfaces/diamond-disambiguate/join.wit
index 3fe026c2..f8bc80c8 100644
--- a/crates/wit-component/tests/interfaces/diamond-disambiguate/join.wit
+++ b/crates/wit-component/tests/interfaces/diamond-disambiguate/join.wit
@@ -1,10 +1,10 @@
-package foo:foo
-
 world w1 {
+  import shared1: pkg.shared1
+
   import foo: interface {
-    use shared1.{t1}
+    use pkg.shared1.{t1}
   }
   import bar: interface {
-    use shared2.{t2}
+    use pkg.shared2.{t2}
   }
 }
diff --git a/crates/wit-component/tests/interfaces/diamond-disambiguate/join.wit.print b/crates/wit-component/tests/interfaces/diamond-disambiguate/join.wit.print
new file mode 100644
index 00000000..3c17d567
--- /dev/null
+++ b/crates/wit-component/tests/interfaces/diamond-disambiguate/join.wit.print
@@ -0,0 +1,10 @@
+world w1 {
+  import shared1: pkg.shared1.shared
+  import foo: interface {
+    use pkg.shared1.shared.{t1}
+  }
+  import shared: pkg.shared2.shared
+  import bar: interface {
+    use pkg.shared2.shared.{t2}
+  }
+}
diff --git a/crates/wit-component/tests/interfaces/diamond-disambiguate/shared1.wit b/crates/wit-component/tests/interfaces/diamond-disambiguate/shared1.wit
index e376a9a6..962bb48c 100644
--- a/crates/wit-component/tests/interfaces/diamond-disambiguate/shared1.wit
+++ b/crates/wit-component/tests/interfaces/diamond-disambiguate/shared1.wit
@@ -1,3 +1,3 @@
-interface shared1 {
+default interface shared {
   type t1 = u8
 }
diff --git a/crates/wit-component/tests/interfaces/diamond-disambiguate/shared1.wit.print b/crates/wit-component/tests/interfaces/diamond-disambiguate/shared1.wit.print
new file mode 100644
index 00000000..5ad82256
--- /dev/null
+++ b/crates/wit-component/tests/interfaces/diamond-disambiguate/shared1.wit.print
@@ -0,0 +1,5 @@
+interface shared {
+  type t1 = u8
+
+}
+
diff --git a/crates/wit-component/tests/interfaces/diamond-disambiguate/shared2.wit b/crates/wit-component/tests/interfaces/diamond-disambiguate/shared2.wit
index 0b6e9c84..e12498ea 100644
--- a/crates/wit-component/tests/interfaces/diamond-disambiguate/shared2.wit
+++ b/crates/wit-component/tests/interfaces/diamond-disambiguate/shared2.wit
@@ -1,3 +1,3 @@
-interface shared2 {
+default interface shared {
   type t2 = u8
 }
diff --git a/crates/wit-component/tests/interfaces/diamond-disambiguate/shared2.wit.print b/crates/wit-component/tests/interfaces/diamond-disambiguate/shared2.wit.print
new file mode 100644
index 00000000..032fea72
--- /dev/null
+++ b/crates/wit-component/tests/interfaces/diamond-disambiguate/shared2.wit.print
@@ -0,0 +1,5 @@
+interface shared {
+  type t2 = u8
+
+}
+
diff --git a/crates/wit-component/tests/interfaces/diamond.wat b/crates/wit-component/tests/interfaces/diamond.wat
index b45bebec..cd397820 100644
--- a/crates/wit-component/tests/interfaces/diamond.wat
+++ b/crates/wit-component/tests/interfaces/diamond.wat
@@ -7,7 +7,7 @@
           (export (;1;) "the-enum" (type (eq 0)))
         )
       )
-      (export (;0;) (interface "foo:foo/shared-items") (instance (type 0)))
+      (export (;0;) "shared" "pkg:/diamond/shared" (instance (type 0)))
       (type (;1;)
         (component
           (type (;0;)
@@ -16,7 +16,7 @@
               (export (;1;) "the-enum" (type (eq 0)))
             )
           )
-          (import (interface "foo:foo/shared-items") (instance (;0;) (type 0)))
+          (import "shared" "pkg:/diamond/shared" (instance (type 0)))
           (alias export 0 "the-enum" (type (;1;)))
           (type (;2;)
             (instance
@@ -24,17 +24,10 @@
               (export (;1;) "the-enum" (type (eq 0)))
             )
           )
-          (import "foo" (instance (;1;) (type 2)))
-          (type (;3;)
-            (instance
-              (alias outer 1 1 (type (;0;)))
-              (export (;1;) "the-enum" (type (eq 0)))
-            )
-          )
-          (import "bar" (instance (;2;) (type 3)))
+          (export (;0;) "bar" (instance (type 2)))
         )
       )
-      (export (;0;) (interface "foo:foo/w1") (component (type 1)))
+      (export (;0;) "w3" "pkg:/diamond/w3" (component (type 1)))
       (type (;2;)
         (component
           (type (;0;)
@@ -43,7 +36,7 @@
               (export (;1;) "the-enum" (type (eq 0)))
             )
           )
-          (import (interface "foo:foo/shared-items") (instance (;0;) (type 0)))
+          (import "shared" "pkg:/diamond/shared" (instance (type 0)))
           (alias export 0 "the-enum" (type (;1;)))
           (type (;2;)
             (instance
@@ -51,17 +44,17 @@
               (export (;1;) "the-enum" (type (eq 0)))
             )
           )
-          (import "foo" (instance (;1;) (type 2)))
+          (import "foo" (instance (type 2)))
           (type (;3;)
             (instance
               (alias outer 1 1 (type (;0;)))
               (export (;1;) "the-enum" (type (eq 0)))
             )
           )
-          (export (;2;) "bar" (instance (type 3)))
+          (export (;0;) "bar" (instance (type 3)))
         )
       )
-      (export (;1;) (interface "foo:foo/w2") (component (type 2)))
+      (export (;1;) "w2" "pkg:/diamond/w2" (component (type 2)))
       (type (;3;)
         (component
           (type (;0;)
@@ -70,7 +63,7 @@
               (export (;1;) "the-enum" (type (eq 0)))
             )
           )
-          (import (interface "foo:foo/shared-items") (instance (;0;) (type 0)))
+          (import "shared" "pkg:/diamond/shared" (instance (type 0)))
           (alias export 0 "the-enum" (type (;1;)))
           (type (;2;)
             (instance
@@ -78,14 +71,18 @@
               (export (;1;) "the-enum" (type (eq 0)))
             )
           )
-          (export (;1;) "bar" (instance (type 2)))
+          (import "foo" (instance (type 2)))
+          (type (;3;)
+            (instance
+              (alias outer 1 1 (type (;0;)))
+              (export (;1;) "the-enum" (type (eq 0)))
+            )
+          )
+          (import "bar" (instance (type 3)))
         )
       )
-      (export (;2;) (interface "foo:foo/w3") (component (type 3)))
+      (export (;2;) "w1" "pkg:/diamond/w1" (component (type 3)))
     )
   )
-  (@producers
-    (processed-by "wit-component" "$CARGO_PKG_VERSION")
-  )
-  (export (;1;) (interface "foo:foo/wit") (type 0))
+  (export (;1;) "diamond" "pkg:/diamond" (type 0))
 )
\ No newline at end of file
diff --git a/crates/wit-component/tests/interfaces/diamond.wit b/crates/wit-component/tests/interfaces/diamond.wit
index f9312951..b5d718b3 100644
--- a/crates/wit-component/tests/interfaces/diamond.wit
+++ b/crates/wit-component/tests/interfaces/diamond.wit
@@ -1,6 +1,4 @@
-package foo:foo
-
-interface shared-items {
+interface shared {
   enum the-enum {
     a
   }
@@ -8,24 +6,24 @@ interface shared-items {
 
 world w1 {
   import foo: interface {
-    use shared-items.{the-enum}
+    use self.shared.{the-enum}
   }
   import bar: interface {
-    use shared-items.{the-enum}
+    use self.shared.{the-enum}
   }
 }
 
 world w2 {
   import foo: interface {
-    use shared-items.{the-enum}
+    use self.shared.{the-enum}
   }
   export bar: interface {
-    use shared-items.{the-enum}
+    use self.shared.{the-enum}
   }
 }
 
 world w3 {
   export bar: interface {
-    use shared-items.{the-enum}
+    use self.shared.{the-enum}
   }
 }
diff --git a/crates/wit-component/tests/interfaces/diamond.wit.print b/crates/wit-component/tests/interfaces/diamond.wit.print
index f09cb0e5..d9801391 100644
--- a/crates/wit-component/tests/interfaces/diamond.wit.print
+++ b/crates/wit-component/tests/interfaces/diamond.wit.print
@@ -1,34 +1,31 @@
-package foo:foo
-
-interface shared-items {
+interface shared {
   enum the-enum {
     a,
   }
+
 }
 
-world w1 {
-  import shared-items
-  import foo: interface {
-    use shared-items.{the-enum}
-  }
-  import bar: interface {
-    use shared-items.{the-enum}
+world w3 {
+  import shared: self.shared
+  export bar: interface {
+    use self.shared.{the-enum}
   }
 }
 world w2 {
-  import shared-items
+  import shared: self.shared
   import foo: interface {
-    use shared-items.{the-enum}
+    use self.shared.{the-enum}
   }
-
   export bar: interface {
-    use shared-items.{the-enum}
+    use self.shared.{the-enum}
   }
 }
-world w3 {
-  import shared-items
-
-  export bar: interface {
-    use shared-items.{the-enum}
+world w1 {
+  import shared: self.shared
+  import foo: interface {
+    use self.shared.{the-enum}
+  }
+  import bar: interface {
+    use self.shared.{the-enum}
   }
 }
diff --git a/crates/wit-component/tests/interfaces/empty.wat b/crates/wit-component/tests/interfaces/empty.wat
index b85aef39..bafe8dc0 100644
--- a/crates/wit-component/tests/interfaces/empty.wat
+++ b/crates/wit-component/tests/interfaces/empty.wat
@@ -4,36 +4,25 @@
       (type (;0;)
         (instance)
       )
-      (export (;0;) (interface "foo:empty/empty") (instance (type 0)))
+      (export (;0;) "empty" "pkg:/empty/empty" (instance (type 0)))
       (type (;1;)
         (component
           (type (;0;)
             (instance)
           )
-          (import (interface "foo:empty/empty") (instance (;0;) (type 0)))
+          (import "empty" "pkg:/empty/empty" (instance (type 0)))
           (type (;1;)
             (instance)
           )
-          (import "empty" (instance (;1;) (type 1)))
-          (type (;2;)
-            (instance)
-          )
-          (export (;2;) (interface "foo:empty/empty") (instance (type 2)))
-          (type (;3;)
-            (instance)
-          )
-          (export (;3;) "empty2" (instance (type 3)))
+          (export (;0;) "empty2" "pkg:/empty/empty" (instance (type 1)))
         )
       )
-      (export (;0;) (interface "foo:empty/empty-world") (component (type 1)))
+      (export (;0;) "empty-world" "pkg:/empty/empty-world" (component (type 1)))
       (type (;2;)
         (component)
       )
-      (export (;1;) (interface "foo:empty/actually-empty-world") (component (type 2)))
+      (export (;1;) "actually-empty-world" "pkg:/empty/actually-empty-world" (component (type 2)))
     )
   )
-  (@producers
-    (processed-by "wit-component" "$CARGO_PKG_VERSION")
-  )
-  (export (;1;) (interface "foo:empty/wit") (type 0))
+  (export (;1;) "empty" "pkg:/empty" (type 0))
 )
\ No newline at end of file
diff --git a/crates/wit-component/tests/interfaces/empty.wit b/crates/wit-component/tests/interfaces/empty.wit
index fce4c42d..db74436f 100644
--- a/crates/wit-component/tests/interfaces/empty.wit
+++ b/crates/wit-component/tests/interfaces/empty.wit
@@ -1,12 +1,8 @@
-package foo:empty
-
 interface empty {}
 
 world empty-world {
-  import empty
-  import empty: interface {}
-  export empty
-  export empty2: interface {}
+  import empty: self.empty
+  export empty2: self.empty
 }
 
 world actually-empty-world {}
diff --git a/crates/wit-component/tests/interfaces/empty.wit.print b/crates/wit-component/tests/interfaces/empty.wit.print
index 4f16a4b9..31b7961c 100644
--- a/crates/wit-component/tests/interfaces/empty.wit.print
+++ b/crates/wit-component/tests/interfaces/empty.wit.print
@@ -1,16 +1,9 @@
-package foo:empty
-
 interface empty {
 }
 
 world empty-world {
-  import empty
-  import empty: interface {
-  }
-
-  export empty
-  export empty2: interface {
-  }
+  import empty: self.empty
+  export empty2: self.empty
 }
 world actually-empty-world {
 }
diff --git a/crates/wit-component/tests/interfaces/export-other-packages-interface.wat b/crates/wit-component/tests/interfaces/export-other-packages-interface.wat
index ca7aa808..2d8a2958 100644
--- a/crates/wit-component/tests/interfaces/export-other-packages-interface.wat
+++ b/crates/wit-component/tests/interfaces/export-other-packages-interface.wat
@@ -9,14 +9,11 @@
               (export (;1;) "t" (type (eq 0)))
             )
           )
-          (export (;0;) (interface "foo:the-dep/the-interface") (instance (type 0)))
+          (export (;0;) "foo" "path:/the-dep/the-doc/the-interface" (instance (type 0)))
         )
       )
-      (export (;0;) (interface "foo:foo/foo") (component (type 0)))
+      (export (;0;) "foo" "pkg:/foo/foo" (component (type 0)))
     )
   )
-  (@producers
-    (processed-by "wit-component" "$CARGO_PKG_VERSION")
-  )
-  (export (;1;) (interface "foo:foo/wit") (type 0))
+  (export (;1;) "foo" "pkg:/foo" (type 0))
 )
\ No newline at end of file
diff --git a/crates/wit-component/tests/interfaces/export-other-packages-interface/deps/the-dep/the-doc.wit b/crates/wit-component/tests/interfaces/export-other-packages-interface/deps/the-dep/the-doc.wit
index a95f6a37..c26eb475 100644
--- a/crates/wit-component/tests/interfaces/export-other-packages-interface/deps/the-dep/the-doc.wit
+++ b/crates/wit-component/tests/interfaces/export-other-packages-interface/deps/the-dep/the-doc.wit
@@ -1,6 +1,4 @@
-package foo:the-dep
-
-interface the-interface {
+default interface the-interface {
   type t = u8
 }
 
diff --git a/crates/wit-component/tests/interfaces/export-other-packages-interface/deps/the-dep/the-doc.wit.print b/crates/wit-component/tests/interfaces/export-other-packages-interface/deps/the-dep/the-doc.wit.print
new file mode 100644
index 00000000..19e97756
--- /dev/null
+++ b/crates/wit-component/tests/interfaces/export-other-packages-interface/deps/the-dep/the-doc.wit.print
@@ -0,0 +1,5 @@
+interface the-interface {
+  type t = u8
+
+}
+
diff --git a/crates/wit-component/tests/interfaces/export-other-packages-interface/foo.wit b/crates/wit-component/tests/interfaces/export-other-packages-interface/foo.wit
index 63721d40..e4ea8aad 100644
--- a/crates/wit-component/tests/interfaces/export-other-packages-interface/foo.wit
+++ b/crates/wit-component/tests/interfaces/export-other-packages-interface/foo.wit
@@ -1,5 +1,3 @@
-package foo:foo
-
 world foo {
-  export foo:the-dep/the-interface
+  export foo: the-dep.the-doc
 }
diff --git a/crates/wit-component/tests/interfaces/export-other-packages-interface/foo.wit.print b/crates/wit-component/tests/interfaces/export-other-packages-interface/foo.wit.print
index 63721d40..46cee892 100644
--- a/crates/wit-component/tests/interfaces/export-other-packages-interface/foo.wit.print
+++ b/crates/wit-component/tests/interfaces/export-other-packages-interface/foo.wit.print
@@ -1,5 +1,3 @@
-package foo:foo
-
 world foo {
-  export foo:the-dep/the-interface
+  export foo: the-dep.the-doc.the-interface
 }
diff --git a/crates/wit-component/tests/interfaces/exports.wat b/crates/wit-component/tests/interfaces/exports.wat
index f7a4edfd..841a18e1 100644
--- a/crates/wit-component/tests/interfaces/exports.wat
+++ b/crates/wit-component/tests/interfaces/exports.wat
@@ -9,7 +9,7 @@
           (export (;0;) "my-function" (func (type 2)))
         )
       )
-      (export (;0;) (interface "foo:foo/foo") (instance (type 0)))
+      (export (;0;) "foo" "pkg:/exports/foo" (instance (type 0)))
       (type (;1;)
         (component
           (type (;0;)
@@ -20,14 +20,11 @@
               (export (;0;) "my-function" (func (type 2)))
             )
           )
-          (export (;0;) (interface "foo:foo/foo") (instance (type 0)))
+          (export (;0;) "foo" "pkg:/exports/foo" (instance (type 0)))
         )
       )
-      (export (;0;) (interface "foo:foo/export-foo") (component (type 1)))
+      (export (;0;) "export-foo" "pkg:/exports/export-foo" (component (type 1)))
     )
   )
-  (@producers
-    (processed-by "wit-component" "$CARGO_PKG_VERSION")
-  )
-  (export (;1;) (interface "foo:foo/wit") (type 0))
+  (export (;1;) "exports" "pkg:/exports" (type 0))
 )
\ No newline at end of file
diff --git a/crates/wit-component/tests/interfaces/exports.wit b/crates/wit-component/tests/interfaces/exports.wit
index 542abad8..c29cb7bd 100644
--- a/crates/wit-component/tests/interfaces/exports.wit
+++ b/crates/wit-component/tests/interfaces/exports.wit
@@ -1,5 +1,3 @@
-package foo:foo
-
 interface foo {
   record my-struct {
     a: u32,
@@ -9,5 +7,5 @@ interface foo {
 }
 
 world export-foo {
-  export foo
+  export foo: self.foo
 }
diff --git a/crates/wit-component/tests/interfaces/exports.wit.print b/crates/wit-component/tests/interfaces/exports.wit.print
index 542abad8..c29cb7bd 100644
--- a/crates/wit-component/tests/interfaces/exports.wit.print
+++ b/crates/wit-component/tests/interfaces/exports.wit.print
@@ -1,5 +1,3 @@
-package foo:foo
-
 interface foo {
   record my-struct {
     a: u32,
@@ -9,5 +7,5 @@ interface foo {
 }
 
 world export-foo {
-  export foo
+  export foo: self.foo
 }
diff --git a/crates/wit-component/tests/interfaces/flags.wat b/crates/wit-component/tests/interfaces/flags.wat
index 0c4ea56d..10390f88 100644
--- a/crates/wit-component/tests/interfaces/flags.wat
+++ b/crates/wit-component/tests/interfaces/flags.wat
@@ -3,79 +3,76 @@
     (component
       (type (;0;)
         (instance
-          (type (;0;) (flags "b0"))
-          (export (;1;) "flag1" (type (eq 0)))
-          (type (;2;) (flags "b0" "b1"))
-          (export (;3;) "flag2" (type (eq 2)))
+          (type (;0;) (flags "b0" "b1" "b2" "b3" "b4" "b5" "b6" "b7"))
+          (export (;1;) "flag8" (type (eq 0)))
+          (type (;2;) (flags "b0" "b1" "b2" "b3" "b4" "b5" "b6" "b7" "b8" "b9" "b10" "b11" "b12" "b13" "b14" "b15" "b16" "b17" "b18" "b19" "b20" "b21" "b22" "b23" "b24" "b25" "b26" "b27" "b28" "b29" "b30" "b31" "b32" "b33" "b34" "b35" "b36" "b37" "b38" "b39" "b40" "b41" "b42" "b43" "b44" "b45" "b46" "b47" "b48" "b49" "b50" "b51" "b52" "b53" "b54" "b55" "b56" "b57" "b58" "b59" "b60" "b61" "b62" "b63"))
+          (export (;3;) "flag64" (type (eq 2)))
           (type (;4;) (flags "b0" "b1" "b2" "b3"))
           (export (;5;) "flag4" (type (eq 4)))
-          (type (;6;) (flags "b0" "b1" "b2" "b3" "b4" "b5" "b6" "b7"))
-          (export (;7;) "flag8" (type (eq 6)))
-          (type (;8;) (flags "b0" "b1" "b2" "b3" "b4" "b5" "b6" "b7" "b8" "b9" "b10" "b11" "b12" "b13" "b14" "b15"))
-          (export (;9;) "flag16" (type (eq 8)))
-          (type (;10;) (flags "b0" "b1" "b2" "b3" "b4" "b5" "b6" "b7" "b8" "b9" "b10" "b11" "b12" "b13" "b14" "b15" "b16" "b17" "b18" "b19" "b20" "b21" "b22" "b23" "b24" "b25" "b26" "b27" "b28" "b29" "b30" "b31"))
-          (export (;11;) "flag32" (type (eq 10)))
-          (type (;12;) (flags "b0" "b1" "b2" "b3" "b4" "b5" "b6" "b7" "b8" "b9" "b10" "b11" "b12" "b13" "b14" "b15" "b16" "b17" "b18" "b19" "b20" "b21" "b22" "b23" "b24" "b25" "b26" "b27" "b28" "b29" "b30" "b31" "b32" "b33" "b34" "b35" "b36" "b37" "b38" "b39" "b40" "b41" "b42" "b43" "b44" "b45" "b46" "b47" "b48" "b49" "b50" "b51" "b52" "b53" "b54" "b55" "b56" "b57" "b58" "b59" "b60" "b61" "b62" "b63"))
-          (export (;13;) "flag64" (type (eq 12)))
-          (type (;14;) (func (param "x" 1) (result 1)))
+          (type (;6;) (flags "b0" "b1" "b2" "b3" "b4" "b5" "b6" "b7" "b8" "b9" "b10" "b11" "b12" "b13" "b14" "b15" "b16" "b17" "b18" "b19" "b20" "b21" "b22" "b23" "b24" "b25" "b26" "b27" "b28" "b29" "b30" "b31"))
+          (export (;7;) "flag32" (type (eq 6)))
+          (type (;8;) (flags "b0" "b1"))
+          (export (;9;) "flag2" (type (eq 8)))
+          (type (;10;) (flags "b0" "b1" "b2" "b3" "b4" "b5" "b6" "b7" "b8" "b9" "b10" "b11" "b12" "b13" "b14" "b15"))
+          (export (;11;) "flag16" (type (eq 10)))
+          (type (;12;) (flags "b0"))
+          (export (;13;) "flag1" (type (eq 12)))
+          (type (;14;) (func (param "x" 13) (result 13)))
           (export (;0;) "roundtrip-flag1" (func (type 14)))
-          (type (;15;) (func (param "x" 3) (result 3)))
+          (type (;15;) (func (param "x" 9) (result 9)))
           (export (;1;) "roundtrip-flag2" (func (type 15)))
           (type (;16;) (func (param "x" 5) (result 5)))
           (export (;2;) "roundtrip-flag4" (func (type 16)))
-          (type (;17;) (func (param "x" 7) (result 7)))
+          (type (;17;) (func (param "x" 1) (result 1)))
           (export (;3;) "roundtrip-flag8" (func (type 17)))
-          (type (;18;) (func (param "x" 9) (result 9)))
+          (type (;18;) (func (param "x" 11) (result 11)))
           (export (;4;) "roundtrip-flag16" (func (type 18)))
-          (type (;19;) (func (param "x" 11) (result 11)))
+          (type (;19;) (func (param "x" 7) (result 7)))
           (export (;5;) "roundtrip-flag32" (func (type 19)))
-          (type (;20;) (func (param "x" 13) (result 13)))
+          (type (;20;) (func (param "x" 3) (result 3)))
           (export (;6;) "roundtrip-flag64" (func (type 20)))
         )
       )
-      (export (;0;) (interface "foo:flags/imports") (instance (type 0)))
+      (export (;0;) "imports" "pkg:/flags/imports" (instance (type 0)))
       (type (;1;)
         (component
           (type (;0;)
             (instance
-              (type (;0;) (flags "b0"))
-              (export (;1;) "flag1" (type (eq 0)))
-              (type (;2;) (flags "b0" "b1"))
-              (export (;3;) "flag2" (type (eq 2)))
+              (type (;0;) (flags "b0" "b1" "b2" "b3" "b4" "b5" "b6" "b7"))
+              (export (;1;) "flag8" (type (eq 0)))
+              (type (;2;) (flags "b0" "b1" "b2" "b3" "b4" "b5" "b6" "b7" "b8" "b9" "b10" "b11" "b12" "b13" "b14" "b15" "b16" "b17" "b18" "b19" "b20" "b21" "b22" "b23" "b24" "b25" "b26" "b27" "b28" "b29" "b30" "b31" "b32" "b33" "b34" "b35" "b36" "b37" "b38" "b39" "b40" "b41" "b42" "b43" "b44" "b45" "b46" "b47" "b48" "b49" "b50" "b51" "b52" "b53" "b54" "b55" "b56" "b57" "b58" "b59" "b60" "b61" "b62" "b63"))
+              (export (;3;) "flag64" (type (eq 2)))
               (type (;4;) (flags "b0" "b1" "b2" "b3"))
               (export (;5;) "flag4" (type (eq 4)))
-              (type (;6;) (flags "b0" "b1" "b2" "b3" "b4" "b5" "b6" "b7"))
-              (export (;7;) "flag8" (type (eq 6)))
-              (type (;8;) (flags "b0" "b1" "b2" "b3" "b4" "b5" "b6" "b7" "b8" "b9" "b10" "b11" "b12" "b13" "b14" "b15"))
-              (export (;9;) "flag16" (type (eq 8)))
-              (type (;10;) (flags "b0" "b1" "b2" "b3" "b4" "b5" "b6" "b7" "b8" "b9" "b10" "b11" "b12" "b13" "b14" "b15" "b16" "b17" "b18" "b19" "b20" "b21" "b22" "b23" "b24" "b25" "b26" "b27" "b28" "b29" "b30" "b31"))
-              (export (;11;) "flag32" (type (eq 10)))
-              (type (;12;) (flags "b0" "b1" "b2" "b3" "b4" "b5" "b6" "b7" "b8" "b9" "b10" "b11" "b12" "b13" "b14" "b15" "b16" "b17" "b18" "b19" "b20" "b21" "b22" "b23" "b24" "b25" "b26" "b27" "b28" "b29" "b30" "b31" "b32" "b33" "b34" "b35" "b36" "b37" "b38" "b39" "b40" "b41" "b42" "b43" "b44" "b45" "b46" "b47" "b48" "b49" "b50" "b51" "b52" "b53" "b54" "b55" "b56" "b57" "b58" "b59" "b60" "b61" "b62" "b63"))
-              (export (;13;) "flag64" (type (eq 12)))
-              (type (;14;) (func (param "x" 1) (result 1)))
+              (type (;6;) (flags "b0" "b1" "b2" "b3" "b4" "b5" "b6" "b7" "b8" "b9" "b10" "b11" "b12" "b13" "b14" "b15" "b16" "b17" "b18" "b19" "b20" "b21" "b22" "b23" "b24" "b25" "b26" "b27" "b28" "b29" "b30" "b31"))
+              (export (;7;) "flag32" (type (eq 6)))
+              (type (;8;) (flags "b0" "b1"))
+              (export (;9;) "flag2" (type (eq 8)))
+              (type (;10;) (flags "b0" "b1" "b2" "b3" "b4" "b5" "b6" "b7" "b8" "b9" "b10" "b11" "b12" "b13" "b14" "b15"))
+              (export (;11;) "flag16" (type (eq 10)))
+              (type (;12;) (flags "b0"))
+              (export (;13;) "flag1" (type (eq 12)))
+              (type (;14;) (func (param "x" 13) (result 13)))
               (export (;0;) "roundtrip-flag1" (func (type 14)))
-              (type (;15;) (func (param "x" 3) (result 3)))
+              (type (;15;) (func (param "x" 9) (result 9)))
               (export (;1;) "roundtrip-flag2" (func (type 15)))
               (type (;16;) (func (param "x" 5) (result 5)))
               (export (;2;) "roundtrip-flag4" (func (type 16)))
-              (type (;17;) (func (param "x" 7) (result 7)))
+              (type (;17;) (func (param "x" 1) (result 1)))
               (export (;3;) "roundtrip-flag8" (func (type 17)))
-              (type (;18;) (func (param "x" 9) (result 9)))
+              (type (;18;) (func (param "x" 11) (result 11)))
               (export (;4;) "roundtrip-flag16" (func (type 18)))
-              (type (;19;) (func (param "x" 11) (result 11)))
+              (type (;19;) (func (param "x" 7) (result 7)))
               (export (;5;) "roundtrip-flag32" (func (type 19)))
-              (type (;20;) (func (param "x" 13) (result 13)))
+              (type (;20;) (func (param "x" 3) (result 3)))
               (export (;6;) "roundtrip-flag64" (func (type 20)))
             )
           )
-          (import (interface "foo:flags/imports") (instance (;0;) (type 0)))
+          (import "imports" "pkg:/flags/imports" (instance (type 0)))
         )
       )
-      (export (;0;) (interface "foo:flags/flags-world") (component (type 1)))
+      (export (;0;) "flags-world" "pkg:/flags/flags-world" (component (type 1)))
     )
   )
-  (@producers
-    (processed-by "wit-component" "$CARGO_PKG_VERSION")
-  )
-  (export (;1;) (interface "foo:flags/wit") (type 0))
+  (export (;1;) "flags" "pkg:/flags" (type 0))
 )
\ No newline at end of file
diff --git a/crates/wit-component/tests/interfaces/flags.wit b/crates/wit-component/tests/interfaces/flags.wit
index 6f23fdd3..63496891 100644
--- a/crates/wit-component/tests/interfaces/flags.wit
+++ b/crates/wit-component/tests/interfaces/flags.wit
@@ -1,5 +1,3 @@
-package foo:%flags
-
 interface imports {
   flags flag1 {
     b0,
@@ -165,5 +163,5 @@ interface imports {
 }
 
 world flags-world {
-  import imports
+  import imports: self.imports
 }
diff --git a/crates/wit-component/tests/interfaces/flags.wit.print b/crates/wit-component/tests/interfaces/flags.wit.print
index 6f23fdd3..4a2715fa 100644
--- a/crates/wit-component/tests/interfaces/flags.wit.print
+++ b/crates/wit-component/tests/interfaces/flags.wit.print
@@ -1,22 +1,4 @@
-package foo:%flags
-
 interface imports {
-  flags flag1 {
-    b0,
-  }
-
-  flags flag2 {
-    b0,
-    b1,
-  }
-
-  flags flag4 {
-    b0,
-    b1,
-    b2,
-    b3,
-  }
-
   flags flag8 {
     b0,
     b1,
@@ -28,7 +10,7 @@ interface imports {
     b7,
   }
 
-  flags flag16 {
+  flags flag64 {
     b0,
     b1,
     b2,
@@ -45,6 +27,61 @@ interface imports {
     b13,
     b14,
     b15,
+    b16,
+    b17,
+    b18,
+    b19,
+    b20,
+    b21,
+    b22,
+    b23,
+    b24,
+    b25,
+    b26,
+    b27,
+    b28,
+    b29,
+    b30,
+    b31,
+    b32,
+    b33,
+    b34,
+    b35,
+    b36,
+    b37,
+    b38,
+    b39,
+    b40,
+    b41,
+    b42,
+    b43,
+    b44,
+    b45,
+    b46,
+    b47,
+    b48,
+    b49,
+    b50,
+    b51,
+    b52,
+    b53,
+    b54,
+    b55,
+    b56,
+    b57,
+    b58,
+    b59,
+    b60,
+    b61,
+    b62,
+    b63,
+  }
+
+  flags flag4 {
+    b0,
+    b1,
+    b2,
+    b3,
   }
 
   flags flag32 {
@@ -82,7 +119,12 @@ interface imports {
     b31,
   }
 
-  flags flag64 {
+  flags flag2 {
+    b0,
+    b1,
+  }
+
+  flags flag16 {
     b0,
     b1,
     b2,
@@ -99,54 +141,10 @@ interface imports {
     b13,
     b14,
     b15,
-    b16,
-    b17,
-    b18,
-    b19,
-    b20,
-    b21,
-    b22,
-    b23,
-    b24,
-    b25,
-    b26,
-    b27,
-    b28,
-    b29,
-    b30,
-    b31,
-    b32,
-    b33,
-    b34,
-    b35,
-    b36,
-    b37,
-    b38,
-    b39,
-    b40,
-    b41,
-    b42,
-    b43,
-    b44,
-    b45,
-    b46,
-    b47,
-    b48,
-    b49,
-    b50,
-    b51,
-    b52,
-    b53,
-    b54,
-    b55,
-    b56,
-    b57,
-    b58,
-    b59,
-    b60,
-    b61,
-    b62,
-    b63,
+  }
+
+  flags flag1 {
+    b0,
   }
 
   roundtrip-flag1: func(x: flag1) -> flag1
@@ -165,5 +163,5 @@ interface imports {
 }
 
 world flags-world {
-  import imports
+  import imports: self.imports
 }
diff --git a/crates/wit-component/tests/interfaces/floats.wat b/crates/wit-component/tests/interfaces/floats.wat
index 0b3457e4..08de2b54 100644
--- a/crates/wit-component/tests/interfaces/floats.wat
+++ b/crates/wit-component/tests/interfaces/floats.wat
@@ -13,7 +13,7 @@
           (export (;3;) "float64-result" (func (type 3)))
         )
       )
-      (export (;0;) (interface "foo:floats/floats") (instance (type 0)))
+      (export (;0;) "floats" "pkg:/floats/floats" (instance (type 0)))
       (type (;1;)
         (component
           (type (;0;)
@@ -28,14 +28,11 @@
               (export (;3;) "float64-result" (func (type 3)))
             )
           )
-          (import (interface "foo:floats/floats") (instance (;0;) (type 0)))
+          (import "floats" "pkg:/floats/floats" (instance (type 0)))
         )
       )
-      (export (;0;) (interface "foo:floats/floats-world") (component (type 1)))
+      (export (;0;) "floats-world" "pkg:/floats/floats-world" (component (type 1)))
     )
   )
-  (@producers
-    (processed-by "wit-component" "$CARGO_PKG_VERSION")
-  )
-  (export (;1;) (interface "foo:floats/wit") (type 0))
+  (export (;1;) "floats" "pkg:/floats" (type 0))
 )
\ No newline at end of file
diff --git a/crates/wit-component/tests/interfaces/floats.wit b/crates/wit-component/tests/interfaces/floats.wit
index 53618a77..8235b096 100644
--- a/crates/wit-component/tests/interfaces/floats.wit
+++ b/crates/wit-component/tests/interfaces/floats.wit
@@ -1,5 +1,3 @@
-package foo:floats
-
 interface floats {
   float32-param: func(x: float32)
   float64-param: func(x: float64)
@@ -8,5 +6,5 @@ interface floats {
 }
 
 world floats-world {
-  import floats
+  import floats: self.floats
 }
diff --git a/crates/wit-component/tests/interfaces/floats.wit.print b/crates/wit-component/tests/interfaces/floats.wit.print
index b770c37e..c3a6f338 100644
--- a/crates/wit-component/tests/interfaces/floats.wit.print
+++ b/crates/wit-component/tests/interfaces/floats.wit.print
@@ -1,5 +1,3 @@
-package foo:floats
-
 interface floats {
   float32-param: func(x: float32)
 
@@ -11,5 +9,5 @@ interface floats {
 }
 
 world floats-world {
-  import floats
+  import floats: self.floats
 }
diff --git a/crates/wit-component/tests/interfaces/foreign-use-chain.wat b/crates/wit-component/tests/interfaces/foreign-use-chain.wat
index f7827c01..5f7f6e2e 100644
--- a/crates/wit-component/tests/interfaces/foreign-use-chain.wat
+++ b/crates/wit-component/tests/interfaces/foreign-use-chain.wat
@@ -9,7 +9,7 @@
               (export (;1;) "the-type" (type (eq 0)))
             )
           )
-          (import (interface "foo:bar/the-interface") (instance (;0;) (type 0)))
+          (import "the-interface" "path:/bar/bar/the-interface" (instance (type 0)))
           (alias export 0 "the-type" (type (;1;)))
           (type (;2;)
             (instance
@@ -17,14 +17,11 @@
               (export (;1;) "bar" (type (eq 0)))
             )
           )
-          (import (interface "foo:bar/bar") (instance (;1;) (type 2)))
+          (import "bar" "path:/bar/bar/the-name" (instance (type 2)))
         )
       )
-      (export (;0;) (interface "foo:foo/foo") (component (type 0)))
+      (export (;0;) "foo" "pkg:/foo/foo" (component (type 0)))
     )
   )
-  (@producers
-    (processed-by "wit-component" "$CARGO_PKG_VERSION")
-  )
-  (export (;1;) (interface "foo:foo/wit") (type 0))
+  (export (;1;) "foo" "pkg:/foo" (type 0))
 )
\ No newline at end of file
diff --git a/crates/wit-component/tests/interfaces/foreign-use-chain/deps/bar/bar.wit b/crates/wit-component/tests/interfaces/foreign-use-chain/deps/bar/bar.wit
index 896c8d9d..bb925cfe 100644
--- a/crates/wit-component/tests/interfaces/foreign-use-chain/deps/bar/bar.wit
+++ b/crates/wit-component/tests/interfaces/foreign-use-chain/deps/bar/bar.wit
@@ -1,7 +1,5 @@
-package foo:bar
-
-interface bar {
-  use the-interface.{the-type as bar}
+default interface the-name {
+  use self.the-interface.{the-type as bar}
 }
 
 interface the-interface {
diff --git a/crates/wit-component/tests/interfaces/foreign-use-chain/deps/bar/bar.wit.print b/crates/wit-component/tests/interfaces/foreign-use-chain/deps/bar/bar.wit.print
new file mode 100644
index 00000000..b6955182
--- /dev/null
+++ b/crates/wit-component/tests/interfaces/foreign-use-chain/deps/bar/bar.wit.print
@@ -0,0 +1,9 @@
+interface the-interface {
+  type the-type = u8
+
+}
+
+interface the-name {
+  use self.the-interface.{the-type as bar}
+}
+
diff --git a/crates/wit-component/tests/interfaces/foreign-use-chain/foo.wit b/crates/wit-component/tests/interfaces/foreign-use-chain/foo.wit
index 74225fc2..439da064 100644
--- a/crates/wit-component/tests/interfaces/foreign-use-chain/foo.wit
+++ b/crates/wit-component/tests/interfaces/foreign-use-chain/foo.wit
@@ -1,5 +1,3 @@
-package foo:foo
-
-world foo {
-  import foo:bar/bar
+default world foo {
+  import bar: bar.bar
 }
diff --git a/crates/wit-component/tests/interfaces/foreign-use-chain/foo.wit.print b/crates/wit-component/tests/interfaces/foreign-use-chain/foo.wit.print
index c05357cd..f4eb14db 100644
--- a/crates/wit-component/tests/interfaces/foreign-use-chain/foo.wit.print
+++ b/crates/wit-component/tests/interfaces/foreign-use-chain/foo.wit.print
@@ -1,6 +1,4 @@
-package foo:foo
-
 world foo {
-  import foo:bar/the-interface
-  import foo:bar/bar
+  import the-interface: bar.bar.the-interface
+  import bar: bar.bar.the-name
 }
diff --git a/crates/wit-component/tests/interfaces/import-and-export.wat b/crates/wit-component/tests/interfaces/import-and-export.wat
index 3396721a..66d779b1 100644
--- a/crates/wit-component/tests/interfaces/import-and-export.wat
+++ b/crates/wit-component/tests/interfaces/import-and-export.wat
@@ -7,14 +7,14 @@
           (export (;0;) "foo" (func (type 0)))
         )
       )
-      (export (;0;) (interface "foo:foo/foo") (instance (type 0)))
+      (export (;0;) "foo" "pkg:/import-and-export/foo" (instance (type 0)))
       (type (;1;)
         (instance
           (type (;0;) (func))
           (export (;0;) "bar" (func (type 0)))
         )
       )
-      (export (;1;) (interface "foo:foo/bar") (instance (type 1)))
+      (export (;1;) "bar" "pkg:/import-and-export/bar" (instance (type 1)))
       (type (;2;)
         (component
           (type (;0;)
@@ -23,21 +23,18 @@
               (export (;0;) "foo" (func (type 0)))
             )
           )
-          (import (interface "foo:foo/foo") (instance (;0;) (type 0)))
+          (import "foo" "pkg:/import-and-export/foo" (instance (type 0)))
           (type (;1;)
             (instance
               (type (;0;) (func))
               (export (;0;) "bar" (func (type 0)))
             )
           )
-          (export (;1;) (interface "foo:foo/bar") (instance (type 1)))
+          (export (;0;) "bar" "pkg:/import-and-export/bar" (instance (type 1)))
         )
       )
-      (export (;0;) (interface "foo:foo/import-and-export") (component (type 2)))
+      (export (;0;) "import-and-export" "pkg:/import-and-export/import-and-export" (component (type 2)))
     )
   )
-  (@producers
-    (processed-by "wit-component" "$CARGO_PKG_VERSION")
-  )
-  (export (;1;) (interface "foo:foo/wit") (type 0))
+  (export (;1;) "import-and-export" "pkg:/import-and-export" (type 0))
 )
\ No newline at end of file
diff --git a/crates/wit-component/tests/interfaces/import-and-export.wit b/crates/wit-component/tests/interfaces/import-and-export.wit
index 3aabe670..a6f02831 100644
--- a/crates/wit-component/tests/interfaces/import-and-export.wit
+++ b/crates/wit-component/tests/interfaces/import-and-export.wit
@@ -1,5 +1,3 @@
-package foo:foo
-
 interface foo {
   foo: func()
 }
@@ -9,6 +7,6 @@ interface bar {
 }
 
 world import-and-export {
-  import foo
-  export bar
+  import foo: self.foo
+  export bar: self.bar
 }
diff --git a/crates/wit-component/tests/interfaces/import-and-export.wit.print b/crates/wit-component/tests/interfaces/import-and-export.wit.print
index 4dbc26b8..a6f02831 100644
--- a/crates/wit-component/tests/interfaces/import-and-export.wit.print
+++ b/crates/wit-component/tests/interfaces/import-and-export.wit.print
@@ -1,5 +1,3 @@
-package foo:foo
-
 interface foo {
   foo: func()
 }
@@ -9,7 +7,6 @@ interface bar {
 }
 
 world import-and-export {
-  import foo
-
-  export bar
+  import foo: self.foo
+  export bar: self.bar
 }
diff --git a/crates/wit-component/tests/interfaces/integers.wat b/crates/wit-component/tests/interfaces/integers.wat
index 51d4a91b..63eda7d6 100644
--- a/crates/wit-component/tests/interfaces/integers.wat
+++ b/crates/wit-component/tests/interfaces/integers.wat
@@ -44,7 +44,7 @@
           (export (;18;) "multi-ret" (func (type 19)))
         )
       )
-      (export (;0;) (interface "foo:foo/integers") (instance (type 0)))
+      (export (;0;) "integers" "pkg:/integers/integers" (instance (type 0)))
       (type (;1;)
         (component
           (type (;0;)
@@ -90,14 +90,11 @@
               (export (;18;) "multi-ret" (func (type 19)))
             )
           )
-          (import (interface "foo:foo/integers") (instance (;0;) (type 0)))
+          (import "integers" "pkg:/integers/integers" (instance (type 0)))
         )
       )
-      (export (;0;) (interface "foo:foo/integers-world") (component (type 1)))
+      (export (;0;) "integers-world" "pkg:/integers/integers-world" (component (type 1)))
     )
   )
-  (@producers
-    (processed-by "wit-component" "$CARGO_PKG_VERSION")
-  )
-  (export (;1;) (interface "foo:foo/wit") (type 0))
+  (export (;1;) "integers" "pkg:/integers" (type 0))
 )
\ No newline at end of file
diff --git a/crates/wit-component/tests/interfaces/integers.wit b/crates/wit-component/tests/interfaces/integers.wit
index 47b04b7d..ef67ac4a 100644
--- a/crates/wit-component/tests/interfaces/integers.wit
+++ b/crates/wit-component/tests/interfaces/integers.wit
@@ -1,5 +1,3 @@
-package foo:foo
-
 interface integers {
   a1: func(x: u8)
   a2: func(x: s8)
@@ -23,5 +21,5 @@ interface integers {
 }
 
 world integers-world {
-  import integers
+  import integers: self.integers
 }
diff --git a/crates/wit-component/tests/interfaces/integers.wit.print b/crates/wit-component/tests/interfaces/integers.wit.print
index d529056c..d8d88ea2 100644
--- a/crates/wit-component/tests/interfaces/integers.wit.print
+++ b/crates/wit-component/tests/interfaces/integers.wit.print
@@ -1,5 +1,3 @@
-package foo:foo
-
 interface integers {
   a1: func(x: u8)
 
@@ -41,5 +39,5 @@ interface integers {
 }
 
 world integers-world {
-  import integers
+  import integers: self.integers
 }
diff --git a/crates/wit-component/tests/interfaces/lists.wat b/crates/wit-component/tests/interfaces/lists.wat
index 09d696f7..342b95e0 100644
--- a/crates/wit-component/tests/interfaces/lists.wat
+++ b/crates/wit-component/tests/interfaces/lists.wat
@@ -3,20 +3,20 @@
     (component
       (type (;0;)
         (instance
-          (type (;0;) (list u8))
-          (type (;1;) (record (field "a1" u32) (field "a2" u64) (field "a3" s32) (field "a4" s64) (field "b" string) (field "c" 0)))
-          (export (;2;) "other-record" (type (eq 1)))
-          (type (;3;) (record (field "x" string) (field "y" 2) (field "c1" u32) (field "c2" u64) (field "c3" s32) (field "c4" s64)))
-          (export (;4;) "some-record" (type (eq 3)))
-          (type (;5;) (variant (case "a") (case "b" u32) (case "c" string)))
-          (export (;6;) "other-variant" (type (eq 5)))
-          (type (;7;) (list 6))
-          (type (;8;) (variant (case "a" string) (case "b") (case "c" u32) (case "d" 7)))
-          (export (;9;) "some-variant" (type (eq 8)))
+          (type (;0;) (variant (case "a") (case "b" u32) (case "c" string)))
+          (export (;1;) "other-variant" (type (eq 0)))
+          (type (;2;) (list 1))
+          (type (;3;) (variant (case "a" string) (case "b") (case "c" u32) (case "d" 2)))
+          (export (;4;) "some-variant" (type (eq 3)))
+          (type (;5;) (list u8))
+          (type (;6;) (record (field "a1" u32) (field "a2" u64) (field "a3" s32) (field "a4" s64) (field "b" string) (field "c" 5)))
+          (export (;7;) "other-record" (type (eq 6)))
+          (type (;8;) (record (field "x" string) (field "y" 7) (field "c1" u32) (field "c2" u64) (field "c3" s32) (field "c4" s64)))
+          (export (;9;) "some-record" (type (eq 8)))
           (type (;10;) (tuple string u8 s8 u16 s16 u32 s32 u64 s64 float32 float64 char))
           (type (;11;) (list 10))
           (export (;12;) "load-store-all-sizes" (type (eq 11)))
-          (type (;13;) (func (param "x" 0)))
+          (type (;13;) (func (param "x" 5)))
           (export (;0;) "list-u8-param" (func (type 13)))
           (type (;14;) (list u16))
           (type (;15;) (func (param "x" 14)))
@@ -45,7 +45,7 @@
           (type (;30;) (list float64))
           (type (;31;) (func (param "x" 30)))
           (export (;9;) "list-float64-param" (func (type 31)))
-          (type (;32;) (func (result 0)))
+          (type (;32;) (func (result 5)))
           (export (;10;) "list-u8-ret" (func (type 32)))
           (type (;33;) (func (result 14)))
           (export (;11;) "list-u16-ret" (func (type 33)))
@@ -84,36 +84,36 @@
           (export (;23;) "tuple-string-list" (func (type 54)))
           (type (;55;) (func (param "x" 47) (result 47)))
           (export (;24;) "string-list" (func (type 55)))
-          (type (;56;) (list 4))
-          (type (;57;) (list 2))
+          (type (;56;) (list 9))
+          (type (;57;) (list 7))
           (type (;58;) (func (param "x" 56) (result 57)))
           (export (;25;) "record-list" (func (type 58)))
-          (type (;59;) (list 9))
-          (type (;60;) (func (param "x" 59) (result 7)))
+          (type (;59;) (list 4))
+          (type (;60;) (func (param "x" 59) (result 2)))
           (export (;26;) "variant-list" (func (type 60)))
           (type (;61;) (func (param "a" 12) (result 12)))
           (export (;27;) "load-store-everything" (func (type 61)))
         )
       )
-      (export (;0;) (interface "foo:foo/lists") (instance (type 0)))
+      (export (;0;) "lists" "pkg:/lists/lists" (instance (type 0)))
       (type (;1;)
         (component
           (type (;0;)
             (instance
-              (type (;0;) (list u8))
-              (type (;1;) (record (field "a1" u32) (field "a2" u64) (field "a3" s32) (field "a4" s64) (field "b" string) (field "c" 0)))
-              (export (;2;) "other-record" (type (eq 1)))
-              (type (;3;) (record (field "x" string) (field "y" 2) (field "c1" u32) (field "c2" u64) (field "c3" s32) (field "c4" s64)))
-              (export (;4;) "some-record" (type (eq 3)))
-              (type (;5;) (variant (case "a") (case "b" u32) (case "c" string)))
-              (export (;6;) "other-variant" (type (eq 5)))
-              (type (;7;) (list 6))
-              (type (;8;) (variant (case "a" string) (case "b") (case "c" u32) (case "d" 7)))
-              (export (;9;) "some-variant" (type (eq 8)))
+              (type (;0;) (variant (case "a") (case "b" u32) (case "c" string)))
+              (export (;1;) "other-variant" (type (eq 0)))
+              (type (;2;) (list 1))
+              (type (;3;) (variant (case "a" string) (case "b") (case "c" u32) (case "d" 2)))
+              (export (;4;) "some-variant" (type (eq 3)))
+              (type (;5;) (list u8))
+              (type (;6;) (record (field "a1" u32) (field "a2" u64) (field "a3" s32) (field "a4" s64) (field "b" string) (field "c" 5)))
+              (export (;7;) "other-record" (type (eq 6)))
+              (type (;8;) (record (field "x" string) (field "y" 7) (field "c1" u32) (field "c2" u64) (field "c3" s32) (field "c4" s64)))
+              (export (;9;) "some-record" (type (eq 8)))
               (type (;10;) (tuple string u8 s8 u16 s16 u32 s32 u64 s64 float32 float64 char))
               (type (;11;) (list 10))
               (export (;12;) "load-store-all-sizes" (type (eq 11)))
-              (type (;13;) (func (param "x" 0)))
+              (type (;13;) (func (param "x" 5)))
               (export (;0;) "list-u8-param" (func (type 13)))
               (type (;14;) (list u16))
               (type (;15;) (func (param "x" 14)))
@@ -142,7 +142,7 @@
               (type (;30;) (list float64))
               (type (;31;) (func (param "x" 30)))
               (export (;9;) "list-float64-param" (func (type 31)))
-              (type (;32;) (func (result 0)))
+              (type (;32;) (func (result 5)))
               (export (;10;) "list-u8-ret" (func (type 32)))
               (type (;33;) (func (result 14)))
               (export (;11;) "list-u16-ret" (func (type 33)))
@@ -181,25 +181,22 @@
               (export (;23;) "tuple-string-list" (func (type 54)))
               (type (;55;) (func (param "x" 47) (result 47)))
               (export (;24;) "string-list" (func (type 55)))
-              (type (;56;) (list 4))
-              (type (;57;) (list 2))
+              (type (;56;) (list 9))
+              (type (;57;) (list 7))
               (type (;58;) (func (param "x" 56) (result 57)))
               (export (;25;) "record-list" (func (type 58)))
-              (type (;59;) (list 9))
-              (type (;60;) (func (param "x" 59) (result 7)))
+              (type (;59;) (list 4))
+              (type (;60;) (func (param "x" 59) (result 2)))
               (export (;26;) "variant-list" (func (type 60)))
               (type (;61;) (func (param "a" 12) (result 12)))
               (export (;27;) "load-store-everything" (func (type 61)))
             )
           )
-          (import (interface "foo:foo/lists") (instance (;0;) (type 0)))
+          (import "lists" "pkg:/lists/lists" (instance (type 0)))
         )
       )
-      (export (;0;) (interface "foo:foo/lists-world") (component (type 1)))
+      (export (;0;) "lists-world" "pkg:/lists/lists-world" (component (type 1)))
     )
   )
-  (@producers
-    (processed-by "wit-component" "$CARGO_PKG_VERSION")
-  )
-  (export (;1;) (interface "foo:foo/wit") (type 0))
+  (export (;1;) "lists" "pkg:/lists" (type 0))
 )
\ No newline at end of file
diff --git a/crates/wit-component/tests/interfaces/lists.wit b/crates/wit-component/tests/interfaces/lists.wit
index c6dfa146..38a84eca 100644
--- a/crates/wit-component/tests/interfaces/lists.wit
+++ b/crates/wit-component/tests/interfaces/lists.wit
@@ -1,5 +1,3 @@
-package foo:foo
-
 interface lists {
   record other-record {
     a1: u32,
@@ -92,5 +90,5 @@ interface lists {
 }
 
 world lists-world {
-  import lists
+  import lists: self.lists
 }
diff --git a/crates/wit-component/tests/interfaces/lists.wit.print b/crates/wit-component/tests/interfaces/lists.wit.print
index c6dfa146..f4f3dafe 100644
--- a/crates/wit-component/tests/interfaces/lists.wit.print
+++ b/crates/wit-component/tests/interfaces/lists.wit.print
@@ -1,6 +1,17 @@
-package foo:foo
-
 interface lists {
+  variant other-variant {
+    a,
+    b(u32),
+    c(string),
+  }
+
+  variant some-variant {
+    a(string),
+    b,
+    c(u32),
+    d(list<other-variant>),
+  }
+
   record other-record {
     a1: u32,
     a2: u64,
@@ -19,19 +30,6 @@ interface lists {
     c4: s64,
   }
 
-  variant other-variant {
-    a,
-    b(u32),
-    c(string),
-  }
-
-  variant some-variant {
-    a(string),
-    b,
-    c(u32),
-    d(list<other-variant>),
-  }
-
   type load-store-all-sizes = list<tuple<string, u8, s8, u16, s16, u32, s32, u64, s64, float32, float64, char>>
 
   list-u8-param: func(x: list<u8>)
@@ -92,5 +90,5 @@ interface lists {
 }
 
 world lists-world {
-  import lists
+  import lists: self.lists
 }
diff --git a/crates/wit-component/tests/interfaces/multi-doc.wat b/crates/wit-component/tests/interfaces/multi-doc.wat
index 3d4f600f..7e47257d 100644
--- a/crates/wit-component/tests/interfaces/multi-doc.wat
+++ b/crates/wit-component/tests/interfaces/multi-doc.wat
@@ -7,7 +7,7 @@
           (export (;1;) "the-type" (type (eq 0)))
         )
       )
-      (export (;0;) (interface "foo:foo/b") (instance (type 0)))
+      (export (;0;) "b" "pkg:/b/b" (instance (type 0)))
       (alias export 0 "the-type" (type (;1;)))
       (type (;2;)
         (instance
@@ -15,25 +15,44 @@
           (export (;1;) "the-type" (type (eq 0)))
         )
       )
-      (export (;1;) (interface "foo:foo/a") (instance (type 2)))
-      (type (;3;)
+      (export (;1;) "a" "pkg:/b/a" (instance (type 2)))
+    )
+  )
+  (export (;1;) "b" "pkg:/b" (type 0))
+  (type (;2;)
+    (component
+      (type (;0;)
+        (instance
+          (type (;0;) (record))
+          (export (;1;) "the-type" (type (eq 0)))
+        )
+      )
+      (import "b2" "pkg:/b/b" (instance (type 0)))
+      (alias export 0 "the-type" (type (;1;)))
+      (type (;2;)
         (instance
           (alias outer 1 1 (type (;0;)))
           (export (;1;) "the-type" (type (eq 0)))
         )
       )
-      (export (;2;) (interface "foo:foo/b2") (instance (type 3)))
+      (import "a2" "pkg:/b/a" (instance (type 2)))
+      (alias export 1 "the-type" (type (;3;)))
       (type (;4;)
         (instance
-          (alias outer 1 1 (type (;0;)))
+          (alias outer 1 3 (type (;0;)))
+          (export (;1;) "the-type" (type (eq 0)))
+        )
+      )
+      (export (;0;) "b" "pkg:/a/b" (instance (type 4)))
+      (alias export 2 "the-type" (type (;5;)))
+      (type (;6;)
+        (instance
+          (alias outer 1 5 (type (;0;)))
           (export (;1;) "the-type" (type (eq 0)))
         )
       )
-      (export (;3;) (interface "foo:foo/a2") (instance (type 4)))
+      (export (;1;) "a" "pkg:/a/a" (instance (type 6)))
     )
   )
-  (@producers
-    (processed-by "wit-component" "$CARGO_PKG_VERSION")
-  )
-  (export (;1;) (interface "foo:foo/wit") (type 0))
+  (export (;3;) "a" "pkg:/a" (type 2))
 )
\ No newline at end of file
diff --git a/crates/wit-component/tests/interfaces/multi-doc/a.wit b/crates/wit-component/tests/interfaces/multi-doc/a.wit
index c0f959e3..71fb0ce2 100644
--- a/crates/wit-component/tests/interfaces/multi-doc/a.wit
+++ b/crates/wit-component/tests/interfaces/multi-doc/a.wit
@@ -1,9 +1,7 @@
-package foo:foo
-
-interface a {
-  use b.{the-type}
+default interface a {
+  use self.b.{the-type}
 }
 
-interface b2 {
-  use b.{the-type}
+interface b {
+  use pkg.b.{the-type}
 }
diff --git a/crates/wit-component/tests/interfaces/multi-doc/a.wit.print b/crates/wit-component/tests/interfaces/multi-doc/a.wit.print
new file mode 100644
index 00000000..c14ae39d
--- /dev/null
+++ b/crates/wit-component/tests/interfaces/multi-doc/a.wit.print
@@ -0,0 +1,8 @@
+interface b {
+  use pkg.b.a.{the-type}
+}
+
+interface a {
+  use self.b.{the-type}
+}
+
diff --git a/crates/wit-component/tests/interfaces/multi-doc/b.wit b/crates/wit-component/tests/interfaces/multi-doc/b.wit
index 94b7a5ff..da21c2e9 100644
--- a/crates/wit-component/tests/interfaces/multi-doc/b.wit
+++ b/crates/wit-component/tests/interfaces/multi-doc/b.wit
@@ -1,5 +1,5 @@
-interface a2 {
-  use b.{the-type}
+default interface a {
+  use self.b.{the-type}
 }
 
 interface b {
diff --git a/crates/wit-component/tests/interfaces/multi-doc/b.wit.print b/crates/wit-component/tests/interfaces/multi-doc/b.wit.print
new file mode 100644
index 00000000..4fa21bab
--- /dev/null
+++ b/crates/wit-component/tests/interfaces/multi-doc/b.wit.print
@@ -0,0 +1,10 @@
+interface b {
+  record the-type {
+  }
+
+}
+
+interface a {
+  use self.b.{the-type}
+}
+
diff --git a/crates/wit-component/tests/interfaces/multi-doc/foo.wit.print b/crates/wit-component/tests/interfaces/multi-doc/foo.wit.print
deleted file mode 100644
index a2b8320e..00000000
--- a/crates/wit-component/tests/interfaces/multi-doc/foo.wit.print
+++ /dev/null
@@ -1,19 +0,0 @@
-package foo:foo
-
-interface b {
-  record the-type {
-  }
-}
-
-interface a {
-  use b.{the-type}
-}
-
-interface b2 {
-  use b.{the-type}
-}
-
-interface a2 {
-  use b.{the-type}
-}
-
diff --git a/crates/wit-component/tests/interfaces/multiple-use.wat b/crates/wit-component/tests/interfaces/multiple-use.wat
index 51eca652..6dcbc441 100644
--- a/crates/wit-component/tests/interfaces/multiple-use.wat
+++ b/crates/wit-component/tests/interfaces/multiple-use.wat
@@ -4,19 +4,19 @@
       (type (;0;)
         (instance
           (type (;0;) u8)
-          (export (;1;) "t1" (type (eq 0)))
+          (export (;1;) "t2" (type (eq 0)))
           (type (;2;) u8)
-          (export (;3;) "t2" (type (eq 2)))
+          (export (;3;) "t1" (type (eq 2)))
         )
       )
-      (export (;0;) (interface "foo:multiuse/foo") (instance (type 0)))
+      (export (;0;) "foo" "pkg:/multiple-use/foo" (instance (type 0)))
       (type (;1;)
         (instance
           (type (;0;) u8)
           (export (;1;) "u" (type (eq 0)))
         )
       )
-      (export (;1;) (interface "foo:multiuse/bar") (instance (type 1)))
+      (export (;1;) "bar" "pkg:/multiple-use/bar" (instance (type 1)))
       (alias export 0 "t1" (type (;2;)))
       (alias export 1 "u" (type (;3;)))
       (alias export 0 "t2" (type (;4;)))
@@ -30,11 +30,8 @@
           (export (;5;) "t2" (type (eq 4)))
         )
       )
-      (export (;2;) (interface "foo:multiuse/baz") (instance (type 5)))
+      (export (;2;) "baz" "pkg:/multiple-use/baz" (instance (type 5)))
     )
   )
-  (@producers
-    (processed-by "wit-component" "$CARGO_PKG_VERSION")
-  )
-  (export (;1;) (interface "foo:multiuse/wit") (type 0))
+  (export (;1;) "multiple-use" "pkg:/multiple-use" (type 0))
 )
\ No newline at end of file
diff --git a/crates/wit-component/tests/interfaces/multiple-use.wit b/crates/wit-component/tests/interfaces/multiple-use.wit
index 33635dc5..89e78be9 100644
--- a/crates/wit-component/tests/interfaces/multiple-use.wit
+++ b/crates/wit-component/tests/interfaces/multiple-use.wit
@@ -1,5 +1,3 @@
-package foo:multiuse
-
 interface foo {
   type t1 = u8
   type t2 = u8
@@ -10,7 +8,7 @@ interface bar {
 }
 
 interface baz {
-  use foo.{t1}
-  use bar.{u}
-  use foo.{t2}
+  use self.foo.{t1}
+  use self.bar.{u}
+  use self.foo.{t2}
 }
diff --git a/crates/wit-component/tests/interfaces/multiple-use.wit.print b/crates/wit-component/tests/interfaces/multiple-use.wit.print
index fe3dde10..4aa8d4b0 100644
--- a/crates/wit-component/tests/interfaces/multiple-use.wit.print
+++ b/crates/wit-component/tests/interfaces/multiple-use.wit.print
@@ -1,18 +1,18 @@
-package foo:multiuse
-
 interface foo {
+  type t2 = u8
+
   type t1 = u8
 
-  type t2 = u8
 }
 
 interface bar {
   type u = u8
+
 }
 
 interface baz {
-  use foo.{t1}
-  use bar.{u}
-  use foo.{t2}
+  use self.foo.{t1}
+  use self.bar.{u}
+  use self.foo.{t2}
 }
 
diff --git a/crates/wit-component/tests/interfaces/pkg-use-chain.wat b/crates/wit-component/tests/interfaces/pkg-use-chain.wat
index 85bf6032..07999686 100644
--- a/crates/wit-component/tests/interfaces/pkg-use-chain.wat
+++ b/crates/wit-component/tests/interfaces/pkg-use-chain.wat
@@ -7,7 +7,7 @@
           (export (;1;) "a" (type (eq 0)))
         )
       )
-      (export (;0;) (interface "foo:chain/a") (instance (type 0)))
+      (export (;0;) "a" "pkg:/def/a" (instance (type 0)))
       (alias export 0 "a" (type (;1;)))
       (type (;2;)
         (instance
@@ -17,7 +17,29 @@
           (export (;3;) "name" (type (eq 2)))
         )
       )
-      (export (;1;) (interface "foo:chain/def") (instance (type 2)))
+      (export (;1;) "name" "pkg:/def/name" (instance (type 2)))
+    )
+  )
+  (export (;1;) "def" "pkg:/def" (type 0))
+  (type (;2;)
+    (component
+      (type (;0;)
+        (instance
+          (type (;0;) u8)
+          (export (;1;) "a" (type (eq 0)))
+        )
+      )
+      (import "a" "pkg:/def/a" (instance (type 0)))
+      (alias export 0 "a" (type (;1;)))
+      (type (;2;)
+        (instance
+          (alias outer 1 1 (type (;0;)))
+          (export (;1;) "a" (type (eq 0)))
+          (type (;2;) (enum "other"))
+          (export (;3;) "name" (type (eq 2)))
+        )
+      )
+      (import "name" "pkg:/def/name" (instance (type 2)))
       (alias export 1 "name" (type (;3;)))
       (type (;4;)
         (instance
@@ -25,11 +47,8 @@
           (export (;1;) "name" (type (eq 0)))
         )
       )
-      (export (;2;) (interface "foo:chain/foo") (instance (type 4)))
+      (export (;0;) "foo" "pkg:/the-use/foo" (instance (type 4)))
     )
   )
-  (@producers
-    (processed-by "wit-component" "$CARGO_PKG_VERSION")
-  )
-  (export (;1;) (interface "foo:chain/wit") (type 0))
+  (export (;3;) "the-use" "pkg:/the-use" (type 2))
 )
\ No newline at end of file
diff --git a/crates/wit-component/tests/interfaces/pkg-use-chain/chain.wit.print b/crates/wit-component/tests/interfaces/pkg-use-chain/chain.wit.print
deleted file mode 100644
index 6d3e94c9..00000000
--- a/crates/wit-component/tests/interfaces/pkg-use-chain/chain.wit.print
+++ /dev/null
@@ -1,18 +0,0 @@
-package foo:chain
-
-interface a {
-  type a = u8
-}
-
-interface def {
-  use a.{a}
-
-  enum name {
-    other,
-  }
-}
-
-interface foo {
-  use def.{name}
-}
-
diff --git a/crates/wit-component/tests/interfaces/pkg-use-chain/def.wit b/crates/wit-component/tests/interfaces/pkg-use-chain/def.wit
index f8276c38..c683bffa 100644
--- a/crates/wit-component/tests/interfaces/pkg-use-chain/def.wit
+++ b/crates/wit-component/tests/interfaces/pkg-use-chain/def.wit
@@ -1,7 +1,5 @@
-package foo:chain
-
-interface def {
-  use a.{a}
+default interface name {
+  use self.a.{a}
 
   enum name {
     other,
diff --git a/crates/wit-component/tests/interfaces/pkg-use-chain/def.wit.print b/crates/wit-component/tests/interfaces/pkg-use-chain/def.wit.print
new file mode 100644
index 00000000..8f339366
--- /dev/null
+++ b/crates/wit-component/tests/interfaces/pkg-use-chain/def.wit.print
@@ -0,0 +1,14 @@
+interface a {
+  type a = u8
+
+}
+
+interface name {
+  use self.a.{a}
+
+  enum name {
+    other,
+  }
+
+}
+
diff --git a/crates/wit-component/tests/interfaces/pkg-use-chain/the-use.wit b/crates/wit-component/tests/interfaces/pkg-use-chain/the-use.wit
index 9fb7322f..730e3168 100644
--- a/crates/wit-component/tests/interfaces/pkg-use-chain/the-use.wit
+++ b/crates/wit-component/tests/interfaces/pkg-use-chain/the-use.wit
@@ -1,5 +1,3 @@
-package foo:chain
-
 interface foo {
-  use def.{name}
+  use pkg.def.{name}
 }
diff --git a/crates/wit-component/tests/interfaces/pkg-use-chain/the-use.wit.print b/crates/wit-component/tests/interfaces/pkg-use-chain/the-use.wit.print
new file mode 100644
index 00000000..d5392e8a
--- /dev/null
+++ b/crates/wit-component/tests/interfaces/pkg-use-chain/the-use.wit.print
@@ -0,0 +1,4 @@
+interface foo {
+  use pkg.def.name.{name}
+}
+
diff --git a/crates/wit-component/tests/interfaces/pkg-use-chain2.wat b/crates/wit-component/tests/interfaces/pkg-use-chain2.wat
index fe88147d..2506fd69 100644
--- a/crates/wit-component/tests/interfaces/pkg-use-chain2.wat
+++ b/crates/wit-component/tests/interfaces/pkg-use-chain2.wat
@@ -7,7 +7,7 @@
           (export (;1;) "name" (type (eq 0)))
         )
       )
-      (export (;0;) (interface "foo:foo/other") (instance (type 0)))
+      (export (;0;) "other" "pkg:/bar/other" (instance (type 0)))
       (alias export 0 "name" (type (;1;)))
       (type (;2;)
         (instance
@@ -17,7 +17,29 @@
           (export (;3;) "name" (type (eq 2)))
         )
       )
-      (export (;1;) (interface "foo:foo/bar") (instance (type 2)))
+      (export (;1;) "d" "pkg:/bar/d" (instance (type 2)))
+    )
+  )
+  (export (;1;) "bar" "pkg:/bar" (type 0))
+  (type (;2;)
+    (component
+      (type (;0;)
+        (instance
+          (type (;0;) (record))
+          (export (;1;) "name" (type (eq 0)))
+        )
+      )
+      (import "other" "pkg:/bar/other" (instance (type 0)))
+      (alias export 0 "name" (type (;1;)))
+      (type (;2;)
+        (instance
+          (alias outer 1 1 (type (;0;)))
+          (export (;1;) "the-name" (type (eq 0)))
+          (type (;2;) (enum "a"))
+          (export (;3;) "name" (type (eq 2)))
+        )
+      )
+      (import "d" "pkg:/bar/d" (instance (type 2)))
       (alias export 1 "the-name" (type (;3;)))
       (type (;4;)
         (instance
@@ -25,11 +47,8 @@
           (export (;1;) "the-name" (type (eq 0)))
         )
       )
-      (export (;2;) (interface "foo:foo/foo") (instance (type 4)))
+      (export (;0;) "foo" "pkg:/foo/foo" (instance (type 4)))
     )
   )
-  (@producers
-    (processed-by "wit-component" "$CARGO_PKG_VERSION")
-  )
-  (export (;1;) (interface "foo:foo/wit") (type 0))
+  (export (;3;) "foo" "pkg:/foo" (type 2))
 )
\ No newline at end of file
diff --git a/crates/wit-component/tests/interfaces/pkg-use-chain2/bar.wit b/crates/wit-component/tests/interfaces/pkg-use-chain2/bar.wit
index f0588f09..9f914daa 100644
--- a/crates/wit-component/tests/interfaces/pkg-use-chain2/bar.wit
+++ b/crates/wit-component/tests/interfaces/pkg-use-chain2/bar.wit
@@ -1,5 +1,5 @@
-interface bar {
-  use other.{name as the-name}
+default interface d {
+  use self.other.{name as the-name}
 
   enum name {
     a
diff --git a/crates/wit-component/tests/interfaces/pkg-use-chain2/bar.wit.print b/crates/wit-component/tests/interfaces/pkg-use-chain2/bar.wit.print
new file mode 100644
index 00000000..39040e8e
--- /dev/null
+++ b/crates/wit-component/tests/interfaces/pkg-use-chain2/bar.wit.print
@@ -0,0 +1,15 @@
+interface other {
+  record name {
+  }
+
+}
+
+interface d {
+  use self.other.{name as the-name}
+
+  enum name {
+    a,
+  }
+
+}
+
diff --git a/crates/wit-component/tests/interfaces/pkg-use-chain2/foo.wit b/crates/wit-component/tests/interfaces/pkg-use-chain2/foo.wit
index f4903f12..6b212e19 100644
--- a/crates/wit-component/tests/interfaces/pkg-use-chain2/foo.wit
+++ b/crates/wit-component/tests/interfaces/pkg-use-chain2/foo.wit
@@ -1,5 +1,3 @@
-package foo:foo
-
 interface foo {
-  use bar.{the-name}
+  use pkg.bar.{the-name}
 }
diff --git a/crates/wit-component/tests/interfaces/pkg-use-chain2/foo.wit.print b/crates/wit-component/tests/interfaces/pkg-use-chain2/foo.wit.print
index 02a7f1a3..3ffe8d59 100644
--- a/crates/wit-component/tests/interfaces/pkg-use-chain2/foo.wit.print
+++ b/crates/wit-component/tests/interfaces/pkg-use-chain2/foo.wit.print
@@ -1,19 +1,4 @@
-package foo:foo
-
-interface other {
-  record name {
-  }
-}
-
-interface bar {
-  use other.{name as the-name}
-
-  enum name {
-    a,
-  }
-}
-
 interface foo {
-  use bar.{the-name}
+  use pkg.bar.d.{the-name}
 }
 
diff --git a/crates/wit-component/tests/interfaces/preserve-dep-type-order.wat b/crates/wit-component/tests/interfaces/preserve-dep-type-order.wat
index 0fb52911..1cf337a1 100644
--- a/crates/wit-component/tests/interfaces/preserve-dep-type-order.wat
+++ b/crates/wit-component/tests/interfaces/preserve-dep-type-order.wat
@@ -3,13 +3,13 @@
     (component
       (type (;0;)
         (instance
-          (type (;0;) (enum "b"))
-          (export (;1;) "a" (type (eq 0)))
-          (type (;2;) (record))
-          (export (;3;) "ty" (type (eq 2)))
+          (type (;0;) (record))
+          (export (;1;) "ty" (type (eq 0)))
+          (type (;2;) (enum "b"))
+          (export (;3;) "a" (type (eq 2)))
         )
       )
-      (import (interface "foo:dep/foo") (instance (;0;) (type 0)))
+      (import "foo2" "path:/dep/foo/foo" (instance (type 0)))
       (alias export 0 "ty" (type (;1;)))
       (type (;2;)
         (instance
@@ -17,25 +17,22 @@
           (export (;1;) "ty" (type (eq 0)))
         )
       )
-      (export (;1;) (interface "foo:foo/foo") (instance (type 2)))
+      (export (;0;) "foo" "pkg:/foo/foo" (instance (type 2)))
       (type (;3;)
         (component
           (type (;0;)
             (instance
-              (type (;0;) (enum "b"))
-              (export (;1;) "a" (type (eq 0)))
-              (type (;2;) (record))
-              (export (;3;) "ty" (type (eq 2)))
+              (type (;0;) (record))
+              (export (;1;) "ty" (type (eq 0)))
+              (type (;2;) (enum "b"))
+              (export (;3;) "a" (type (eq 2)))
             )
           )
-          (import (interface "foo:dep/foo") (instance (;0;) (type 0)))
+          (import "foo" "path:/dep/foo/foo" (instance (type 0)))
         )
       )
-      (export (;0;) (interface "foo:foo/bar") (component (type 3)))
+      (export (;0;) "bar" "pkg:/foo/bar" (component (type 3)))
     )
   )
-  (@producers
-    (processed-by "wit-component" "$CARGO_PKG_VERSION")
-  )
-  (export (;1;) (interface "foo:foo/wit") (type 0))
+  (export (;1;) "foo" "pkg:/foo" (type 0))
 )
\ No newline at end of file
diff --git a/crates/wit-component/tests/interfaces/preserve-dep-type-order/deps/dep/foo.wit b/crates/wit-component/tests/interfaces/preserve-dep-type-order/deps/dep/foo.wit
index 661037d4..3196821a 100644
--- a/crates/wit-component/tests/interfaces/preserve-dep-type-order/deps/dep/foo.wit
+++ b/crates/wit-component/tests/interfaces/preserve-dep-type-order/deps/dep/foo.wit
@@ -1,6 +1,4 @@
-package foo:dep
-
-interface foo {
+default interface foo {
   enum a {
     b
   }
diff --git a/crates/wit-component/tests/interfaces/preserve-dep-type-order/deps/dep/foo.wit.print b/crates/wit-component/tests/interfaces/preserve-dep-type-order/deps/dep/foo.wit.print
new file mode 100644
index 00000000..32713582
--- /dev/null
+++ b/crates/wit-component/tests/interfaces/preserve-dep-type-order/deps/dep/foo.wit.print
@@ -0,0 +1,10 @@
+interface foo {
+  record ty {
+  }
+
+  enum a {
+    b,
+  }
+
+}
+
diff --git a/crates/wit-component/tests/interfaces/preserve-dep-type-order/foo.wit b/crates/wit-component/tests/interfaces/preserve-dep-type-order/foo.wit
index eafc1919..ae08a263 100644
--- a/crates/wit-component/tests/interfaces/preserve-dep-type-order/foo.wit
+++ b/crates/wit-component/tests/interfaces/preserve-dep-type-order/foo.wit
@@ -1,9 +1,7 @@
-package foo:foo
-
 interface foo {
-  use foo:dep/foo.{ty}
+  use dep.foo.{ty}
 }
 
 world bar {
-  import foo:dep/foo
+  import foo: dep.foo
 }
diff --git a/crates/wit-component/tests/interfaces/preserve-dep-type-order/foo.wit.print b/crates/wit-component/tests/interfaces/preserve-dep-type-order/foo.wit.print
index eafc1919..f9c2f983 100644
--- a/crates/wit-component/tests/interfaces/preserve-dep-type-order/foo.wit.print
+++ b/crates/wit-component/tests/interfaces/preserve-dep-type-order/foo.wit.print
@@ -1,9 +1,7 @@
-package foo:foo
-
 interface foo {
-  use foo:dep/foo.{ty}
+  use dep.foo.foo.{ty}
 }
 
 world bar {
-  import foo:dep/foo
+  import foo: dep.foo.foo
 }
diff --git a/crates/wit-component/tests/interfaces/preserve-foreign-reexport.wat b/crates/wit-component/tests/interfaces/preserve-foreign-reexport.wat
index 6c4760c0..30f021ad 100644
--- a/crates/wit-component/tests/interfaces/preserve-foreign-reexport.wat
+++ b/crates/wit-component/tests/interfaces/preserve-foreign-reexport.wat
@@ -10,14 +10,11 @@
               (export (;2;) "bar" (type (eq 1)))
             )
           )
-          (export (;0;) (interface "foo:my-dep/my-interface") (instance (type 0)))
+          (export (;0;) "foo" "path:/my-dep/my-doc/my-interface" (instance (type 0)))
         )
       )
-      (export (;0;) (interface "foo:foo/foo") (component (type 0)))
+      (export (;0;) "foo" "pkg:/foo/foo" (component (type 0)))
     )
   )
-  (@producers
-    (processed-by "wit-component" "$CARGO_PKG_VERSION")
-  )
-  (export (;1;) (interface "foo:foo/wit") (type 0))
+  (export (;1;) "foo" "pkg:/foo" (type 0))
 )
\ No newline at end of file
diff --git a/crates/wit-component/tests/interfaces/preserve-foreign-reexport/deps/my-dep/my-doc.wit b/crates/wit-component/tests/interfaces/preserve-foreign-reexport/deps/my-dep/my-doc.wit
index 6feaeb11..2eeed9cd 100644
--- a/crates/wit-component/tests/interfaces/preserve-foreign-reexport/deps/my-dep/my-doc.wit
+++ b/crates/wit-component/tests/interfaces/preserve-foreign-reexport/deps/my-dep/my-doc.wit
@@ -1,6 +1,4 @@
-package foo:my-dep
-
-interface my-interface {
+default interface my-interface {
   record foo {}
   type bar = foo
 }
diff --git a/crates/wit-component/tests/interfaces/preserve-foreign-reexport/deps/my-dep/my-doc.wit.print b/crates/wit-component/tests/interfaces/preserve-foreign-reexport/deps/my-dep/my-doc.wit.print
new file mode 100644
index 00000000..0c86fc6c
--- /dev/null
+++ b/crates/wit-component/tests/interfaces/preserve-foreign-reexport/deps/my-dep/my-doc.wit.print
@@ -0,0 +1,8 @@
+interface my-interface {
+  record foo {
+  }
+
+  type bar = foo
+
+}
+
diff --git a/crates/wit-component/tests/interfaces/preserve-foreign-reexport/foo.wit b/crates/wit-component/tests/interfaces/preserve-foreign-reexport/foo.wit
index ae83137a..ec472fe2 100644
--- a/crates/wit-component/tests/interfaces/preserve-foreign-reexport/foo.wit
+++ b/crates/wit-component/tests/interfaces/preserve-foreign-reexport/foo.wit
@@ -1,5 +1,3 @@
-package foo:foo
-
 world foo {
-  export foo:my-dep/my-interface
+  export foo: my-dep.my-doc
 }
diff --git a/crates/wit-component/tests/interfaces/preserve-foreign-reexport/foo.wit.print b/crates/wit-component/tests/interfaces/preserve-foreign-reexport/foo.wit.print
index ae83137a..f9406dd1 100644
--- a/crates/wit-component/tests/interfaces/preserve-foreign-reexport/foo.wit.print
+++ b/crates/wit-component/tests/interfaces/preserve-foreign-reexport/foo.wit.print
@@ -1,5 +1,3 @@
-package foo:foo
-
 world foo {
-  export foo:my-dep/my-interface
+  export foo: my-dep.my-doc.my-interface
 }
diff --git a/crates/wit-component/tests/interfaces/print-keyword.wat b/crates/wit-component/tests/interfaces/print-keyword.wat
index 796d5ec6..8f526800 100644
--- a/crates/wit-component/tests/interfaces/print-keyword.wat
+++ b/crates/wit-component/tests/interfaces/print-keyword.wat
@@ -10,11 +10,8 @@
           (export (;4;) "record" (type (eq 3)))
         )
       )
-      (export (;0;) (interface "foo:foo/interface") (instance (type 0)))
+      (export (;0;) "interface" "pkg:/print-keyword/interface" (instance (type 0)))
     )
   )
-  (@producers
-    (processed-by "wit-component" "$CARGO_PKG_VERSION")
-  )
-  (export (;1;) (interface "foo:foo/wit") (type 0))
+  (export (;1;) "print-keyword" "pkg:/print-keyword" (type 0))
 )
\ No newline at end of file
diff --git a/crates/wit-component/tests/interfaces/print-keyword.wit b/crates/wit-component/tests/interfaces/print-keyword.wit
index 7cbe9083..9d938a98 100644
--- a/crates/wit-component/tests/interfaces/print-keyword.wit
+++ b/crates/wit-component/tests/interfaces/print-keyword.wit
@@ -1,5 +1,3 @@
-package foo:foo
-
 interface %interface {
   type %type = u32
   type %world = %type
diff --git a/crates/wit-component/tests/interfaces/print-keyword.wit.print b/crates/wit-component/tests/interfaces/print-keyword.wit.print
index 4488715b..7d930bdc 100644
--- a/crates/wit-component/tests/interfaces/print-keyword.wit.print
+++ b/crates/wit-component/tests/interfaces/print-keyword.wit.print
@@ -1,5 +1,3 @@
-package foo:foo
-
 interface %interface {
   type %type = u32
 
@@ -8,5 +6,6 @@ interface %interface {
   record %record {
     %variant: %world,
   }
+
 }
 
diff --git a/crates/wit-component/tests/interfaces/records.wat b/crates/wit-component/tests/interfaces/records.wat
index 5cf3db1c..be0efa18 100644
--- a/crates/wit-component/tests/interfaces/records.wat
+++ b/crates/wit-component/tests/interfaces/records.wat
@@ -3,133 +3,130 @@
     (component
       (type (;0;)
         (instance
-          (type (;0;) (record))
-          (export (;1;) "empty" (type (eq 0)))
-          (type (;2;) (record (field "a" u32) (field "b" u32)))
-          (export (;3;) "scalars" (type (eq 2)))
-          (type (;4;) (flags "a" "b" "c" "d" "e" "f" "g" "h" "i"))
-          (export (;5;) "really-flags" (type (eq 4)))
-          (type (;6;) (record (field "a" 3) (field "b" u32) (field "c" 1) (field "d" string) (field "e" 5)))
-          (export (;7;) "aggregates" (type (eq 6)))
-          (type (;8;) s32)
-          (export (;9;) "int-typedef" (type (eq 8)))
-          (type (;10;) (tuple 9))
-          (export (;11;) "tuple-typedef2" (type (eq 10)))
+          (type (;0;) (record (field "a" u32) (field "b" u32)))
+          (export (;1;) "scalars" (type (eq 0)))
+          (type (;2;) (flags "a" "b" "c" "d" "e" "f" "g" "h" "i"))
+          (export (;3;) "really-flags" (type (eq 2)))
+          (type (;4;) s32)
+          (export (;5;) "int-typedef" (type (eq 4)))
+          (type (;6;) (tuple 5))
+          (export (;7;) "tuple-typedef2" (type (eq 6)))
+          (type (;8;) (record))
+          (export (;9;) "empty" (type (eq 8)))
+          (type (;10;) (record (field "a" 1) (field "b" u32) (field "c" 9) (field "d" string) (field "e" 3)))
+          (export (;11;) "aggregates" (type (eq 10)))
           (type (;12;) (tuple char u32))
           (type (;13;) (func (param "x" 12)))
           (export (;0;) "tuple-arg" (func (type 13)))
           (type (;14;) (func (result 12)))
           (export (;1;) "tuple-result" (func (type 14)))
-          (type (;15;) (func (param "x" 1)))
+          (type (;15;) (func (param "x" 9)))
           (export (;2;) "empty-arg" (func (type 15)))
-          (type (;16;) (func (result 1)))
+          (type (;16;) (func (result 9)))
           (export (;3;) "empty-result" (func (type 16)))
-          (type (;17;) (func (param "x" 3)))
+          (type (;17;) (func (param "x" 1)))
           (export (;4;) "scalar-arg" (func (type 17)))
-          (type (;18;) (func (result 3)))
+          (type (;18;) (func (result 1)))
           (export (;5;) "scalar-result" (func (type 18)))
-          (type (;19;) (func (param "x" 5)))
+          (type (;19;) (func (param "x" 3)))
           (export (;6;) "flags-arg" (func (type 19)))
-          (type (;20;) (func (result 5)))
+          (type (;20;) (func (result 3)))
           (export (;7;) "flags-result" (func (type 20)))
-          (type (;21;) (func (param "x" 7)))
+          (type (;21;) (func (param "x" 11)))
           (export (;8;) "aggregate-arg" (func (type 21)))
-          (type (;22;) (func (result 7)))
+          (type (;22;) (func (result 11)))
           (export (;9;) "aggregate-result" (func (type 22)))
-          (type (;23;) (func (param "e" 11) (result s32)))
+          (type (;23;) (func (param "e" 7) (result s32)))
           (export (;10;) "typedef-inout" (func (type 23)))
         )
       )
-      (export (;0;) (interface "foo:records/records") (instance (type 0)))
+      (export (;0;) "records" "pkg:/records/records" (instance (type 0)))
       (type (;1;)
         (component
           (type (;0;)
             (instance
-              (type (;0;) (record))
-              (export (;1;) "empty" (type (eq 0)))
-              (type (;2;) (record (field "a" u32) (field "b" u32)))
-              (export (;3;) "scalars" (type (eq 2)))
-              (type (;4;) (flags "a" "b" "c" "d" "e" "f" "g" "h" "i"))
-              (export (;5;) "really-flags" (type (eq 4)))
-              (type (;6;) (record (field "a" 3) (field "b" u32) (field "c" 1) (field "d" string) (field "e" 5)))
-              (export (;7;) "aggregates" (type (eq 6)))
-              (type (;8;) s32)
-              (export (;9;) "int-typedef" (type (eq 8)))
-              (type (;10;) (tuple 9))
-              (export (;11;) "tuple-typedef2" (type (eq 10)))
+              (type (;0;) (record (field "a" u32) (field "b" u32)))
+              (export (;1;) "scalars" (type (eq 0)))
+              (type (;2;) (flags "a" "b" "c" "d" "e" "f" "g" "h" "i"))
+              (export (;3;) "really-flags" (type (eq 2)))
+              (type (;4;) s32)
+              (export (;5;) "int-typedef" (type (eq 4)))
+              (type (;6;) (tuple 5))
+              (export (;7;) "tuple-typedef2" (type (eq 6)))
+              (type (;8;) (record))
+              (export (;9;) "empty" (type (eq 8)))
+              (type (;10;) (record (field "a" 1) (field "b" u32) (field "c" 9) (field "d" string) (field "e" 3)))
+              (export (;11;) "aggregates" (type (eq 10)))
               (type (;12;) (tuple char u32))
               (type (;13;) (func (param "x" 12)))
               (export (;0;) "tuple-arg" (func (type 13)))
               (type (;14;) (func (result 12)))
               (export (;1;) "tuple-result" (func (type 14)))
-              (type (;15;) (func (param "x" 1)))
+              (type (;15;) (func (param "x" 9)))
               (export (;2;) "empty-arg" (func (type 15)))
-              (type (;16;) (func (result 1)))
+              (type (;16;) (func (result 9)))
               (export (;3;) "empty-result" (func (type 16)))
-              (type (;17;) (func (param "x" 3)))
+              (type (;17;) (func (param "x" 1)))
               (export (;4;) "scalar-arg" (func (type 17)))
-              (type (;18;) (func (result 3)))
+              (type (;18;) (func (result 1)))
               (export (;5;) "scalar-result" (func (type 18)))
-              (type (;19;) (func (param "x" 5)))
+              (type (;19;) (func (param "x" 3)))
               (export (;6;) "flags-arg" (func (type 19)))
-              (type (;20;) (func (result 5)))
+              (type (;20;) (func (result 3)))
               (export (;7;) "flags-result" (func (type 20)))
-              (type (;21;) (func (param "x" 7)))
+              (type (;21;) (func (param "x" 11)))
               (export (;8;) "aggregate-arg" (func (type 21)))
-              (type (;22;) (func (result 7)))
+              (type (;22;) (func (result 11)))
               (export (;9;) "aggregate-result" (func (type 22)))
-              (type (;23;) (func (param "e" 11) (result s32)))
+              (type (;23;) (func (param "e" 7) (result s32)))
               (export (;10;) "typedef-inout" (func (type 23)))
             )
           )
-          (import (interface "foo:records/records") (instance (;0;) (type 0)))
+          (import "records" "pkg:/records/records" (instance (type 0)))
           (type (;1;)
             (instance
-              (type (;0;) (record))
-              (export (;1;) "empty" (type (eq 0)))
-              (type (;2;) (record (field "a" u32) (field "b" u32)))
-              (export (;3;) "scalars" (type (eq 2)))
-              (type (;4;) (flags "a" "b" "c" "d" "e" "f" "g" "h" "i"))
-              (export (;5;) "really-flags" (type (eq 4)))
-              (type (;6;) (record (field "a" 3) (field "b" u32) (field "c" 1) (field "d" string) (field "e" 5)))
-              (export (;7;) "aggregates" (type (eq 6)))
-              (type (;8;) s32)
-              (export (;9;) "int-typedef" (type (eq 8)))
-              (type (;10;) (tuple 9))
-              (export (;11;) "tuple-typedef2" (type (eq 10)))
+              (type (;0;) (record (field "a" u32) (field "b" u32)))
+              (export (;1;) "scalars" (type (eq 0)))
+              (type (;2;) (flags "a" "b" "c" "d" "e" "f" "g" "h" "i"))
+              (export (;3;) "really-flags" (type (eq 2)))
+              (type (;4;) s32)
+              (export (;5;) "int-typedef" (type (eq 4)))
+              (type (;6;) (tuple 5))
+              (export (;7;) "tuple-typedef2" (type (eq 6)))
+              (type (;8;) (record))
+              (export (;9;) "empty" (type (eq 8)))
+              (type (;10;) (record (field "a" 1) (field "b" u32) (field "c" 9) (field "d" string) (field "e" 3)))
+              (export (;11;) "aggregates" (type (eq 10)))
               (type (;12;) (tuple char u32))
               (type (;13;) (func (param "x" 12)))
               (export (;0;) "tuple-arg" (func (type 13)))
               (type (;14;) (func (result 12)))
               (export (;1;) "tuple-result" (func (type 14)))
-              (type (;15;) (func (param "x" 1)))
+              (type (;15;) (func (param "x" 9)))
               (export (;2;) "empty-arg" (func (type 15)))
-              (type (;16;) (func (result 1)))
+              (type (;16;) (func (result 9)))
               (export (;3;) "empty-result" (func (type 16)))
-              (type (;17;) (func (param "x" 3)))
+              (type (;17;) (func (param "x" 1)))
               (export (;4;) "scalar-arg" (func (type 17)))
-              (type (;18;) (func (result 3)))
+              (type (;18;) (func (result 1)))
               (export (;5;) "scalar-result" (func (type 18)))
-              (type (;19;) (func (param "x" 5)))
+              (type (;19;) (func (param "x" 3)))
               (export (;6;) "flags-arg" (func (type 19)))
-              (type (;20;) (func (result 5)))
+              (type (;20;) (func (result 3)))
               (export (;7;) "flags-result" (func (type 20)))
-              (type (;21;) (func (param "x" 7)))
+              (type (;21;) (func (param "x" 11)))
               (export (;8;) "aggregate-arg" (func (type 21)))
-              (type (;22;) (func (result 7)))
+              (type (;22;) (func (result 11)))
               (export (;9;) "aggregate-result" (func (type 22)))
-              (type (;23;) (func (param "e" 11) (result s32)))
+              (type (;23;) (func (param "e" 7) (result s32)))
               (export (;10;) "typedef-inout" (func (type 23)))
             )
           )
-          (export (;1;) (interface "foo:records/records") (instance (type 1)))
+          (export (;0;) "records2" "pkg:/records/records" (instance (type 1)))
         )
       )
-      (export (;0;) (interface "foo:records/records-world") (component (type 1)))
+      (export (;0;) "records-world" "pkg:/records/records-world" (component (type 1)))
     )
   )
-  (@producers
-    (processed-by "wit-component" "$CARGO_PKG_VERSION")
-  )
-  (export (;1;) (interface "foo:records/wit") (type 0))
+  (export (;1;) "records" "pkg:/records" (type 0))
 )
\ No newline at end of file
diff --git a/crates/wit-component/tests/interfaces/records.wit b/crates/wit-component/tests/interfaces/records.wit
index 65a0378f..a61e43f7 100644
--- a/crates/wit-component/tests/interfaces/records.wit
+++ b/crates/wit-component/tests/interfaces/records.wit
@@ -1,5 +1,3 @@
-package foo:records
-
 interface records {
   record empty {
   }
@@ -57,6 +55,6 @@ interface records {
 }
 
 world records-world {
-  import records
-  export records
+  import records: self.records
+  export records2: self.records
 }
diff --git a/crates/wit-component/tests/interfaces/records.wit.print b/crates/wit-component/tests/interfaces/records.wit.print
index 938a4902..542db700 100644
--- a/crates/wit-component/tests/interfaces/records.wit.print
+++ b/crates/wit-component/tests/interfaces/records.wit.print
@@ -1,9 +1,4 @@
-package foo:records
-
 interface records {
-  record empty {
-  }
-
   record scalars {
     a: u32,
     b: u32,
@@ -21,6 +16,13 @@ interface records {
     i,
   }
 
+  type int-typedef = s32
+
+  type tuple-typedef2 = tuple<int-typedef>
+
+  record empty {
+  }
+
   record aggregates {
     a: scalars,
     b: u32,
@@ -29,10 +31,6 @@ interface records {
     e: really-flags,
   }
 
-  type int-typedef = s32
-
-  type tuple-typedef2 = tuple<int-typedef>
-
   tuple-arg: func(x: tuple<char, u32>)
 
   tuple-result: func() -> tuple<char, u32>
@@ -57,7 +55,6 @@ interface records {
 }
 
 world records-world {
-  import records
-
-  export records
+  import records: self.records
+  export records2: self.records
 }
diff --git a/crates/wit-component/tests/interfaces/reference-out-of-order.wat b/crates/wit-component/tests/interfaces/reference-out-of-order.wat
index cf0458a5..207eef29 100644
--- a/crates/wit-component/tests/interfaces/reference-out-of-order.wat
+++ b/crates/wit-component/tests/interfaces/reference-out-of-order.wat
@@ -3,55 +3,52 @@
     (component
       (type (;0;)
         (instance
-          (type (;0;) (record (field "s" string)))
-          (export (;1;) "r" (type (eq 0)))
+          (type (;0;) (variant (case "s" u32)))
+          (export (;1;) "v-no-string" (type (eq 0)))
           (type (;2;) (variant (case "s" string)))
           (export (;3;) "v" (type (eq 2)))
           (type (;4;) (record (field "s" u32)))
           (export (;5;) "r-no-string" (type (eq 4)))
-          (type (;6;) (variant (case "s" u32)))
-          (export (;7;) "v-no-string" (type (eq 6)))
-          (type (;8;) (func (param "x" 1)))
+          (type (;6;) (record (field "s" string)))
+          (export (;7;) "r" (type (eq 6)))
+          (type (;8;) (func (param "x" 7)))
           (export (;0;) "a" (func (type 8)))
           (type (;9;) (func (param "x" 3)))
           (export (;1;) "b" (func (type 9)))
           (type (;10;) (func (param "x" 5)))
           (export (;2;) "c" (func (type 10)))
-          (type (;11;) (func (param "x" 7)))
+          (type (;11;) (func (param "x" 1)))
           (export (;3;) "d" (func (type 11)))
         )
       )
-      (export (;0;) (interface "foo:foo/foo") (instance (type 0)))
+      (export (;0;) "foo" "pkg:/reference-out-of-order/foo" (instance (type 0)))
       (type (;1;)
         (component
           (type (;0;)
             (instance
-              (type (;0;) (record (field "s" string)))
-              (export (;1;) "r" (type (eq 0)))
+              (type (;0;) (variant (case "s" u32)))
+              (export (;1;) "v-no-string" (type (eq 0)))
               (type (;2;) (variant (case "s" string)))
               (export (;3;) "v" (type (eq 2)))
               (type (;4;) (record (field "s" u32)))
               (export (;5;) "r-no-string" (type (eq 4)))
-              (type (;6;) (variant (case "s" u32)))
-              (export (;7;) "v-no-string" (type (eq 6)))
-              (type (;8;) (func (param "x" 1)))
+              (type (;6;) (record (field "s" string)))
+              (export (;7;) "r" (type (eq 6)))
+              (type (;8;) (func (param "x" 7)))
               (export (;0;) "a" (func (type 8)))
               (type (;9;) (func (param "x" 3)))
               (export (;1;) "b" (func (type 9)))
               (type (;10;) (func (param "x" 5)))
               (export (;2;) "c" (func (type 10)))
-              (type (;11;) (func (param "x" 7)))
+              (type (;11;) (func (param "x" 1)))
               (export (;3;) "d" (func (type 11)))
             )
           )
-          (import (interface "foo:foo/foo") (instance (;0;) (type 0)))
+          (import "foo" "pkg:/reference-out-of-order/foo" (instance (type 0)))
         )
       )
-      (export (;0;) (interface "foo:foo/foo-world") (component (type 1)))
+      (export (;0;) "foo-world" "pkg:/reference-out-of-order/foo-world" (component (type 1)))
     )
   )
-  (@producers
-    (processed-by "wit-component" "$CARGO_PKG_VERSION")
-  )
-  (export (;1;) (interface "foo:foo/wit") (type 0))
+  (export (;1;) "reference-out-of-order" "pkg:/reference-out-of-order" (type 0))
 )
\ No newline at end of file
diff --git a/crates/wit-component/tests/interfaces/reference-out-of-order.wit b/crates/wit-component/tests/interfaces/reference-out-of-order.wit
index 51f181a7..82a7aaf9 100644
--- a/crates/wit-component/tests/interfaces/reference-out-of-order.wit
+++ b/crates/wit-component/tests/interfaces/reference-out-of-order.wit
@@ -1,5 +1,3 @@
-package foo:foo
-
 interface foo {
   a: func(x: r)
   b: func(x: v)
@@ -24,5 +22,5 @@ interface foo {
 }
 
 world foo-world {
-  import foo
+  import foo: self.foo
 }
diff --git a/crates/wit-component/tests/interfaces/reference-out-of-order.wit.print b/crates/wit-component/tests/interfaces/reference-out-of-order.wit.print
index dd2f9390..f37173f2 100644
--- a/crates/wit-component/tests/interfaces/reference-out-of-order.wit.print
+++ b/crates/wit-component/tests/interfaces/reference-out-of-order.wit.print
@@ -1,8 +1,6 @@
-package foo:foo
-
 interface foo {
-  record r {
-    s: string,
+  variant v-no-string {
+    s(u32),
   }
 
   variant v {
@@ -13,8 +11,8 @@ interface foo {
     s: u32,
   }
 
-  variant v-no-string {
-    s(u32),
+  record r {
+    s: string,
   }
 
   a: func(x: r)
@@ -27,5 +25,5 @@ interface foo {
 }
 
 world foo-world {
-  import foo
+  import foo: self.foo
 }
diff --git a/crates/wit-component/tests/interfaces/resources.wat b/crates/wit-component/tests/interfaces/resources.wat
deleted file mode 100644
index 3a1f8642..00000000
--- a/crates/wit-component/tests/interfaces/resources.wat
+++ /dev/null
@@ -1,152 +0,0 @@
-(component
-  (type (;0;)
-    (component
-      (type (;0;)
-        (instance
-          (export (;0;) "bar" (type (sub resource)))
-          (export (;1;) "t" (type (eq 0)))
-          (type (;2;) (own 0))
-          (export (;3;) "t2" (type (eq 2)))
-          (type (;4;) (own 0))
-          (type (;5;) (func (result 4)))
-          (export (;0;) "[constructor]bar" (func (type 5)))
-          (type (;6;) (func))
-          (export (;1;) "[static]bar.a" (func (type 6)))
-          (type (;7;) (borrow 0))
-          (type (;8;) (func (param "self" 7)))
-          (export (;2;) "[method]bar.b" (func (type 8)))
-          (type (;9;) (func (param "x" 4) (result 4)))
-          (export (;3;) "a" (func (type 9)))
-        )
-      )
-      (export (;0;) (interface "foo:bar/foo") (instance (type 0)))
-      (alias export 0 "bar" (type (;1;)))
-      (alias export 0 "t" (type (;2;)))
-      (type (;3;)
-        (instance
-          (alias outer 1 1 (type (;0;)))
-          (export (;1;) "bar" (type (eq 0)))
-          (alias outer 1 2 (type (;2;)))
-          (export (;3;) "t" (type (eq 2)))
-          (type (;4;) (own 1))
-          (type (;5;) (func (param "x" 4) (result 4)))
-          (export (;0;) "a" (func (type 5)))
-          (type (;6;) (own 3))
-          (type (;7;) (func (result 6)))
-          (export (;1;) "b" (func (type 7)))
-        )
-      )
-      (export (;1;) (interface "foo:bar/baz") (instance (type 3)))
-      (type (;4;)
-        (instance
-          (export (;0;) "a" (type (sub resource)))
-          (type (;1;) (own 0))
-          (type (;2;) (func (param "a1" 1) (param "a2" 1) (result 1)))
-          (export (;0;) "b" (func (type 2)))
-          (type (;3;) (list 1))
-          (type (;4;) (func (result 3)))
-          (export (;1;) "c" (func (type 4)))
-        )
-      )
-      (export (;2;) (interface "foo:bar/implicit-own-handles") (instance (type 4)))
-      (type (;5;)
-        (instance
-          (export (;0;) "a" (type (sub resource)))
-          (export (;1;) "b" (type (sub resource)))
-          (export (;2;) "c" (type (sub resource)))
-          (type (;3;) (own 0))
-          (type (;4;) (list 3))
-          (type (;5;) (func (param "a" 4) (result 3)))
-          (export (;0;) "[constructor]a" (func (type 5)))
-          (type (;6;) (own 1))
-          (type (;7;) (list 6))
-          (type (;8;) (func (param "a" 7) (param "b" 6) (result 6)))
-          (export (;1;) "[constructor]b" (func (type 8)))
-          (type (;9;) (own 2))
-          (type (;10;) (func (param "a" 9) (result 9)))
-          (export (;2;) "[static]c.a" (func (type 10)))
-        )
-      )
-      (export (;3;) (interface "foo:bar/implicit-own-handles2") (instance (type 5)))
-      (type (;6;)
-        (component
-          (type (;0;)
-            (instance
-              (export (;0;) "a" (type (sub resource)))
-              (type (;1;) (own 0))
-              (type (;2;) (func (result 1)))
-              (export (;0;) "[constructor]a" (func (type 2)))
-              (type (;3;) (func))
-              (export (;1;) "[static]a.b" (func (type 3)))
-              (type (;4;) (borrow 0))
-              (type (;5;) (func (param "self" 4)))
-              (export (;2;) "[method]a.c" (func (type 5)))
-            )
-          )
-          (import "anon" (instance (;0;) (type 0)))
-          (type (;1;)
-            (instance
-              (export (;0;) "bar" (type (sub resource)))
-              (export (;1;) "t" (type (eq 0)))
-              (type (;2;) (own 0))
-              (export (;3;) "t2" (type (eq 2)))
-              (type (;4;) (own 0))
-              (type (;5;) (func (result 4)))
-              (export (;0;) "[constructor]bar" (func (type 5)))
-              (type (;6;) (func))
-              (export (;1;) "[static]bar.a" (func (type 6)))
-              (type (;7;) (borrow 0))
-              (type (;8;) (func (param "self" 7)))
-              (export (;2;) "[method]bar.b" (func (type 8)))
-              (type (;9;) (func (param "x" 4) (result 4)))
-              (export (;3;) "a" (func (type 9)))
-            )
-          )
-          (import (interface "foo:bar/foo") (instance (;1;) (type 1)))
-          (alias export 1 "bar" (type (;2;)))
-          (alias export 1 "t" (type (;3;)))
-          (type (;4;)
-            (instance
-              (alias outer 1 2 (type (;0;)))
-              (export (;1;) "bar" (type (eq 0)))
-              (alias outer 1 3 (type (;2;)))
-              (export (;3;) "t" (type (eq 2)))
-              (type (;4;) (own 1))
-              (type (;5;) (func (param "x" 4) (result 4)))
-              (export (;0;) "a" (func (type 5)))
-              (type (;6;) (own 3))
-              (type (;7;) (func (result 6)))
-              (export (;1;) "b" (func (type 7)))
-            )
-          )
-          (import (interface "foo:bar/baz") (instance (;2;) (type 4)))
-          (alias export 2 "bar" (type (;5;)))
-          (import "bar" (type (;6;) (eq 5)))
-          (import "a" (type (;7;) (sub resource)))
-          (type (;8;) (own 7))
-          (type (;9;) (func (result 8)))
-          (import "[constructor]a" (func (;0;) (type 9)))
-          (export (;1;) "x" (func (type 9)))
-          (type (;10;) (own 6))
-          (type (;11;) (func (result 10)))
-          (export (;2;) "y" (func (type 11)))
-        )
-      )
-      (export (;0;) (interface "foo:bar/some-world") (component (type 6)))
-      (type (;7;)
-        (component
-          (import "a" (type (;0;) (sub resource)))
-          (type (;1;) (own 0))
-          (type (;2;) (list 1))
-          (type (;3;) (func (param "a" 2) (param "b" 2) (result 1)))
-          (import "[constructor]a" (func (;0;) (type 3)))
-        )
-      )
-      (export (;1;) (interface "foo:bar/implicit-own-handles3") (component (type 7)))
-    )
-  )
-  (@producers
-    (processed-by "wit-component" "$CARGO_PKG_VERSION")
-  )
-  (export (;1;) (interface "foo:bar/wit") (type 0))
-)
\ No newline at end of file
diff --git a/crates/wit-component/tests/interfaces/resources.wit b/crates/wit-component/tests/interfaces/resources.wit
deleted file mode 100644
index 80c7cf67..00000000
--- a/crates/wit-component/tests/interfaces/resources.wit
+++ /dev/null
@@ -1,76 +0,0 @@
-package foo:bar
-
-interface foo {
-  resource bar {
-    constructor()
-    a: static func()
-    b: func()
-  }
-
-  a: func(x: bar) -> bar
-  type t = bar
-  type t2 = own<bar>
-}
-
-interface baz {
-  use foo.{bar,t}
-  a: func(x: bar) -> bar
-
-  b: func() -> t
-}
-
-
-world some-world {
-  use baz.{bar}
-
-  resource a {
-    constructor()
-  }
-
-  export x: func() -> a
-  export y: func() -> bar
-
-  import anon: interface {
-    resource a {
-      constructor()
-
-      b: static func()
-
-      c: func()
-    }
-  }
-}
-
-interface implicit-own-handles {
-  resource a
-
-  b: func(a1: a, a2: a) -> own<a>
-  c: func() -> list<own<a>>
-}
-
-interface implicit-own-handles2 {
-  // the `own` return and list param should be the same `own`
-  resource a {
-    constructor(a: list<a>)
-  }
-
-  // same as above, even when the `list<b>` implicitly-defined `own` comes
-  // before an explicitly defined `own`
-  resource b {
-    constructor(a: list<b>, b: own<b>)
-  }
-
-  // same as the above, the `own` argument should have the same type as the
-  // return value
-  resource c {
-    a: static func(a: own<c>) -> c
-  }
-}
-
-world implicit-own-handles3 {
-  // there should only be one `list` type despite there looking like two
-  // list types here
-  resource a {
-    constructor(a: list<a>, b: list<own<a>>)
-  }
-}
diff --git a/crates/wit-component/tests/interfaces/resources.wit.print b/crates/wit-component/tests/interfaces/resources.wit.print
deleted file mode 100644
index de90c452..00000000
--- a/crates/wit-component/tests/interfaces/resources.wit.print
+++ /dev/null
@@ -1,70 +0,0 @@
-package foo:bar
-
-interface foo {
-  resource bar {
-    constructor()
-    a: static func()
-    b: func()
-  }
-
-  type t = bar
-
-  type t2 = own<bar>
-
-  a: func(x: bar) -> bar
-}
-
-interface baz {
-  use foo.{bar, t}
-
-  a: func(x: bar) -> bar
-
-  b: func() -> t
-}
-
-interface implicit-own-handles {
-  resource a
-
-  b: func(a1: a, a2: a) -> a
-
-  c: func() -> list<a>
-}
-
-interface implicit-own-handles2 {
-  resource a {
-    constructor(a: list<a>)
-  }
-
-  resource b {
-    constructor(a: list<b>, b: b)
-  }
-
-  resource c {
-    a: static func(a: c) -> c
-  }
-}
-
-world some-world {
-  import anon: interface {
-    resource a {
-      constructor()
-      b: static func()
-      c: func()
-    }
-  }
-  import foo
-  import baz
-  use baz.{bar}
-
-  resource a {
-    constructor()
-  }
-
-  export x: func() -> a
-  export y: func() -> bar
-}
-world implicit-own-handles3 {
-  resource a {
-    constructor(a: list<a>, b: list<a>)
-  }
-}
diff --git a/crates/wit-component/tests/interfaces/simple-deps.wat b/crates/wit-component/tests/interfaces/simple-deps.wat
index 4e84a600..7d25c30d 100644
--- a/crates/wit-component/tests/interfaces/simple-deps.wat
+++ b/crates/wit-component/tests/interfaces/simple-deps.wat
@@ -7,7 +7,7 @@
           (export (;1;) "some-type" (type (eq 0)))
         )
       )
-      (import (interface "foo:some-dep/types") (instance (;0;) (type 0)))
+      (import "types" "path:/some-dep/types/types" (instance (type 0)))
       (alias export 0 "some-type" (type (;1;)))
       (type (;2;)
         (instance
@@ -15,11 +15,8 @@
           (export (;1;) "some-type" (type (eq 0)))
         )
       )
-      (export (;1;) (interface "foo:foo/foo") (instance (type 2)))
+      (export (;0;) "foo" "pkg:/foo/foo" (instance (type 2)))
     )
   )
-  (@producers
-    (processed-by "wit-component" "$CARGO_PKG_VERSION")
-  )
-  (export (;1;) (interface "foo:foo/wit") (type 0))
+  (export (;1;) "foo" "pkg:/foo" (type 0))
 )
\ No newline at end of file
diff --git a/crates/wit-component/tests/interfaces/simple-deps/deps/some-dep/types.wit b/crates/wit-component/tests/interfaces/simple-deps/deps/some-dep/types.wit
index 500f811c..1fd77614 100644
--- a/crates/wit-component/tests/interfaces/simple-deps/deps/some-dep/types.wit
+++ b/crates/wit-component/tests/interfaces/simple-deps/deps/some-dep/types.wit
@@ -1,5 +1,3 @@
-package foo:some-dep
-
-interface types {
+default interface types {
   type some-type = u8
 }
diff --git a/crates/wit-component/tests/interfaces/simple-deps/deps/some-dep/types.wit.print b/crates/wit-component/tests/interfaces/simple-deps/deps/some-dep/types.wit.print
new file mode 100644
index 00000000..0c1b0124
--- /dev/null
+++ b/crates/wit-component/tests/interfaces/simple-deps/deps/some-dep/types.wit.print
@@ -0,0 +1,5 @@
+interface types {
+  type some-type = u8
+
+}
+
diff --git a/crates/wit-component/tests/interfaces/simple-deps/foo.wit b/crates/wit-component/tests/interfaces/simple-deps/foo.wit
index 087d0d15..0b034021 100644
--- a/crates/wit-component/tests/interfaces/simple-deps/foo.wit
+++ b/crates/wit-component/tests/interfaces/simple-deps/foo.wit
@@ -1,4 +1,3 @@
-package foo:foo
 interface foo {
-  use foo:some-dep/types.{some-type}
+  use some-dep.types.{some-type}
 }
diff --git a/crates/wit-component/tests/interfaces/simple-deps/foo.wit.print b/crates/wit-component/tests/interfaces/simple-deps/foo.wit.print
index 66aa4587..eaf5632f 100644
--- a/crates/wit-component/tests/interfaces/simple-deps/foo.wit.print
+++ b/crates/wit-component/tests/interfaces/simple-deps/foo.wit.print
@@ -1,6 +1,4 @@
-package foo:foo
-
 interface foo {
-  use foo:some-dep/types.{some-type}
+  use some-dep.types.types.{some-type}
 }
 
diff --git a/crates/wit-component/tests/interfaces/simple-multi.wat b/crates/wit-component/tests/interfaces/simple-multi.wat
index 2250baa2..8bd0c5bf 100644
--- a/crates/wit-component/tests/interfaces/simple-multi.wat
+++ b/crates/wit-component/tests/interfaces/simple-multi.wat
@@ -4,15 +4,17 @@
       (type (;0;)
         (instance)
       )
-      (export (;0;) (interface "foo:foo/bar") (instance (type 0)))
-      (type (;1;)
+      (export (;0;) "foo" "pkg:/foo/foo" (instance (type 0)))
+    )
+  )
+  (export (;1;) "foo" "pkg:/foo" (type 0))
+  (type (;2;)
+    (component
+      (type (;0;)
         (instance)
       )
-      (export (;1;) (interface "foo:foo/foo") (instance (type 1)))
+      (export (;0;) "bar" "pkg:/bar/bar" (instance (type 0)))
     )
   )
-  (@producers
-    (processed-by "wit-component" "$CARGO_PKG_VERSION")
-  )
-  (export (;1;) (interface "foo:foo/wit") (type 0))
+  (export (;3;) "bar" "pkg:/bar" (type 2))
 )
\ No newline at end of file
diff --git a/crates/wit-component/tests/interfaces/simple-multi/bar.wit.print b/crates/wit-component/tests/interfaces/simple-multi/bar.wit.print
new file mode 100644
index 00000000..1f15fd4e
--- /dev/null
+++ b/crates/wit-component/tests/interfaces/simple-multi/bar.wit.print
@@ -0,0 +1,3 @@
+interface bar {
+}
+
diff --git a/crates/wit-component/tests/interfaces/simple-multi/foo.wit b/crates/wit-component/tests/interfaces/simple-multi/foo.wit
index f8a9027d..27947d8a 100644
--- a/crates/wit-component/tests/interfaces/simple-multi/foo.wit
+++ b/crates/wit-component/tests/interfaces/simple-multi/foo.wit
@@ -1,3 +1 @@
-package foo:foo
-
 interface foo {}
diff --git a/crates/wit-component/tests/interfaces/simple-multi/foo.wit.print b/crates/wit-component/tests/interfaces/simple-multi/foo.wit.print
index 985ae52f..80bb5274 100644
--- a/crates/wit-component/tests/interfaces/simple-multi/foo.wit.print
+++ b/crates/wit-component/tests/interfaces/simple-multi/foo.wit.print
@@ -1,8 +1,3 @@
-package foo:foo
-
-interface bar {
-}
-
 interface foo {
 }
 
diff --git a/crates/wit-component/tests/interfaces/simple-use.wat b/crates/wit-component/tests/interfaces/simple-use.wat
index f30b3eff..54c217ed 100644
--- a/crates/wit-component/tests/interfaces/simple-use.wat
+++ b/crates/wit-component/tests/interfaces/simple-use.wat
@@ -7,7 +7,7 @@
           (export (;1;) "level" (type (eq 0)))
         )
       )
-      (export (;0;) (interface "foo:foo/types") (instance (type 0)))
+      (export (;0;) "types" "pkg:/simple-use/types" (instance (type 0)))
       (alias export 0 "level" (type (;1;)))
       (type (;2;)
         (instance
@@ -17,11 +17,8 @@
           (export (;0;) "log" (func (type 2)))
         )
       )
-      (export (;1;) (interface "foo:foo/console") (instance (type 2)))
+      (export (;1;) "console" "pkg:/simple-use/console" (instance (type 2)))
     )
   )
-  (@producers
-    (processed-by "wit-component" "$CARGO_PKG_VERSION")
-  )
-  (export (;1;) (interface "foo:foo/wit") (type 0))
+  (export (;1;) "simple-use" "pkg:/simple-use" (type 0))
 )
\ No newline at end of file
diff --git a/crates/wit-component/tests/interfaces/simple-use.wit b/crates/wit-component/tests/interfaces/simple-use.wit
index 69069bd9..c09566db 100644
--- a/crates/wit-component/tests/interfaces/simple-use.wit
+++ b/crates/wit-component/tests/interfaces/simple-use.wit
@@ -1,5 +1,3 @@
-package foo:foo
-
 interface types {
   enum level {
     info,
@@ -8,6 +6,6 @@ interface types {
 }
 
 interface console {
-  use types.{level}
+  use self.types.{level}
   log: func(level: level, msg: string)
 }
diff --git a/crates/wit-component/tests/interfaces/simple-use.wit.print b/crates/wit-component/tests/interfaces/simple-use.wit.print
index 00b4d1e1..a71079d3 100644
--- a/crates/wit-component/tests/interfaces/simple-use.wit.print
+++ b/crates/wit-component/tests/interfaces/simple-use.wit.print
@@ -1,15 +1,13 @@
-package foo:foo
-
 interface types {
   enum level {
     info,
     debug,
   }
+
 }
 
 interface console {
-  use types.{level}
-
+  use self.types.{level}
   log: func(level: level, msg: string)
 }
 
diff --git a/crates/wit-component/tests/interfaces/simple-world.wat b/crates/wit-component/tests/interfaces/simple-world.wat
index 74140a62..3c408281 100644
--- a/crates/wit-component/tests/interfaces/simple-world.wat
+++ b/crates/wit-component/tests/interfaces/simple-world.wat
@@ -7,7 +7,7 @@
           (export (;0;) "log" (func (type 0)))
         )
       )
-      (export (;0;) (interface "foo:foo/console") (instance (type 0)))
+      (export (;0;) "console" "pkg:/simple-world/console" (instance (type 0)))
       (type (;1;)
         (component
           (type (;0;)
@@ -16,14 +16,11 @@
               (export (;0;) "log" (func (type 0)))
             )
           )
-          (import (interface "foo:foo/console") (instance (;0;) (type 0)))
+          (import "console" "pkg:/simple-world/console" (instance (type 0)))
         )
       )
-      (export (;0;) (interface "foo:foo/the-world") (component (type 1)))
+      (export (;0;) "the-world" "pkg:/simple-world/the-world" (component (type 1)))
     )
   )
-  (@producers
-    (processed-by "wit-component" "$CARGO_PKG_VERSION")
-  )
-  (export (;1;) (interface "foo:foo/wit") (type 0))
+  (export (;1;) "simple-world" "pkg:/simple-world" (type 0))
 )
\ No newline at end of file
diff --git a/crates/wit-component/tests/interfaces/simple-world.wit b/crates/wit-component/tests/interfaces/simple-world.wit
index 3dd08016..c5d1ef2b 100644
--- a/crates/wit-component/tests/interfaces/simple-world.wit
+++ b/crates/wit-component/tests/interfaces/simple-world.wit
@@ -1,7 +1,5 @@
-package foo:foo
-
 world the-world {
-  import console
+  import console: self.console
 }
 
 interface console {
diff --git a/crates/wit-component/tests/interfaces/simple-world.wit.print b/crates/wit-component/tests/interfaces/simple-world.wit.print
index ef62499f..e059d63b 100644
--- a/crates/wit-component/tests/interfaces/simple-world.wit.print
+++ b/crates/wit-component/tests/interfaces/simple-world.wit.print
@@ -1,9 +1,7 @@
-package foo:foo
-
 interface console {
   log: func(arg: string)
 }
 
 world the-world {
-  import console
+  import console: self.console
 }
diff --git a/crates/wit-component/tests/interfaces/single-named-result.wat b/crates/wit-component/tests/interfaces/single-named-result.wat
index a0ce0956..6c8616bc 100644
--- a/crates/wit-component/tests/interfaces/single-named-result.wat
+++ b/crates/wit-component/tests/interfaces/single-named-result.wat
@@ -7,11 +7,8 @@
           (export (;0;) "a" (func (type 0)))
         )
       )
-      (export (;0;) (interface "foo:foo/foo") (instance (type 0)))
+      (export (;0;) "foo" "pkg:/single-named-result/foo" (instance (type 0)))
     )
   )
-  (@producers
-    (processed-by "wit-component" "$CARGO_PKG_VERSION")
-  )
-  (export (;1;) (interface "foo:foo/wit") (type 0))
+  (export (;1;) "single-named-result" "pkg:/single-named-result" (type 0))
 )
\ No newline at end of file
diff --git a/crates/wit-component/tests/interfaces/single-named-result.wit b/crates/wit-component/tests/interfaces/single-named-result.wit
index 8fd946ff..13afc00d 100644
--- a/crates/wit-component/tests/interfaces/single-named-result.wit
+++ b/crates/wit-component/tests/interfaces/single-named-result.wit
@@ -1,5 +1,3 @@
-package foo:foo
-
 interface foo {
   a: func() -> (a: u32)
 }
diff --git a/crates/wit-component/tests/interfaces/single-named-result.wit.print b/crates/wit-component/tests/interfaces/single-named-result.wit.print
index fe78a21b..cd6cb560 100644
--- a/crates/wit-component/tests/interfaces/single-named-result.wit.print
+++ b/crates/wit-component/tests/interfaces/single-named-result.wit.print
@@ -1,5 +1,3 @@
-package foo:foo
-
 interface foo {
   a: func() -> (a: u32)
 }
diff --git a/crates/wit-component/tests/interfaces/type-alias.wat b/crates/wit-component/tests/interfaces/type-alias.wat
index 2feb4e34..00a94861 100644
--- a/crates/wit-component/tests/interfaces/type-alias.wat
+++ b/crates/wit-component/tests/interfaces/type-alias.wat
@@ -10,7 +10,7 @@
           (export (;0;) "f" (func (type 3)))
         )
       )
-      (export (;0;) (interface "foo:foo/foo") (instance (type 0)))
+      (export (;0;) "foo" "pkg:/type-alias/foo" (instance (type 0)))
       (type (;1;)
         (component
           (type (;0;)
@@ -22,7 +22,7 @@
               (export (;0;) "f" (func (type 3)))
             )
           )
-          (import (interface "foo:foo/foo") (instance (;0;) (type 0)))
+          (import "foo" "pkg:/type-alias/foo" (instance (type 0)))
           (type (;1;)
             (instance
               (type (;0;) u8)
@@ -32,14 +32,11 @@
               (export (;0;) "f" (func (type 3)))
             )
           )
-          (export (;1;) (interface "foo:foo/foo") (instance (type 1)))
+          (export (;0;) "foo2" "pkg:/type-alias/foo" (instance (type 1)))
         )
       )
-      (export (;0;) (interface "foo:foo/my-world") (component (type 1)))
+      (export (;0;) "my-world" "pkg:/type-alias/my-world" (component (type 1)))
     )
   )
-  (@producers
-    (processed-by "wit-component" "$CARGO_PKG_VERSION")
-  )
-  (export (;1;) (interface "foo:foo/wit") (type 0))
+  (export (;1;) "type-alias" "pkg:/type-alias" (type 0))
 )
\ No newline at end of file
diff --git a/crates/wit-component/tests/interfaces/type-alias.wit b/crates/wit-component/tests/interfaces/type-alias.wit
index ebf40425..80da5975 100644
--- a/crates/wit-component/tests/interfaces/type-alias.wit
+++ b/crates/wit-component/tests/interfaces/type-alias.wit
@@ -1,5 +1,3 @@
-package foo:foo
-
 interface foo {
   type a = u8
   type b = a
@@ -8,6 +6,6 @@ interface foo {
 }
 
 world my-world {
-  import foo
-  export foo
+  import foo: self.foo
+  export foo2: self.foo
 }
diff --git a/crates/wit-component/tests/interfaces/type-alias.wit.print b/crates/wit-component/tests/interfaces/type-alias.wit.print
index 6d9300cc..56c75fcd 100644
--- a/crates/wit-component/tests/interfaces/type-alias.wit.print
+++ b/crates/wit-component/tests/interfaces/type-alias.wit.print
@@ -1,5 +1,3 @@
-package foo:foo
-
 interface foo {
   type a = u8
 
@@ -9,7 +7,6 @@ interface foo {
 }
 
 world my-world {
-  import foo
-
-  export foo
+  import foo: self.foo
+  export foo2: self.foo
 }
diff --git a/crates/wit-component/tests/interfaces/type-alias2.wat b/crates/wit-component/tests/interfaces/type-alias2.wat
index 91a47346..acccc8e4 100644
--- a/crates/wit-component/tests/interfaces/type-alias2.wat
+++ b/crates/wit-component/tests/interfaces/type-alias2.wat
@@ -10,7 +10,7 @@
           (export (;0;) "f" (func (type 3)))
         )
       )
-      (export (;0;) (interface "foo:foo/foo") (instance (type 0)))
+      (export (;0;) "foo" "pkg:/type-alias2/foo" (instance (type 0)))
       (type (;1;)
         (component
           (type (;0;)
@@ -22,14 +22,11 @@
               (export (;0;) "f" (func (type 3)))
             )
           )
-          (export (;0;) (interface "foo:foo/foo") (instance (type 0)))
+          (export (;0;) "foo" "pkg:/type-alias2/foo" (instance (type 0)))
         )
       )
-      (export (;0;) (interface "foo:foo/my-world") (component (type 1)))
+      (export (;0;) "my-world" "pkg:/type-alias2/my-world" (component (type 1)))
     )
   )
-  (@producers
-    (processed-by "wit-component" "$CARGO_PKG_VERSION")
-  )
-  (export (;1;) (interface "foo:foo/wit") (type 0))
+  (export (;1;) "type-alias2" "pkg:/type-alias2" (type 0))
 )
\ No newline at end of file
diff --git a/crates/wit-component/tests/interfaces/type-alias2.wit b/crates/wit-component/tests/interfaces/type-alias2.wit
index b3a3d3fc..0af05e58 100644
--- a/crates/wit-component/tests/interfaces/type-alias2.wit
+++ b/crates/wit-component/tests/interfaces/type-alias2.wit
@@ -1,5 +1,3 @@
-package foo:foo
-
 interface foo {
   flags a {
     b,
@@ -11,5 +9,5 @@ interface foo {
 }
 
 world my-world {
-  export foo
+  export foo: self.foo
 }
diff --git a/crates/wit-component/tests/interfaces/type-alias2.wit.print b/crates/wit-component/tests/interfaces/type-alias2.wit.print
index b3a3d3fc..0af05e58 100644
--- a/crates/wit-component/tests/interfaces/type-alias2.wit.print
+++ b/crates/wit-component/tests/interfaces/type-alias2.wit.print
@@ -1,5 +1,3 @@
-package foo:foo
-
 interface foo {
   flags a {
     b,
@@ -11,5 +9,5 @@ interface foo {
 }
 
 world my-world {
-  export foo
+  export foo: self.foo
 }
diff --git a/crates/wit-component/tests/interfaces/upstream-deps-same-name.wat b/crates/wit-component/tests/interfaces/upstream-deps-same-name.wat
index 2dc006c0..e8a55451 100644
--- a/crates/wit-component/tests/interfaces/upstream-deps-same-name.wat
+++ b/crates/wit-component/tests/interfaces/upstream-deps-same-name.wat
@@ -7,14 +7,14 @@
           (export (;1;) "ty" (type (eq 0)))
         )
       )
-      (import (interface "foo:a/the-name") (instance (;0;) (type 0)))
+      (import "the-iface" "path:/a/the-name/the-iface" (instance (type 0)))
       (type (;1;)
         (instance
           (type (;0;) u8)
           (export (;1;) "ty" (type (eq 0)))
         )
       )
-      (import (interface "foo:b/the-name") (instance (;1;) (type 1)))
+      (import "the-iface2" "path:/b/the-name/the-iface" (instance (type 1)))
       (alias export 0 "ty" (type (;2;)))
       (alias export 1 "ty" (type (;3;)))
       (type (;4;)
@@ -25,11 +25,8 @@
           (export (;3;) "ty2" (type (eq 2)))
         )
       )
-      (export (;2;) (interface "foo:foo/a") (instance (type 4)))
+      (export (;0;) "a" "pkg:/foo/a" (instance (type 4)))
     )
   )
-  (@producers
-    (processed-by "wit-component" "$CARGO_PKG_VERSION")
-  )
-  (export (;1;) (interface "foo:foo/wit") (type 0))
+  (export (;1;) "foo" "pkg:/foo" (type 0))
 )
\ No newline at end of file
diff --git a/crates/wit-component/tests/interfaces/upstream-deps-same-name/deps/a/the-name.wit b/crates/wit-component/tests/interfaces/upstream-deps-same-name/deps/a/the-name.wit
index dc0d8f01..72566832 100644
--- a/crates/wit-component/tests/interfaces/upstream-deps-same-name/deps/a/the-name.wit
+++ b/crates/wit-component/tests/interfaces/upstream-deps-same-name/deps/a/the-name.wit
@@ -1,4 +1,3 @@
-package foo:a
-interface the-name {
+default interface the-iface {
   type ty = u8
 }
diff --git a/crates/wit-component/tests/interfaces/upstream-deps-same-name/deps/a/the-name.wit.print b/crates/wit-component/tests/interfaces/upstream-deps-same-name/deps/a/the-name.wit.print
new file mode 100644
index 00000000..a0f0577e
--- /dev/null
+++ b/crates/wit-component/tests/interfaces/upstream-deps-same-name/deps/a/the-name.wit.print
@@ -0,0 +1,5 @@
+interface the-iface {
+  type ty = u8
+
+}
+
diff --git a/crates/wit-component/tests/interfaces/upstream-deps-same-name/deps/b/the-name.wit b/crates/wit-component/tests/interfaces/upstream-deps-same-name/deps/b/the-name.wit
index 92ff659a..72566832 100644
--- a/crates/wit-component/tests/interfaces/upstream-deps-same-name/deps/b/the-name.wit
+++ b/crates/wit-component/tests/interfaces/upstream-deps-same-name/deps/b/the-name.wit
@@ -1,4 +1,3 @@
-package foo:b
-interface the-name {
+default interface the-iface {
   type ty = u8
 }
diff --git a/crates/wit-component/tests/interfaces/upstream-deps-same-name/deps/b/the-name.wit.print b/crates/wit-component/tests/interfaces/upstream-deps-same-name/deps/b/the-name.wit.print
new file mode 100644
index 00000000..a0f0577e
--- /dev/null
+++ b/crates/wit-component/tests/interfaces/upstream-deps-same-name/deps/b/the-name.wit.print
@@ -0,0 +1,5 @@
+interface the-iface {
+  type ty = u8
+
+}
+
diff --git a/crates/wit-component/tests/interfaces/upstream-deps-same-name/foo.wit b/crates/wit-component/tests/interfaces/upstream-deps-same-name/foo.wit
index ee38300a..8199b7a8 100644
--- a/crates/wit-component/tests/interfaces/upstream-deps-same-name/foo.wit
+++ b/crates/wit-component/tests/interfaces/upstream-deps-same-name/foo.wit
@@ -1,6 +1,4 @@
-package foo:foo
-
 interface a {
-  use foo:a/the-name.{ty}
-  use foo:b/the-name.{ty as ty2}
+  use a.the-name.{ty}
+  use b.the-name.{ty as ty2}
 }
diff --git a/crates/wit-component/tests/interfaces/upstream-deps-same-name/foo.wit.print b/crates/wit-component/tests/interfaces/upstream-deps-same-name/foo.wit.print
index 4f16d68b..504600d9 100644
--- a/crates/wit-component/tests/interfaces/upstream-deps-same-name/foo.wit.print
+++ b/crates/wit-component/tests/interfaces/upstream-deps-same-name/foo.wit.print
@@ -1,7 +1,5 @@
-package foo:foo
-
 interface a {
-  use foo:a/the-name.{ty}
-  use foo:b/the-name.{ty as ty2}
+  use a.the-name.the-iface.{ty}
+  use b.the-name.the-iface.{ty as ty2}
 }
 
diff --git a/crates/wit-component/tests/interfaces/use-chain.wat b/crates/wit-component/tests/interfaces/use-chain.wat
index 34fabfc8..a6236597 100644
--- a/crates/wit-component/tests/interfaces/use-chain.wat
+++ b/crates/wit-component/tests/interfaces/use-chain.wat
@@ -9,7 +9,7 @@
           (export (;3;) "c" (type (eq 2)))
         )
       )
-      (export (;0;) (interface "foo:foo/foo") (instance (type 0)))
+      (export (;0;) "foo" "pkg:/use-chain/foo" (instance (type 0)))
       (alias export 0 "c" (type (;1;)))
       (type (;2;)
         (instance
@@ -17,7 +17,7 @@
           (export (;1;) "c" (type (eq 0)))
         )
       )
-      (export (;1;) (interface "foo:foo/bar") (instance (type 2)))
+      (export (;1;) "bar" "pkg:/use-chain/bar" (instance (type 2)))
       (alias export 1 "c" (type (;3;)))
       (type (;4;)
         (instance
@@ -25,11 +25,8 @@
           (export (;1;) "c" (type (eq 0)))
         )
       )
-      (export (;2;) (interface "foo:foo/baz") (instance (type 4)))
+      (export (;2;) "baz" "pkg:/use-chain/baz" (instance (type 4)))
     )
   )
-  (@producers
-    (processed-by "wit-component" "$CARGO_PKG_VERSION")
-  )
-  (export (;1;) (interface "foo:foo/wit") (type 0))
+  (export (;1;) "use-chain" "pkg:/use-chain" (type 0))
 )
\ No newline at end of file
diff --git a/crates/wit-component/tests/interfaces/use-chain.wit b/crates/wit-component/tests/interfaces/use-chain.wit
index a8169f83..61bfb307 100644
--- a/crates/wit-component/tests/interfaces/use-chain.wit
+++ b/crates/wit-component/tests/interfaces/use-chain.wit
@@ -1,5 +1,3 @@
-package foo:foo
-
 interface foo {
   type a = u32
   type b = a
@@ -7,9 +5,9 @@ interface foo {
 }
 
 interface bar {
-  use foo.{c}
+  use self.foo.{c}
 }
 
 interface baz {
-  use bar.{c}
+  use self.bar.{c}
 }
diff --git a/crates/wit-component/tests/interfaces/use-chain.wit.print b/crates/wit-component/tests/interfaces/use-chain.wit.print
index fc19fb45..35910f70 100644
--- a/crates/wit-component/tests/interfaces/use-chain.wit.print
+++ b/crates/wit-component/tests/interfaces/use-chain.wit.print
@@ -1,18 +1,17 @@
-package foo:foo
-
 interface foo {
   type a = u32
 
   type b = a
 
   type c = b
+
 }
 
 interface bar {
-  use foo.{c}
+  use self.foo.{c}
 }
 
 interface baz {
-  use bar.{c}
+  use self.bar.{c}
 }
 
diff --git a/crates/wit-component/tests/interfaces/use-for-type.wat b/crates/wit-component/tests/interfaces/use-for-type.wat
index 8730037c..1267e4d9 100644
--- a/crates/wit-component/tests/interfaces/use-for-type.wat
+++ b/crates/wit-component/tests/interfaces/use-for-type.wat
@@ -4,14 +4,14 @@
       (type (;0;)
         (instance)
       )
-      (export (;0;) (interface "foo:foo/foo") (instance (type 0)))
+      (export (;0;) "foo" "pkg:/use-for-type/foo" (instance (type 0)))
       (type (;1;)
         (instance
           (type (;0;) u8)
           (export (;1;) "t" (type (eq 0)))
         )
       )
-      (export (;1;) (interface "foo:foo/bar") (instance (type 1)))
+      (export (;1;) "bar" "pkg:/use-for-type/bar" (instance (type 1)))
       (alias export 1 "t" (type (;2;)))
       (type (;3;)
         (instance
@@ -21,11 +21,8 @@
           (export (;3;) "bar" (type (eq 2)))
         )
       )
-      (export (;2;) (interface "foo:foo/baz") (instance (type 3)))
+      (export (;2;) "baz" "pkg:/use-for-type/baz" (instance (type 3)))
     )
   )
-  (@producers
-    (processed-by "wit-component" "$CARGO_PKG_VERSION")
-  )
-  (export (;1;) (interface "foo:foo/wit") (type 0))
+  (export (;1;) "use-for-type" "pkg:/use-for-type" (type 0))
 )
\ No newline at end of file
diff --git a/crates/wit-component/tests/interfaces/use-for-type.wit b/crates/wit-component/tests/interfaces/use-for-type.wit
index 36dfac22..fa401502 100644
--- a/crates/wit-component/tests/interfaces/use-for-type.wit
+++ b/crates/wit-component/tests/interfaces/use-for-type.wit
@@ -1,6 +1,4 @@
-package foo:foo
-
-interface foo {
+default interface foo {
 }
 
 interface bar {
@@ -8,7 +6,7 @@ interface bar {
 }
 
 interface baz {
-  use bar.{t}
+  use self.bar.{t}
 
   record bar {
     a: t,
diff --git a/crates/wit-component/tests/interfaces/use-for-type.wit.print b/crates/wit-component/tests/interfaces/use-for-type.wit.print
index 96599209..8f81480b 100644
--- a/crates/wit-component/tests/interfaces/use-for-type.wit.print
+++ b/crates/wit-component/tests/interfaces/use-for-type.wit.print
@@ -1,17 +1,17 @@
-package foo:foo
-
 interface foo {
 }
 
 interface bar {
   type t = u8
+
 }
 
 interface baz {
-  use bar.{t}
+  use self.bar.{t}
 
   record bar {
     a: t,
   }
+
 }
 
diff --git a/crates/wit-component/tests/interfaces/variants.wat b/crates/wit-component/tests/interfaces/variants.wat
index f3c28376..61150cbd 100644
--- a/crates/wit-component/tests/interfaces/variants.wat
+++ b/crates/wit-component/tests/interfaces/variants.wat
@@ -3,41 +3,41 @@
     (component
       (type (;0;)
         (instance
-          (type (;0;) (enum "a"))
-          (export (;1;) "e1" (type (eq 0)))
-          (type (;2;) (union u32 float32))
-          (export (;3;) "u1" (type (eq 2)))
+          (type (;0;) (union u32 float32))
+          (export (;1;) "u1" (type (eq 0)))
+          (type (;2;) (enum "bad1" "bad2"))
+          (export (;3;) "my-errno" (type (eq 2)))
           (type (;4;) (record))
           (export (;5;) "empty" (type (eq 4)))
-          (type (;6;) (variant (case "a") (case "b" 3) (case "c" 1) (case "d" string) (case "e" 5) (case "f") (case "g" u32)))
-          (export (;7;) "v1" (type (eq 6)))
-          (type (;8;) (variant (case "a" s32) (case "b" float32)))
-          (export (;9;) "casts1" (type (eq 8)))
-          (type (;10;) (variant (case "a" float64) (case "b" float32)))
-          (export (;11;) "casts2" (type (eq 10)))
-          (type (;12;) (variant (case "a" float64) (case "b" u64)))
-          (export (;13;) "casts3" (type (eq 12)))
-          (type (;14;) (variant (case "a" u32) (case "b" s64)))
-          (export (;15;) "casts4" (type (eq 14)))
-          (type (;16;) (variant (case "a" float32) (case "b" s64)))
-          (export (;17;) "casts5" (type (eq 16)))
-          (type (;18;) (tuple float32 u32))
-          (type (;19;) (tuple u32 u32))
-          (type (;20;) (variant (case "a" 18) (case "b" 19)))
-          (export (;21;) "casts6" (type (eq 20)))
-          (type (;22;) (enum "bad1" "bad2"))
-          (export (;23;) "my-errno" (type (eq 22)))
-          (type (;24;) (func (param "x" 1)))
+          (type (;6;) (enum "a"))
+          (export (;7;) "e1" (type (eq 6)))
+          (type (;8;) (variant (case "a") (case "b" 1) (case "c" 7) (case "d" string) (case "e" 5) (case "f") (case "g" u32)))
+          (export (;9;) "v1" (type (eq 8)))
+          (type (;10;) (tuple float32 u32))
+          (type (;11;) (tuple u32 u32))
+          (type (;12;) (variant (case "a" 10) (case "b" 11)))
+          (export (;13;) "casts6" (type (eq 12)))
+          (type (;14;) (variant (case "a" float32) (case "b" s64)))
+          (export (;15;) "casts5" (type (eq 14)))
+          (type (;16;) (variant (case "a" u32) (case "b" s64)))
+          (export (;17;) "casts4" (type (eq 16)))
+          (type (;18;) (variant (case "a" float64) (case "b" u64)))
+          (export (;19;) "casts3" (type (eq 18)))
+          (type (;20;) (variant (case "a" float64) (case "b" float32)))
+          (export (;21;) "casts2" (type (eq 20)))
+          (type (;22;) (variant (case "a" s32) (case "b" float32)))
+          (export (;23;) "casts1" (type (eq 22)))
+          (type (;24;) (func (param "x" 7)))
           (export (;0;) "e1-arg" (func (type 24)))
-          (type (;25;) (func (result 1)))
+          (type (;25;) (func (result 7)))
           (export (;1;) "e1-result" (func (type 25)))
-          (type (;26;) (func (param "x" 3)))
+          (type (;26;) (func (param "x" 1)))
           (export (;2;) "u1-arg" (func (type 26)))
-          (type (;27;) (func (result 3)))
+          (type (;27;) (func (result 1)))
           (export (;3;) "u1-result" (func (type 27)))
-          (type (;28;) (func (param "x" 7)))
+          (type (;28;) (func (param "x" 9)))
           (export (;4;) "v1-arg" (func (type 28)))
-          (type (;29;) (func (result 7)))
+          (type (;29;) (func (result 9)))
           (export (;5;) "v1-result" (func (type 29)))
           (type (;30;) (func (param "x" bool)))
           (export (;6;) "bool-arg" (func (type 30)))
@@ -47,23 +47,23 @@
           (type (;33;) (tuple))
           (type (;34;) (option 33))
           (type (;35;) (option u32))
-          (type (;36;) (option 1))
+          (type (;36;) (option 7))
           (type (;37;) (option float32))
-          (type (;38;) (option 3))
+          (type (;38;) (option 1))
           (type (;39;) (option 32))
           (type (;40;) (func (param "a" 32) (param "b" 34) (param "c" 35) (param "d" 36) (param "e" 37) (param "f" 38) (param "g" 39)))
           (export (;8;) "option-arg" (func (type 40)))
           (type (;41;) (tuple 32 34 35 36 37 38 39))
           (type (;42;) (func (result 41)))
           (export (;9;) "option-result" (func (type 42)))
-          (type (;43;) (tuple 9 11 13 15 17 21))
-          (type (;44;) (func (param "a" 9) (param "b" 11) (param "c" 13) (param "d" 15) (param "e" 17) (param "f" 21) (result 43)))
+          (type (;43;) (tuple 23 21 19 17 15 13))
+          (type (;44;) (func (param "a" 23) (param "b" 21) (param "c" 19) (param "d" 17) (param "e" 15) (param "f" 13) (result 43)))
           (export (;10;) "casts" (func (type 44)))
           (type (;45;) (result))
-          (type (;46;) (result (error 1)))
-          (type (;47;) (result 1))
+          (type (;46;) (result (error 7)))
+          (type (;47;) (result 7))
           (type (;48;) (result 33 (error 33)))
-          (type (;49;) (result u32 (error 7)))
+          (type (;49;) (result u32 (error 9)))
           (type (;50;) (list u8))
           (type (;51;) (result string (error 50)))
           (type (;52;) (func (param "a" 45) (param "b" 46) (param "c" 47) (param "d" 48) (param "e" 49) (param "f" 51)))
@@ -71,23 +71,23 @@
           (type (;53;) (tuple 45 46 47 48 49 51))
           (type (;54;) (func (result 53)))
           (export (;12;) "expected-result" (func (type 54)))
-          (type (;55;) (result s32 (error 23)))
+          (type (;55;) (result s32 (error 3)))
           (type (;56;) (func (result 55)))
           (export (;13;) "return-expected-sugar" (func (type 56)))
-          (type (;57;) (result (error 23)))
+          (type (;57;) (result (error 3)))
           (type (;58;) (func (result 57)))
           (export (;14;) "return-expected-sugar2" (func (type 58)))
-          (type (;59;) (result 23 (error 23)))
+          (type (;59;) (result 3 (error 3)))
           (type (;60;) (func (result 59)))
           (export (;15;) "return-expected-sugar3" (func (type 60)))
           (type (;61;) (tuple s32 u32))
-          (type (;62;) (result 61 (error 23)))
+          (type (;62;) (result 61 (error 3)))
           (type (;63;) (func (result 62)))
           (export (;16;) "return-expected-sugar4" (func (type 63)))
           (type (;64;) (option s32))
           (type (;65;) (func (result 64)))
           (export (;17;) "return-option-sugar" (func (type 65)))
-          (type (;66;) (option 23))
+          (type (;66;) (option 3))
           (type (;67;) (func (result 66)))
           (export (;18;) "return-option-sugar2" (func (type 67)))
           (type (;68;) (result u32 (error s32)))
@@ -95,46 +95,46 @@
           (export (;19;) "expected-simple" (func (type 69)))
         )
       )
-      (export (;0;) (interface "foo:variants/variants") (instance (type 0)))
+      (export (;0;) "variants" "pkg:/variants/variants" (instance (type 0)))
       (type (;1;)
         (component
           (type (;0;)
             (instance
-              (type (;0;) (enum "a"))
-              (export (;1;) "e1" (type (eq 0)))
-              (type (;2;) (union u32 float32))
-              (export (;3;) "u1" (type (eq 2)))
+              (type (;0;) (union u32 float32))
+              (export (;1;) "u1" (type (eq 0)))
+              (type (;2;) (enum "bad1" "bad2"))
+              (export (;3;) "my-errno" (type (eq 2)))
               (type (;4;) (record))
               (export (;5;) "empty" (type (eq 4)))
-              (type (;6;) (variant (case "a") (case "b" 3) (case "c" 1) (case "d" string) (case "e" 5) (case "f") (case "g" u32)))
-              (export (;7;) "v1" (type (eq 6)))
-              (type (;8;) (variant (case "a" s32) (case "b" float32)))
-              (export (;9;) "casts1" (type (eq 8)))
-              (type (;10;) (variant (case "a" float64) (case "b" float32)))
-              (export (;11;) "casts2" (type (eq 10)))
-              (type (;12;) (variant (case "a" float64) (case "b" u64)))
-              (export (;13;) "casts3" (type (eq 12)))
-              (type (;14;) (variant (case "a" u32) (case "b" s64)))
-              (export (;15;) "casts4" (type (eq 14)))
-              (type (;16;) (variant (case "a" float32) (case "b" s64)))
-              (export (;17;) "casts5" (type (eq 16)))
-              (type (;18;) (tuple float32 u32))
-              (type (;19;) (tuple u32 u32))
-              (type (;20;) (variant (case "a" 18) (case "b" 19)))
-              (export (;21;) "casts6" (type (eq 20)))
-              (type (;22;) (enum "bad1" "bad2"))
-              (export (;23;) "my-errno" (type (eq 22)))
-              (type (;24;) (func (param "x" 1)))
+              (type (;6;) (enum "a"))
+              (export (;7;) "e1" (type (eq 6)))
+              (type (;8;) (variant (case "a") (case "b" 1) (case "c" 7) (case "d" string) (case "e" 5) (case "f") (case "g" u32)))
+              (export (;9;) "v1" (type (eq 8)))
+              (type (;10;) (tuple float32 u32))
+              (type (;11;) (tuple u32 u32))
+              (type (;12;) (variant (case "a" 10) (case "b" 11)))
+              (export (;13;) "casts6" (type (eq 12)))
+              (type (;14;) (variant (case "a" float32) (case "b" s64)))
+              (export (;15;) "casts5" (type (eq 14)))
+              (type (;16;) (variant (case "a" u32) (case "b" s64)))
+              (export (;17;) "casts4" (type (eq 16)))
+              (type (;18;) (variant (case "a" float64) (case "b" u64)))
+              (export (;19;) "casts3" (type (eq 18)))
+              (type (;20;) (variant (case "a" float64) (case "b" float32)))
+              (export (;21;) "casts2" (type (eq 20)))
+              (type (;22;) (variant (case "a" s32) (case "b" float32)))
+              (export (;23;) "casts1" (type (eq 22)))
+              (type (;24;) (func (param "x" 7)))
               (export (;0;) "e1-arg" (func (type 24)))
-              (type (;25;) (func (result 1)))
+              (type (;25;) (func (result 7)))
               (export (;1;) "e1-result" (func (type 25)))
-              (type (;26;) (func (param "x" 3)))
+              (type (;26;) (func (param "x" 1)))
               (export (;2;) "u1-arg" (func (type 26)))
-              (type (;27;) (func (result 3)))
+              (type (;27;) (func (result 1)))
               (export (;3;) "u1-result" (func (type 27)))
-              (type (;28;) (func (param "x" 7)))
+              (type (;28;) (func (param "x" 9)))
               (export (;4;) "v1-arg" (func (type 28)))
-              (type (;29;) (func (result 7)))
+              (type (;29;) (func (result 9)))
               (export (;5;) "v1-result" (func (type 29)))
               (type (;30;) (func (param "x" bool)))
               (export (;6;) "bool-arg" (func (type 30)))
@@ -144,23 +144,23 @@
               (type (;33;) (tuple))
               (type (;34;) (option 33))
               (type (;35;) (option u32))
-              (type (;36;) (option 1))
+              (type (;36;) (option 7))
               (type (;37;) (option float32))
-              (type (;38;) (option 3))
+              (type (;38;) (option 1))
               (type (;39;) (option 32))
               (type (;40;) (func (param "a" 32) (param "b" 34) (param "c" 35) (param "d" 36) (param "e" 37) (param "f" 38) (param "g" 39)))
               (export (;8;) "option-arg" (func (type 40)))
               (type (;41;) (tuple 32 34 35 36 37 38 39))
               (type (;42;) (func (result 41)))
               (export (;9;) "option-result" (func (type 42)))
-              (type (;43;) (tuple 9 11 13 15 17 21))
-              (type (;44;) (func (param "a" 9) (param "b" 11) (param "c" 13) (param "d" 15) (param "e" 17) (param "f" 21) (result 43)))
+              (type (;43;) (tuple 23 21 19 17 15 13))
+              (type (;44;) (func (param "a" 23) (param "b" 21) (param "c" 19) (param "d" 17) (param "e" 15) (param "f" 13) (result 43)))
               (export (;10;) "casts" (func (type 44)))
               (type (;45;) (result))
-              (type (;46;) (result (error 1)))
-              (type (;47;) (result 1))
+              (type (;46;) (result (error 7)))
+              (type (;47;) (result 7))
               (type (;48;) (result 33 (error 33)))
-              (type (;49;) (result u32 (error 7)))
+              (type (;49;) (result u32 (error 9)))
               (type (;50;) (list u8))
               (type (;51;) (result string (error 50)))
               (type (;52;) (func (param "a" 45) (param "b" 46) (param "c" 47) (param "d" 48) (param "e" 49) (param "f" 51)))
@@ -168,23 +168,23 @@
               (type (;53;) (tuple 45 46 47 48 49 51))
               (type (;54;) (func (result 53)))
               (export (;12;) "expected-result" (func (type 54)))
-              (type (;55;) (result s32 (error 23)))
+              (type (;55;) (result s32 (error 3)))
               (type (;56;) (func (result 55)))
               (export (;13;) "return-expected-sugar" (func (type 56)))
-              (type (;57;) (result (error 23)))
+              (type (;57;) (result (error 3)))
               (type (;58;) (func (result 57)))
               (export (;14;) "return-expected-sugar2" (func (type 58)))
-              (type (;59;) (result 23 (error 23)))
+              (type (;59;) (result 3 (error 3)))
               (type (;60;) (func (result 59)))
               (export (;15;) "return-expected-sugar3" (func (type 60)))
               (type (;61;) (tuple s32 u32))
-              (type (;62;) (result 61 (error 23)))
+              (type (;62;) (result 61 (error 3)))
               (type (;63;) (func (result 62)))
               (export (;16;) "return-expected-sugar4" (func (type 63)))
               (type (;64;) (option s32))
               (type (;65;) (func (result 64)))
               (export (;17;) "return-option-sugar" (func (type 65)))
-              (type (;66;) (option 23))
+              (type (;66;) (option 3))
               (type (;67;) (func (result 66)))
               (export (;18;) "return-option-sugar2" (func (type 67)))
               (type (;68;) (result u32 (error s32)))
@@ -192,14 +192,11 @@
               (export (;19;) "expected-simple" (func (type 69)))
             )
           )
-          (import (interface "foo:variants/variants") (instance (;0;) (type 0)))
+          (import "variants" "pkg:/variants/variants" (instance (type 0)))
         )
       )
-      (export (;0;) (interface "foo:variants/variants-world") (component (type 1)))
+      (export (;0;) "variants-world" "pkg:/variants/variants-world" (component (type 1)))
     )
   )
-  (@producers
-    (processed-by "wit-component" "$CARGO_PKG_VERSION")
-  )
-  (export (;1;) (interface "foo:variants/wit") (type 0))
+  (export (;1;) "variants" "pkg:/variants" (type 0))
 )
\ No newline at end of file
diff --git a/crates/wit-component/tests/interfaces/variants.wit b/crates/wit-component/tests/interfaces/variants.wit
index 195ffac4..bb642626 100644
--- a/crates/wit-component/tests/interfaces/variants.wit
+++ b/crates/wit-component/tests/interfaces/variants.wit
@@ -1,5 +1,3 @@
-package foo:variants
-
 interface variants {
   enum e1 {
     a,
@@ -81,5 +79,5 @@ interface variants {
 }
 
 world variants-world {
-  import variants
+  import variants: self.variants
 }
diff --git a/crates/wit-component/tests/interfaces/variants.wit.print b/crates/wit-component/tests/interfaces/variants.wit.print
index 81d6b182..3e9a73b3 100644
--- a/crates/wit-component/tests/interfaces/variants.wit.print
+++ b/crates/wit-component/tests/interfaces/variants.wit.print
@@ -1,18 +1,21 @@
-package foo:variants
-
 interface variants {
-  enum e1 {
-    a,
-  }
-
   union u1 {
     u32,
     float32,
   }
 
+  enum my-errno {
+    bad1,
+    bad2,
+  }
+
   record empty {
   }
 
+  enum e1 {
+    a,
+  }
+
   variant v1 {
     a,
     b(u1),
@@ -23,19 +26,14 @@ interface variants {
     g(u32),
   }
 
-  variant casts1 {
-    a(s32),
-    b(float32),
-  }
-
-  variant casts2 {
-    a(float64),
-    b(float32),
+  variant casts6 {
+    a(tuple<float32, u32>),
+    b(tuple<u32, u32>),
   }
 
-  variant casts3 {
-    a(float64),
-    b(u64),
+  variant casts5 {
+    a(float32),
+    b(s64),
   }
 
   variant casts4 {
@@ -43,19 +41,19 @@ interface variants {
     b(s64),
   }
 
-  variant casts5 {
-    a(float32),
-    b(s64),
+  variant casts3 {
+    a(float64),
+    b(u64),
   }
 
-  variant casts6 {
-    a(tuple<float32, u32>),
-    b(tuple<u32, u32>),
+  variant casts2 {
+    a(float64),
+    b(float32),
   }
 
-  enum my-errno {
-    bad1,
-    bad2,
+  variant casts1 {
+    a(s32),
+    b(float32),
   }
 
   e1-arg: func(x: e1)
@@ -100,5 +98,5 @@ interface variants {
 }
 
 world variants-world {
-  import variants
+  import variants: self.variants
 }
diff --git a/crates/wit-component/tests/interfaces/wasi-http.wat b/crates/wit-component/tests/interfaces/wasi-http.wat
index f848e986..2a04a462 100644
--- a/crates/wit-component/tests/interfaces/wasi-http.wat
+++ b/crates/wit-component/tests/interfaces/wasi-http.wat
@@ -3,408 +3,93 @@
     (component
       (type (;0;)
         (instance
-          (type (;0;) u32)
-          (export (;1;) "pollable" (type (eq 0)))
-        )
-      )
-      (import (interface "wasi:poll/poll") (instance (;0;) (type 0)))
-      (alias export 0 "pollable" (type (;1;)))
-      (type (;2;)
-        (instance
-          (alias outer 1 1 (type (;0;)))
-          (export (;1;) "pollable" (type (eq 0)))
+          (type (;0;) (record))
+          (export (;1;) "response" (type (eq 0)))
           (type (;2;) (record))
-          (export (;3;) "stream-error" (type (eq 2)))
-          (type (;4;) u32)
-          (export (;5;) "input-stream" (type (eq 4)))
-          (type (;6;) u32)
-          (export (;7;) "output-stream" (type (eq 6)))
+          (export (;3;) "request" (type (eq 2)))
         )
       )
-      (import (interface "wasi:io/streams") (instance (;1;) (type 2)))
-      (alias export 1 "input-stream" (type (;3;)))
-      (alias export 1 "output-stream" (type (;4;)))
-      (type (;5;)
+      (export (;0;) "types" "pkg:/types/types" (instance (type 0)))
+    )
+  )
+  (export (;1;) "types" "pkg:/types" (type 0))
+  (type (;2;)
+    (component
+      (type (;0;)
         (instance
-          (alias outer 1 3 (type (;0;)))
-          (export (;1;) "input-stream" (type (eq 0)))
-          (alias outer 1 4 (type (;2;)))
-          (export (;3;) "output-stream" (type (eq 2)))
-          (alias outer 1 1 (type (;4;)))
-          (export (;5;) "pollable" (type (eq 4)))
-          (type (;6;) (variant (case "get") (case "head") (case "post") (case "put") (case "delete") (case "connect") (case "options") (case "trace") (case "patch") (case "other" string)))
-          (export (;7;) "method" (type (eq 6)))
-          (type (;8;) (variant (case "HTTP") (case "HTTPS") (case "other" string)))
-          (export (;9;) "scheme" (type (eq 8)))
-          (type (;10;) (variant (case "invalid-url" string) (case "timeout-error" string) (case "protocol-error" string) (case "unexpected-error" string)))
-          (export (;11;) "error" (type (eq 10)))
-          (type (;12;) u32)
-          (export (;13;) "fields" (type (eq 12)))
-          (export (;14;) "headers" (type (eq 13)))
-          (export (;15;) "trailers" (type (eq 13)))
-          (export (;16;) "incoming-stream" (type (eq 1)))
-          (export (;17;) "outgoing-stream" (type (eq 3)))
-          (type (;18;) u32)
-          (export (;19;) "incoming-request" (type (eq 18)))
-          (type (;20;) u32)
-          (export (;21;) "outgoing-request" (type (eq 20)))
-          (type (;22;) (option u32))
-          (type (;23;) (record (field "connect-timeout-ms" 22) (field "first-byte-timeout-ms" 22) (field "between-bytes-timeout-ms" 22)))
-          (export (;24;) "request-options" (type (eq 23)))
-          (type (;25;) u32)
-          (export (;26;) "response-outparam" (type (eq 25)))
-          (type (;27;) u16)
-          (export (;28;) "status-code" (type (eq 27)))
-          (type (;29;) u32)
-          (export (;30;) "incoming-response" (type (eq 29)))
-          (type (;31;) u32)
-          (export (;32;) "outgoing-response" (type (eq 31)))
-          (type (;33;) u32)
-          (export (;34;) "future-incoming-response" (type (eq 33)))
-          (type (;35;) (func (param "fields" 13)))
-          (export (;0;) "drop-fields" (func (type 35)))
-          (type (;36;) (tuple string string))
-          (type (;37;) (list 36))
-          (type (;38;) (func (param "entries" 37) (result 13)))
-          (export (;1;) "new-fields" (func (type 38)))
-          (type (;39;) (list string))
-          (type (;40;) (func (param "fields" 13) (param "name" string) (result 39)))
-          (export (;2;) "fields-get" (func (type 40)))
-          (type (;41;) (func (param "fields" 13) (param "name" string) (param "value" 39)))
-          (export (;3;) "fields-set" (func (type 41)))
-          (type (;42;) (func (param "fields" 13) (param "name" string)))
-          (export (;4;) "fields-delete" (func (type 42)))
-          (type (;43;) (func (param "fields" 13) (param "name" string) (param "value" string)))
-          (export (;5;) "fields-append" (func (type 43)))
-          (type (;44;) (func (param "fields" 13) (result 37)))
-          (export (;6;) "fields-entries" (func (type 44)))
-          (type (;45;) (func (param "fields" 13) (result 13)))
-          (export (;7;) "fields-clone" (func (type 45)))
-          (type (;46;) (option 15))
-          (type (;47;) (func (param "s" 16) (result 46)))
-          (export (;8;) "finish-incoming-stream" (func (type 47)))
-          (type (;48;) (func (param "s" 17) (param "trailers" 46)))
-          (export (;9;) "finish-outgoing-stream" (func (type 48)))
-          (type (;49;) (func (param "request" 19)))
-          (export (;10;) "drop-incoming-request" (func (type 49)))
-          (type (;50;) (func (param "request" 21)))
-          (export (;11;) "drop-outgoing-request" (func (type 50)))
-          (type (;51;) (func (param "request" 19) (result 7)))
-          (export (;12;) "incoming-request-method" (func (type 51)))
-          (type (;52;) (func (param "request" 19) (result string)))
-          (export (;13;) "incoming-request-path" (func (type 52)))
-          (export (;14;) "incoming-request-query" (func (type 52)))
-          (type (;53;) (option 9))
-          (type (;54;) (func (param "request" 19) (result 53)))
-          (export (;15;) "incoming-request-scheme" (func (type 54)))
-          (export (;16;) "incoming-request-authority" (func (type 52)))
-          (type (;55;) (func (param "request" 19) (result 14)))
-          (export (;17;) "incoming-request-headers" (func (type 55)))
-          (type (;56;) (result 16))
-          (type (;57;) (func (param "request" 19) (result 56)))
-          (export (;18;) "incoming-request-consume" (func (type 57)))
-          (type (;58;) (func (param "method" 7) (param "path" string) (param "query" string) (param "scheme" 53) (param "authority" string) (param "headers" 14) (result 21)))
-          (export (;19;) "new-outgoing-request" (func (type 58)))
-          (type (;59;) (result 17))
-          (type (;60;) (func (param "request" 21) (result 59)))
-          (export (;20;) "outgoing-request-write" (func (type 60)))
-          (type (;61;) (func (param "response" 26)))
-          (export (;21;) "drop-response-outparam" (func (type 61)))
-          (type (;62;) (result 32 (error 11)))
-          (type (;63;) (result))
-          (type (;64;) (func (param "param" 26) (param "response" 62) (result 63)))
-          (export (;22;) "set-response-outparam" (func (type 64)))
-          (type (;65;) (func (param "response" 30)))
-          (export (;23;) "drop-incoming-response" (func (type 65)))
-          (type (;66;) (func (param "response" 32)))
-          (export (;24;) "drop-outgoing-response" (func (type 66)))
-          (type (;67;) (func (param "response" 30) (result 28)))
-          (export (;25;) "incoming-response-status" (func (type 67)))
-          (type (;68;) (func (param "response" 30) (result 14)))
-          (export (;26;) "incoming-response-headers" (func (type 68)))
-          (type (;69;) (func (param "response" 30) (result 56)))
-          (export (;27;) "incoming-response-consume" (func (type 69)))
-          (type (;70;) (func (param "status-code" 28) (param "headers" 14) (result 32)))
-          (export (;28;) "new-outgoing-response" (func (type 70)))
-          (type (;71;) (func (param "response" 32) (result 59)))
-          (export (;29;) "outgoing-response-write" (func (type 71)))
-          (type (;72;) (func (param "f" 34)))
-          (export (;30;) "drop-future-incoming-response" (func (type 72)))
-          (type (;73;) (result 30 (error 11)))
-          (type (;74;) (option 73))
-          (type (;75;) (func (param "f" 34) (result 74)))
-          (export (;31;) "future-incoming-response-get" (func (type 75)))
-          (type (;76;) (func (param "f" 34) (result 5)))
-          (export (;32;) "listen-to-future-incoming-response" (func (type 76)))
+          (type (;0;) (record))
+          (export (;1;) "response" (type (eq 0)))
+          (type (;2;) (record))
+          (export (;3;) "request" (type (eq 2)))
         )
       )
-      (export (;2;) (interface "wasi:http/types") (instance (type 5)))
-      (alias export 2 "incoming-request" (type (;6;)))
-      (alias export 2 "response-outparam" (type (;7;)))
-      (type (;8;)
+      (import "types" "pkg:/types/types" (instance (type 0)))
+      (alias export 0 "request" (type (;1;)))
+      (alias export 0 "response" (type (;2;)))
+      (type (;3;)
         (instance
-          (alias outer 1 6 (type (;0;)))
-          (export (;1;) "incoming-request" (type (eq 0)))
-          (alias outer 1 7 (type (;2;)))
-          (export (;3;) "response-outparam" (type (eq 2)))
-          (type (;4;) (func (param "request" 1) (param "response-out" 3)))
+          (alias outer 1 1 (type (;0;)))
+          (export (;1;) "request" (type (eq 0)))
+          (alias outer 1 2 (type (;2;)))
+          (export (;3;) "response" (type (eq 2)))
+          (type (;4;) (func (param "request" 1) (result 3)))
           (export (;0;) "handle" (func (type 4)))
         )
       )
-      (export (;3;) (interface "wasi:http/incoming-handler") (instance (type 8)))
-      (alias export 2 "outgoing-request" (type (;9;)))
-      (alias export 2 "request-options" (type (;10;)))
-      (alias export 2 "future-incoming-response" (type (;11;)))
-      (type (;12;)
-        (instance
-          (alias outer 1 9 (type (;0;)))
-          (export (;1;) "outgoing-request" (type (eq 0)))
-          (alias outer 1 10 (type (;2;)))
-          (export (;3;) "request-options" (type (eq 2)))
-          (alias outer 1 11 (type (;4;)))
-          (export (;5;) "future-incoming-response" (type (eq 4)))
-          (type (;6;) (option 3))
-          (type (;7;) (func (param "request" 1) (param "options" 6) (result 5)))
-          (export (;0;) "handle" (func (type 7)))
-        )
-      )
-      (export (;4;) (interface "wasi:http/outgoing-handler") (instance (type 12)))
-      (type (;13;)
+      (export (;0;) "handler" "pkg:/handler/handler" (instance (type 3)))
+    )
+  )
+  (export (;3;) "handler" "pkg:/handler" (type 2))
+  (type (;4;)
+    (component
+      (type (;0;)
         (component
           (type (;0;)
             (instance
-              (type (;0;) (list u8))
-              (type (;1;) (func (param "len" u64) (result 0)))
-              (export (;0;) "get-random-bytes" (func (type 1)))
-              (type (;2;) (func (result u64)))
-              (export (;1;) "get-random-u64" (func (type 2)))
-              (type (;3;) (tuple u64 u64))
-              (type (;4;) (func (result 3)))
-              (export (;2;) "insecure-random" (func (type 4)))
-            )
-          )
-          (import (interface "wasi:random/random") (instance (;0;) (type 0)))
-          (type (;1;)
-            (instance
-              (type (;0;) (enum "trace" "debug" "info" "warn" "error"))
+              (type (;0;) (enum "info" "debug"))
               (export (;1;) "level" (type (eq 0)))
-              (type (;2;) (func (param "level" 1) (param "context" string) (param "message" string)))
+              (type (;2;) (func (param "level" 1) (param "msg" string)))
               (export (;0;) "log" (func (type 2)))
             )
           )
-          (import (interface "wasi:logging/handler") (instance (;1;) (type 1)))
-          (type (;2;)
-            (instance
-              (type (;0;) u32)
-              (export (;1;) "pollable" (type (eq 0)))
-              (type (;2;) (func (param "this" 1)))
-              (export (;0;) "drop-pollable" (func (type 2)))
-              (type (;3;) (list 1))
-              (type (;4;) (list u8))
-              (type (;5;) (func (param "in" 3) (result 4)))
-              (export (;1;) "poll-oneoff" (func (type 5)))
-            )
-          )
-          (import (interface "wasi:poll/poll") (instance (;2;) (type 2)))
-          (alias export 2 "pollable" (type (;3;)))
-          (type (;4;)
+          (import "console" "path:/wasi-logging/backend/backend" (instance (type 0)))
+          (type (;1;)
             (instance
-              (alias outer 1 3 (type (;0;)))
-              (export (;1;) "pollable" (type (eq 0)))
+              (type (;0;) (record))
+              (export (;1;) "response" (type (eq 0)))
               (type (;2;) (record))
-              (export (;3;) "stream-error" (type (eq 2)))
-              (type (;4;) u32)
-              (export (;5;) "input-stream" (type (eq 4)))
-              (type (;6;) u32)
-              (export (;7;) "output-stream" (type (eq 6)))
-              (type (;8;) (list u8))
-              (type (;9;) (tuple 8 bool))
-              (type (;10;) (result 9 (error 3)))
-              (type (;11;) (func (param "this" 5) (param "len" u64) (result 10)))
-              (export (;0;) "read" (func (type 11)))
-              (export (;1;) "blocking-read" (func (type 11)))
-              (type (;12;) (tuple u64 bool))
-              (type (;13;) (result 12 (error 3)))
-              (type (;14;) (func (param "this" 5) (param "len" u64) (result 13)))
-              (export (;2;) "skip" (func (type 14)))
-              (export (;3;) "blocking-skip" (func (type 14)))
-              (type (;15;) (func (param "this" 5) (result 1)))
-              (export (;4;) "subscribe-to-input-stream" (func (type 15)))
-              (type (;16;) (func (param "this" 5)))
-              (export (;5;) "drop-input-stream" (func (type 16)))
-              (type (;17;) (result u64 (error 3)))
-              (type (;18;) (func (param "this" 7) (param "buf" 8) (result 17)))
-              (export (;6;) "write" (func (type 18)))
-              (export (;7;) "blocking-write" (func (type 18)))
-              (type (;19;) (func (param "this" 7) (param "len" u64) (result 17)))
-              (export (;8;) "write-zeroes" (func (type 19)))
-              (export (;9;) "blocking-write-zeroes" (func (type 19)))
-              (type (;20;) (func (param "this" 7) (param "src" 5) (param "len" u64) (result 13)))
-              (export (;10;) "splice" (func (type 20)))
-              (export (;11;) "blocking-splice" (func (type 20)))
-              (type (;21;) (func (param "this" 7) (param "src" 5) (result 17)))
-              (export (;12;) "forward" (func (type 21)))
-              (type (;22;) (func (param "this" 7) (result 1)))
-              (export (;13;) "subscribe-to-output-stream" (func (type 22)))
-              (type (;23;) (func (param "this" 7)))
-              (export (;14;) "drop-output-stream" (func (type 23)))
-            )
-          )
-          (import (interface "wasi:io/streams") (instance (;3;) (type 4)))
-          (alias export 3 "input-stream" (type (;5;)))
-          (alias export 3 "output-stream" (type (;6;)))
-          (type (;7;)
-            (instance
-              (alias outer 1 5 (type (;0;)))
-              (export (;1;) "input-stream" (type (eq 0)))
-              (alias outer 1 6 (type (;2;)))
-              (export (;3;) "output-stream" (type (eq 2)))
-              (alias outer 1 3 (type (;4;)))
-              (export (;5;) "pollable" (type (eq 4)))
-              (type (;6;) (variant (case "get") (case "head") (case "post") (case "put") (case "delete") (case "connect") (case "options") (case "trace") (case "patch") (case "other" string)))
-              (export (;7;) "method" (type (eq 6)))
-              (type (;8;) (variant (case "HTTP") (case "HTTPS") (case "other" string)))
-              (export (;9;) "scheme" (type (eq 8)))
-              (type (;10;) (variant (case "invalid-url" string) (case "timeout-error" string) (case "protocol-error" string) (case "unexpected-error" string)))
-              (export (;11;) "error" (type (eq 10)))
-              (type (;12;) u32)
-              (export (;13;) "fields" (type (eq 12)))
-              (export (;14;) "headers" (type (eq 13)))
-              (export (;15;) "trailers" (type (eq 13)))
-              (export (;16;) "incoming-stream" (type (eq 1)))
-              (export (;17;) "outgoing-stream" (type (eq 3)))
-              (type (;18;) u32)
-              (export (;19;) "incoming-request" (type (eq 18)))
-              (type (;20;) u32)
-              (export (;21;) "outgoing-request" (type (eq 20)))
-              (type (;22;) (option u32))
-              (type (;23;) (record (field "connect-timeout-ms" 22) (field "first-byte-timeout-ms" 22) (field "between-bytes-timeout-ms" 22)))
-              (export (;24;) "request-options" (type (eq 23)))
-              (type (;25;) u32)
-              (export (;26;) "response-outparam" (type (eq 25)))
-              (type (;27;) u16)
-              (export (;28;) "status-code" (type (eq 27)))
-              (type (;29;) u32)
-              (export (;30;) "incoming-response" (type (eq 29)))
-              (type (;31;) u32)
-              (export (;32;) "outgoing-response" (type (eq 31)))
-              (type (;33;) u32)
-              (export (;34;) "future-incoming-response" (type (eq 33)))
-              (type (;35;) (func (param "fields" 13)))
-              (export (;0;) "drop-fields" (func (type 35)))
-              (type (;36;) (tuple string string))
-              (type (;37;) (list 36))
-              (type (;38;) (func (param "entries" 37) (result 13)))
-              (export (;1;) "new-fields" (func (type 38)))
-              (type (;39;) (list string))
-              (type (;40;) (func (param "fields" 13) (param "name" string) (result 39)))
-              (export (;2;) "fields-get" (func (type 40)))
-              (type (;41;) (func (param "fields" 13) (param "name" string) (param "value" 39)))
-              (export (;3;) "fields-set" (func (type 41)))
-              (type (;42;) (func (param "fields" 13) (param "name" string)))
-              (export (;4;) "fields-delete" (func (type 42)))
-              (type (;43;) (func (param "fields" 13) (param "name" string) (param "value" string)))
-              (export (;5;) "fields-append" (func (type 43)))
-              (type (;44;) (func (param "fields" 13) (result 37)))
-              (export (;6;) "fields-entries" (func (type 44)))
-              (type (;45;) (func (param "fields" 13) (result 13)))
-              (export (;7;) "fields-clone" (func (type 45)))
-              (type (;46;) (option 15))
-              (type (;47;) (func (param "s" 16) (result 46)))
-              (export (;8;) "finish-incoming-stream" (func (type 47)))
-              (type (;48;) (func (param "s" 17) (param "trailers" 46)))
-              (export (;9;) "finish-outgoing-stream" (func (type 48)))
-              (type (;49;) (func (param "request" 19)))
-              (export (;10;) "drop-incoming-request" (func (type 49)))
-              (type (;50;) (func (param "request" 21)))
-              (export (;11;) "drop-outgoing-request" (func (type 50)))
-              (type (;51;) (func (param "request" 19) (result 7)))
-              (export (;12;) "incoming-request-method" (func (type 51)))
-              (type (;52;) (func (param "request" 19) (result string)))
-              (export (;13;) "incoming-request-path" (func (type 52)))
-              (export (;14;) "incoming-request-query" (func (type 52)))
-              (type (;53;) (option 9))
-              (type (;54;) (func (param "request" 19) (result 53)))
-              (export (;15;) "incoming-request-scheme" (func (type 54)))
-              (export (;16;) "incoming-request-authority" (func (type 52)))
-              (type (;55;) (func (param "request" 19) (result 14)))
-              (export (;17;) "incoming-request-headers" (func (type 55)))
-              (type (;56;) (result 16))
-              (type (;57;) (func (param "request" 19) (result 56)))
-              (export (;18;) "incoming-request-consume" (func (type 57)))
-              (type (;58;) (func (param "method" 7) (param "path" string) (param "query" string) (param "scheme" 53) (param "authority" string) (param "headers" 14) (result 21)))
-              (export (;19;) "new-outgoing-request" (func (type 58)))
-              (type (;59;) (result 17))
-              (type (;60;) (func (param "request" 21) (result 59)))
-              (export (;20;) "outgoing-request-write" (func (type 60)))
-              (type (;61;) (func (param "response" 26)))
-              (export (;21;) "drop-response-outparam" (func (type 61)))
-              (type (;62;) (result 32 (error 11)))
-              (type (;63;) (result))
-              (type (;64;) (func (param "param" 26) (param "response" 62) (result 63)))
-              (export (;22;) "set-response-outparam" (func (type 64)))
-              (type (;65;) (func (param "response" 30)))
-              (export (;23;) "drop-incoming-response" (func (type 65)))
-              (type (;66;) (func (param "response" 32)))
-              (export (;24;) "drop-outgoing-response" (func (type 66)))
-              (type (;67;) (func (param "response" 30) (result 28)))
-              (export (;25;) "incoming-response-status" (func (type 67)))
-              (type (;68;) (func (param "response" 30) (result 14)))
-              (export (;26;) "incoming-response-headers" (func (type 68)))
-              (type (;69;) (func (param "response" 30) (result 56)))
-              (export (;27;) "incoming-response-consume" (func (type 69)))
-              (type (;70;) (func (param "status-code" 28) (param "headers" 14) (result 32)))
-              (export (;28;) "new-outgoing-response" (func (type 70)))
-              (type (;71;) (func (param "response" 32) (result 59)))
-              (export (;29;) "outgoing-response-write" (func (type 71)))
-              (type (;72;) (func (param "f" 34)))
-              (export (;30;) "drop-future-incoming-response" (func (type 72)))
-              (type (;73;) (result 30 (error 11)))
-              (type (;74;) (option 73))
-              (type (;75;) (func (param "f" 34) (result 74)))
-              (export (;31;) "future-incoming-response-get" (func (type 75)))
-              (type (;76;) (func (param "f" 34) (result 5)))
-              (export (;32;) "listen-to-future-incoming-response" (func (type 76)))
+              (export (;3;) "request" (type (eq 2)))
             )
           )
-          (import (interface "wasi:http/types") (instance (;4;) (type 7)))
-          (alias export 4 "outgoing-request" (type (;8;)))
-          (alias export 4 "request-options" (type (;9;)))
-          (alias export 4 "future-incoming-response" (type (;10;)))
-          (type (;11;)
+          (import "types" "pkg:/types/types" (instance (type 1)))
+          (alias export 1 "request" (type (;2;)))
+          (alias export 1 "response" (type (;3;)))
+          (type (;4;)
             (instance
-              (alias outer 1 8 (type (;0;)))
-              (export (;1;) "outgoing-request" (type (eq 0)))
-              (alias outer 1 9 (type (;2;)))
-              (export (;3;) "request-options" (type (eq 2)))
-              (alias outer 1 10 (type (;4;)))
-              (export (;5;) "future-incoming-response" (type (eq 4)))
-              (type (;6;) (option 3))
-              (type (;7;) (func (param "request" 1) (param "options" 6) (result 5)))
-              (export (;0;) "handle" (func (type 7)))
+              (alias outer 1 2 (type (;0;)))
+              (export (;1;) "request" (type (eq 0)))
+              (alias outer 1 3 (type (;2;)))
+              (export (;3;) "response" (type (eq 2)))
+              (type (;4;) (func (param "request" 1) (result 3)))
+              (export (;0;) "handle" (func (type 4)))
             )
           )
-          (import (interface "wasi:http/outgoing-handler") (instance (;5;) (type 11)))
-          (alias export 4 "incoming-request" (type (;12;)))
-          (alias export 4 "response-outparam" (type (;13;)))
-          (type (;14;)
+          (import "origin" "pkg:/handler/handler" (instance (type 4)))
+          (type (;5;)
             (instance
-              (alias outer 1 12 (type (;0;)))
-              (export (;1;) "incoming-request" (type (eq 0)))
-              (alias outer 1 13 (type (;2;)))
-              (export (;3;) "response-outparam" (type (eq 2)))
-              (type (;4;) (func (param "request" 1) (param "response-out" 3)))
+              (alias outer 1 2 (type (;0;)))
+              (export (;1;) "request" (type (eq 0)))
+              (alias outer 1 3 (type (;2;)))
+              (export (;3;) "response" (type (eq 2)))
+              (type (;4;) (func (param "request" 1) (result 3)))
               (export (;0;) "handle" (func (type 4)))
             )
           )
-          (export (;6;) (interface "wasi:http/incoming-handler") (instance (type 14)))
+          (export (;0;) "handler" "pkg:/handler/handler" (instance (type 5)))
         )
       )
-      (export (;0;) (interface "wasi:http/proxy") (component (type 13)))
+      (export (;0;) "proxy" "pkg:/proxy/proxy" (component (type 0)))
     )
   )
-  (@producers
-    (processed-by "wit-component" "$CARGO_PKG_VERSION")
-  )
-  (export (;1;) (interface "wasi:http/wit") (type 0))
+  (export (;5;) "proxy" "pkg:/proxy" (type 4))
 )
\ No newline at end of file
diff --git a/crates/wit-component/tests/interfaces/wasi-http/deps/io/streams.wit b/crates/wit-component/tests/interfaces/wasi-http/deps/io/streams.wit
deleted file mode 100644
index 008e36cf..00000000
--- a/crates/wit-component/tests/interfaces/wasi-http/deps/io/streams.wit
+++ /dev/null
@@ -1,215 +0,0 @@
-package wasi:io
-
-/// WASI I/O is an I/O abstraction API which is currently focused on providing
-/// stream types.
-///
-/// In the future, the component model is expected to add built-in stream types;
-/// when it does, they are expected to subsume this API.
-interface streams {
-    use wasi:poll/poll.{pollable}
-
-    /// An error type returned from a stream operation. Currently this
-    /// doesn't provide any additional information.
-    record stream-error {}
-
-    /// An input bytestream. In the future, this will be replaced by handle
-    /// types.
-    ///
-    /// This conceptually represents a `stream<u8, _>`. It's temporary
-    /// scaffolding until component-model's async features are ready.
-    ///
-    /// `input-stream`s are *non-blocking* to the extent practical on underlying
-    /// platforms. I/O operations always return promptly; if fewer bytes are
-    /// promptly available than requested, they return the number of bytes promptly
-    /// available, which could even be zero. To wait for data to be available,
-    /// use the `subscribe-to-input-stream` function to obtain a `pollable` which
-    /// can be polled for using `wasi_poll`.
-    ///
-    /// And at present, it is a `u32` instead of being an actual handle, until
-    /// the wit-bindgen implementation of handles and resources is ready.
-    ///
-    /// This [represents a resource](https://github.com/WebAssembly/WASI/blob/main/docs/WitInWasi.md#Resources).
-    type input-stream = u32
-
-    /// Read bytes from a stream.
-    ///
-    /// This function returns a list of bytes containing the data that was
-    /// read, along with a bool which, when true, indicates that the end of the
-    /// stream was reached. The returned list will contain up to `len` bytes; it
-    /// may return fewer than requested, but not more.
-    ///
-    /// Once a stream has reached the end, subsequent calls to read or
-    /// `skip` will always report end-of-stream rather than producing more
-    /// data.
-    ///
-    /// If `len` is 0, it represents a request to read 0 bytes, which should
-    /// always succeed, assuming the stream hasn't reached its end yet, and
-    /// return an empty list.
-    ///
-    /// The len here is a `u64`, but some callees may not be able to allocate
-    /// a buffer as large as that would imply.
-    /// FIXME: describe what happens if allocation fails.
-    read: func(
-        this: input-stream,
-        /// The maximum number of bytes to read
-        len: u64
-    ) -> result<tuple<list<u8>, bool>, stream-error>
-
-    /// Read bytes from a stream, with blocking.
-    ///
-    /// This is similar to `read`, except that it blocks until at least one
-    /// byte can be read.
-    blocking-read: func(
-        this: input-stream,
-        /// The maximum number of bytes to read
-        len: u64
-    ) -> result<tuple<list<u8>, bool>, stream-error>
-
-    /// Skip bytes from a stream.
-    ///
-    /// This is similar to the `read` function, but avoids copying the
-    /// bytes into the instance.
-    ///
-    /// Once a stream has reached the end, subsequent calls to read or
-    /// `skip` will always report end-of-stream rather than producing more
-    /// data.
-    ///
-    /// This function returns the number of bytes skipped, along with a bool
-    /// indicating whether the end of the stream was reached. The returned
-    /// value will be at most `len`; it may be less.
-    skip: func(
-        this: input-stream,
-        /// The maximum number of bytes to skip.
-        len: u64,
-    ) -> result<tuple<u64, bool>, stream-error>
-
-    /// Skip bytes from a stream, with blocking.
-    ///
-    /// This is similar to `skip`, except that it blocks until at least one
-    /// byte can be consumed.
-    blocking-skip: func(
-        this: input-stream,
-        /// The maximum number of bytes to skip.
-        len: u64,
-    ) -> result<tuple<u64, bool>, stream-error>
-
-    /// Create a `pollable` which will resolve once either the specified stream
-    /// has bytes available to read or the other end of the stream has been
-    /// closed.
-    subscribe-to-input-stream: func(this: input-stream) -> pollable
-
-    /// Dispose of the specified `input-stream`, after which it may no longer
-    /// be used.
-    drop-input-stream: func(this: input-stream)
-
-    /// An output bytestream. In the future, this will be replaced by handle
-    /// types.
-    ///
-    /// This conceptually represents a `stream<u8, _>`. It's temporary
-    /// scaffolding until component-model's async features are ready.
-    ///
-    /// `output-stream`s are *non-blocking* to the extent practical on
-    /// underlying platforms. Except where specified otherwise, I/O operations also
-    /// always return promptly, after the number of bytes that can be written
-    /// promptly, which could even be zero. To wait for the stream to be ready to
-    /// accept data, the `subscribe-to-output-stream` function to obtain a
-    /// `pollable` which can be polled for using `wasi_poll`.
-    ///
-    /// And at present, it is a `u32` instead of being an actual handle, until
-    /// the wit-bindgen implementation of handles and resources is ready.
-    ///
-    /// This [represents a resource](https://github.com/WebAssembly/WASI/blob/main/docs/WitInWasi.md#Resources).
-    type output-stream = u32
-
-    /// Write bytes to a stream.
-    ///
-    /// This function returns a `u64` indicating the number of bytes from
-    /// `buf` that were written; it may be less than the full list.
-    write: func(
-        this: output-stream,
-        /// Data to write
-        buf: list<u8>
-    ) -> result<u64, stream-error>
-
-    /// Write bytes to a stream, with blocking.
-    ///
-    /// This is similar to `write`, except that it blocks until at least one
-    /// byte can be written.
-    blocking-write: func(
-        this: output-stream,
-        /// Data to write
-        buf: list<u8>
-    ) -> result<u64, stream-error>
-
-    /// Write multiple zero bytes to a stream.
-    ///
-    /// This function returns a `u64` indicating the number of zero bytes
-    /// that were written; it may be less than `len`.
-    write-zeroes: func(
-        this: output-stream,
-        /// The number of zero bytes to write
-        len: u64
-    ) -> result<u64, stream-error>
-
-    /// Write multiple zero bytes to a stream, with blocking.
-    ///
-    /// This is similar to `write-zeroes`, except that it blocks until at least
-    /// one byte can be written.
-    blocking-write-zeroes: func(
-        this: output-stream,
-        /// The number of zero bytes to write
-        len: u64
-    ) -> result<u64, stream-error>
-
-    /// Read from one stream and write to another.
-    ///
-    /// This function returns the number of bytes transferred; it may be less
-    /// than `len`.
-    ///
-    /// Unlike other I/O functions, this function blocks until all the data
-    /// read from the input stream has been written to the output stream.
-    splice: func(
-        this: output-stream,
-        /// The stream to read from
-        src: input-stream,
-        /// The number of bytes to splice
-        len: u64,
-    ) -> result<tuple<u64, bool>, stream-error>
-
-    /// Read from one stream and write to another, with blocking.
-    ///
-    /// This is similar to `splice`, except that it blocks until at least
-    /// one byte can be read.
-    blocking-splice: func(
-        this: output-stream,
-        /// The stream to read from
-        src: input-stream,
-        /// The number of bytes to splice
-        len: u64,
-    ) -> result<tuple<u64, bool>, stream-error>
-
-    /// Forward the entire contents of an input stream to an output stream.
-    ///
-    /// This function repeatedly reads from the input stream and writes
-    /// the data to the output stream, until the end of the input stream
-    /// is reached, or an error is encountered.
-    ///
-    /// Unlike other I/O functions, this function blocks until the end
-    /// of the input stream is seen and all the data has been written to
-    /// the output stream.
-    ///
-    /// This function returns the number of bytes transferred.
-    forward: func(
-        this: output-stream,
-        /// The stream to read from
-        src: input-stream
-    ) -> result<u64, stream-error>
-
-    /// Create a `pollable` which will resolve once either the specified stream
-    /// is ready to accept bytes or the other end of the stream has been closed.
-    subscribe-to-output-stream: func(this: output-stream) -> pollable
-
-    /// Dispose of the specified `output-stream`, after which it may no longer
-    /// be used.
-    drop-output-stream: func(this: output-stream)
-}
diff --git a/crates/wit-component/tests/interfaces/wasi-http/deps/logging/handler.wit b/crates/wit-component/tests/interfaces/wasi-http/deps/logging/handler.wit
deleted file mode 100644
index e6b077be..00000000
--- a/crates/wit-component/tests/interfaces/wasi-http/deps/logging/handler.wit
+++ /dev/null
@@ -1,34 +0,0 @@
-package wasi:logging
-
-/// WASI Logging is a logging API intended to let users emit log messages with
-/// simple priority levels and context values.
-interface handler {
-    /// A log level, describing a kind of message.
-    enum level {
-       /// Describes messages about the values of variables and the flow of
-       /// control within a program.
-       trace,
-
-       /// Describes messages likely to be of interest to someone debugging a
-       /// program.
-       debug,
-
-       /// Describes messages likely to be of interest to someone monitoring a
-       /// program.
-       info,
-
-       /// Describes messages indicating hazardous situations.
-       warn,
-
-       /// Describes messages indicating serious errors.
-       error,
-    }
-
-    /// Emit a log message.
-    ///
-    /// A log message has a `level` describing what kind of message is being
-    /// sent, a context, which is an uninterpreted string meant to help
-    /// consumers group similar messages, and a string containing the message
-    /// text.
-    log: func(level: level, context: string, message: string)
-}
diff --git a/crates/wit-component/tests/interfaces/wasi-http/deps/poll/poll.wit b/crates/wit-component/tests/interfaces/wasi-http/deps/poll/poll.wit
deleted file mode 100644
index cf5d8779..00000000
--- a/crates/wit-component/tests/interfaces/wasi-http/deps/poll/poll.wit
+++ /dev/null
@@ -1,41 +0,0 @@
-package wasi:poll
-
-/// A poll API intended to let users wait for I/O events on multiple handles
-/// at once.
-interface poll {
-    /// A "pollable" handle.
-    ///
-    /// This is conceptually represents a `stream<_, _>`, or in other words,
-    /// a stream that one can wait on, repeatedly, but which does not itself
-    /// produce any data. It's temporary scaffolding until component-model's
-    /// async features are ready.
-    ///
-    /// And at present, it is a `u32` instead of being an actual handle, until
-    /// the wit-bindgen implementation of handles and resources is ready.
-    ///
-    /// `pollable` lifetimes are not automatically managed. Users must ensure
-    /// that they do not outlive the resource they reference.
-    ///
-    /// This [represents a resource](https://github.com/WebAssembly/WASI/blob/main/docs/WitInWasi.md#Resources).
-    type pollable = u32
-
-    /// Dispose of the specified `pollable`, after which it may no longer
-    /// be used.
-    drop-pollable: func(this: pollable)
-
-    /// Poll for completion on a set of pollables.
-    ///
-    /// The "oneoff" in the name refers to the fact that this function must do a
-    /// linear scan through the entire list of subscriptions, which may be
-    /// inefficient if the number is large and the same subscriptions are used
-    /// many times. In the future, this is expected to be obsoleted by the
-    /// component model async proposal, which will include a scalable waiting
-    /// facility.
-    ///
-    /// Note that the return type would ideally be `list<bool>`, but that would
-    /// be more difficult to polyfill given the current state of `wit-bindgen`.
-    /// See <https://github.com/bytecodealliance/preview2-prototyping/pull/11#issuecomment-1329873061>
-    /// for details.  For now, we use zero to mean "not ready" and non-zero to
-    /// mean "ready".
-    poll-oneoff: func(in: list<pollable>) -> list<u8>
-}
diff --git a/crates/wit-component/tests/interfaces/wasi-http/deps/random/random.wit b/crates/wit-component/tests/interfaces/wasi-http/deps/random/random.wit
deleted file mode 100644
index f956798d..00000000
--- a/crates/wit-component/tests/interfaces/wasi-http/deps/random/random.wit
+++ /dev/null
@@ -1,44 +0,0 @@
-package wasi:random
-
-/// WASI Random is a random data API.
-///
-/// It is intended to be portable at least between Unix-family platforms and
-/// Windows.
-interface random {
-    /// Return `len` cryptographically-secure pseudo-random bytes.
-    ///
-    /// This function must produce data from an adequately seeded
-    /// cryptographically-secure pseudo-random number generator (CSPRNG), so it
-    /// must not block, from the perspective of the calling program, and the
-    /// returned data is always unpredictable.
-    ///
-    /// This function must always return fresh pseudo-random data. Deterministic
-    /// environments must omit this function, rather than implementing it with
-    /// deterministic data.
-    get-random-bytes: func(len: u64) -> list<u8>
-
-    /// Return a cryptographically-secure pseudo-random `u64` value.
-    ///
-    /// This function returns the same type of pseudo-random data as
-    /// `get-random-bytes`, represented as a `u64`.
-    get-random-u64: func() -> u64
-
-    /// Return a 128-bit value that may contain a pseudo-random value.
-    ///
-    /// The returned value is not required to be computed from a CSPRNG, and may
-    /// even be entirely deterministic. Host implementations are encouraged to
-    /// provide pseudo-random values to any program exposed to
-    /// attacker-controlled content, to enable DoS protection built into many
-    /// languages' hash-map implementations.
-    ///
-    /// This function is intended to only be called once, by a source language
-    /// to initialize Denial Of Service (DoS) protection in its hash-map
-    /// implementation.
-    ///
-    /// # Expected future evolution
-    ///
-    /// This will likely be changed to a value import, to prevent it from being
-    /// called multiple times and potentially used for purposes other than DoS
-    /// protection.
-    insecure-random: func() -> tuple<u64, u64>
-}
diff --git a/crates/wit-component/tests/interfaces/wasi-http/deps/wasi-logging/backend.wit b/crates/wit-component/tests/interfaces/wasi-http/deps/wasi-logging/backend.wit
new file mode 100644
index 00000000..e3293d51
--- /dev/null
+++ b/crates/wit-component/tests/interfaces/wasi-http/deps/wasi-logging/backend.wit
@@ -0,0 +1,8 @@
+default interface backend {
+  enum level {
+    info,
+    debug,
+  }
+
+  log: func(level: level, msg: string)
+}
diff --git a/crates/wit-component/tests/interfaces/wasi-http/deps/wasi-logging/backend.wit.print b/crates/wit-component/tests/interfaces/wasi-http/deps/wasi-logging/backend.wit.print
new file mode 100644
index 00000000..9833d6f7
--- /dev/null
+++ b/crates/wit-component/tests/interfaces/wasi-http/deps/wasi-logging/backend.wit.print
@@ -0,0 +1,9 @@
+interface backend {
+  enum level {
+    info,
+    debug,
+  }
+
+  log: func(level: level, msg: string)
+}
+
diff --git a/crates/wit-component/tests/interfaces/wasi-http/handler.wit b/crates/wit-component/tests/interfaces/wasi-http/handler.wit
new file mode 100644
index 00000000..873938d7
--- /dev/null
+++ b/crates/wit-component/tests/interfaces/wasi-http/handler.wit
@@ -0,0 +1,4 @@
+default interface handler {
+  use pkg.types.{request, response}
+  handle: func(request: request) -> response
+}
diff --git a/crates/wit-component/tests/interfaces/wasi-http/handler.wit.print b/crates/wit-component/tests/interfaces/wasi-http/handler.wit.print
new file mode 100644
index 00000000..70836e29
--- /dev/null
+++ b/crates/wit-component/tests/interfaces/wasi-http/handler.wit.print
@@ -0,0 +1,5 @@
+interface handler {
+  use pkg.types.types.{request, response}
+  handle: func(request: request) -> response
+}
+
diff --git a/crates/wit-component/tests/interfaces/wasi-http/http.wit.print b/crates/wit-component/tests/interfaces/wasi-http/http.wit.print
deleted file mode 100644
index d47d8aeb..00000000
--- a/crates/wit-component/tests/interfaces/wasi-http/http.wit.print
+++ /dev/null
@@ -1,151 +0,0 @@
-package wasi:http
-
-interface types {
-  use wasi:io/streams.{input-stream, output-stream}
-  use wasi:poll/poll.{pollable}
-
-  variant method {
-    get,
-    head,
-    post,
-    put,
-    delete,
-    connect,
-    options,
-    trace,
-    patch,
-    other(string),
-  }
-
-  variant scheme {
-    HTTP,
-    HTTPS,
-    other(string),
-  }
-
-  variant error {
-    invalid-url(string),
-    timeout-error(string),
-    protocol-error(string),
-    unexpected-error(string),
-  }
-
-  type fields = u32
-
-  type headers = fields
-
-  type trailers = fields
-
-  type incoming-stream = input-stream
-
-  type outgoing-stream = output-stream
-
-  type incoming-request = u32
-
-  type outgoing-request = u32
-
-  record request-options {
-    connect-timeout-ms: option<u32>,
-    first-byte-timeout-ms: option<u32>,
-    between-bytes-timeout-ms: option<u32>,
-  }
-
-  type response-outparam = u32
-
-  type status-code = u16
-
-  type incoming-response = u32
-
-  type outgoing-response = u32
-
-  type future-incoming-response = u32
-
-  drop-fields: func(fields: fields)
-
-  new-fields: func(entries: list<tuple<string, string>>) -> fields
-
-  fields-get: func(fields: fields, name: string) -> list<string>
-
-  fields-set: func(fields: fields, name: string, value: list<string>)
-
-  fields-delete: func(fields: fields, name: string)
-
-  fields-append: func(fields: fields, name: string, value: string)
-
-  fields-entries: func(fields: fields) -> list<tuple<string, string>>
-
-  fields-clone: func(fields: fields) -> fields
-
-  finish-incoming-stream: func(s: incoming-stream) -> option<trailers>
-
-  finish-outgoing-stream: func(s: outgoing-stream, trailers: option<trailers>)
-
-  drop-incoming-request: func(request: incoming-request)
-
-  drop-outgoing-request: func(request: outgoing-request)
-
-  incoming-request-method: func(request: incoming-request) -> method
-
-  incoming-request-path: func(request: incoming-request) -> string
-
-  incoming-request-query: func(request: incoming-request) -> string
-
-  incoming-request-scheme: func(request: incoming-request) -> option<scheme>
-
-  incoming-request-authority: func(request: incoming-request) -> string
-
-  incoming-request-headers: func(request: incoming-request) -> headers
-
-  incoming-request-consume: func(request: incoming-request) -> result<incoming-stream>
-
-  new-outgoing-request: func(method: method, path: string, query: string, scheme: option<scheme>, authority: string, headers: headers) -> outgoing-request
-
-  outgoing-request-write: func(request: outgoing-request) -> result<outgoing-stream>
-
-  drop-response-outparam: func(response: response-outparam)
-
-  set-response-outparam: func(param: response-outparam, response: result<outgoing-response, error>) -> result
-
-  drop-incoming-response: func(response: incoming-response)
-
-  drop-outgoing-response: func(response: outgoing-response)
-
-  incoming-response-status: func(response: incoming-response) -> status-code
-
-  incoming-response-headers: func(response: incoming-response) -> headers
-
-  incoming-response-consume: func(response: incoming-response) -> result<incoming-stream>
-
-  new-outgoing-response: func(status-code: status-code, headers: headers) -> outgoing-response
-
-  outgoing-response-write: func(response: outgoing-response) -> result<outgoing-stream>
-
-  drop-future-incoming-response: func(f: future-incoming-response)
-
-  future-incoming-response-get: func(f: future-incoming-response) -> option<result<incoming-response, error>>
-
-  listen-to-future-incoming-response: func(f: future-incoming-response) -> pollable
-}
-
-interface incoming-handler {
-  use types.{incoming-request, response-outparam}
-
-  handle: func(request: incoming-request, response-out: response-outparam)
-}
-
-interface outgoing-handler {
-  use types.{outgoing-request, request-options, future-incoming-response}
-
-  handle: func(request: outgoing-request, options: option<request-options>) -> future-incoming-response
-}
-
-world proxy {
-  import wasi:random/random
-  import wasi:logging/handler
-  import wasi:poll/poll
-  import wasi:io/streams
-  import types
-  import outgoing-handler
-
-  export incoming-handler
-}
diff --git a/crates/wit-component/tests/interfaces/wasi-http/incoming-handler.wit b/crates/wit-component/tests/interfaces/wasi-http/incoming-handler.wit
deleted file mode 100644
index f98429fe..00000000
--- a/crates/wit-component/tests/interfaces/wasi-http/incoming-handler.wit
+++ /dev/null
@@ -1,26 +0,0 @@
-// The `wasi:http/incoming-handler` interface is meant to be exported by
-// components and called by the host in response to a new incoming HTTP
-// response.
-//
-//   NOTE: in Preview3, this interface will be merged with
-//   `wasi:http/outgoing-handler` into a single `wasi:http/handler` interface
-//   that takes a `request` parameter and returns a `response` result.
-//
-interface incoming-handler {
-  use types.{incoming-request, response-outparam}
-
-  // The `handle` function takes an outparam instead of returning its response
-  // so that the component may stream its response while streaming any other
-  // request or response bodies. The callee MUST write a response to the
-  // `response-out` and then finish the response before returning. The caller
-  // is expected to start streaming the response once `set-response-outparam`
-  // is called and finish streaming the response when `drop-response-outparam`
-  // is called. The `handle` function is then allowed to continue executing
-  // any post-response logic before returning. While this post-response
-  // execution is taken off the critical path, since there is no return value,
-  // there is no way to report its success or failure.
-  handle: func(
-    request: incoming-request,
-    response-out: response-outparam
-  )
-}
diff --git a/crates/wit-component/tests/interfaces/wasi-http/outgoing-handler.wit b/crates/wit-component/tests/interfaces/wasi-http/outgoing-handler.wit
deleted file mode 100644
index 06c8e469..00000000
--- a/crates/wit-component/tests/interfaces/wasi-http/outgoing-handler.wit
+++ /dev/null
@@ -1,18 +0,0 @@
-// The `wasi:http/outgoing-handler` interface is meant to be imported by
-// components and implemented by the host.
-//
-//   NOTE: in Preview3, this interface will be merged with
-//   `wasi:http/outgoing-handler` into a single `wasi:http/handler` interface
-//   that takes a `request` parameter and returns a `response` result.
-//
-interface outgoing-handler {
-  use types.{outgoing-request, request-options, future-incoming-response}
-
-  // The parameter and result types of the `handle` function allow the caller
-  // to concurrently stream the bodies of the outgoing request and the incoming
-  // response.
-  handle: func(
-    request: outgoing-request,
-    options: option<request-options>
-  ) -> future-incoming-response
-}
diff --git a/crates/wit-component/tests/interfaces/wasi-http/proxy.wit b/crates/wit-component/tests/interfaces/wasi-http/proxy.wit
index a0330490..2651e5fe 100644
--- a/crates/wit-component/tests/interfaces/wasi-http/proxy.wit
+++ b/crates/wit-component/tests/interfaces/wasi-http/proxy.wit
@@ -1,24 +1,5 @@
-// The `wasi:http/proxy` world captures a widely-implementable intersection of
-// hosts that includes HTTP forward and reverse proxies. Components targeting
-// this world may concurrently stream in and out any number of incoming and
-// outgoing HTTP requests.
-world proxy {
-  // HTTP proxies have access to time and randomness.
-  import wasi:random/random
-  // TODO: add `import wall-clock: clocks.wall-clock`
-  // TODO: add `import monotonic-clock: clocks.monotonic-clock`
-
-  // This is the default logging handler to use when user code simply wants to
-  // log to a developer-facing console (e.g., via `console.log()`).
-  import wasi:logging/handler
-
-  // This is the default handler to use when user code simply wants to make an
-  // HTTP request (e.g., via `fetch()`).
-  import outgoing-handler
-
-  // The host delivers incoming HTTP requests to a component by calling the
-  // `handle` function of this exported interface. A host may arbitrarily reuse
-  // or not reuse component instance when delivering incoming HTTP requests and
-  // thus a component must be able to handle 0..N calls to `handle`.
-  export incoming-handler
+default world proxy {
+  import console: wasi-logging.backend
+  import origin: pkg.handler
+  export handler: pkg.handler
 }
diff --git a/crates/wit-component/tests/interfaces/wasi-http/proxy.wit.print b/crates/wit-component/tests/interfaces/wasi-http/proxy.wit.print
new file mode 100644
index 00000000..9d2d081c
--- /dev/null
+++ b/crates/wit-component/tests/interfaces/wasi-http/proxy.wit.print
@@ -0,0 +1,6 @@
+world proxy {
+  import console: wasi-logging.backend.backend
+  import types: pkg.types.types
+  import origin: pkg.handler.handler
+  export handler: pkg.handler.handler
+}
diff --git a/crates/wit-component/tests/interfaces/wasi-http/types.wit b/crates/wit-component/tests/interfaces/wasi-http/types.wit
index 09cd3742..9f55e779 100644
--- a/crates/wit-component/tests/interfaces/wasi-http/types.wit
+++ b/crates/wit-component/tests/interfaces/wasi-http/types.wit
@@ -1,159 +1,4 @@
-package wasi:http
-
-// The `wasi:http/types` interface is meant to be imported by components to
-// define the HTTP resource types and operations used by the component's
-// imported and exported interfaces.
-interface types {
-  use wasi:io/streams.{input-stream, output-stream}
-  use wasi:poll/poll.{pollable}
-
-  // This type corresponds to HTTP standard Methods.
-  variant method {
-    get,
-    head,
-    post,
-    put,
-    delete,
-    connect,
-    options,
-    trace,
-    patch,
-    other(string)
-  }
-
-  // This type corresponds to HTTP standard Related Schemes.
-  variant scheme {
-    HTTP,
-    HTTPS,
-    other(string)
-  }
-
-  // TODO: perhaps better align with HTTP semantics?
-  // This type enumerates the different kinds of errors that may occur when
-  // initially returning a response.
-  variant error {
-      invalid-url(string),
-      timeout-error(string),
-      protocol-error(string),
-      unexpected-error(string)
-  }
-
-  // This following block defines the `fields` resource which corresponds to
-  // HTTP standard Fields. Soon, when resource types are added, the `type
-  // fields = u32` type alias can be replaced by a proper `resource fields`
-  // definition containing all the functions using the method syntactic sugar.
-  type fields = u32
-  drop-fields: func(fields: fields)
-  new-fields: func(entries: list<tuple<string,string>>) -> fields
-  fields-get: func(fields: fields, name: string) -> list<string>
-  fields-set: func(fields: fields, name: string, value: list<string>)
-  fields-delete: func(fields: fields, name: string)
-  fields-append: func(fields: fields, name: string, value: string)
-  fields-entries: func(fields: fields) -> list<tuple<string,string>>
-  fields-clone: func(fields: fields) -> fields
-
-  type headers = fields
-  type trailers = fields
-
-  // The following block defines stream types which corresponds to the HTTP
-  // standard Contents and Trailers. With Preview3, all of these fields can be
-  // replaced by a stream<u8, option<trailers>>. In the interim, we need to
-  // build on separate resource types defined by `wasi:io/streams`. The
-  // `finish-` functions emulate the stream's result value and MUST be called
-  // exactly once after the final read/write from/to the stream before dropping
-  // the stream.
-  type incoming-stream = input-stream
-  type outgoing-stream = output-stream
-  finish-incoming-stream: func(s: incoming-stream) -> option<trailers>
-  finish-outgoing-stream: func(s: outgoing-stream, trailers: option<trailers>)
-
-  // The following block defines the `incoming-request` and `outgoing-request`
-  // resource types that correspond to HTTP standard Requests. Soon, when
-  // resource types are added, the `u32` type aliases can be replaced by
-  // proper `resource` type definitions containing all the functions as
-  // methods. Later, Preview2 will allow both types to be merged together into
-  // a single `request` type (that uses the single `stream` type mentioned
-  // above). The `consume` and `write` methods may only be called once (and
-  // return failure thereafter).
-  type incoming-request = u32
-  type outgoing-request = u32
-  drop-incoming-request: func(request: incoming-request)
-  drop-outgoing-request: func(request: outgoing-request)
-  incoming-request-method: func(request: incoming-request) -> method
-  incoming-request-path: func(request: incoming-request) -> string
-  incoming-request-query: func(request: incoming-request) -> string
-  incoming-request-scheme: func(request: incoming-request) -> option<scheme>
-  incoming-request-authority: func(request: incoming-request) -> string
-  incoming-request-headers: func(request: incoming-request) -> headers
-  incoming-request-consume: func(request: incoming-request) -> result<incoming-stream>
-  new-outgoing-request: func(
-    method: method,
-    path: string,
-    query: string,
-    scheme: option<scheme>,
-    authority: string,
-    headers: headers
-  ) -> outgoing-request
-  outgoing-request-write: func(request: outgoing-request) -> result<outgoing-stream>
-
-  // Additional optional parameters that can be set when making a request.
-  record request-options {
-    // The following timeouts are specific to the HTTP protocol and work
-    // independently of the overall timeouts passed to `io.poll.poll-oneoff`.
-
-    // The timeout for the initial connect.
-    connect-timeout-ms: option<u32>,
-
-    // The timeout for receiving the first byte of the response body.
-    first-byte-timeout-ms: option<u32>,
-
-    // The timeout for receiving the next chunk of bytes in the response body
-    // stream.
-    between-bytes-timeout-ms: option<u32>
-  }
-
-  // The following block defines a special resource type used by the
-  // `wasi:http/incoming-handler` interface. When resource types are added, this
-  // block can be replaced by a proper `resource response-outparam { ... }`
-  // definition. Later, with Preview3, the need for an outparam goes away entirely
-  // (the `wasi:http/handler` interface used for both incoming and outgoing can
-  // simply return a `stream`).
-  type response-outparam = u32
-  drop-response-outparam: func(response: response-outparam)
-  set-response-outparam: func(param: response-outparam, response: result<outgoing-response, error>) -> result
-
-  // This type corresponds to the HTTP standard Status Code.
-  type status-code = u16
-
-  // The following block defines the `incoming-response` and `outgoing-response`
-  // resource types that correspond to HTTP standard Responses. Soon, when
-  // resource types are added, the `u32` type aliases can be replaced by proper
-  // `resource` type definitions containing all the functions as methods. Later,
-  // Preview2 will allow both types to be merged together into a single `response`
-  // type (that uses the single `stream` type mentioned above). The `consume` and
-  // `write` methods may only be called once (and return failure thereafter).
-  type incoming-response = u32
-  type outgoing-response = u32
-  drop-incoming-response: func(response: incoming-response)
-  drop-outgoing-response: func(response: outgoing-response)
-  incoming-response-status: func(response: incoming-response) -> status-code
-  incoming-response-headers: func(response: incoming-response) -> headers
-  incoming-response-consume: func(response: incoming-response) -> result<incoming-stream>
-  new-outgoing-response: func(
-    status-code: status-code,
-    headers: headers
-  ) -> outgoing-response
-  outgoing-response-write: func(response: outgoing-response) -> result<outgoing-stream>
-
-  // The following block defines a special resource type used by the
-  // `wasi:http/outgoing-handler` interface to emulate
-  // `future<result<response, error>>` in advance of Preview3. Given a
-  // `future-incoming-response`, the client can call the non-blocking `get`
-  // method to get the result if it is available. If the result is not available,
-  // the client can call `listen` to get a `pollable` that can be passed to
-  // `io.poll.poll-oneoff`.
-  type future-incoming-response = u32
-  drop-future-incoming-response: func(f: future-incoming-response)
-  future-incoming-response-get: func(f: future-incoming-response) -> option<result<incoming-response, error>>
-  listen-to-future-incoming-response: func(f: future-incoming-response) -> pollable
+default interface types {
+  record request {  }
+  record response {  }
 }
diff --git a/crates/wit-component/tests/interfaces/wasi-http/types.wit.print b/crates/wit-component/tests/interfaces/wasi-http/types.wit.print
new file mode 100644
index 00000000..f54e85cd
--- /dev/null
+++ b/crates/wit-component/tests/interfaces/wasi-http/types.wit.print
@@ -0,0 +1,9 @@
+interface types {
+  record response {
+  }
+
+  record request {
+  }
+
+}
+
diff --git a/crates/wit-component/tests/interfaces/world-inline-interface.wat b/crates/wit-component/tests/interfaces/world-inline-interface.wat
index 860e0173..782ecd44 100644
--- a/crates/wit-component/tests/interfaces/world-inline-interface.wat
+++ b/crates/wit-component/tests/interfaces/world-inline-interface.wat
@@ -6,18 +6,15 @@
           (type (;0;)
             (instance)
           )
-          (import "foo" (instance (;0;) (type 0)))
+          (import "foo" (instance (type 0)))
           (type (;1;)
             (instance)
           )
-          (export (;1;) "bar" (instance (type 1)))
+          (export (;0;) "bar" (instance (type 1)))
         )
       )
-      (export (;0;) (interface "foo:foo/has-inline") (component (type 0)))
+      (export (;0;) "has-inline" "pkg:/world-inline-interface/has-inline" (component (type 0)))
     )
   )
-  (@producers
-    (processed-by "wit-component" "$CARGO_PKG_VERSION")
-  )
-  (export (;1;) (interface "foo:foo/wit") (type 0))
+  (export (;1;) "world-inline-interface" "pkg:/world-inline-interface" (type 0))
 )
\ No newline at end of file
diff --git a/crates/wit-component/tests/interfaces/world-inline-interface.wit b/crates/wit-component/tests/interfaces/world-inline-interface.wit
index 7c4a6338..9940392e 100644
--- a/crates/wit-component/tests/interfaces/world-inline-interface.wit
+++ b/crates/wit-component/tests/interfaces/world-inline-interface.wit
@@ -1,5 +1,3 @@
-package foo:foo
-
 world has-inline {
   import foo: interface {}
   export bar: interface {}
diff --git a/crates/wit-component/tests/interfaces/world-inline-interface.wit.print b/crates/wit-component/tests/interfaces/world-inline-interface.wit.print
index ede6fa0a..33ec54b0 100644
--- a/crates/wit-component/tests/interfaces/world-inline-interface.wit.print
+++ b/crates/wit-component/tests/interfaces/world-inline-interface.wit.print
@@ -1,9 +1,6 @@
-package foo:foo
-
 world has-inline {
   import foo: interface {
   }
-
   export bar: interface {
   }
 }
diff --git a/crates/wit-component/tests/interfaces/world-pkg-conflict.wat b/crates/wit-component/tests/interfaces/world-pkg-conflict.wat
deleted file mode 100644
index d671aadd..00000000
--- a/crates/wit-component/tests/interfaces/world-pkg-conflict.wat
+++ /dev/null
@@ -1,29 +0,0 @@
-(component
-  (type (;0;)
-    (component
-      (type (;0;)
-        (instance
-          (type (;0;) u32)
-          (export (;1;) "t" (type (eq 0)))
-        )
-      )
-      (export (;0;) (interface "foo:foo/a") (instance (type 0)))
-      (alias export 0 "t" (type (;1;)))
-      (type (;2;)
-        (instance
-          (alias outer 1 1 (type (;0;)))
-          (export (;1;) "t" (type (eq 0)))
-        )
-      )
-      (export (;1;) (interface "foo:foo/foo") (instance (type 2)))
-      (type (;3;)
-        (component)
-      )
-      (export (;0;) (interface "foo:foo/c") (component (type 3)))
-    )
-  )
-  (@producers
-    (processed-by "wit-component" "$CARGO_PKG_VERSION")
-  )
-  (export (;1;) (interface "foo:foo/wit") (type 0))
-)
\ No newline at end of file
diff --git a/crates/wit-component/tests/interfaces/world-pkg-conflict/bar.wit b/crates/wit-component/tests/interfaces/world-pkg-conflict/bar.wit
deleted file mode 100644
index 3e09d4d2..00000000
--- a/crates/wit-component/tests/interfaces/world-pkg-conflict/bar.wit
+++ /dev/null
@@ -1,3 +0,0 @@
-interface a {
-  type t = u32
-}
diff --git a/crates/wit-component/tests/interfaces/world-pkg-conflict/foo.wit b/crates/wit-component/tests/interfaces/world-pkg-conflict/foo.wit
deleted file mode 100644
index c34d99d3..00000000
--- a/crates/wit-component/tests/interfaces/world-pkg-conflict/foo.wit
+++ /dev/null
@@ -1,9 +0,0 @@
-package foo:foo
-
-world c {
-
-}
-
-interface foo {
-  use a.{t}
-}
diff --git a/crates/wit-component/tests/interfaces/world-pkg-conflict/foo.wit.print b/crates/wit-component/tests/interfaces/world-pkg-conflict/foo.wit.print
deleted file mode 100644
index ffc2995e..00000000
--- a/crates/wit-component/tests/interfaces/world-pkg-conflict/foo.wit.print
+++ /dev/null
@@ -1,12 +0,0 @@
-package foo:foo
-
-interface a {
-  type t = u32
-}
-
-interface foo {
-  use a.{t}
-}
-
-world c {
-}
diff --git a/crates/wit-component/tests/interfaces/world-top-level.wat b/crates/wit-component/tests/interfaces/world-top-level.wat
index 39fe9a9d..9c0dca06 100644
--- a/crates/wit-component/tests/interfaces/world-top-level.wat
+++ b/crates/wit-component/tests/interfaces/world-top-level.wat
@@ -3,42 +3,39 @@
     (component
       (type (;0;)
         (component
-          (type (;0;)
-            (instance)
-          )
-          (import "some-interface" (instance (;0;) (type 0)))
-          (type (;1;) (func))
-          (import "foo" (func (;0;) (type 1)))
-          (type (;2;) (func (param "arg" u32)))
-          (import "bar" (func (;1;) (type 2)))
-          (type (;3;)
-            (instance)
-          )
-          (export (;1;) "another-interface" (instance (type 3)))
-          (export (;2;) "foo2" (func (type 1)))
-          (type (;4;) (func (result u32)))
-          (export (;3;) "bar2" (func (type 4)))
+          (type (;0;) (func))
+          (import "foo" (func (type 0)))
         )
       )
-      (export (;0;) (interface "foo:foo/foo") (component (type 0)))
+      (export (;0;) "just-import" "pkg:/world-top-level/just-import" (component (type 0)))
       (type (;1;)
         (component
           (type (;0;) (func))
-          (import "foo" (func (;0;) (type 0)))
+          (export (;0;) "foo" (func (type 0)))
         )
       )
-      (export (;1;) (interface "foo:foo/just-import") (component (type 1)))
+      (export (;1;) "just-export" "pkg:/world-top-level/just-export" (component (type 1)))
       (type (;2;)
         (component
-          (type (;0;) (func))
-          (export (;0;) "foo" (func (type 0)))
+          (type (;0;)
+            (instance)
+          )
+          (import "some-interface" (instance (type 0)))
+          (type (;1;) (func))
+          (import "foo" (func (type 1)))
+          (type (;2;) (func (param "arg" u32)))
+          (import "bar" (func (type 2)))
+          (type (;3;)
+            (instance)
+          )
+          (export (;0;) "another-interface" (instance (type 3)))
+          (export (;0;) "foo2" (func (type 1)))
+          (type (;4;) (func (result u32)))
+          (export (;1;) "bar2" (func (type 4)))
         )
       )
-      (export (;2;) (interface "foo:foo/just-export") (component (type 2)))
+      (export (;2;) "foo" "pkg:/world-top-level/foo" (component (type 2)))
     )
   )
-  (@producers
-    (processed-by "wit-component" "$CARGO_PKG_VERSION")
-  )
-  (export (;1;) (interface "foo:foo/wit") (type 0))
+  (export (;1;) "world-top-level" "pkg:/world-top-level" (type 0))
 )
\ No newline at end of file
diff --git a/crates/wit-component/tests/interfaces/world-top-level.wit b/crates/wit-component/tests/interfaces/world-top-level.wit
index c3107da9..58e891e1 100644
--- a/crates/wit-component/tests/interfaces/world-top-level.wit
+++ b/crates/wit-component/tests/interfaces/world-top-level.wit
@@ -1,5 +1,3 @@
-package foo:foo
-
 world foo {
   import foo: func()
   export foo2: func()
diff --git a/crates/wit-component/tests/interfaces/world-top-level.wit.print b/crates/wit-component/tests/interfaces/world-top-level.wit.print
index b21b9f8a..a5249ac8 100644
--- a/crates/wit-component/tests/interfaces/world-top-level.wit.print
+++ b/crates/wit-component/tests/interfaces/world-top-level.wit.print
@@ -1,19 +1,16 @@
-package foo:foo
-
+world just-import {
+  import foo: func()
+}
+world just-export {
+  export foo: func()
+}
 world foo {
   import some-interface: interface {
   }
   import foo: func()
   import bar: func(arg: u32)
-
   export another-interface: interface {
   }
   export foo2: func()
   export bar2: func() -> u32
 }
-world just-import {
-  import foo: func()
-}
-world just-export {
-  export foo: func()
-}
diff --git a/crates/wit-component/tests/interfaces/worlds-with-types.wat b/crates/wit-component/tests/interfaces/worlds-with-types.wat
index 8b8d3bdd..810fc059 100644
--- a/crates/wit-component/tests/interfaces/worlds-with-types.wat
+++ b/crates/wit-component/tests/interfaces/worlds-with-types.wat
@@ -7,19 +7,8 @@
           (export (;1;) "foo" (type (eq 0)))
         )
       )
-      (export (;0;) (interface "foo:foo/import-me") (instance (type 0)))
+      (export (;0;) "import-me" "pkg:/worlds-with-types/import-me" (instance (type 0)))
       (type (;1;)
-        (component
-          (type (;0;) (record))
-          (import "foo" (type (;1;) (eq 0)))
-          (import "bar" (type (;2;) (eq 1)))
-          (type (;3;) (func (param "a" 1) (result 2)))
-          (import "a" (func (;0;) (type 3)))
-          (export (;1;) "b" (func (type 3)))
-        )
-      )
-      (export (;0;) (interface "foo:foo/simple") (component (type 1)))
-      (type (;2;)
         (component
           (type (;0;)
             (instance
@@ -27,19 +16,27 @@
               (export (;1;) "foo" (type (eq 0)))
             )
           )
-          (import (interface "foo:foo/import-me") (instance (;0;) (type 0)))
+          (import "import-me" "pkg:/worlds-with-types/import-me" (instance (type 0)))
           (alias export 0 "foo" (type (;1;)))
-          (import "foo" (type (;2;) (eq 1)))
-          (type (;3;) (func (param "a" 2)))
-          (import "a" (func (;0;) (type 3)))
-          (export (;1;) "b" (func (type 3)))
+          (import "foo" (type (eq 1)))
+          (type (;2;) (func (param "a" 2)))
+          (import "a" (func (type 3)))
+          (export (;0;) "b" (func (type 3)))
         )
       )
-      (export (;1;) (interface "foo:foo/with-imports") (component (type 2)))
+      (export (;0;) "with-imports" "pkg:/worlds-with-types/with-imports" (component (type 1)))
+      (type (;2;)
+        (component
+          (type (;0;) (record))
+          (import "foo" (type (eq 0)))
+          (import "bar" (type (eq 1)))
+          (type (;1;) (func (param "a" 1) (result 2)))
+          (import "a" (func (type 3)))
+          (export (;0;) "b" (func (type 3)))
+        )
+      )
+      (export (;1;) "simple" "pkg:/worlds-with-types/simple" (component (type 2)))
     )
   )
-  (@producers
-    (processed-by "wit-component" "$CARGO_PKG_VERSION")
-  )
-  (export (;1;) (interface "foo:foo/wit") (type 0))
+  (export (;1;) "worlds-with-types" "pkg:/worlds-with-types" (type 0))
 )
\ No newline at end of file
diff --git a/crates/wit-component/tests/interfaces/worlds-with-types.wit b/crates/wit-component/tests/interfaces/worlds-with-types.wit
index 44fc574d..d1142435 100644
--- a/crates/wit-component/tests/interfaces/worlds-with-types.wit
+++ b/crates/wit-component/tests/interfaces/worlds-with-types.wit
@@ -1,5 +1,3 @@
-package foo:foo
-
 world simple {
   record foo {
   }
@@ -15,7 +13,7 @@ interface import-me {
 }
 
 world with-imports {
-  use import-me.{foo}
+  use self.import-me.{foo}
 
   import a: func(a: foo)
   export b: func(a: foo)
diff --git a/crates/wit-component/tests/interfaces/worlds-with-types.wit.print b/crates/wit-component/tests/interfaces/worlds-with-types.wit.print
index 3faf9a83..931274fd 100644
--- a/crates/wit-component/tests/interfaces/worlds-with-types.wit.print
+++ b/crates/wit-component/tests/interfaces/worlds-with-types.wit.print
@@ -1,12 +1,16 @@
-package foo:foo
-
 interface import-me {
   type foo = u32
+
 }
 
+world with-imports {
+  import import-me: self.import-me
+  import a: func(a: foo)
+  use self.import-me.{foo}
+  export b: func(a: foo)
+}
 world simple {
   import a: func(a: foo) -> bar
-
   record foo {
   }
 
@@ -14,10 +18,3 @@ world simple {
 
   export b: func(a: foo) -> bar
 }
-world with-imports {
-  import import-me
-  import a: func(a: foo)
-  use import-me.{foo}
-
-  export b: func(a: foo)
-}
diff --git a/crates/wit-component/tests/merge.rs b/crates/wit-component/tests/merge.rs
deleted file mode 100644
index 6176b1c1..00000000
--- a/crates/wit-component/tests/merge.rs
+++ /dev/null
@@ -1,157 +0,0 @@
-use anyhow::{Context, Result};
-use pretty_assertions::assert_eq;
-use std::collections::HashSet;
-use std::{fs, path::Path};
-use wit_component::WitPrinter;
-use wit_parser::{Resolve, TypeOwner, WorldItem};
-
-/// This is a test which iterates over the `tests/merge` directory and treats
-/// each subdirectory as its own test. Each subdirectory has an `into` and a
-/// `from` folder which represent two different `Resolve` sets, each with their
-/// own set of dependencies as well.
-///
-/// Each test will merge the `from` into the `into` and assert that everything
-/// is valid along the way. On successful merge the resulting documents
-/// are printed and asserted against expectations. Failures assert the
-/// correct error message.
-#[test]
-fn merging() -> Result<()> {
-    drop(env_logger::try_init());
-
-    for entry in fs::read_dir("tests/merge")? {
-        let path = entry?.path();
-        if !path.is_dir() {
-            continue;
-        }
-
-        let test_case = path.file_stem().unwrap().to_str().unwrap();
-        println!("testing {test_case}");
-
-        let mut from = Resolve::default();
-        from.push_dir(&path.join("from"))?;
-        let mut into = Resolve::default();
-        into.push_dir(&path.join("into"))?;
-
-        assert_valid_resolve(&from);
-        assert_valid_resolve(&into);
-
-        match into.merge(from) {
-            Ok(_) => {
-                assert!(
-                    !test_case.starts_with("bad-"),
-                    "should have failed to merge"
-                );
-                assert_valid_resolve(&into);
-                for (id, pkg) in into.packages.iter() {
-                    let expected = path
-                        .join("merge")
-                        .join(&pkg.name.name)
-                        .with_extension("wit");
-                    let output = WitPrinter::default().print(&into, id)?;
-                    assert_output(&expected, &output)?;
-                }
-            }
-            Err(e) => {
-                assert!(test_case.starts_with("bad-"), "failed to merge with {e:?}");
-                assert_output(&path.join("error.txt"), &format!("{e:?}"))?;
-            }
-        }
-    }
-
-    Ok(())
-}
-
-fn assert_output(expected: &Path, actual: &str) -> Result<()> {
-    if std::env::var_os("BLESS").is_some() {
-        fs::create_dir_all(expected.parent().unwrap())?;
-        fs::write(expected, actual).with_context(|| format!("failed to write {expected:?}"))?;
-    } else {
-        assert_eq!(
-            fs::read_to_string(expected)
-                .with_context(|| format!("failed to read {expected:?}"))?
-                .replace("\r\n", "\n"),
-            actual,
-            "expectation `{}` did not match actual",
-            expected.display(),
-        );
-    }
-    Ok(())
-}
-
-fn assert_valid_resolve(resolve: &Resolve) {
-    let mut package_interfaces = Vec::new();
-    let mut package_worlds = Vec::new();
-    for (id, pkg) in resolve.packages.iter() {
-        let mut interfaces = HashSet::new();
-        for (name, iface) in pkg.interfaces.iter() {
-            assert!(interfaces.insert(*iface));
-            let iface = &resolve.interfaces[*iface];
-            assert_eq!(name, iface.name.as_ref().unwrap());
-            assert_eq!(iface.package.unwrap(), id);
-        }
-        package_interfaces.push(pkg.interfaces.values().copied().collect::<HashSet<_>>());
-        let mut worlds = HashSet::new();
-        for (name, world) in pkg.worlds.iter() {
-            assert!(worlds.insert(*world));
-            let world = &resolve.worlds[*world];
-            assert_eq!(*name, world.name);
-            assert_eq!(world.package.unwrap(), id);
-        }
-        package_worlds.push(pkg.worlds.values().copied().collect::<HashSet<_>>());
-    }
-
-    let mut interface_types = Vec::new();
-    for (id, iface) in resolve.interfaces.iter() {
-        assert!(resolve.packages.get(iface.package.unwrap()).is_some());
-        if iface.name.is_some() {
-            assert!(package_interfaces[iface.package.unwrap().index()].contains(&id));
-        }
-
-        for (name, ty) in iface.types.iter() {
-            let ty = &resolve.types[*ty];
-            assert_eq!(ty.name.as_ref(), Some(name));
-            assert_eq!(ty.owner, TypeOwner::Interface(id));
-        }
-        interface_types.push(iface.types.values().copied().collect::<HashSet<_>>());
-        for (name, f) in iface.functions.iter() {
-            assert_eq!(*name, f.name);
-        }
-    }
-
-    let mut world_types = Vec::new();
-    for (id, world) in resolve.worlds.iter() {
-        assert!(resolve.packages.get(world.package.unwrap()).is_some());
-        assert!(package_worlds[world.package.unwrap().index()].contains(&id));
-
-        let mut types = HashSet::new();
-        for (name, item) in world.imports.iter().chain(world.exports.iter()) {
-            match item {
-                WorldItem::Interface(_) => {}
-                WorldItem::Function(f) => {
-                    assert_eq!(f.name, name.clone().unwrap_name());
-                }
-                WorldItem::Type(ty) => {
-                    assert!(types.insert(*ty));
-                    let ty = &resolve.types[*ty];
-                    assert_eq!(ty.name, Some(name.clone().unwrap_name()));
-                    assert_eq!(ty.owner, TypeOwner::World(id));
-                }
-            }
-        }
-        world_types.push(types);
-    }
-
-    for (ty_id, ty) in resolve.types.iter() {
-        match ty.owner {
-            TypeOwner::Interface(id) => {
-                assert!(resolve.interfaces.get(id).is_some());
-                assert!(interface_types[id.index()].contains(&ty_id));
-            }
-            TypeOwner::World(id) => {
-                assert!(resolve.worlds.get(id).is_some());
-                assert!(world_types[id.index()].contains(&ty_id));
-            }
-            TypeOwner::None => {}
-        }
-    }
-}
diff --git a/crates/wit-component/tests/merge/bad-interface1/error.txt b/crates/wit-component/tests/merge/bad-interface1/error.txt
deleted file mode 100644
index 951bb365..00000000
--- a/crates/wit-component/tests/merge/bad-interface1/error.txt
+++ /dev/null
@@ -1,5 +0,0 @@
-failed to merge package `foo:foo` into existing copy
-
-Caused by:
-    0: failed to merge interface `a`
-    1: expected type `a` to be present
\ No newline at end of file
diff --git a/crates/wit-component/tests/merge/bad-interface1/from/a.wit b/crates/wit-component/tests/merge/bad-interface1/from/a.wit
deleted file mode 100644
index 9450b432..00000000
--- a/crates/wit-component/tests/merge/bad-interface1/from/a.wit
+++ /dev/null
@@ -1,5 +0,0 @@
-package foo:%from
-
-interface a {
-  use foo:foo/a.{a}
-}
diff --git a/crates/wit-component/tests/merge/bad-interface1/from/deps/foo/a.wit b/crates/wit-component/tests/merge/bad-interface1/from/deps/foo/a.wit
deleted file mode 100644
index 91105570..00000000
--- a/crates/wit-component/tests/merge/bad-interface1/from/deps/foo/a.wit
+++ /dev/null
@@ -1,5 +0,0 @@
-package foo:foo
-
-interface a {
-  type a = u32
-}
diff --git a/crates/wit-component/tests/merge/bad-interface1/into/a.wit b/crates/wit-component/tests/merge/bad-interface1/into/a.wit
deleted file mode 100644
index d29a31d2..00000000
--- a/crates/wit-component/tests/merge/bad-interface1/into/a.wit
+++ /dev/null
@@ -1,5 +0,0 @@
-package foo:into
-
-interface a {
-  use foo:foo/a.{b}
-}
diff --git a/crates/wit-component/tests/merge/bad-interface1/into/deps/foo/a.wit b/crates/wit-component/tests/merge/bad-interface1/into/deps/foo/a.wit
deleted file mode 100644
index b8b88dd7..00000000
--- a/crates/wit-component/tests/merge/bad-interface1/into/deps/foo/a.wit
+++ /dev/null
@@ -1,6 +0,0 @@
-package foo:foo
-
-interface a {
-  type b = s32
-}
-
diff --git a/crates/wit-component/tests/merge/bad-interface2/error.txt b/crates/wit-component/tests/merge/bad-interface2/error.txt
deleted file mode 100644
index bbb5f232..00000000
--- a/crates/wit-component/tests/merge/bad-interface2/error.txt
+++ /dev/null
@@ -1,5 +0,0 @@
-failed to merge package `foo:foo` into existing copy
-
-Caused by:
-    0: failed to merge interface `a`
-    1: expected function `a` to be present
\ No newline at end of file
diff --git a/crates/wit-component/tests/merge/bad-interface2/from/a.wit b/crates/wit-component/tests/merge/bad-interface2/from/a.wit
deleted file mode 100644
index 470e63ae..00000000
--- a/crates/wit-component/tests/merge/bad-interface2/from/a.wit
+++ /dev/null
@@ -1,5 +0,0 @@
-package foo:%from
-
-interface a {
-  use foo:foo/a.{t}
-}
diff --git a/crates/wit-component/tests/merge/bad-interface2/from/deps/foo/a.wit b/crates/wit-component/tests/merge/bad-interface2/from/deps/foo/a.wit
deleted file mode 100644
index 2afd16d7..00000000
--- a/crates/wit-component/tests/merge/bad-interface2/from/deps/foo/a.wit
+++ /dev/null
@@ -1,8 +0,0 @@
-package foo:foo
-
-interface a {
-  type t = u32
-
-  a: func()
-}
-
diff --git a/crates/wit-component/tests/merge/bad-interface2/into/a.wit b/crates/wit-component/tests/merge/bad-interface2/into/a.wit
deleted file mode 100644
index 0e958da9..00000000
--- a/crates/wit-component/tests/merge/bad-interface2/into/a.wit
+++ /dev/null
@@ -1,5 +0,0 @@
-package foo:into
-
-interface a {
-  use foo:foo/a.{t}
-}
diff --git a/crates/wit-component/tests/merge/bad-interface2/into/deps/foo/a.wit b/crates/wit-component/tests/merge/bad-interface2/into/deps/foo/a.wit
deleted file mode 100644
index f9454dd6..00000000
--- a/crates/wit-component/tests/merge/bad-interface2/into/deps/foo/a.wit
+++ /dev/null
@@ -1,8 +0,0 @@
-package foo:foo
-
-interface a {
-  type t = u32
-
-  b: func()
-}
-
diff --git a/crates/wit-component/tests/merge/bad-world1/error.txt b/crates/wit-component/tests/merge/bad-world1/error.txt
deleted file mode 100644
index f04e2ed0..00000000
--- a/crates/wit-component/tests/merge/bad-world1/error.txt
+++ /dev/null
@@ -1,5 +0,0 @@
-failed to merge package `foo:foo` into existing copy
-
-Caused by:
-    0: failed to merge world `foo`
-    1: import `b` not found in target world
\ No newline at end of file
diff --git a/crates/wit-component/tests/merge/bad-world1/from/a.wit b/crates/wit-component/tests/merge/bad-world1/from/a.wit
deleted file mode 100644
index 7c171152..00000000
--- a/crates/wit-component/tests/merge/bad-world1/from/a.wit
+++ /dev/null
@@ -1,4 +0,0 @@
-package foo:%from
-interface a {
-  use foo:foo/a.{a}
-}
diff --git a/crates/wit-component/tests/merge/bad-world1/into/a.wit b/crates/wit-component/tests/merge/bad-world1/into/a.wit
deleted file mode 100644
index 435e17c2..00000000
--- a/crates/wit-component/tests/merge/bad-world1/into/a.wit
+++ /dev/null
@@ -1,4 +0,0 @@
-package foo:into
-interface a {
-  use foo:foo/a.{a}
-}
diff --git a/crates/wit-component/tests/merge/bad-world1/into/deps/foo/a.wit b/crates/wit-component/tests/merge/bad-world1/into/deps/foo/a.wit
deleted file mode 100644
index 9b324fb2..00000000
--- a/crates/wit-component/tests/merge/bad-world1/into/deps/foo/a.wit
+++ /dev/null
@@ -1,9 +0,0 @@
-package foo:foo
-
-interface a {
-  type a = u32
-}
-
-world foo {
-  import a
-}
diff --git a/crates/wit-component/tests/merge/bad-world2/error.txt b/crates/wit-component/tests/merge/bad-world2/error.txt
deleted file mode 100644
index bca74e7b..00000000
--- a/crates/wit-component/tests/merge/bad-world2/error.txt
+++ /dev/null
@@ -1,5 +0,0 @@
-failed to merge package `foo:foo` into existing copy
-
-Caused by:
-    0: failed to merge world `foo`
-    1: world contains different number of imports than expected
\ No newline at end of file
diff --git a/crates/wit-component/tests/merge/bad-world2/from/a.wit b/crates/wit-component/tests/merge/bad-world2/from/a.wit
deleted file mode 100644
index 9450b432..00000000
--- a/crates/wit-component/tests/merge/bad-world2/from/a.wit
+++ /dev/null
@@ -1,5 +0,0 @@
-package foo:%from
-
-interface a {
-  use foo:foo/a.{a}
-}
diff --git a/crates/wit-component/tests/merge/bad-world2/from/deps/foo/a.wit b/crates/wit-component/tests/merge/bad-world2/from/deps/foo/a.wit
deleted file mode 100644
index 5ab008c8..00000000
--- a/crates/wit-component/tests/merge/bad-world2/from/deps/foo/a.wit
+++ /dev/null
@@ -1,8 +0,0 @@
-package foo:foo
-
-interface a {
-  type a = u32
-}
-
-world foo {
-}
diff --git a/crates/wit-component/tests/merge/bad-world2/into/a.wit b/crates/wit-component/tests/merge/bad-world2/into/a.wit
deleted file mode 100644
index ed66a781..00000000
--- a/crates/wit-component/tests/merge/bad-world2/into/a.wit
+++ /dev/null
@@ -1,5 +0,0 @@
-package foo:into
-
-interface a {
-  use foo:foo/a.{a}
-}
diff --git a/crates/wit-component/tests/merge/bad-world2/into/deps/foo/a.wit b/crates/wit-component/tests/merge/bad-world2/into/deps/foo/a.wit
deleted file mode 100644
index 9b324fb2..00000000
--- a/crates/wit-component/tests/merge/bad-world2/into/deps/foo/a.wit
+++ /dev/null
@@ -1,9 +0,0 @@
-package foo:foo
-
-interface a {
-  type a = u32
-}
-
-world foo {
-  import a
-}
diff --git a/crates/wit-component/tests/merge/bad-world3/error.txt b/crates/wit-component/tests/merge/bad-world3/error.txt
deleted file mode 100644
index daf6860f..00000000
--- a/crates/wit-component/tests/merge/bad-world3/error.txt
+++ /dev/null
@@ -1,5 +0,0 @@
-failed to merge package `foo:foo` into existing copy
-
-Caused by:
-    0: failed to merge world `foo`
-    1: world contains different number of exports than expected
\ No newline at end of file
diff --git a/crates/wit-component/tests/merge/bad-world3/from/a.wit b/crates/wit-component/tests/merge/bad-world3/from/a.wit
deleted file mode 100644
index 9450b432..00000000
--- a/crates/wit-component/tests/merge/bad-world3/from/a.wit
+++ /dev/null
@@ -1,5 +0,0 @@
-package foo:%from
-
-interface a {
-  use foo:foo/a.{a}
-}
diff --git a/crates/wit-component/tests/merge/bad-world3/from/deps/foo/a.wit b/crates/wit-component/tests/merge/bad-world3/from/deps/foo/a.wit
deleted file mode 100644
index 5ab008c8..00000000
--- a/crates/wit-component/tests/merge/bad-world3/from/deps/foo/a.wit
+++ /dev/null
@@ -1,8 +0,0 @@
-package foo:foo
-
-interface a {
-  type a = u32
-}
-
-world foo {
-}
diff --git a/crates/wit-component/tests/merge/bad-world3/into/a.wit b/crates/wit-component/tests/merge/bad-world3/into/a.wit
deleted file mode 100644
index ed66a781..00000000
--- a/crates/wit-component/tests/merge/bad-world3/into/a.wit
+++ /dev/null
@@ -1,5 +0,0 @@
-package foo:into
-
-interface a {
-  use foo:foo/a.{a}
-}
diff --git a/crates/wit-component/tests/merge/bad-world3/into/deps/foo/a.wit b/crates/wit-component/tests/merge/bad-world3/into/deps/foo/a.wit
deleted file mode 100644
index e287ffb7..00000000
--- a/crates/wit-component/tests/merge/bad-world3/into/deps/foo/a.wit
+++ /dev/null
@@ -1,9 +0,0 @@
-package foo:foo
-
-interface a {
-  type a = u32
-}
-
-world foo {
-  export a
-}
diff --git a/crates/wit-component/tests/merge/bad-world4/error.txt b/crates/wit-component/tests/merge/bad-world4/error.txt
deleted file mode 100644
index 5cf21c92..00000000
--- a/crates/wit-component/tests/merge/bad-world4/error.txt
+++ /dev/null
@@ -1,5 +0,0 @@
-failed to merge package `foo:foo` into existing copy
-
-Caused by:
-    0: failed to merge world `foo`
-    1: export `b` not found in target world
\ No newline at end of file
diff --git a/crates/wit-component/tests/merge/bad-world4/from/a.wit b/crates/wit-component/tests/merge/bad-world4/from/a.wit
deleted file mode 100644
index 9450b432..00000000
--- a/crates/wit-component/tests/merge/bad-world4/from/a.wit
+++ /dev/null
@@ -1,5 +0,0 @@
-package foo:%from
-
-interface a {
-  use foo:foo/a.{a}
-}
diff --git a/crates/wit-component/tests/merge/bad-world4/from/deps/foo/a.wit b/crates/wit-component/tests/merge/bad-world4/from/deps/foo/a.wit
deleted file mode 100644
index 6164abd1..00000000
--- a/crates/wit-component/tests/merge/bad-world4/from/deps/foo/a.wit
+++ /dev/null
@@ -1,11 +0,0 @@
-package foo:foo
-
-interface a {
-  type a = u32
-}
-
-world foo {
-  export b: interface {
-    type a = u32
-  }
-}
diff --git a/crates/wit-component/tests/merge/bad-world4/into/a.wit b/crates/wit-component/tests/merge/bad-world4/into/a.wit
deleted file mode 100644
index ed66a781..00000000
--- a/crates/wit-component/tests/merge/bad-world4/into/a.wit
+++ /dev/null
@@ -1,5 +0,0 @@
-package foo:into
-
-interface a {
-  use foo:foo/a.{a}
-}
diff --git a/crates/wit-component/tests/merge/bad-world4/into/deps/foo/a.wit b/crates/wit-component/tests/merge/bad-world4/into/deps/foo/a.wit
deleted file mode 100644
index e287ffb7..00000000
--- a/crates/wit-component/tests/merge/bad-world4/into/deps/foo/a.wit
+++ /dev/null
@@ -1,9 +0,0 @@
-package foo:foo
-
-interface a {
-  type a = u32
-}
-
-world foo {
-  export a
-}
diff --git a/crates/wit-component/tests/merge/bad-world5/error.txt b/crates/wit-component/tests/merge/bad-world5/error.txt
deleted file mode 100644
index 9eb40e75..00000000
--- a/crates/wit-component/tests/merge/bad-world5/error.txt
+++ /dev/null
@@ -1,5 +0,0 @@
-failed to merge package `foo:foo` into existing copy
-
-Caused by:
-    0: failed to merge world `foo`
-    1: import `a` not found in target world
\ No newline at end of file
diff --git a/crates/wit-component/tests/merge/bad-world5/from/a.wit b/crates/wit-component/tests/merge/bad-world5/from/a.wit
deleted file mode 100644
index 9450b432..00000000
--- a/crates/wit-component/tests/merge/bad-world5/from/a.wit
+++ /dev/null
@@ -1,5 +0,0 @@
-package foo:%from
-
-interface a {
-  use foo:foo/a.{a}
-}
diff --git a/crates/wit-component/tests/merge/bad-world5/from/deps/foo/a.wit b/crates/wit-component/tests/merge/bad-world5/from/deps/foo/a.wit
deleted file mode 100644
index 67333842..00000000
--- a/crates/wit-component/tests/merge/bad-world5/from/deps/foo/a.wit
+++ /dev/null
@@ -1,11 +0,0 @@
-package foo:foo
-
-interface a {
-  type a = u32
-}
-
-world foo {
-  import a: interface {
-    type a = u32
-  }
-}
diff --git a/crates/wit-component/tests/merge/bad-world5/into/a.wit b/crates/wit-component/tests/merge/bad-world5/into/a.wit
deleted file mode 100644
index ed66a781..00000000
--- a/crates/wit-component/tests/merge/bad-world5/into/a.wit
+++ /dev/null
@@ -1,5 +0,0 @@
-package foo:into
-
-interface a {
-  use foo:foo/a.{a}
-}
diff --git a/crates/wit-component/tests/merge/bad-world5/into/deps/foo/a.wit b/crates/wit-component/tests/merge/bad-world5/into/deps/foo/a.wit
deleted file mode 100644
index 9b324fb2..00000000
--- a/crates/wit-component/tests/merge/bad-world5/into/deps/foo/a.wit
+++ /dev/null
@@ -1,9 +0,0 @@
-package foo:foo
-
-interface a {
-  type a = u32
-}
-
-world foo {
-  import a
-}
diff --git a/crates/wit-component/tests/merge/success/from/a.wit b/crates/wit-component/tests/merge/success/from/a.wit
deleted file mode 100644
index 987aa763..00000000
--- a/crates/wit-component/tests/merge/success/from/a.wit
+++ /dev/null
@@ -1,7 +0,0 @@
-package foo:%from
-
-interface a {
-  use foo:foo/only-from.{r}
-
-  foo: func()
-}
diff --git a/crates/wit-component/tests/merge/success/from/deps/foo/only-from.wit b/crates/wit-component/tests/merge/success/from/deps/foo/only-from.wit
deleted file mode 100644
index 5c4c62d7..00000000
--- a/crates/wit-component/tests/merge/success/from/deps/foo/only-from.wit
+++ /dev/null
@@ -1,5 +0,0 @@
-interface only-from {
-  record r {}
-
-  foo: func() -> r
-}
diff --git a/crates/wit-component/tests/merge/success/from/deps/foo/shared.wit b/crates/wit-component/tests/merge/success/from/deps/foo/shared.wit
deleted file mode 100644
index 566860e9..00000000
--- a/crates/wit-component/tests/merge/success/from/deps/foo/shared.wit
+++ /dev/null
@@ -1,25 +0,0 @@
-package foo:foo
-
-interface shared-only-from {
-  variant v {
-    c1,
-  }
-
-  bar: func(x: v)
-
-  use foo:only-from-dep/a.{a}
-}
-
-interface shared-items {
-  type a = u32
-}
-
-world shared-world {
-  import shared-items
-
-  export shared-items
-
-  type c = u32
-
-  import d: interface {}
-}
diff --git a/crates/wit-component/tests/merge/success/from/deps/only-from-dep/a.wit b/crates/wit-component/tests/merge/success/from/deps/only-from-dep/a.wit
deleted file mode 100644
index ce3f3599..00000000
--- a/crates/wit-component/tests/merge/success/from/deps/only-from-dep/a.wit
+++ /dev/null
@@ -1,5 +0,0 @@
-package foo:only-from-dep
-
-interface a {
-  type a = u32
-}
diff --git a/crates/wit-component/tests/merge/success/into/b.wit b/crates/wit-component/tests/merge/success/into/b.wit
deleted file mode 100644
index df1292fe..00000000
--- a/crates/wit-component/tests/merge/success/into/b.wit
+++ /dev/null
@@ -1,7 +0,0 @@
-package foo:into
-
-interface b {
-  use foo:foo/only-into.{r}
-
-  foo: func()
-}
diff --git a/crates/wit-component/tests/merge/success/into/deps/foo/only-into.wit b/crates/wit-component/tests/merge/success/into/deps/foo/only-into.wit
deleted file mode 100644
index 012f2b96..00000000
--- a/crates/wit-component/tests/merge/success/into/deps/foo/only-into.wit
+++ /dev/null
@@ -1,5 +0,0 @@
-interface only-into {
-  record r {}
-
-  foo: func() -> r
-}
diff --git a/crates/wit-component/tests/merge/success/into/deps/foo/shared.wit b/crates/wit-component/tests/merge/success/into/deps/foo/shared.wit
deleted file mode 100644
index 2518832b..00000000
--- a/crates/wit-component/tests/merge/success/into/deps/foo/shared.wit
+++ /dev/null
@@ -1,23 +0,0 @@
-package foo:foo
-
-interface shared-only-into {
-  variant v {
-    c1,
-  }
-
-  bar: func(x: v)
-}
-
-interface shared-items {
-  type a = u32
-}
-
-world shared-world {
-  import shared-items
-
-  export shared-items
-
-  type c = u32
-
-  import d: interface {}
-}
diff --git a/crates/wit-component/tests/merge/success/merge/foo.wit b/crates/wit-component/tests/merge/success/merge/foo.wit
deleted file mode 100644
index 6d99577b..00000000
--- a/crates/wit-component/tests/merge/success/merge/foo.wit
+++ /dev/null
@@ -1,47 +0,0 @@
-package foo:foo
-
-interface only-into {
-  record r {
-  }
-
-  foo: func() -> r
-}
-
-interface shared-only-into {
-  variant v {
-    c1,
-  }
-
-  bar: func(x: v)
-}
-
-interface shared-items {
-  type a = u32
-}
-
-interface only-from {
-  record r {
-  }
-
-  foo: func() -> r
-}
-
-interface shared-only-from {
-  use foo:only-from-dep/a.{a}
-
-  variant v {
-    c1,
-  }
-
-  bar: func(x: v)
-}
-
-world shared-world {
-  import shared-items
-  import d: interface {
-  }
-
-  type c = u32
-
-  export shared-items
-}
diff --git a/crates/wit-component/tests/merge/success/merge/from.wit b/crates/wit-component/tests/merge/success/merge/from.wit
deleted file mode 100644
index 3561136b..00000000
--- a/crates/wit-component/tests/merge/success/merge/from.wit
+++ /dev/null
@@ -1,8 +0,0 @@
-package foo:%from
-
-interface a {
-  use foo:foo/only-from.{r}
-
-  foo: func()
-}
-
diff --git a/crates/wit-component/tests/merge/success/merge/into.wit b/crates/wit-component/tests/merge/success/merge/into.wit
deleted file mode 100644
index 4e61e7f5..00000000
--- a/crates/wit-component/tests/merge/success/merge/into.wit
+++ /dev/null
@@ -1,8 +0,0 @@
-package foo:into
-
-interface b {
-  use foo:foo/only-into.{r}
-
-  foo: func()
-}
-
diff --git a/crates/wit-component/tests/merge/success/merge/only-from-dep.wit b/crates/wit-component/tests/merge/success/merge/only-from-dep.wit
deleted file mode 100644
index 3381d36c..00000000
--- a/crates/wit-component/tests/merge/success/merge/only-from-dep.wit
+++ /dev/null
@@ -1,6 +0,0 @@
-package foo:only-from-dep
-
-interface a {
-  type a = u32
-}
-
diff --git a/crates/wit-component/tests/targets.rs b/crates/wit-component/tests/targets.rs
deleted file mode 100644
index 23579b7f..00000000
--- a/crates/wit-component/tests/targets.rs
+++ /dev/null
@@ -1,93 +0,0 @@
-use anyhow::{Context, Result};
-use std::{fs, path::Path};
-use wit_parser::{Resolve, UnresolvedPackage, WorldId};
-
-/// Tests whether a component targets a world.
-///
-/// This test looks in the `targets/` directory for test cases.
-///
-/// The expected input files for a test case are:
-///
-/// * [required] `test.wat` -- contains the component to test
-/// encoded as a component produced via the `embed` and `new`
-/// subcommands of `wasm-tools component`.
-/// * [required] `test.wit` -- WIT package describing the target
-/// world to use when checking conformance.
-///
-/// And the output file is:
-/// * `error.txt` - the expected error message if the synthetic
-/// component constructed for testing is a invalid component encoding.
-/// NOTE: an invalid encoding here indicates that the targets check has failed.
-///
-/// Run the test with the environment variable `BLESS` set to update `error.txt`.
-///
-/// Each test is effectively executing as:
-/// ```wasm-tools component targets -w foobar test.wit test.wat```
-#[test]
-fn targets() -> Result<()> {
-    drop(env_logger::try_init());
-
-    for entry in fs::read_dir("tests/targets")? {
-        let path = entry?.path();
-        if !path.is_dir() {
-            continue;
-        }
-
-        let test_case = path.file_stem().unwrap().to_str().unwrap();
-        println!("testing {test_case}");
-
-        let (resolve, world) = load_test_wit(&path)?;
-
-        let component = wat::parse_file(path.join("test.wat"))
-            .with_context(|| "failed to parse component WAT".to_string())?;
-
-        match wit_component::targets(&resolve, world, &component) {
-            Ok(_) => {
-                assert!(
-                    !test_case.starts_with("error-"),
-                    "should have failed targets check"
-                );
-            }
-            Err(e) => {
-                assert!(test_case.starts_with("error-"), "{e:?}");
-                assert_output(&path.join("error.txt"), &format!("{e:?}"))?;
-            }
-        }
-    }
-
-    Ok(())
-}
-
-fn assert_output(expected: &Path, actual: &str) -> Result<()> {
-    if std::env::var_os("BLESS").is_some() {
-        fs::create_dir_all(expected.parent().unwrap())?;
-        fs::write(expected, actual).with_context(|| format!("failed to write {expected:?}"))?;
-    } else {
-        assert_eq!(
-            fs::read_to_string(expected)
-                .with_context(|| format!("failed to read {expected:?}"))?
-                .replace("\r\n", "\n"),
-            actual,
-            "expectation `{}` did not match actual",
-            expected.display(),
-        );
-    }
-    Ok(())
-}
-
-fn load_test_wit(path: &Path) -> Result<(Resolve, WorldId)> {
-    const TEST_TARGET_WORLD_ID: &str = "foobar";
-
-    let test_wit_path = path.join("test.wit");
-    let package =
-        UnresolvedPackage::parse_file(&test_wit_path).context("failed to parse WIT package")?;
-
-    let mut resolve = Resolve::default();
-    let package_id = resolve.push(package)?;
-
-    let world_id = resolve
-        .select_world(package_id, Some(TEST_TARGET_WORLD_ID))
-        .with_context(|| "failed to select world from package".to_string())?;
-
-    Ok((resolve, world_id))
-}
diff --git a/crates/wit-component/tests/targets/error-missing-export/error.txt b/crates/wit-component/tests/targets/error-missing-export/error.txt
deleted file mode 100644
index 7b949359..00000000
--- a/crates/wit-component/tests/targets/error-missing-export/error.txt
+++ /dev/null
@@ -1,5 +0,0 @@
-failed to validate encoded bytes
-
-Caused by:
-    type mismatch for import `foobar`
-    missing export named `test:foo/bar` (at offset 0x1a4)
\ No newline at end of file
diff --git a/crates/wit-component/tests/targets/error-missing-export/test.wat b/crates/wit-component/tests/targets/error-missing-export/test.wat
deleted file mode 100644
index 89a159ce..00000000
--- a/crates/wit-component/tests/targets/error-missing-export/test.wat
+++ /dev/null
@@ -1,39 +0,0 @@
-(component
-  (core module (;0;)
-    (type (;0;) (func))
-    (type (;1;) (func (param i32 i32 i32 i32) (result i32)))
-    (func (;0;) (type 0)
-      unreachable
-    )
-    (func (;1;) (type 1) (param i32 i32 i32 i32) (result i32)
-      unreachable
-    )
-    (memory (;0;) 0)
-    (export "test:foo/foo#f" (func 0))
-    (export "memory" (memory 0))
-    (export "cabi_realloc" (func 1))
-    (@producers
-      (processed-by "wit-component" "0.11.0")
-    )
-  )
-  (core instance (;0;) (instantiate 0))
-  (alias core export 0 "memory" (core memory (;0;)))
-  (alias core export 0 "cabi_realloc" (core func (;0;)))
-  (type (;0;) (func))
-  (alias core export 0 "test:foo/foo#f" (core func (;1;)))
-  (func (;0;) (type 0) (canon lift (core func 1)))
-  (component (;0;)
-    (type (;0;) (func))
-    (import "import-func-f" (func (;0;) (type 0)))
-    (type (;1;) (func))
-    (export (;1;) "f" (func 0) (func (type 1)))
-  )
-  (instance (;0;) (instantiate 0
-      (with "import-func-f" (func 0))
-    )
-  )
-  (@producers
-    (processed-by "wit-component" "0.11.0")
-  )
-  (export (;1;) (interface "test:foo/foo") (instance 0))
-)
\ No newline at end of file
diff --git a/crates/wit-component/tests/targets/error-missing-export/test.wit b/crates/wit-component/tests/targets/error-missing-export/test.wit
deleted file mode 100644
index 2f5a61b9..00000000
--- a/crates/wit-component/tests/targets/error-missing-export/test.wit
+++ /dev/null
@@ -1,18 +0,0 @@
-package test:foo
-
-interface bar {
-    f: func()
-}
-
-interface foo {
-    f: func()
-}
-
-world foobar {
-    export bar
-    export foo
-}
-
-world foo-only {
-    export foo
-}
\ No newline at end of file
diff --git a/crates/wit-component/tests/targets/error-missing-import/error.txt b/crates/wit-component/tests/targets/error-missing-import/error.txt
deleted file mode 100644
index afdb7dfe..00000000
--- a/crates/wit-component/tests/targets/error-missing-import/error.txt
+++ /dev/null
@@ -1,5 +0,0 @@
-failed to validate encoded bytes
-
-Caused by:
-    type mismatch for import `foobar`
-    missing import named `test:foo/foo` (at offset 0x144)
\ No newline at end of file
diff --git a/crates/wit-component/tests/targets/error-missing-import/test.wat b/crates/wit-component/tests/targets/error-missing-import/test.wat
deleted file mode 100644
index 9ee18134..00000000
--- a/crates/wit-component/tests/targets/error-missing-import/test.wat
+++ /dev/null
@@ -1,37 +0,0 @@
-(component
-  (type (;0;)
-    (instance
-      (type (;0;) (func))
-      (export (;0;) "f" (func (type 0)))
-    )
-  )
-  (import (interface "test:foo/foo") (instance (;0;) (type 0)))
-  (core module (;0;)
-    (type (;0;) (func))
-    (type (;1;) (func (param i32 i32 i32 i32) (result i32)))
-    (import "test:foo/foo" "f" (func (;0;) (type 0)))
-    (func (;1;) (type 1) (param i32 i32 i32 i32) (result i32)
-      unreachable
-    )
-    (memory (;0;) 0)
-    (export "memory" (memory 0))
-    (export "cabi_realloc" (func 1))
-    (@producers
-      (processed-by "wit-component" "0.11.0")
-    )
-  )
-  (alias export 0 "f" (func (;0;)))
-  (core func (;0;) (canon lower (func 0)))
-  (core instance (;0;)
-    (export "f" (func 0))
-  )
-  (core instance (;1;) (instantiate 0
-      (with "test:foo/foo" (instance 0))
-    )
-  )
-  (@producers
-    (processed-by "wit-component" "0.11.0")
-  )
-  (alias core export 1 "memory" (core memory (;0;)))
-  (alias core export 1 "cabi_realloc" (core func (;1;)))
-)
\ No newline at end of file
diff --git a/crates/wit-component/tests/targets/error-missing-import/test.wit b/crates/wit-component/tests/targets/error-missing-import/test.wit
deleted file mode 100644
index abf776fc..00000000
--- a/crates/wit-component/tests/targets/error-missing-import/test.wit
+++ /dev/null
@@ -1,13 +0,0 @@
-package test:foo
-
-interface foo {
-    f: func()
-}
-
-world foobar {
-    export foo
-}
-
-world imports {
-    import foo
-}
\ No newline at end of file
diff --git a/crates/wit-component/tests/targets/success-empty/test.wat b/crates/wit-component/tests/targets/success-empty/test.wat
deleted file mode 100644
index 04743950..00000000
--- a/crates/wit-component/tests/targets/success-empty/test.wat
+++ /dev/null
@@ -1 +0,0 @@
-(component)
\ No newline at end of file
diff --git a/crates/wit-component/tests/targets/success-empty/test.wit b/crates/wit-component/tests/targets/success-empty/test.wit
deleted file mode 100644
index 70353fe8..00000000
--- a/crates/wit-component/tests/targets/success-empty/test.wit
+++ /dev/null
@@ -1,9 +0,0 @@
-package test:foo
-
-interface foo {
-    f: func()
-}
-
-world foobar {
-    import foo
-}
\ No newline at end of file
diff --git a/crates/wit-component/tests/targets/success/test.wat b/crates/wit-component/tests/targets/success/test.wat
deleted file mode 100644
index ad10aeb1..00000000
--- a/crates/wit-component/tests/targets/success/test.wat
+++ /dev/null
@@ -1,56 +0,0 @@
-(component
-  (core module (;0;)
-    (type (;0;) (func))
-    (type (;1;) (func (param i32 i32 i32 i32) (result i32)))
-    (func (;0;) (type 0)
-      unreachable
-    )
-    (func (;1;) (type 0)
-      unreachable
-    )
-    (func (;2;) (type 1) (param i32 i32 i32 i32) (result i32)
-      unreachable
-    )
-    (memory (;0;) 0)
-    (export "test:foo/bar#f" (func 0))
-    (export "test:foo/foo#f" (func 1))
-    (export "memory" (memory 0))
-    (export "cabi_realloc" (func 2))
-    (@producers
-      (processed-by "wit-component" "0.11.0")
-    )
-  )
-  (core instance (;0;) (instantiate 0))
-  (alias core export 0 "memory" (core memory (;0;)))
-  (alias core export 0 "cabi_realloc" (core func (;0;)))
-  (type (;0;) (func))
-  (alias core export 0 "test:foo/bar#f" (core func (;1;)))
-  (func (;0;) (type 0) (canon lift (core func 1)))
-  (component (;0;)
-    (type (;0;) (func))
-    (import "import-func-f" (func (;0;) (type 0)))
-    (type (;1;) (func))
-    (export (;1;) "f" (func 0) (func (type 1)))
-  )
-  (instance (;0;) (instantiate 0
-      (with "import-func-f" (func 0))
-    )
-  )
-  (export (;1;) (interface "test:foo/bar") (instance 0))
-  (alias core export 0 "test:foo/foo#f" (core func (;2;)))
-  (func (;1;) (type 0) (canon lift (core func 2)))
-  (component (;1;)
-    (type (;0;) (func))
-    (import "import-func-f" (func (;0;) (type 0)))
-    (type (;1;) (func))
-    (export (;1;) "f" (func 0) (func (type 1)))
-  )
-  (instance (;2;) (instantiate 1
-      (with "import-func-f" (func 1))
-    )
-  )
-  (@producers
-    (processed-by "wit-component" "0.11.0")
-  )
-  (export (;3;) (interface "test:foo/foo") (instance 2))
-)
\ No newline at end of file
diff --git a/crates/wit-component/tests/targets/success/test.wit b/crates/wit-component/tests/targets/success/test.wit
deleted file mode 100644
index 6f70f8d1..00000000
--- a/crates/wit-component/tests/targets/success/test.wit
+++ /dev/null
@@ -1,14 +0,0 @@
-package test:foo
-
-interface bar {
-    f: func()
-}
-
-interface foo {
-    f: func()
-}
-
-world foobar {
-    export bar
-    export foo
-}
\ No newline at end of file
diff --git a/crates/wit-parser/Cargo.toml b/crates/wit-parser/Cargo.toml
index 83022f82..6b9696ee 100644
--- a/crates/wit-parser/Cargo.toml
+++ b/crates/wit-parser/Cargo.toml
@@ -1,7 +1,7 @@
 [package]
 name = "wit-parser"
 authors = ["Alex Crichton <alex@alexcrichton.com>"]
-version = "0.9.0"
+version = "0.6.4"
 edition.workspace = true
 license = "Apache-2.0 WITH LLVM-exception"
 readme = "README.md"
@@ -16,11 +16,10 @@ Tooling for parsing `*.wit` files and working with their contents.
 id-arena = "2"
 anyhow = { workspace = true }
 indexmap = { workspace = true }
-pulldown-cmark = { version = "0.9.3", default-features = false }
+pulldown-cmark = { version = "0.8", default-features = false }
 unicode-xid = "0.2.2"
 log = { workspace = true }
 url = { workspace = true }
-semver = { workspace = true }
 
 [dev-dependencies]
 rayon = "1"
diff --git a/crates/wit-parser/src/abi.rs b/crates/wit-parser/src/abi.rs
index 998775b3..e725674a 100644
--- a/crates/wit-parser/src/abi.rs
+++ b/crates/wit-parser/src/abi.rs
@@ -1,6 +1,6 @@
 use crate::sizealign::align_to;
 use crate::{
-    Enum, Flags, FlagsRepr, Function, Handle, Int, Record, Resolve, Result_, Results, Tuple, Type,
+    Enum, Flags, FlagsRepr, Function, Int, Record, Resolve, Result_, Results, Tuple, Type,
     TypeDefKind, TypeId, Union, Variant,
 };
 
@@ -382,20 +382,6 @@ def_instruction! {
             ty: TypeId,
         } : [record.fields.len()] => [1],
 
-        /// Create an `i32` from a handle.
-        HandleLower {
-            handle: &'a Handle,
-            name: &'a str,
-            ty: TypeId,
-        } : [1] => [1],
-
-        /// Create a handle from an `i32`.
-        HandleLift {
-            handle: &'a Handle,
-            name: &'a str,
-            ty: TypeId,
-        } : [1] => [1],
-
         /// Pops a tuple value off the stack, decomposes the tuple to all of
         /// its fields, and then pushes the fields onto the stack.
         TupleLower {
@@ -786,12 +772,6 @@ impl Resolve {
             Type::Id(id) => match &self.types[*id].kind {
                 TypeDefKind::Type(t) => self.push_wasm(variant, t, result),
 
-                TypeDefKind::Handle(Handle::Own(_) | Handle::Borrow(_)) => {
-                    result.push(WasmType::I32);
-                }
-
-                TypeDefKind::Resource => todo!(),
-
                 TypeDefKind::Record(r) => {
                     for field in r.fields.iter() {
                         self.push_wasm(variant, &field.ty, result);
@@ -919,8 +899,6 @@ impl Resolve {
             Type::Id(id) => match &self.types[*id].kind {
                 TypeDefKind::List(_) => true,
                 TypeDefKind::Type(t) => self.needs_post_return(t),
-                TypeDefKind::Handle(_) => false,
-                TypeDefKind::Resource => false,
                 TypeDefKind::Record(r) => r.fields.iter().any(|f| self.needs_post_return(&f.ty)),
                 TypeDefKind::Tuple(t) => t.types.iter().any(|t| self.needs_post_return(t)),
                 TypeDefKind::Union(t) => t.cases.iter().any(|t| self.needs_post_return(&t.ty)),
@@ -1307,17 +1285,6 @@ impl<'a, B: Bindgen> Generator<'a, B> {
                         self.emit(&ListLower { element, realloc });
                     }
                 }
-                TypeDefKind::Handle(handle) => {
-                    let (Handle::Own(ty) | Handle::Borrow(ty)) = handle;
-                    self.emit(&HandleLower {
-                        handle,
-                        ty: id,
-                        name: self.resolve.types[*ty].name.as_deref().unwrap(),
-                    });
-                }
-                TypeDefKind::Resource => {
-                    todo!();
-                }
                 TypeDefKind::Record(record) => {
                     self.emit(&RecordLower {
                         record,
@@ -1501,17 +1468,6 @@ impl<'a, B: Bindgen> Generator<'a, B> {
                         self.emit(&ListLift { element, ty: id });
                     }
                 }
-                TypeDefKind::Handle(handle) => {
-                    let (Handle::Own(ty) | Handle::Borrow(ty)) = handle;
-                    self.emit(&HandleLift {
-                        handle,
-                        ty: id,
-                        name: self.resolve.types[*ty].name.as_deref().unwrap(),
-                    });
-                }
-                TypeDefKind::Resource => {
-                    todo!();
-                }
                 TypeDefKind::Record(record) => {
                     let mut temp = Vec::new();
                     self.resolve.push_wasm(self.variant, ty, &mut temp);
@@ -1659,8 +1615,6 @@ impl<'a, B: Bindgen> Generator<'a, B> {
                 TypeDefKind::Type(t) => self.write_to_memory(t, addr, offset),
                 TypeDefKind::List(_) => self.write_list_to_memory(ty, addr, offset),
 
-                TypeDefKind::Handle(_) => todo!(),
-
                 // Decompose the record into its components and then write all
                 // the components into memory one-by-one.
                 TypeDefKind::Record(record) => {
@@ -1671,9 +1625,6 @@ impl<'a, B: Bindgen> Generator<'a, B> {
                     });
                     self.write_fields_to_memory(record.fields.iter().map(|f| &f.ty), addr, offset);
                 }
-                TypeDefKind::Resource => {
-                    todo!()
-                }
                 TypeDefKind::Tuple(tuple) => {
                     self.emit(&TupleLower { tuple, ty: id });
                     self.write_fields_to_memory(tuple.types.iter(), addr, offset);
@@ -1863,14 +1814,6 @@ impl<'a, B: Bindgen> Generator<'a, B> {
 
                 TypeDefKind::List(_) => self.read_list_from_memory(ty, addr, offset),
 
-                TypeDefKind::Handle(_) => {
-                    todo!();
-                }
-
-                TypeDefKind::Resource => {
-                    todo!();
-                }
-
                 // Read and lift each field individually, adjusting the offset
                 // as we go along, then aggregate all the fields into the
                 // record.
@@ -1882,7 +1825,6 @@ impl<'a, B: Bindgen> Generator<'a, B> {
                         name: self.resolve.types[id].name.as_deref().unwrap(),
                     });
                 }
-
                 TypeDefKind::Tuple(tuple) => {
                     self.read_fields_from_memory(&tuple.types, addr, offset);
                     self.emit(&TupleLift { tuple, ty: id });
@@ -2087,14 +2029,6 @@ impl<'a, B: Bindgen> Generator<'a, B> {
                     self.emit(&Instruction::GuestDeallocateList { element });
                 }
 
-                TypeDefKind::Handle(_) => {
-                    todo!()
-                }
-
-                TypeDefKind::Resource => {
-                    todo!()
-                }
-
                 TypeDefKind::Record(record) => {
                     self.deallocate_fields(
                         &record.fields.iter().map(|f| f.ty).collect::<Vec<_>>(),
@@ -2102,7 +2036,6 @@ impl<'a, B: Bindgen> Generator<'a, B> {
                         offset,
                     );
                 }
-
                 TypeDefKind::Tuple(tuple) => {
                     self.deallocate_fields(&tuple.types, addr, offset);
                 }
diff --git a/crates/wit-parser/src/ast.rs b/crates/wit-parser/src/ast.rs
index 96282bd4..c2a93ae2 100644
--- a/crates/wit-parser/src/ast.rs
+++ b/crates/wit-parser/src/ast.rs
@@ -1,7 +1,6 @@
 use crate::{Error, UnresolvedPackage};
 use anyhow::{bail, Context, Result};
 use lex::{Span, Token, Tokenizer};
-use semver::Version;
 use std::borrow::Cow;
 use std::convert::TryFrom;
 use std::fmt;
@@ -16,32 +15,22 @@ pub mod toposort;
 pub use lex::validate_id;
 
 pub struct Ast<'a> {
-    package_id: Option<PackageName<'a>>,
-    items: Vec<AstItem<'a>>,
+    pub items: Vec<AstItem<'a>>,
 }
 
 impl<'a> Ast<'a> {
     pub fn parse(lexer: &mut Tokenizer<'a>) -> Result<Self> {
         let mut items = Vec::new();
-        let mut package_id = None;
-        if lexer.eat(Token::Package)? {
-            package_id = Some(PackageName::parse(lexer)?);
-        }
         while lexer.clone().next()?.is_some() {
             let docs = parse_docs(lexer)?;
             items.push(AstItem::parse(lexer, docs)?);
         }
-        Ok(Self { package_id, items })
+        Ok(Self { items })
     }
 
     fn for_each_path<'b>(
         &'b self,
-        mut f: impl FnMut(
-            Option<&'b Id<'a>>,
-            &'b UsePath<'a>,
-            Option<&'b [UseName<'a>]>,
-            WorldOrInterface,
-        ) -> Result<()>,
+        mut f: impl FnMut(Option<&'b Id<'a>>, &'b UsePath<'a>, Option<&[UseName<'a>]>) -> Result<()>,
     ) -> Result<()> {
         for item in self.items.iter() {
             match item {
@@ -54,12 +43,7 @@ impl<'a> Ast<'a> {
                     let mut exports = Vec::new();
                     for item in world.items.iter() {
                         match item {
-                            WorldItem::Use(u) => {
-                                f(None, &u.from, Some(&u.names), WorldOrInterface::Interface)?
-                            }
-                            WorldItem::Include(i) => {
-                                f(Some(&world.name), &i.from, None, WorldOrInterface::World)?
-                            }
+                            WorldItem::Use(u) => f(None, &u.from, Some(&u.names))?,
                             WorldItem::Type(_) => {}
                             WorldItem::Import(Import { kind, .. }) => imports.push(kind),
                             WorldItem::Export(Export { kind, .. }) => exports.push(kind),
@@ -70,19 +54,14 @@ impl<'a> Ast<'a> {
                         ExternKind::Interface(_, items) => {
                             for item in items {
                                 match item {
-                                    InterfaceItem::Use(u) => f(
-                                        None,
-                                        &u.from,
-                                        Some(&u.names),
-                                        WorldOrInterface::Interface,
-                                    )?,
+                                    InterfaceItem::Use(u) => f(None, &u.from, Some(&u.names))?,
                                     _ => {}
                                 }
                             }
                             Ok(())
                         }
-                        ExternKind::Path(path) => f(None, path, None, WorldOrInterface::Interface),
-                        ExternKind::Func(..) => Ok(()),
+                        ExternKind::Path(path) => f(None, path, None),
+                        ExternKind::Func(_) => Ok(()),
                     };
 
                     for kind in imports {
@@ -95,111 +74,56 @@ impl<'a> Ast<'a> {
                 AstItem::Interface(i) => {
                     for item in i.items.iter() {
                         match item {
-                            InterfaceItem::Use(u) => f(
-                                Some(&i.name),
-                                &u.from,
-                                Some(&u.names),
-                                WorldOrInterface::Interface,
-                            )?,
+                            InterfaceItem::Use(u) => f(Some(&i.name), &u.from, Some(&u.names))?,
                             _ => {}
                         }
                     }
                 }
-                AstItem::Use(u) => {
-                    // At the top-level, we don't know if this is a world or an interface
-                    // It is up to the resolver to decides how to handle this ambiguity.
-                    f(None, &u.item, None, WorldOrInterface::Unknown)?;
-                }
             }
         }
         Ok(())
     }
 }
 
-enum AstItem<'a> {
+pub enum AstItem<'a> {
     Interface(Interface<'a>),
     World(World<'a>),
-    Use(ToplevelUse<'a>),
 }
 
 impl<'a> AstItem<'a> {
     fn parse(tokens: &mut Tokenizer<'a>, docs: Docs<'a>) -> Result<Self> {
-        match tokens.clone().next()? {
+        let mut clone = tokens.clone();
+        let token = match clone.next()? {
+            Some((_span, Token::Default)) => clone.next()?,
+            other => other,
+        };
+        match token {
             Some((_span, Token::Interface)) => Interface::parse(tokens, docs).map(Self::Interface),
             Some((_span, Token::World)) => World::parse(tokens, docs).map(Self::World),
-            Some((_span, Token::Use)) => ToplevelUse::parse(tokens).map(Self::Use),
-            other => Err(err_expected(tokens, "`world`, `interface` or `use`", other).into()),
-        }
-    }
-}
-
-#[derive(Debug, Clone)]
-struct PackageName<'a> {
-    span: Span,
-    namespace: Id<'a>,
-    name: Id<'a>,
-    version: Option<(Span, Version)>,
-}
-
-impl<'a> PackageName<'a> {
-    fn parse(tokens: &mut Tokenizer<'a>) -> Result<Self> {
-        let namespace = parse_id(tokens)?;
-        tokens.expect(Token::Colon)?;
-        let name = parse_id(tokens)?;
-        let version = parse_opt_version(tokens)?;
-        Ok(PackageName {
-            span: Span {
-                start: namespace.span.start,
-                end: version
-                    .as_ref()
-                    .map(|(s, _)| s.end)
-                    .unwrap_or(name.span.end),
-            },
-            namespace,
-            name,
-            version,
-        })
-    }
-
-    fn package_name(&self) -> crate::PackageName {
-        crate::PackageName {
-            namespace: self.namespace.name.to_string(),
-            name: self.name.name.to_string(),
-            version: self.version.as_ref().map(|(_, v)| v.clone()),
+            other => Err(err_expected(tokens, "`default`, `world` or `interface`", other).into()),
         }
     }
 }
 
-struct ToplevelUse<'a> {
-    item: UsePath<'a>,
-    as_: Option<Id<'a>>,
-}
-
-impl<'a> ToplevelUse<'a> {
-    fn parse(tokens: &mut Tokenizer<'a>) -> Result<Self> {
-        tokens.expect(Token::Use)?;
-        let item = UsePath::parse(tokens)?;
-        let as_ = if tokens.eat(Token::As)? {
-            Some(parse_id(tokens)?)
-        } else {
-            None
-        };
-        Ok(ToplevelUse { item, as_ })
-    }
-}
-
-struct World<'a> {
+pub struct World<'a> {
     docs: Docs<'a>,
     name: Id<'a>,
     items: Vec<WorldItem<'a>>,
+    default: bool,
 }
 
 impl<'a> World<'a> {
     fn parse(tokens: &mut Tokenizer<'a>, docs: Docs<'a>) -> Result<Self> {
+        let default = tokens.eat(Token::Default)?;
         tokens.expect(Token::World)?;
         let name = parse_id(tokens)?;
         let items = Self::parse_items(tokens)?;
-        Ok(World { docs, name, items })
+        Ok(World {
+            docs,
+            name,
+            items,
+            default,
+        })
     }
 
     fn parse_items(tokens: &mut Tokenizer<'a>) -> Result<Vec<WorldItem<'a>>> {
@@ -216,12 +140,11 @@ impl<'a> World<'a> {
     }
 }
 
-enum WorldItem<'a> {
+pub enum WorldItem<'a> {
     Import(Import<'a>),
     Export(Export<'a>),
     Use(Use<'a>),
     Type(TypeDef<'a>),
-    Include(Include<'a>),
 }
 
 impl<'a> WorldItem<'a> {
@@ -232,9 +155,6 @@ impl<'a> WorldItem<'a> {
             Some((_span, Token::Use)) => Use::parse(tokens).map(WorldItem::Use),
             Some((_span, Token::Type)) => TypeDef::parse(tokens, docs).map(WorldItem::Type),
             Some((_span, Token::Flags)) => TypeDef::parse_flags(tokens, docs).map(WorldItem::Type),
-            Some((_span, Token::Resource)) => {
-                TypeDef::parse_resource(tokens, docs).map(WorldItem::Type)
-            }
             Some((_span, Token::Record)) => {
                 TypeDef::parse_record(tokens, docs).map(WorldItem::Type)
             }
@@ -243,10 +163,9 @@ impl<'a> WorldItem<'a> {
             }
             Some((_span, Token::Union)) => TypeDef::parse_union(tokens, docs).map(WorldItem::Type),
             Some((_span, Token::Enum)) => TypeDef::parse_enum(tokens, docs).map(WorldItem::Type),
-            Some((_span, Token::Include)) => Include::parse(tokens).map(WorldItem::Include),
             other => Err(err_expected(
                 tokens,
-                "`import`, `export`, `include`, `use`, or type definition",
+                "`import`, `export`, `use`, or type definition",
                 other,
             )
             .into()),
@@ -254,92 +173,80 @@ impl<'a> WorldItem<'a> {
     }
 }
 
-struct Import<'a> {
+pub struct Import<'a> {
     docs: Docs<'a>,
+    name: Id<'a>,
     kind: ExternKind<'a>,
 }
 
 impl<'a> Import<'a> {
     fn parse(tokens: &mut Tokenizer<'a>, docs: Docs<'a>) -> Result<Import<'a>> {
         tokens.expect(Token::Import)?;
+        let name = parse_id(tokens)?;
+        tokens.expect(Token::Colon)?;
         let kind = ExternKind::parse(tokens)?;
-        Ok(Import { docs, kind })
+        Ok(Import { docs, name, kind })
     }
 }
 
-struct Export<'a> {
+pub struct Export<'a> {
     docs: Docs<'a>,
+    name: Id<'a>,
     kind: ExternKind<'a>,
 }
 
 impl<'a> Export<'a> {
     fn parse(tokens: &mut Tokenizer<'a>, docs: Docs<'a>) -> Result<Export<'a>> {
         tokens.expect(Token::Export)?;
+        let name = parse_id(tokens)?;
+        tokens.expect(Token::Colon)?;
         let kind = ExternKind::parse(tokens)?;
-        Ok(Export { docs, kind })
+        Ok(Export { docs, name, kind })
     }
 }
 
-enum ExternKind<'a> {
-    Interface(Id<'a>, Vec<InterfaceItem<'a>>),
+pub enum ExternKind<'a> {
+    Interface(Span, Vec<InterfaceItem<'a>>),
     Path(UsePath<'a>),
-    Func(Id<'a>, Func<'a>),
+    Func(Func<'a>),
 }
 
 impl<'a> ExternKind<'a> {
     fn parse(tokens: &mut Tokenizer<'a>) -> Result<ExternKind<'a>> {
-        // Create a copy of the token stream to test out if this is a function
-        // or an interface import. In those situations the token stream gets
-        // reset to the state of the clone and we continue down those paths.
-        //
-        // If neither a function nor an interface appears here though then the
-        // clone is thrown away and the original token stream is parsed for an
-        // interface. This will redo the original ID parse and the original
-        // colon parse, but that shouldn't be too too bad perf-wise.
-        let mut clone = tokens.clone();
-        let id = parse_id(&mut clone)?;
-        if clone.eat(Token::Colon)? {
-            // import foo: func(...)
-            if clone.clone().eat(Token::Func)? {
-                *tokens = clone;
-                return Ok(ExternKind::Func(id, Func::parse(tokens)?));
+        match tokens.clone().next()? {
+            Some((_span, Token::Id | Token::ExplicitId | Token::Pkg | Token::Self_)) => {
+                UsePath::parse(tokens).map(ExternKind::Path)
             }
-
-            // import foo: interface { ... }
-            if clone.eat(Token::Interface)? {
-                *tokens = clone;
-                return Ok(ExternKind::Interface(id, Interface::parse_items(tokens)?));
+            Some((_span, Token::Interface)) => {
+                let span = tokens.expect(Token::Interface)?;
+                let items = Interface::parse_items(tokens)?;
+                Ok(ExternKind::Interface(span, items))
             }
-        }
-
-        // import foo
-        // import foo/bar
-        // import foo:bar/baz
-        Ok(ExternKind::Path(UsePath::parse(tokens)?))
-    }
-
-    fn span(&self) -> Span {
-        match self {
-            ExternKind::Interface(id, _) => id.span,
-            ExternKind::Path(UsePath::Id(id)) => id.span,
-            ExternKind::Path(UsePath::Package { name, .. }) => name.span,
-            ExternKind::Func(id, _) => id.span,
+            Some((_span, Token::Func)) => Ok(ExternKind::Func(Func::parse(tokens)?)),
+            other => Err(err_expected(tokens, "path, value, or interface", other).into()),
         }
     }
 }
 
-struct Interface<'a> {
+pub struct Interface<'a> {
     docs: Docs<'a>,
     name: Id<'a>,
     items: Vec<InterfaceItem<'a>>,
+    default: bool,
 }
 
 impl<'a> Interface<'a> {
     fn parse(tokens: &mut Tokenizer<'a>, docs: Docs<'a>) -> Result<Self> {
+        let default = tokens.eat(Token::Default)?;
         tokens.expect(Token::Interface)?;
         let name = parse_id(tokens)?;
         let items = Self::parse_items(tokens)?;
-        Ok(Interface { docs, name, items })
+        Ok(Interface {
+            docs,
+            name,
+            items,
+            default,
+        })
     }
 
     pub(super) fn parse_items(tokens: &mut Tokenizer<'a>) -> Result<Vec<InterfaceItem<'a>>> {
@@ -356,69 +263,33 @@ impl<'a> Interface<'a> {
     }
 }
 
-#[derive(Debug)]
-pub enum WorldOrInterface {
-    World,
-    Interface,
-    Unknown,
-}
-
-enum InterfaceItem<'a> {
+pub enum InterfaceItem<'a> {
     TypeDef(TypeDef<'a>),
-    Func(NamedFunc<'a>),
+    Value(Value<'a>),
     Use(Use<'a>),
 }
 
-struct Use<'a> {
-    from: UsePath<'a>,
-    names: Vec<UseName<'a>>,
+pub struct Use<'a> {
+    pub from: UsePath<'a>,
+    pub names: Vec<UseName<'a>>,
 }
 
-#[derive(Debug)]
-enum UsePath<'a> {
-    Id(Id<'a>),
-    Package { id: PackageName<'a>, name: Id<'a> },
+pub enum UsePath<'a> {
+    Self_(Id<'a>),
+    Package {
+        doc: Id<'a>,
+        iface: Option<Id<'a>>,
+    },
+    Dependency {
+        dep: Id<'a>,
+        doc: Id<'a>,
+        iface: Option<Id<'a>>,
+    },
 }
 
-impl<'a> UsePath<'a> {
-    fn parse(tokens: &mut Tokenizer<'a>) -> Result<Self> {
-        let id = parse_id(tokens)?;
-        if tokens.eat(Token::Colon)? {
-            // `foo:bar/baz@1.0`
-            let namespace = id;
-            let pkg_name = parse_id(tokens)?;
-            tokens.expect(Token::Slash)?;
-            let name = parse_id(tokens)?;
-            let version = parse_opt_version(tokens)?;
-            Ok(UsePath::Package {
-                id: PackageName {
-                    span: Span {
-                        start: namespace.span.start,
-                        end: pkg_name.span.end,
-                    },
-                    namespace,
-                    name: pkg_name,
-                    version,
-                },
-                name,
-            })
-        } else {
-            // `foo`
-            Ok(UsePath::Id(id))
-        }
-    }
-
-    fn name(&self) -> &Id<'a> {
-        match self {
-            UsePath::Id(id) => id,
-            UsePath::Package { name, .. } => name,
-        }
-    }
-}
-
-struct UseName<'a> {
-    name: Id<'a>,
-    as_: Option<Id<'a>>,
+pub struct UseName<'a> {
+    pub name: Id<'a>,
+    pub as_: Option<Id<'a>>,
 }
 
 impl<'a> Use<'a> {
@@ -447,45 +318,50 @@ impl<'a> Use<'a> {
     }
 }
 
-struct Include<'a> {
-    from: UsePath<'a>,
-    names: Vec<IncludeName<'a>>,
-}
-
-struct IncludeName<'a> {
-    name: Id<'a>,
-    as_: Id<'a>,
-}
-
-impl<'a> Include<'a> {
+impl<'a> UsePath<'a> {
     fn parse(tokens: &mut Tokenizer<'a>) -> Result<Self> {
-        tokens.expect(Token::Include)?;
-        let from = UsePath::parse(tokens)?;
-
-        let names = if tokens.eat(Token::With)? {
-            parse_list(
-                tokens,
-                Token::LeftBrace,
-                Token::RightBrace,
-                |_docs, tokens| {
-                    let name = parse_id(tokens)?;
-                    tokens.expect(Token::As)?;
-                    let as_ = parse_id(tokens)?;
-                    Ok(IncludeName { name, as_ })
-                },
-            )?
-        } else {
-            Vec::new()
-        };
-
-        Ok(Include { from, names })
+        match tokens.clone().next()? {
+            Some((_span, Token::Self_)) => {
+                tokens.expect(Token::Self_)?;
+                tokens.expect(Token::Period)?;
+                let name = parse_id(tokens)?;
+                Ok(UsePath::Self_(name))
+            }
+            Some((_span, Token::Pkg)) => {
+                tokens.expect(Token::Pkg)?;
+                tokens.expect(Token::Period)?;
+                let doc = parse_id(tokens)?;
+                let mut clone = tokens.clone();
+                let iface = if clone.eat(Token::Period)? && !clone.eat(Token::LeftBrace)? {
+                    tokens.expect(Token::Period)?;
+                    Some(parse_id(tokens)?)
+                } else {
+                    None
+                };
+                Ok(UsePath::Package { doc, iface })
+            }
+            Some((_span, Token::Id | Token::ExplicitId)) => {
+                let dep = parse_id(tokens)?;
+                tokens.expect(Token::Period)?;
+                let doc = parse_id(tokens)?;
+                let mut clone = tokens.clone();
+                let iface = if clone.eat(Token::Period)? && !clone.eat(Token::LeftBrace)? {
+                    tokens.expect(Token::Period)?;
+                    Some(parse_id(tokens)?)
+                } else {
+                    None
+                };
+                Ok(UsePath::Dependency { dep, doc, iface })
+            }
+            other => return Err(err_expected(tokens, "`self`, `pkg`, or identifier", other).into()),
+        }
     }
 }
 
 #[derive(Debug, Clone)]
 pub struct Id<'a> {
-    name: &'a str,
-    span: Span,
+    pub name: &'a str,
+    pub span: Span,
 }
 
 impl<'a> From<&'a str> for Id<'a> {
@@ -502,7 +378,7 @@ pub struct Docs<'a> {
     docs: Vec<Cow<'a, str>>,
 }
 
-struct TypeDef<'a> {
+pub struct TypeDef<'a> {
     docs: Docs<'a>,
     name: Id<'a>,
     ty: Type<'a>,
@@ -524,8 +400,6 @@ enum Type<'a> {
     String,
     Name(Id<'a>),
     List(Box<Type<'a>>),
-    Handle(Handle<'a>),
-    Resource(Resource<'a>),
     Record(Record<'a>),
     Flags(Flags<'a>),
     Variant(Variant<'a>),
@@ -538,68 +412,6 @@ enum Type<'a> {
     Union(Union<'a>),
 }
 
-enum Handle<'a> {
-    Own { resource: Id<'a> },
-    Borrow { resource: Id<'a> },
-}
-
-struct Resource<'a> {
-    funcs: Vec<ResourceFunc<'a>>,
-}
-
-enum ResourceFunc<'a> {
-    Method(NamedFunc<'a>),
-    Static(NamedFunc<'a>),
-    Constructor(NamedFunc<'a>),
-}
-
-impl<'a> ResourceFunc<'a> {
-    fn parse(docs: Docs<'a>, tokens: &mut Tokenizer<'a>) -> Result<Self> {
-        match tokens.clone().next()? {
-            Some((span, Token::Constructor)) => {
-                tokens.expect(Token::Constructor)?;
-                tokens.expect(Token::LeftParen)?;
-                let params = parse_list_trailer(tokens, Token::RightParen, |_docs, tokens| {
-                    let name = parse_id(tokens)?;
-                    tokens.expect(Token::Colon)?;
-                    let ty = Type::parse(tokens)?;
-                    Ok((name, ty))
-                })?;
-                Ok(ResourceFunc::Constructor(NamedFunc {
-                    docs,
-                    name: Id {
-                        span,
-                        name: "constructor",
-                    },
-                    func: Func {
-                        params,
-                        results: ResultList::Named(Vec::new()),
-                    },
-                }))
-            }
-            Some((_span, Token::Id | Token::ExplicitId)) => {
-                let name = parse_id(tokens)?;
-                tokens.expect(Token::Colon)?;
-                let ctor = if tokens.eat(Token::Static)? {
-                    ResourceFunc::Static
-                } else {
-                    ResourceFunc::Method
-                };
-                let func = Func::parse(tokens)?;
-                Ok(ctor(NamedFunc { docs, name, func }))
-            }
-            other => Err(err_expected(tokens, "`constructor` or identifier", other).into()),
-        }
-    }
-
-    fn named_func(&self) -> &NamedFunc<'a> {
-        use ResourceFunc::*;
-        match self {
-            Method(f) | Static(f) | Constructor(f) => f,
-        }
-    }
-}
-
 struct Record<'a> {
     fields: Vec<Field<'a>>,
 }
@@ -650,10 +462,10 @@ struct Stream<'a> {
     end: Option<Box<Type<'a>>>,
 }
 
-struct NamedFunc<'a> {
+pub struct Value<'a> {
     docs: Docs<'a>,
     name: Id<'a>,
-    func: Func<'a>,
+    kind: ValueKind<'a>,
 }
 
 struct Union<'a> {
@@ -673,7 +485,11 @@ enum ResultList<'a> {
     Anon(Type<'a>),
 }
 
-struct Func<'a> {
+enum ValueKind<'a> {
+    Func(Func<'a>),
+}
+
+pub struct Func<'a> {
     params: ParamList<'a>,
     results: ResultList<'a>,
 }
@@ -711,6 +527,12 @@ impl<'a> Func<'a> {
     }
 }
 
+impl<'a> ValueKind<'a> {
+    fn parse(tokens: &mut Tokenizer<'a>) -> Result<ValueKind<'a>> {
+        Func::parse(tokens).map(ValueKind::Func)
+    }
+}
+
 impl<'a> InterfaceItem<'a> {
     fn parse(tokens: &mut Tokenizer<'a>, docs: Docs<'a>) -> Result<InterfaceItem<'a>> {
         match tokens.clone().next()? {
@@ -724,9 +546,6 @@ impl<'a> InterfaceItem<'a> {
             Some((_span, Token::Variant)) => {
                 TypeDef::parse_variant(tokens, docs).map(InterfaceItem::TypeDef)
             }
-            Some((_span, Token::Resource)) => {
-                TypeDef::parse_resource(tokens, docs).map(InterfaceItem::TypeDef)
-            }
             Some((_span, Token::Record)) => {
                 TypeDef::parse_record(tokens, docs).map(InterfaceItem::TypeDef)
             }
@@ -734,10 +553,10 @@ impl<'a> InterfaceItem<'a> {
                 TypeDef::parse_union(tokens, docs).map(InterfaceItem::TypeDef)
             }
             Some((_span, Token::Id)) | Some((_span, Token::ExplicitId)) => {
-                NamedFunc::parse(tokens, docs).map(InterfaceItem::Func)
+                Value::parse(tokens, docs).map(InterfaceItem::Value)
             }
             Some((_span, Token::Use)) => Use::parse(tokens).map(InterfaceItem::Use),
-            other => Err(err_expected(tokens, "`type`, `resource` or `func`", other).into()),
+            other => Err(err_expected(tokens, "`type` or `func`", other).into()),
         }
     }
 }
@@ -768,19 +587,6 @@ impl<'a> TypeDef<'a> {
         Ok(TypeDef { docs, name, ty })
     }
 
-    fn parse_resource(tokens: &mut Tokenizer<'a>, docs: Docs<'a>) -> Result<Self> {
-        tokens.expect(Token::Resource)?;
-        let name = parse_id(tokens)?;
-        let mut funcs = Vec::new();
-        if tokens.eat(Token::LeftBrace)? {
-            while !tokens.eat(Token::RightBrace)? {
-                funcs.push(ResourceFunc::parse(parse_docs(tokens)?, tokens)?);
-            }
-        }
-        let ty = Type::Resource(Resource { funcs });
-        Ok(TypeDef { docs, name, ty })
-    }
-
     fn parse_record(tokens: &mut Tokenizer<'a>, docs: Docs<'a>) -> Result<Self> {
         tokens.expect(Token::Record)?;
         let name = parse_id(tokens)?;
@@ -862,12 +668,12 @@ impl<'a> TypeDef<'a> {
     }
 }
 
-impl<'a> NamedFunc<'a> {
+impl<'a> Value<'a> {
     fn parse(tokens: &mut Tokenizer<'a>, docs: Docs<'a>) -> Result<Self> {
         let name = parse_id(tokens)?;
         tokens.expect(Token::Colon)?;
-        let func = Func::parse(tokens)?;
-        Ok(NamedFunc { docs, name, func })
+        let kind = ValueKind::parse(tokens)?;
+        Ok(Value { docs, name, kind })
     }
 }
 
@@ -885,56 +691,6 @@ fn parse_id<'a>(tokens: &mut Tokenizer<'a>) -> Result<Id<'a>> {
     }
 }
 
-fn parse_opt_version(tokens: &mut Tokenizer<'_>) -> Result<Option<(Span, Version)>> {
-    if !tokens.eat(Token::At)? {
-        return Ok(None);
-    }
-    let start = tokens.expect(Token::Integer)?.start;
-    tokens.expect(Token::Period)?;
-    tokens.expect(Token::Integer)?;
-    tokens.expect(Token::Period)?;
-    let end = tokens.expect(Token::Integer)?.end;
-    let mut span = Span { start, end };
-    eat_ids(tokens, Token::Minus, &mut span)?;
-    eat_ids(tokens, Token::Plus, &mut span)?;
-    let string = tokens.get_span(span);
-    let version = Version::parse(string).map_err(|e| Error {
-        span,
-        msg: e.to_string(),
-    })?;
-    return Ok(Some((span, version)));
-
-    fn eat_ids(tokens: &mut Tokenizer<'_>, prefix: Token, end: &mut Span) -> Result<()> {
-        if !tokens.eat(prefix)? {
-            return Ok(());
-        }
-        loop {
-            match tokens.next()? {
-                Some((span, Token::Id)) | Some((span, Token::Integer)) => end.end = span.end,
-                other => break Err(err_expected(tokens, "an id or integer", other).into()),
-            }
-
-            // If there's no trailing period, then this semver identifier is
-            // done.
-            let mut clone = tokens.clone();
-            if !clone.eat(Token::Period)? {
-                break Ok(());
-            }
-
-            // If there's more to the identifier, then eat the period for real
-            // and continue
-            if clone.eat(Token::Id)? || clone.eat(Token::Integer)? {
-                tokens.eat(Token::Period)?;
-                continue;
-            }
-
-            // Otherwise for something like `use foo:bar/baz@1.2.3+foo.{` stop
-            // the parsing here.
-            break Ok(());
-        }
-    }
-}
-
 fn parse_docs<'a>(tokens: &mut Tokenizer<'a>) -> Result<Docs<'a>> {
     let mut docs = Docs::default();
     let mut clone = tokens.clone();
@@ -1052,22 +808,6 @@ impl<'a> Type<'a> {
                 Ok(Type::Stream(Stream { element, end }))
             }
 
-            // own<T>
-            Some((_span, Token::Own)) => {
-                tokens.expect(Token::LessThan)?;
-                let resource = parse_id(tokens)?;
-                tokens.expect(Token::GreaterThan)?;
-                Ok(Type::Handle(Handle::Own { resource }))
-            }
-
-            // borrow<T>
-            Some((_span, Token::Borrow)) => {
-                tokens.expect(Token::LessThan)?;
-                let resource = parse_id(tokens)?;
-                tokens.expect(Token::GreaterThan)?;
-                Ok(Type::Handle(Handle::Borrow { resource }))
-            }
-
             // `foo`
             Some((span, Token::Id)) => Ok(Type::Name(Id {
                 name: tokens.parse_id(span)?.into(),
@@ -1154,6 +894,7 @@ pub struct SourceMap {
 struct Source {
     offset: u32,
     path: PathBuf,
+    name: String,
     contents: String,
 }
 
@@ -1165,21 +906,32 @@ impl SourceMap {
 
     /// Reads the file `path` on the filesystem and appends its contents to this
     /// [`SourceMap`].
+    ///
+    /// This method pushes a new document into the source map. The name of the
+    /// document is derived from the filename of the `path` provided.
     pub fn push_file(&mut self, path: &Path) -> Result<()> {
         let contents = std::fs::read_to_string(path)
             .with_context(|| format!("failed to read file {path:?}"))?;
-        self.push(path, contents);
+        let filename = match path.file_name().and_then(|s| s.to_str()) {
+            Some(stem) => stem,
+            None => bail!("no filename for {path:?}"),
+        };
+        let name = match filename.find('.') {
+            Some(i) => &filename[..i],
+            None => filename,
+        };
+        self.push(path, name, contents);
         Ok(())
     }
 
     /// Appends the given contents with the given path into this source map.
     ///
-    /// The `path` provided is not read from the filesystem and is instead only
-    /// used during error messages. Each file added to a [`SourceMap`] is
-    /// used to create the final parsed package namely by unioning all the
-    /// interfaces and worlds defined together. Note that each file has its own
-    /// personal namespace, however, for top-level `use` and such.
-    pub fn push(&mut self, path: &Path, contents: impl Into<String>) {
+    /// Each path added to a [`SourceMap`] will become a document in the final
+    /// package. The `path` provided is not read from the filesystem and is
+    /// instead only used during error messages. The `name` provided is the name
+    /// of the document within the WIT package and must be a valid WIT
+    /// identifier.
+    pub fn push(&mut self, path: &Path, name: &str, contents: impl Into<String>) {
         let mut contents = contents.into();
         if path.extension().and_then(|s| s.to_str()) == Some("md") {
             log::debug!("automatically unwrapping markdown container");
@@ -1190,6 +942,7 @@ impl SourceMap {
             offset: self.offset,
             path: path.to_path_buf(),
             contents,
+            name: name.to_string(),
         });
         self.offset = new_offset;
 
@@ -1232,20 +985,23 @@ impl SourceMap {
     }
 
     /// Parses the files added to this source map into an [`UnresolvedPackage`].
-    pub fn parse(self) -> Result<UnresolvedPackage> {
+    ///
+    /// All files previously added are considered documents of the package to be
+    /// returned.
+    pub fn parse(self, name: &str, url: Option<&str>) -> Result<UnresolvedPackage> {
         let mut doc = self.rewrite_error(|| {
             let mut resolver = Resolver::default();
             let mut srcs = self.sources.iter().collect::<Vec<_>>();
-            srcs.sort_by_key(|src| &src.path);
+            srcs.sort_by_key(|src| &src.name);
             for src in srcs {
                 let mut tokens = Tokenizer::new(&src.contents, src.offset)
                     .with_context(|| format!("failed to tokenize path: {}", src.path.display()))?;
                 let ast = Ast::parse(&mut tokens)?;
-                resolver.push(ast).with_context(|| {
+                resolver.push(&src.name, ast).with_context(|| {
                     format!("failed to start resolving path: {}", src.path.display())
                 })?;
             }
-            resolver.resolve()
+            resolver.resolve(name, url)
         })?;
         doc.source_map = self;
         Ok(doc)
@@ -1341,22 +1097,3 @@ impl SourceMap {
         self.sources.iter().map(|src| src.path.as_path())
     }
 }
-
-pub(crate) enum AstUsePath {
-    Name(String),
-    Package(crate::PackageName, String),
-}
-
-pub(crate) fn parse_use_path(s: &str) -> Result<AstUsePath> {
-    let mut tokens = Tokenizer::new(s, 0)?;
-    let path = UsePath::parse(&mut tokens)?;
-    if tokens.next()?.is_some() {
-        bail!("trailing tokens in path specifier");
-    }
-    Ok(match path {
-        UsePath::Id(id) => AstUsePath::Name(id.name.to_string()),
-        UsePath::Package { id, name } => {
-            AstUsePath::Package(id.package_name(), name.name.to_string())
-        }
-    })
-}
diff --git a/crates/wit-parser/src/ast/lex.rs b/crates/wit-parser/src/ast/lex.rs
index ee79d20c..5023a854 100644
--- a/crates/wit-parser/src/ast/lex.rs
+++ b/crates/wit-parser/src/ast/lex.rs
@@ -46,10 +46,6 @@ pub enum Token {
     GreaterThan,
     RArrow,
     Star,
-    At,
-    Slash,
-    Plus,
-    Minus,
 
     Use,
     Type,
@@ -66,9 +62,6 @@ pub enum Token {
     Float64,
     Char,
     Record,
-    Resource,
-    Own,
-    Borrow,
     Flags,
     Variant,
     Enum,
@@ -86,19 +79,16 @@ pub enum Token {
     Static,
     Interface,
     Tuple,
+    Implements,
     Import,
     Export,
     World,
-    Package,
-    Constructor,
+    Default,
+    Pkg,
+    Self_,
 
     Id,
     ExplicitId,
-
-    Integer,
-
-    Include,
-    With,
 }
 
 #[derive(Eq, PartialEq, Debug)]
@@ -184,7 +174,6 @@ impl<'a> Tokenizer<'a> {
                             break;
                         }
                     }
-                    Comment
                 // eat a block comment if it's `/*...`
                 } else if self.eatc('*') {
                     let mut depth = 1;
@@ -199,10 +188,11 @@ impl<'a> Tokenizer<'a> {
                             _ => {}
                         }
                     }
-                    Comment
                 } else {
-                    Slash
+                    return Err(Error::Unexpected(start, ch));
                 }
+
+                Comment
             }
             '=' => Equals,
             ',' => Comma,
@@ -216,15 +206,13 @@ impl<'a> Tokenizer<'a> {
             '<' => LessThan,
             '>' => GreaterThan,
             '*' => Star,
-            '@' => At,
             '-' => {
                 if self.eatc('>') {
                     RArrow
                 } else {
-                    Minus
+                    return Err(Error::Unexpected(start, '-'));
                 }
             }
-            '+' => Plus,
             '%' => {
                 let mut iter = self.chars.clone();
                 if let Some((_, ch)) = iter.next() {
@@ -266,9 +254,6 @@ impl<'a> Tokenizer<'a> {
                     "float32" => Float32,
                     "float64" => Float64,
                     "char" => Char,
-                    "resource" => Resource,
-                    "own" => Own,
-                    "borrow" => Borrow,
                     "record" => Record,
                     "flags" => Flags,
                     "variant" => Variant,
@@ -287,29 +272,16 @@ impl<'a> Tokenizer<'a> {
                     "static" => Static,
                     "interface" => Interface,
                     "tuple" => Tuple,
+                    "implements" => Implements,
                     "world" => World,
                     "import" => Import,
                     "export" => Export,
-                    "package" => Package,
-                    "constructor" => Constructor,
-                    "include" => Include,
-                    "with" => With,
+                    "default" => Default,
+                    "pkg" => Pkg,
+                    "self" => Self_,
                     _ => Id,
                 }
             }
-
-            ch if ch.is_ascii_digit() => {
-                let mut iter = self.chars.clone();
-                while let Some((_, ch)) = iter.next() {
-                    if !ch.is_ascii_digit() {
-                        break;
-                    }
-                    self.chars = iter.clone();
-                }
-
-                Integer
-            }
-
             ch => return Err(Error::Unexpected(start, ch)),
         };
         let end = match self.chars.clone().next() {
@@ -515,9 +487,6 @@ impl Token {
             Float32 => "keyword `float32`",
             Float64 => "keyword `float64`",
             Char => "keyword `char`",
-            Own => "keyword `own`",
-            Borrow => "keyword `borrow`",
-            Resource => "keyword `resource`",
             Record => "keyword `record`",
             Flags => "keyword `flags`",
             Variant => "keyword `variant`",
@@ -535,23 +504,18 @@ impl Token {
             ExplicitId => "an '%' identifier",
             RArrow => "`->`",
             Star => "`*`",
-            At => "`@`",
-            Slash => "`/`",
-            Plus => "`+`",
-            Minus => "`-`",
             As => "keyword `as`",
             From_ => "keyword `from`",
             Static => "keyword `static`",
             Interface => "keyword `interface`",
             Tuple => "keyword `tuple`",
+            Implements => "keyword `implements`",
             Import => "keyword `import`",
             Export => "keyword `export`",
             World => "keyword `world`",
-            Package => "keyword `package`",
-            Constructor => "keyword `constructor`",
-            Integer => "an integer",
-            Include => "keyword `include`",
-            With => "keyword `with`",
+            Default => "keyword `default`",
+            Self_ => "keyword `self`",
+            Pkg => "keyword `pkg`",
         }
     }
 }
@@ -685,25 +649,6 @@ fn test_tokenizer() {
         ]
     );
 
-    assert_eq!(collect("resource").unwrap(), vec![Token::Resource]);
-
-    assert_eq!(collect("own").unwrap(), vec![Token::Own]);
-    assert_eq!(
-        collect("own<some-id>").unwrap(),
-        vec![Token::Own, Token::LessThan, Token::Id, Token::GreaterThan]
-    );
-
-    assert_eq!(collect("borrow").unwrap(), vec![Token::Borrow]);
-    assert_eq!(
-        collect("borrow<some-id>").unwrap(),
-        vec![
-            Token::Borrow,
-            Token::LessThan,
-            Token::Id,
-            Token::GreaterThan
-        ]
-    );
-
     assert!(collect("\u{149}").is_err(), "strongly discouraged");
     assert!(collect("\u{673}").is_err(), "strongly discouraged");
     assert!(collect("\u{17a3}").is_err(), "strongly discouraged");
diff --git a/crates/wit-parser/src/ast/resolve.rs b/crates/wit-parser/src/ast/resolve.rs
index 70f4d12a..ba499cb5 100644
--- a/crates/wit-parser/src/ast/resolve.rs
+++ b/crates/wit-parser/src/ast/resolve.rs
@@ -1,93 +1,41 @@
-use super::{Error, ParamList, ResultList, WorldOrInterface};
+use super::{Error, ParamList, ResultList, ValueKind};
 use crate::ast::toposort::toposort;
 use crate::*;
-use anyhow::{bail, Result};
+use anyhow::{anyhow, bail, Result};
 use indexmap::IndexMap;
-use std::collections::{HashMap, HashSet};
+use std::collections::HashMap;
 use std::mem;
 
 #[derive(Default)]
 pub struct Resolver<'a> {
-    /// Current package named learned through the ASTs pushed onto this resolver.
-    package_name: Option<PackageName>,
-
-    /// All WIT files which are going to be resolved together.
-    asts: Vec<ast::Ast<'a>>,
-
-    // Arenas that get plumbed to the final `UnresolvedPackage`
+    asts: IndexMap<&'a str, ast::Ast<'a>>,
     types: Arena<TypeDef>,
+    anon_types: HashMap<Key, TypeId>,
     interfaces: Arena<Interface>,
+    documents: Arena<Document>,
     worlds: Arena<World>,
-
-    // Interning structure for types which-need-not-be-named such as
-    // `list<string>` and such.
-    anon_types: HashMap<Key, TypeId>,
-
-    /// The index within `self.ast_items` that lookups should go through. This
-    /// is updated as the ASTs are walked.
-    cur_ast_index: usize,
-
-    /// A map per `ast::Ast` which keeps track of the file's top level names in
-    /// scope. This maps each name onto either a world or an interface, handling
-    /// things like `use` at the top level.
-    ast_items: Vec<IndexMap<&'a str, AstItem>>,
-
-    /// A map for the entire package being created of all names defined within,
-    /// along with the ID they're mapping to.
-    package_items: IndexMap<&'a str, AstItem>,
-
-    /// A per-interface map of name to item-in-the-interface. This is the same
-    /// length as `self.types` and is pushed to whenever `self.types` is pushed
-    /// to.
+    document_lookup: IndexMap<&'a str, DocumentId>,
+    document_interfaces: Vec<IndexMap<&'a str, DocumentItem>>,
     interface_types: Vec<IndexMap<&'a str, (TypeOrItem, Span)>>,
-
-    /// Metadata about foreign dependencies which are not defined in this
-    /// package. This map is keyed by the name of the package being imported
-    /// from. The next level of key is the name of the interface being imported
-    /// from, and the final value is the assigned ID of the interface.
-    foreign_deps: IndexMap<PackageName, IndexMap<&'a str, AstItem>>,
-
-    /// All interfaces that are present within `self.foreign_deps`.
-    foreign_interfaces: HashSet<InterfaceId>,
-
-    foreign_worlds: HashSet<WorldId>,
-
-    /// The current type lookup scope which will eventually make its way into
-    /// `self.interface_types`.
+    foreign_deps: IndexMap<&'a str, IndexMap<&'a str, DocumentId>>,
     type_lookup: IndexMap<&'a str, (TypeOrItem, Span)>,
 
-    /// An assigned span for where all types inserted into `self.types` as
-    /// imported from foreign interfaces. These types all show up first in the
-    /// `self.types` arena and this span is used to generate an error message
-    /// pointing to it if the item isn't actually defined.
     unknown_type_spans: Vec<Span>,
-
-    /// Spans for each world in `self.world` to assign for each import/export
-    /// for later error reporting.
-    world_item_spans: Vec<(Vec<Span>, Vec<Span>)>,
-
-    /// Spans for each world in `self.world`
-    world_spans: Vec<Span>,
-
-    /// The span of each interface's definition which is used for error
-    /// reporting during the final `Resolve` phase.
+    world_spans: Vec<(Vec<Span>, Vec<Span>)>,
+    document_spans: Vec<Span>,
     interface_spans: Vec<Span>,
-
-    /// Spans per entry in `self.foreign_deps` for where the dependency was
-    /// introduced to print an error message if necessary.
     foreign_dep_spans: Vec<Span>,
+}
 
-    include_world_spans: Vec<Span>,
-
-    /// A list of `TypeDefKind::Unknown` types which are required to be
-    /// resources when this package is resolved against its dependencies.
-    required_resource_types: Vec<(TypeId, Span)>,
+#[derive(Copy, Clone)]
+enum DocumentItem {
+    Interface(InterfaceId),
+    World(WorldId),
 }
 
 #[derive(PartialEq, Eq, Hash)]
 enum Key {
     Variant(Vec<(String, Option<Type>)>),
-    BorrowHandle(TypeId),
     Record(Vec<(String, Type)>),
     Flags(Vec<String>),
     Tuple(Vec<Type>),
@@ -111,95 +59,71 @@ enum TypeOrItem {
 }
 
 impl<'a> Resolver<'a> {
-    pub(crate) fn push(&mut self, ast: ast::Ast<'a>) -> Result<()> {
-        // As each WIT file is pushed into this resolver keep track of the
-        // current package name assigned. Only one file needs to mention it, but
-        // if multiple mention it then they must all match.
-        if let Some(cur) = &ast.package_id {
-            let cur_name = cur.package_name();
-            if let Some(prev) = &self.package_name {
-                if cur_name != *prev {
-                    bail!(Error {
-                        span: cur.span,
-                        msg: format!(
-                            "package identifier `{cur_name}` does not match \
-                             previous package name of `{prev}`"
-                        ),
-                    })
-                }
-            }
-            self.package_name = Some(cur_name);
+    pub(crate) fn push(&mut self, name: &'a str, ast: ast::Ast<'a>) -> Result<()> {
+        // Note that this specifically uses `map_err` instead of `with_context`
+        // since the error returned from `validate_id` is an `Error` which has a
+        // filename and a line number, but there's no filename or line number
+        // associated with this error so we just want the string message.
+        crate::validate_id(name)
+            .map_err(|e| anyhow!("name of document isn't a valid WIT identifier `{name}`: {e}"))?;
+
+        let prev = self.asts.insert(name, ast);
+        if prev.is_some() {
+            bail!("document `{name}` is defined more than once");
         }
-        self.asts.push(ast);
         Ok(())
     }
 
-    pub(crate) fn resolve(&mut self) -> Result<UnresolvedPackage> {
-        // At least one of the WIT files must have a `package` annotation.
-        let name = match &self.package_name {
-            Some(name) => name.clone(),
-            None => bail!("no `package` header was found in any WIT file for this package"),
-        };
-
-        // First populate information about foreign dependencies and the general
-        // structure of the package. This should resolve the "base" of many
-        // `use` statements and additionally generate a topological ordering of
-        // all interfaces in the package to visit.
-        let asts = mem::take(&mut self.asts);
-        self.populate_foreign_deps(&asts);
-        let (iface_order, world_order) = self.populate_ast_items(&asts)?;
-        self.populate_foreign_types(&asts)?;
-
-        // Use the topological ordering of all interfaces to resolve all
-        // interfaces in-order. Note that a reverse-mapping from ID to AST is
-        // generated here to assist with this.
-        let mut iface_id_to_ast = IndexMap::new();
-        let mut world_id_to_ast = IndexMap::new();
-        for (i, ast) in asts.iter().enumerate() {
-            for item in ast.items.iter() {
-                match item {
-                    ast::AstItem::Interface(iface) => {
-                        let id = match self.ast_items[i][iface.name.name] {
-                            AstItem::Interface(id) => id,
-                            AstItem::World(_) => unreachable!(),
-                        };
-                        iface_id_to_ast.insert(id, (iface, i));
-                    }
-                    ast::AstItem::World(world) => {
-                        let id = match self.ast_items[i][world.name.name] {
-                            AstItem::World(id) => id,
-                            AstItem::Interface(_) => unreachable!(),
-                        };
-                        world_id_to_ast.insert(id, (world, i));
-                    }
-                    ast::AstItem::Use(_) => {}
+    pub(crate) fn resolve(&mut self, name: &str, url: Option<&str>) -> Result<UnresolvedPackage> {
+        self.populate_foreign_deps();
+
+        // Determine the dependencies between documents in the current package
+        // we're parsing to perform a topological sort and how to visit the
+        // documents in order.
+        let mut doc_deps = IndexMap::new();
+        for (name, ast) in self.asts.iter() {
+            let mut deps = Vec::new();
+            ast.for_each_path(|_, path, _names| {
+                let doc = match path {
+                    ast::UsePath::Package { doc, iface: _ } => doc,
+                    _ => return Ok(()),
+                };
+                // If this document imports from itself using `pkg` syntax
+                // that's ok and skip this dependency to prevent it from
+                // otherwise being flagged as cyclic.
+                if doc.name == *name {
+                    return Ok(());
                 }
-            }
-        }
+                deps.push(doc.clone());
+                Ok(())
+            })
+            .unwrap();
 
-        for id in iface_order {
-            let (interface, i) = &iface_id_to_ast[&id];
-            self.cur_ast_index = *i;
-            self.resolve_interface(id, &interface.items, &interface.docs)?;
+            let prev = doc_deps.insert(*name, deps);
+            assert!(prev.is_none());
         }
 
-        for id in world_order {
-            let (workld, i) = &world_id_to_ast[&id];
-            self.cur_ast_index = *i;
-            self.resolve_world(id, workld)?;
+        let order = toposort("document", &doc_deps)?;
+        log::debug!("toposort for documents is {order:?}");
+        let mut asts = mem::take(&mut self.asts);
+        for name in order {
+            let ast = asts.remove(&name).unwrap();
+            self.resolve_document(name, &ast)?;
         }
 
         Ok(UnresolvedPackage {
-            name,
+            name: name.to_string(),
+            url: url.map(|s| s.to_string()),
             worlds: mem::take(&mut self.worlds),
             types: mem::take(&mut self.types),
             interfaces: mem::take(&mut self.interfaces),
+            documents: mem::take(&mut self.documents),
             foreign_deps: self
                 .foreign_deps
                 .iter()
                 .map(|(name, deps)| {
                     (
-                        name.clone(),
+                        name.to_string(),
                         deps.iter()
                             .map(|(name, id)| (name.to_string(), *id))
                             .collect(),
@@ -207,322 +131,88 @@ impl<'a> Resolver<'a> {
                 })
                 .collect(),
             unknown_type_spans: mem::take(&mut self.unknown_type_spans),
-            world_item_spans: mem::take(&mut self.world_item_spans),
-            interface_spans: mem::take(&mut self.interface_spans),
             world_spans: mem::take(&mut self.world_spans),
+            document_spans: mem::take(&mut self.document_spans),
+            interface_spans: mem::take(&mut self.interface_spans),
             foreign_dep_spans: mem::take(&mut self.foreign_dep_spans),
             source_map: SourceMap::default(),
-            include_world_spans: mem::take(&mut self.include_world_spans),
-            required_resource_types: mem::take(&mut self.required_resource_types),
         })
     }
 
-    /// Registers all foreign dependencies made within the ASTs provided.
+    /// Populate "unknown" for all types referenced from foreign packages as
+    /// well as inserting interfaces for referenced interfaces.
     ///
-    /// This will populate the `self.foreign_{deps,interfaces,worlds}` maps with all
-    /// `UsePath::Package` entries.
-    fn populate_foreign_deps(&mut self, asts: &[ast::Ast<'a>]) {
-        let mut foreign_deps = mem::take(&mut self.foreign_deps);
-        let mut foreign_interfaces = mem::take(&mut self.foreign_interfaces);
-        let mut foreign_worlds = mem::take(&mut self.foreign_worlds);
-        for ast in asts {
-            ast.for_each_path(|_, path, _names, world_or_iface| {
-                let (id, name) = match path {
-                    ast::UsePath::Package { id, name } => (id, name),
+    /// This will populate the initial set of documents/interfaces/types with
+    /// everything referenced from foreign packages, or those through
+    /// `UsePath::Dependency`. The items created here are extracted later via
+    /// `resolve_path`.
+    fn populate_foreign_deps(&mut self) {
+        for (_, ast) in self.asts.iter() {
+            ast.for_each_path(|_, path, names| {
+                let (dep, doc, iface) = match path {
+                    ast::UsePath::Dependency { dep, doc, iface } => (dep, doc, iface),
                     _ => return Ok(()),
                 };
 
-                let deps = foreign_deps.entry(id.package_name()).or_insert_with(|| {
-                    self.foreign_dep_spans.push(id.span);
+                let deps = self.foreign_deps.entry(dep.name).or_insert_with(|| {
+                    self.foreign_dep_spans.push(dep.span);
                     IndexMap::new()
                 });
-                let id = *deps.entry(name.name).or_insert_with(|| {
-                    match world_or_iface {
-                        WorldOrInterface::World => {
-                            log::trace!(
-                                "creating a world for foreign dep: {}/{}",
-                                id.package_name(),
-                                name.name
-                            );
-                            AstItem::World(self.alloc_world(name.span, true))
-                        }
-                        WorldOrInterface::Interface | WorldOrInterface::Unknown => {
-                            // Currently top-level `use` always assumes an interface, so the
-                            // `Unknown` case is the same as `Interface`.
-                            log::trace!(
-                                "creating an interface for foreign dep: {}/{}",
-                                id.package_name(),
-                                name.name
-                            );
-                            AstItem::Interface(self.alloc_interface(name.span))
-                        }
-                    }
+                let doc_span = doc.span;
+                let doc = *deps.entry(doc.name).or_insert_with(|| {
+                    log::trace!("creating a document for foreign dep: {}", dep.name);
+                    self.document_interfaces.push(IndexMap::new());
+                    self.document_spans.push(doc_span);
+                    self.documents.alloc(Document {
+                        name: doc.name.to_string(),
+                        default_interface: None,
+                        default_world: None,
+                        interfaces: IndexMap::new(),
+                        worlds: IndexMap::new(),
+                        package: None,
+                    })
                 });
 
-                let _ = match id {
-                    AstItem::Interface(id) => foreign_interfaces.insert(id),
-                    AstItem::World(id) => foreign_worlds.insert(id),
-                };
-
-                Ok(())
-            })
-            .unwrap();
-        }
-        self.foreign_deps = foreign_deps;
-        self.foreign_interfaces = foreign_interfaces;
-        self.foreign_worlds = foreign_worlds;
-    }
-
-    fn alloc_interface(&mut self, span: Span) -> InterfaceId {
-        self.interface_types.push(IndexMap::new());
-        self.interface_spans.push(span);
-        self.interfaces.alloc(Interface {
-            name: None,
-            types: IndexMap::new(),
-            docs: Docs::default(),
-            functions: IndexMap::new(),
-            package: None,
-        })
-    }
-
-    fn alloc_world(&mut self, span: Span, dummy_span: bool) -> WorldId {
-        self.world_spans.push(span);
-        if dummy_span {
-            self.world_item_spans.push((Vec::new(), Vec::new()));
-        }
-        self.worlds.alloc(World {
-            name: String::new(),
-            docs: Docs::default(),
-            exports: IndexMap::new(),
-            imports: IndexMap::new(),
-            package: None,
-            includes: Default::default(),
-            include_names: Default::default(),
-        })
-    }
-
-    /// This method will create a `World` and an `Interface` for all items
-    /// present in the specified set of ASTs. Additionally maps for each AST are
-    /// generated for resolving use-paths later on.
-    fn populate_ast_items(
-        &mut self,
-        asts: &[ast::Ast<'a>],
-    ) -> Result<(Vec<InterfaceId>, Vec<WorldId>)> {
-        let mut package_items = IndexMap::new();
-
-        // Validate that all worlds and interfaces have unique names within this
-        // package across all ASTs which make up the package.
-        let mut names = HashMap::new();
-        let mut ast_namespaces = Vec::new();
-        let mut order = IndexMap::new();
-        for ast in asts {
-            let mut ast_ns = IndexMap::new();
-            for item in ast.items.iter() {
-                match item {
-                    ast::AstItem::Interface(i) => {
-                        if package_items.insert(i.name.name, i.name.span).is_some() {
-                            bail!(Error {
-                                span: i.name.span,
-                                msg: format!("duplicate item named `{}`", i.name.name),
-                            })
-                        }
-                        let prev = ast_ns.insert(i.name.name, ());
-                        assert!(prev.is_none());
-                        let prev = order.insert(i.name.name, Vec::new());
-                        assert!(prev.is_none());
-                        let prev = names.insert(i.name.name, item);
-                        assert!(prev.is_none());
-                    }
-                    ast::AstItem::World(w) => {
-                        if package_items.insert(w.name.name, w.name.span).is_some() {
-                            bail!(Error {
-                                span: w.name.span,
-                                msg: format!("duplicate item named `{}", w.name.name),
-                            })
-                        }
-                        let prev = ast_ns.insert(w.name.name, ());
-                        assert!(prev.is_none());
-                        let prev = order.insert(w.name.name, Vec::new());
-                        assert!(prev.is_none());
-                        let prev = names.insert(w.name.name, item);
-                        assert!(prev.is_none());
-                    }
-                    // These are processed down below.
-                    ast::AstItem::Use(_) => {}
-                }
-            }
-            ast_namespaces.push(ast_ns);
-        }
-
-        // Next record dependencies between interfaces as induced via `use`
-        // paths. This step is used to perform a topological sort of all
-        // interfaces to ensure there are no cycles and to generate an ordering
-        // which we can resolve in.
-        enum ItemSource<'a> {
-            Foreign,
-            Local(ast::Id<'a>),
-        }
-
-        for ast in asts {
-            // Record, in the context of this file, what all names are defined
-            // at the top level and whether they point to other items in this
-            // package or foreign items. Foreign deps are ignored for
-            // topological ordering.
-            let mut ast_ns = IndexMap::new();
-            for item in ast.items.iter() {
-                let (name, src) = match item {
-                    ast::AstItem::Use(u) => {
-                        let name = u.as_.as_ref().unwrap_or(u.item.name());
-                        let src = match &u.item {
-                            ast::UsePath::Id(id) => ItemSource::Local(id.clone()),
-                            ast::UsePath::Package { .. } => ItemSource::Foreign,
-                        };
-                        (name, src)
-                    }
-                    ast::AstItem::Interface(i) => (&i.name, ItemSource::Local(i.name.clone())),
-                    ast::AstItem::World(w) => (&w.name, ItemSource::Local(w.name.clone())),
-                };
-                if ast_ns.insert(name.name, (name.span, src)).is_some() {
-                    bail!(Error {
-                        span: name.span,
-                        msg: format!("duplicate name `{}` in this file", name.name),
-                    });
-                }
-            }
-
-            // With this file's namespace information look at all `use` paths
-            // and record dependencies between interfaces.
-            ast.for_each_path(|iface, path, _names, _| {
-                // If this import isn't contained within an interface then it's
-                // in a world and it doesn't need to participate in our
-                // topo-sort.
                 let iface = match iface {
-                    Some(name) => name,
-                    None => return Ok(()),
-                };
-                let used_name = match path {
-                    ast::UsePath::Id(id) => id,
-                    ast::UsePath::Package { .. } => return Ok(()),
-                };
-                match ast_ns.get(used_name.name) {
-                    Some((_, ItemSource::Foreign)) => return Ok(()),
-                    Some((_, ItemSource::Local(id))) => {
-                        order[iface.name].push(id.clone());
-                    }
-                    None => match package_items.get(used_name.name) {
-                        Some(_) => {
-                            order[iface.name].push(used_name.clone());
+                    Some(iface) => {
+                        let item = self.document_interfaces[doc.index()]
+                            .entry(iface.name)
+                            .or_insert_with(|| {
+                                self.interface_types.push(IndexMap::new());
+                                self.interface_spans.push(iface.span);
+                                let id = self.interfaces.alloc(Interface {
+                                    name: Some(iface.name.to_string()),
+                                    types: IndexMap::new(),
+                                    docs: Docs::default(),
+                                    document: doc,
+                                    functions: IndexMap::new(),
+                                });
+                                DocumentItem::Interface(id)
+                            });
+                        match item {
+                            DocumentItem::Interface(id) => *id,
+                            _ => unreachable!(),
                         }
-                        None => {
-                            bail!(Error {
-                                span: used_name.span,
-                                msg: format!(
-                                    "interface or world `{name}` not found in package",
-                                    name = used_name.name
-                                ),
-                            })
-                        }
-                    },
-                }
-                Ok(())
-            })?;
-        }
-
-        let order = toposort("interface or world", &order)?;
-        log::debug!("toposort for interfaces and worlds in order: {:?}", order);
-
-        // Allocate interfaces in-order now that the ordering is defined. This
-        // is then used to build up internal maps for each AST which are stored
-        // in `self.ast_items`.
-        let mut ids = IndexMap::new();
-        let mut iface_id_order = Vec::new();
-        let mut world_id_order = Vec::new();
-        for name in order {
-            match names.get(name).unwrap() {
-                ast::AstItem::Interface(_) => {
-                    let id = self.alloc_interface(package_items[name]);
-                    self.interfaces[id].name = Some(name.to_string());
-                    let prev = ids.insert(name, AstItem::Interface(id));
-                    assert!(prev.is_none());
-                    iface_id_order.push(id);
-                }
-                ast::AstItem::World(_) => {
-                    // No dummy span needs to be created because they will be created at `resolve_world`
-                    let id = self.alloc_world(package_items[name], false);
-                    self.worlds[id].name = name.to_string();
-                    let prev = ids.insert(name, AstItem::World(id));
-                    assert!(prev.is_none());
-                    world_id_order.push(id);
-                }
-                ast::AstItem::Use(_) => unreachable!(),
-            };
-        }
-        for ast in asts {
-            let mut items = IndexMap::new();
-            for item in ast.items.iter() {
-                let (name, ast_item) = match item {
-                    ast::AstItem::Use(u) => {
-                        let name = u.as_.as_ref().unwrap_or(u.item.name());
-                        let item = match &u.item {
-                            ast::UsePath::Id(name) => *ids.get(name.name).ok_or_else(|| Error {
-                                span: name.span,
-                                msg: format!(
-                                    "interface or world `{name}` does not exist",
-                                    name = name.name
-                                ),
-                            })?,
-                            ast::UsePath::Package { id, name } => {
-                                self.foreign_deps[&id.package_name()][name.name]
-                            }
-                        };
-                        (name.name, item)
-                    }
-                    ast::AstItem::Interface(i) => {
-                        let iface_item = ids[i.name.name];
-                        assert!(matches!(iface_item, AstItem::Interface(_)));
-                        (i.name.name, iface_item)
-                    }
-                    ast::AstItem::World(w) => {
-                        let world_item = ids[w.name.name];
-                        assert!(matches!(world_item, AstItem::World(_)));
-                        (w.name.name, world_item)
                     }
+                    None => *self.documents[doc]
+                        .default_interface
+                        .get_or_insert_with(|| {
+                            self.interface_types.push(IndexMap::new());
+                            self.interface_spans.push(doc_span);
+                            self.interfaces.alloc(Interface {
+                                name: None,
+                                types: IndexMap::new(),
+                                docs: Docs::default(),
+                                document: doc,
+                                functions: IndexMap::new(),
+                            })
+                        }),
                 };
-                let prev = items.insert(name, ast_item);
-                assert!(prev.is_none());
 
-                // Items defined via `use` don't go into the package namespace,
-                // only the file namespace.
-                if !matches!(item, ast::AstItem::Use(_)) {
-                    let prev = self.package_items.insert(name, ast_item);
-                    assert!(prev.is_none());
-                }
-            }
-            self.ast_items.push(items);
-        }
-        Ok((iface_id_order, world_id_order))
-    }
-
-    /// Generate a `Type::Unknown` entry for all types imported from foreign
-    /// packages.
-    ///
-    /// This is done after all interfaces are generated so `self.resolve_path`
-    /// can be used to determine if what's being imported from is a foreign
-    /// interface or not.
-    fn populate_foreign_types(&mut self, asts: &[ast::Ast<'a>]) -> Result<()> {
-        for (i, ast) in asts.iter().enumerate() {
-            self.cur_ast_index = i;
-            ast.for_each_path(|_, path, names, _| {
                 let names = match names {
                     Some(names) => names,
                     None => return Ok(()),
                 };
-                let (item, name, span) = self.resolve_ast_item_path(path)?;
-                let iface = self.extract_iface_from_item(&item, &name, span)?;
-                if !self.foreign_interfaces.contains(&iface) {
-                    return Ok(());
-                }
-
                 let lookup = &mut self.interface_types[iface.index()];
                 for name in names {
                     // If this name has already been defined then use that prior
@@ -545,14 +235,165 @@ impl<'a> Resolver<'a> {
                 }
 
                 Ok(())
-            })?;
+            })
+            .unwrap();
         }
-        Ok(())
     }
 
-    fn resolve_world(&mut self, world_id: WorldId, world: &ast::World<'a>) -> Result<WorldId> {
+    fn resolve_document(&mut self, name: &'a str, ast: &ast::Ast<'a>) -> Result<DocumentId> {
+        // Verify all top-level names in this document are unique, and save off
+        // the name of the default interface for drawing topological
+        // dependencies in a moment.
+        let mut names = HashMap::new();
+        let mut default_interface_name = None;
+        let mut deps = IndexMap::new();
+        for item in ast.items.iter() {
+            let name = match item {
+                ast::AstItem::Interface(i) => {
+                    if i.default && default_interface_name.is_none() {
+                        default_interface_name = Some(i.name.name);
+                    }
+                    &i.name
+                }
+                ast::AstItem::World(w) => &w.name,
+            };
+            deps.insert(name.name, Vec::new());
+            if names.insert(name.name, item).is_some() {
+                return Err(Error {
+                    span: name.span,
+                    msg: format!("name `{}` previously defined in document", name.name),
+                }
+                .into());
+            }
+        }
+
+        // Walk all `UsePath` entries in this AST and record dependencies
+        // between interfaces. These are dependencies specified via `use
+        // self...` or via `use pkg.this-doc...`.
+        ast.for_each_path(|iface, path, _names| {
+            // If this import isn't contained within an interface then it's in a
+            // world and it doesn't need to participate in our topo-sort.
+            let iface = match iface {
+                Some(name) => name,
+                None => return Ok(()),
+            };
+            let deps = &mut deps[iface.name];
+            match path {
+                // Self-deps are what we're mostly interested in here.
+                ast::UsePath::Self_(name) => deps.push(name.clone()),
+
+                // Self-deps via the package happen when the `doc` name listed
+                // is the same as the name of the document being defined.
+                ast::UsePath::Package { doc, iface } => {
+                    if doc.name != name {
+                        return Ok(());
+                    }
+                    let name = match iface {
+                        Some(name) => name.clone(),
+                        None => {
+                            let name = default_interface_name.ok_or_else(|| Error {
+                                span: doc.span,
+                                msg: format!("no `default` interface in document to use from"),
+                            })?;
+                            ast::Id {
+                                span: doc.span,
+                                name,
+                            }
+                        }
+                    };
+                    deps.push(name);
+                }
+
+                // Dependencies on other packages don't participate in this
+                // topological ordering.
+                ast::UsePath::Dependency { .. } => {}
+            }
+            Ok(())
+        })?;
+        let order = toposort("interface", &deps)?;
+        log::debug!("toposort for interfaces in `{name}` is {order:?}");
+
+        // Allocate a document ID and then start processing all of the
+        // interfaces as defined by our `order` to insert new interfaces into
+        // this.
+        let document_id = self.documents.alloc(Document {
+            name: name.to_string(),
+            default_interface: None,
+            default_world: None,
+            interfaces: IndexMap::new(),
+            worlds: IndexMap::new(),
+            package: None,
+        });
+        self.document_interfaces.push(IndexMap::new());
+        self.document_lookup.insert(name, document_id);
+
+        let mut worlds = Vec::new();
+        for name in order {
+            let interface = match names.remove(&name).unwrap() {
+                ast::AstItem::Interface(i) => i,
+                ast::AstItem::World(world) => {
+                    worlds.push((name, world));
+                    continue;
+                }
+            };
+            let id = self.resolve_interface(
+                document_id,
+                Some(interface.name.name),
+                &interface.items,
+                &interface.docs,
+            )?;
+            if interface.default {
+                let prev = &mut self.documents[document_id].default_interface;
+                if prev.is_some() {
+                    return Err(Error {
+                        span: interface.name.span,
+                        msg: format!("cannot specify more than one `default` interface"),
+                    }
+                    .into());
+                }
+                *prev = Some(id);
+            }
+            let prev = self.documents[document_id]
+                .interfaces
+                .insert(name.to_string(), id);
+            assert!(prev.is_none());
+        }
+
+        // After all interfaces are defined then process all worlds as all items
+        // they import from should now be available.
+        for (name, world) in worlds {
+            let id = self.resolve_world(document_id, world)?;
+            if world.default {
+                let prev = &mut self.documents[document_id].default_world;
+                if prev.is_some() {
+                    return Err(Error {
+                        span: world.name.span,
+                        msg: format!("cannot specify more than one `default` world"),
+                    }
+                    .into());
+                }
+                *prev = Some(id);
+            }
+            let prev = self.documents[document_id]
+                .worlds
+                .insert(name.to_string(), id);
+            assert!(prev.is_none());
+        }
+
+        Ok(document_id)
+    }
+
+    fn resolve_world(&mut self, document: DocumentId, world: &ast::World<'a>) -> Result<WorldId> {
         let docs = self.docs(&world.docs);
-        self.worlds[world_id].docs = docs;
+        let world_id = self.worlds.alloc(World {
+            docs,
+            document,
+            name: world.name.name.to_string(),
+            exports: IndexMap::new(),
+            imports: IndexMap::new(),
+        });
+        self.document_interfaces[document.index()]
+            .insert(world.name.name, DocumentItem::World(world_id));
 
         self.resolve_types(
             TypeOwner::World(world_id),
@@ -560,20 +401,9 @@ impl<'a> Resolver<'a> {
                 ast::WorldItem::Use(u) => Some(TypeItem::Use(u)),
                 ast::WorldItem::Type(t) => Some(TypeItem::Def(t)),
                 ast::WorldItem::Import(_) | ast::WorldItem::Export(_) => None,
-                // should be handled in `wit-parser::resolve`
-                ast::WorldItem::Include(_) => None,
             }),
         )?;
 
-        // resolve include items
-        let items = world.items.iter().filter_map(|i| match i {
-            ast::WorldItem::Include(i) => Some(i),
-            _ => None,
-        });
-        for include in items {
-            self.resolve_include(TypeOwner::World(world_id), include)?;
-        }
-
         let mut export_spans = Vec::new();
         let mut import_spans = Vec::new();
         let mut used_names = HashMap::new();
@@ -592,19 +422,23 @@ impl<'a> Resolver<'a> {
                     }
                     self.worlds[world_id]
                         .imports
-                        .insert(WorldKey::Name(name.to_string()), WorldItem::Type(id));
+                        .insert(name.to_string(), WorldItem::Type(id));
                     import_spans.push(*span);
                 }
                 TypeOrItem::Item(_) => unreachable!(),
             }
         }
 
-        let mut imported_interfaces = HashSet::new();
-        let mut exported_interfaces = HashSet::new();
+        let mut imported_interfaces = HashMap::new();
+        let mut exported_interfaces = HashMap::new();
         for item in world.items.iter() {
-            let (docs, kind, desc, spans, interfaces) = match item {
+            let (docs, name, kind, desc, spans, interfaces) = match item {
+                // handled in `resolve_types`
+                ast::WorldItem::Use(_) | ast::WorldItem::Type(_) => continue,
+
                 ast::WorldItem::Import(import) => (
                     &import.docs,
+                    &import.name,
                     &import.kind,
                     "import",
                     &mut import_spans,
@@ -612,64 +446,35 @@ impl<'a> Resolver<'a> {
                 ),
                 ast::WorldItem::Export(export) => (
                     &export.docs,
+                    &export.name,
                     &export.kind,
                     "export",
                     &mut export_spans,
                     &mut exported_interfaces,
                 ),
-
-                ast::WorldItem::Type(ast::TypeDef {
-                    name,
-                    ty: ast::Type::Resource(r),
-                    ..
-                }) => {
-                    for func in r.funcs.iter() {
-                        import_spans.push(func.named_func().name.span);
-                        let func = self.resolve_resource_func(func, name)?;
-                        let prev = self.worlds[world_id]
-                            .imports
-                            .insert(WorldKey::Name(func.name.clone()), WorldItem::Function(func));
-                        // Resource names themselves are unique, and methods are
-                        // uniquely named, so this should be possible to assert
-                        // at this point and never trip.
-                        assert!(prev.is_none());
-                    }
-                    continue;
-                }
-
-                // handled in `resolve_types`
-                ast::WorldItem::Use(_) | ast::WorldItem::Type(_) | ast::WorldItem::Include(_) => {
-                    continue
-                }
             };
-            let key = match kind {
-                ast::ExternKind::Interface(name, _) | ast::ExternKind::Func(name, _) => {
-                    let prev = used_names.insert(name.name, desc);
-                    if let Some(prev) = prev {
-                        return Err(Error {
-                            span: kind.span(),
-                            msg: format!(
-                                "{desc} `{name}` conflicts with prior {prev} of same name",
-                                name = name.name
-                            ),
-                        }
-                        .into());
-                    }
-                    WorldKey::Name(name.name.to_string())
-                }
-                ast::ExternKind::Path(path) => {
-                    let (item, name, span) = self.resolve_ast_item_path(path)?;
-                    let id = self.extract_iface_from_item(&item, &name, span)?;
-                    WorldKey::Interface(id)
+            let prev = used_names.insert(name.name, desc);
+            if let Some(prev) = prev {
+                return Err(Error {
+                    span: name.span,
+                    msg: format!(
+                        "{desc} `{name}` conflicts with prior {prev} of same name",
+                        name = name.name
+                    ),
                 }
-            };
-            let world_item = self.resolve_world_item(docs, kind)?;
+                .into());
+            }
+            let world_item = self.resolve_world_item(docs, name.name, document, kind)?;
             if let WorldItem::Interface(id) = world_item {
-                if !interfaces.insert(id) {
-                    bail!(Error {
-                        span: kind.span(),
-                        msg: format!("interface cannot be {desc}ed more than once"),
-                    })
+                if interfaces.insert(id, name.name).is_some() {
+                    return Err(Error {
+                        span: name.span,
+                        msg: format!(
+                            "interface `{name}` cannot be {desc}ed more than once",
+                            name = name.name
+                        ),
+                    }
+                    .into());
                 }
             }
             let dst = if desc == "import" {
@@ -677,11 +482,11 @@ impl<'a> Resolver<'a> {
             } else {
                 &mut self.worlds[world_id].exports
             };
-            let prev = dst.insert(key, world_item);
+            let prev = dst.insert(name.name.to_string(), world_item);
             assert!(prev.is_none());
-            spans.push(kind.span());
+            spans.push(name.span);
         }
-        self.world_item_spans.push((import_spans, export_spans));
+        self.world_spans.push((import_spans, export_spans));
         self.type_lookup.clear();
 
         Ok(world_id)
@@ -690,24 +495,23 @@ impl<'a> Resolver<'a> {
     fn resolve_world_item(
         &mut self,
         docs: &ast::Docs<'a>,
+        name: &str,
+        document: DocumentId,
         kind: &ast::ExternKind<'a>,
     ) -> Result<WorldItem> {
         match kind {
-            ast::ExternKind::Interface(name, items) => {
+            ast::ExternKind::Interface(_span, items) => {
                 let prev = mem::take(&mut self.type_lookup);
-                let id = self.alloc_interface(name.span);
-                self.resolve_interface(id, items, docs)?;
+                let id = self.resolve_interface(document, None, items, docs)?;
                 self.type_lookup = prev;
                 Ok(WorldItem::Interface(id))
             }
             ast::ExternKind::Path(path) => {
-                let (item, name, span) = self.resolve_ast_item_path(path)?;
-                let id = self.extract_iface_from_item(&item, &name, span)?;
+                let id = self.resolve_path(path)?;
                 Ok(WorldItem::Interface(id))
             }
-            ast::ExternKind::Func(name, func) => {
-                let func =
-                    self.resolve_function(docs, name.name, func, FunctionKind::Freestanding)?;
+            ast::ExternKind::Func(func) => {
+                let func = self.resolve_function(docs, name, func)?;
                 Ok(WorldItem::Function(func))
             }
         }
@@ -715,19 +519,30 @@ impl<'a> Resolver<'a> {
 
     fn resolve_interface(
         &mut self,
-        interface_id: InterfaceId,
+        document: DocumentId,
+        name: Option<&'a str>,
         fields: &[ast::InterfaceItem<'a>],
         docs: &ast::Docs<'a>,
-    ) -> Result<()> {
+    ) -> Result<InterfaceId> {
         let docs = self.docs(docs);
-        self.interfaces[interface_id].docs = docs;
+        let interface_id = self.interfaces.alloc(Interface {
+            docs,
+            document,
+            name: name.map(|s| s.to_string()),
+            functions: IndexMap::new(),
+            types: IndexMap::new(),
+        });
+        if let Some(name) = name {
+            self.document_interfaces[document.index()]
+                .insert(name, DocumentItem::Interface(interface_id));
+        }
 
         self.resolve_types(
             TypeOwner::Interface(interface_id),
             fields.iter().filter_map(|i| match i {
                 ast::InterfaceItem::Use(u) => Some(TypeItem::Use(u)),
                 ast::InterfaceItem::TypeDef(t) => Some(TypeItem::Def(t)),
-                ast::InterfaceItem::Func(_) => None,
+                ast::InterfaceItem::Value(_) => None,
             }),
         )?;
 
@@ -744,42 +559,27 @@ impl<'a> Resolver<'a> {
 
         // Finally process all function definitions now that all types are
         // defined.
-        let mut funcs = Vec::new();
         for field in fields {
             match field {
-                ast::InterfaceItem::Func(f) => {
-                    self.define_interface_name(&f.name, TypeOrItem::Item("function"))?;
-                    funcs.push(self.resolve_function(
-                        &f.docs,
-                        &f.name.name,
-                        &f.func,
-                        FunctionKind::Freestanding,
-                    )?);
-                }
-                ast::InterfaceItem::Use(_) => {}
-                ast::InterfaceItem::TypeDef(ast::TypeDef {
-                    name,
-                    ty: ast::Type::Resource(r),
-                    ..
-                }) => {
-                    for func in r.funcs.iter() {
-                        funcs.push(self.resolve_resource_func(func, name)?);
+                ast::InterfaceItem::Value(value) => match &value.kind {
+                    ValueKind::Func(func) => {
+                        self.define_interface_name(&value.name, TypeOrItem::Item("function"))?;
+                        let func = self.resolve_function(&value.docs, value.name.name, func)?;
+                        let prev = self.interfaces[interface_id]
+                            .functions
+                            .insert(value.name.name.to_string(), func);
+                        assert!(prev.is_none());
                     }
-                }
-                ast::InterfaceItem::TypeDef(_) => {}
+                },
+                ast::InterfaceItem::Use(_) | ast::InterfaceItem::TypeDef(_) => {}
             }
         }
-        for func in funcs {
-            let prev = self.interfaces[interface_id]
-                .functions
-                .insert(func.name.clone(), func);
-            assert!(prev.is_none());
-        }
 
         let lookup = mem::take(&mut self.type_lookup);
-        self.interface_types[interface_id.index()] = lookup;
+        assert_eq!(interface_id.index(), self.interface_types.len());
+        self.interface_types.push(lookup);
 
-        Ok(())
+        Ok(interface_id)
     }
 
     fn resolve_types<'b>(
@@ -852,9 +652,7 @@ impl<'a> Resolver<'a> {
     }
 
     fn resolve_use(&mut self, owner: TypeOwner, u: &ast::Use<'a>) -> Result<()> {
-        let (item, name, span) = self.resolve_ast_item_path(&u.from)?;
-        let use_from = self.extract_iface_from_item(&item, &name, span)?;
-
+        let use_from = self.resolve_path(&u.from)?;
         for name in u.names.iter() {
             let lookup = &self.interface_types[use_from.index()];
             let id = match lookup.get(name.name.name) {
@@ -882,124 +680,80 @@ impl<'a> Resolver<'a> {
         Ok(())
     }
 
-    /// For each name in the `include`, resolve the path of the include, add it to the self.includes
-    fn resolve_include(&mut self, owner: TypeOwner, i: &ast::Include<'a>) -> Result<()> {
-        let (item, name, span) = self.resolve_ast_item_path(&i.from)?;
-        let include_from = self.extract_world_from_item(&item, &name, span)?;
-        self.include_world_spans.push(span);
-        let world_id = match owner {
-            TypeOwner::World(id) => id,
-            _ => unreachable!(),
-        };
-        self.worlds[world_id].includes.push(include_from);
-        self.worlds[world_id].include_names.push(
-            i.names
-                .iter()
-                .map(|n| IncludeName {
-                    name: n.name.name.to_string(),
-                    as_: n.as_.name.to_string(),
-                })
-                .collect(),
-        );
-        Ok(())
-    }
-
-    fn resolve_resource_func(
-        &mut self,
-        func: &ast::ResourceFunc<'_>,
-        resource: &ast::Id<'_>,
-    ) -> Result<Function> {
-        let resource_id = match self.type_lookup.get(resource.name) {
-            Some((TypeOrItem::Type(id), _)) => *id,
-            _ => panic!("type lookup for resource failed"),
-        };
-        let (name, kind);
-        match func {
-            ast::ResourceFunc::Method(f) => {
-                name = format!("[method]{}.{}", resource.name, f.name.name);
-                kind = FunctionKind::Method(resource_id);
-            }
-            ast::ResourceFunc::Static(f) => {
-                name = format!("[static]{}.{}", resource.name, f.name.name);
-                kind = FunctionKind::Static(resource_id);
-            }
-            ast::ResourceFunc::Constructor(_) => {
-                name = format!("[constructor]{}", resource.name);
-                kind = FunctionKind::Constructor(resource_id);
-            }
-        }
-        let named_func = func.named_func();
-        self.resolve_function(&named_func.docs, &name, &named_func.func, kind)
-    }
-
     fn resolve_function(
         &mut self,
         docs: &ast::Docs<'_>,
         name: &str,
         func: &ast::Func,
-        kind: FunctionKind,
     ) -> Result<Function> {
         let docs = self.docs(docs);
-        let params = self.resolve_params(&func.params, &kind)?;
-        let results = self.resolve_results(&func.results, &kind)?;
+        let params = self.resolve_params(&func.params)?;
+        let results = self.resolve_results(&func.results)?;
         Ok(Function {
             docs,
             name: name.to_string(),
-            kind,
+            kind: FunctionKind::Freestanding,
             params,
             results,
         })
     }
 
-    fn resolve_ast_item_path(&self, path: &ast::UsePath<'a>) -> Result<(AstItem, String, Span)> {
+    fn resolve_path(&self, path: &ast::UsePath<'a>) -> Result<InterfaceId> {
         match path {
-            ast::UsePath::Id(id) => {
-                let item = self.ast_items[self.cur_ast_index]
-                    .get(id.name)
-                    .or_else(|| self.package_items.get(id.name));
-                match item {
-                    Some(item) => Ok((*item, id.name.into(), id.span)),
-                    None => {
-                        bail!(Error {
-                            span: id.span,
-                            msg: format!("interface or world `{}` does not exist", id.name),
-                        })
-                    }
+            ast::UsePath::Self_(iface) => {
+                match self.document_interfaces.last().unwrap().get(iface.name) {
+                    Some(DocumentItem::Interface(id)) => Ok(*id),
+                    Some(DocumentItem::World(_)) => bail!(Error {
+                        span: iface.span,
+                        msg: format!(
+                            "name `{}` is defined as a world, not an interface",
+                            iface.name
+                        ),
+                    }),
+                    None => bail!(Error {
+                        span: iface.span,
+                        msg: format!("interface does not exist"),
+                    }),
                 }
             }
-            ast::UsePath::Package { id, name } => Ok((
-                self.foreign_deps[&id.package_name()][name.name],
-                name.name.into(),
-                name.span,
-            )),
-        }
-    }
-
-    fn extract_iface_from_item(
-        &self,
-        item: &AstItem,
-        name: &str,
-        span: Span,
-    ) -> Result<InterfaceId> {
-        match item {
-            AstItem::Interface(id) => Ok(*id),
-            AstItem::World(_) => {
-                bail!(Error {
-                    span: span,
-                    msg: format!("name `{}` is defined as a world, not an interface", name),
-                })
+            ast::UsePath::Package { doc, iface } => {
+                let doc_id = self.document_lookup[doc.name];
+                match iface {
+                    // If `iface` was provided then it must have been previously
+                    // processed
+                    Some(id) => {
+                        let lookup = &self.document_interfaces[doc_id.index()];
+                        match lookup.get(id.name) {
+                            Some(DocumentItem::Interface(id)) => Ok(*id),
+                            Some(DocumentItem::World(_)) => Err(Error {
+                                span: id.span,
+                                msg: format!("cannot import from world `{}`", id.name),
+                            }
+                            .into()),
+                            None => bail!(Error {
+                                span: id.span,
+                                msg: format!("interface does not exist"),
+                            }),
+                        }
+                    }
+                    None => self.documents[doc_id].default_interface.ok_or_else(|| {
+                        Error {
+                            span: doc.span,
+                            msg: format!("document does not specify a default interface"),
+                        }
+                        .into()
+                    }),
+                }
             }
-        }
-    }
-
-    fn extract_world_from_item(&self, item: &AstItem, name: &str, span: Span) -> Result<WorldId> {
-        match item {
-            AstItem::World(id) => Ok(*id),
-            AstItem::Interface(_) => {
-                bail!(Error {
-                    span: span,
-                    msg: format!("name `{}` is defined as an interface, not a world", name),
-                })
+            ast::UsePath::Dependency { dep, doc, iface } => {
+                let doc = self.foreign_deps[dep.name][doc.name];
+                match iface {
+                    Some(name) => match self.document_interfaces[doc.index()][name.name] {
+                        DocumentItem::Interface(id) => Ok(id),
+                        DocumentItem::World(_) => unreachable!(),
+                    },
+                    None => Ok(self.documents[doc].default_interface.unwrap()),
+                }
             }
         }
     }
@@ -1033,48 +787,23 @@ impl<'a> Resolver<'a> {
             ast::Type::Char => TypeDefKind::Type(Type::Char),
             ast::Type::String => TypeDefKind::Type(Type::String),
             ast::Type::Name(name) => {
-                let id = self.resolve_type_name(name)?;
+                let id = match self.type_lookup.get(name.name) {
+                    Some((TypeOrItem::Type(id), _)) => *id,
+                    Some((TypeOrItem::Item(s), _)) => bail!(Error {
+                        span: name.span,
+                        msg: format!("cannot use {s} `{name}` as a type", name = name.name),
+                    }),
+                    None => bail!(Error {
+                        span: name.span,
+                        msg: format!("name `{name}` is not defined", name = name.name),
+                    }),
+                };
                 TypeDefKind::Type(Type::Id(id))
             }
             ast::Type::List(list) => {
                 let ty = self.resolve_type(list)?;
                 TypeDefKind::List(ty)
             }
-            ast::Type::Handle(handle) => TypeDefKind::Handle(match handle {
-                ast::Handle::Own { resource } => Handle::Own(self.validate_resource(resource)?),
-                ast::Handle::Borrow { resource } => {
-                    Handle::Borrow(self.validate_resource(resource)?)
-                }
-            }),
-            ast::Type::Resource(resource) => {
-                // Validate here that the resource doesn't have any duplicate-ly
-                // named methods and that there's at most one constructor.
-                let mut ctors = 0;
-                let mut names = HashSet::new();
-                for func in resource.funcs.iter() {
-                    match func {
-                        ast::ResourceFunc::Method(f) | ast::ResourceFunc::Static(f) => {
-                            if !names.insert(&f.name.name) {
-                                bail!(Error {
-                                    span: f.name.span,
-                                    msg: format!("duplicate function name `{}`", f.name.name),
-                                })
-                            }
-                        }
-                        ast::ResourceFunc::Constructor(f) => {
-                            ctors += 1;
-                            if ctors > 1 {
-                                bail!(Error {
-                                    span: f.name.span,
-                                    msg: format!("duplicate constructors"),
-                                })
-                            }
-                        }
-                    }
-                }
-
-                TypeDefKind::Resource
-            }
             ast::Type::Record(record) => {
                 let fields = record
                     .fields
@@ -1181,47 +910,7 @@ impl<'a> Resolver<'a> {
         })
     }
 
-    fn resolve_type_name(&mut self, name: &ast::Id<'_>) -> Result<TypeId> {
-        match self.type_lookup.get(name.name) {
-            Some((TypeOrItem::Type(id), _)) => Ok(*id),
-            Some((TypeOrItem::Item(s), _)) => bail!(Error {
-                span: name.span,
-                msg: format!("cannot use {s} `{name}` as a type", name = name.name),
-            }),
-            None => bail!(Error {
-                span: name.span,
-                msg: format!("name `{name}` is not defined", name = name.name),
-            }),
-        }
-    }
-
-    fn validate_resource(&mut self, name: &ast::Id<'_>) -> Result<TypeId> {
-        let id = self.resolve_type_name(name)?;
-        let mut cur = id;
-        loop {
-            match self.types[cur].kind {
-                TypeDefKind::Resource => break Ok(id),
-                TypeDefKind::Type(Type::Id(ty)) => cur = ty,
-                TypeDefKind::Unknown => {
-                    self.required_resource_types.push((cur, name.span));
-                    break Ok(id);
-                }
-                _ => bail!(Error {
-                    span: name.span,
-                    msg: format!("type `{}` used in a handle must be a resource", name.name),
-                }),
-            }
-        }
-    }
-
     fn resolve_type(&mut self, ty: &super::Type<'_>) -> Result<Type> {
-        // Resources must be declared at the top level to have their methods
-        // processed appropriately, but resources also shouldn't show up
-        // recursively so assert that's not happening here.
-        match ty {
-            ast::Type::Resource(_) => unreachable!(),
-            _ => {}
-        }
         let kind = self.resolve_type_def(ty)?;
         Ok(self.anon_type_def(TypeDef {
             kind,
@@ -1247,13 +936,6 @@ impl<'a> Resolver<'a> {
                     .map(|case| (case.name.clone(), case.ty))
                     .collect::<Vec<_>>(),
             ),
-            TypeDefKind::Handle(Handle::Borrow(h)) => Key::BorrowHandle(*h),
-            // An anonymous `own<T>` type is the same as a reference to the type
-            // `T`, so avoid creating anonymous type and return that here
-            // directly. Note that this additionally avoids creating distinct
-            // anonymous types for `list<T>` and `list<own<T>>` for example.
-            TypeDefKind::Handle(Handle::Own(id)) => return Type::Id(*id),
-            TypeDefKind::Resource => unreachable!("anonymous resources aren't supported"),
             TypeDefKind::Record(r) => Key::Record(
                 r.fields
                     .iter()
@@ -1308,59 +990,17 @@ impl<'a> Resolver<'a> {
         Docs { contents: docs }
     }
 
-    fn resolve_params(&mut self, params: &ParamList<'_>, kind: &FunctionKind) -> Result<Params> {
-        let mut ret = Vec::new();
-        match *kind {
-            // These kinds of methods don't have any adjustments to the
-            // parameters, so do nothing here.
-            FunctionKind::Freestanding | FunctionKind::Constructor(_) | FunctionKind::Static(_) => {
-            }
-
-            // Methods automatically get a `self` initial argument so insert
-            // that here before processing the normal parameters.
-            FunctionKind::Method(id) => {
-                let shared = self.anon_type_def(TypeDef {
-                    docs: Docs::default(),
-                    kind: TypeDefKind::Handle(Handle::Borrow(id)),
-                    name: None,
-                    owner: TypeOwner::None,
-                });
-                ret.push(("self".to_string(), shared));
-            }
-        }
-        for (name, ty) in params {
-            ret.push((name.name.to_string(), self.resolve_type(ty)?));
-        }
-        Ok(ret)
+    fn resolve_params(&mut self, params: &ParamList<'_>) -> Result<Params> {
+        params
+            .iter()
+            .map(|(name, ty)| Ok((name.name.to_string(), self.resolve_type(ty)?)))
+            .collect::<Result<_>>()
     }
 
-    fn resolve_results(
-        &mut self,
-        results: &ResultList<'_>,
-        kind: &FunctionKind,
-    ) -> Result<Results> {
-        match *kind {
-            // These kinds of methods don't have any adjustments to the return
-            // values, so plumb them through as-is.
-            FunctionKind::Freestanding | FunctionKind::Method(_) | FunctionKind::Static(_) => {
-                match results {
-                    ResultList::Named(rs) => Ok(Results::Named(
-                        self.resolve_params(rs, &FunctionKind::Freestanding)?,
-                    )),
-                    ResultList::Anon(ty) => Ok(Results::Anon(self.resolve_type(ty)?)),
-                }
-            }
-
-            // Constructors are alwys parsed as 0 returned types but they're
-            // automatically translated as a single return type of the type that
-            // it's a constructor for.
-            FunctionKind::Constructor(id) => {
-                match results {
-                    ResultList::Named(rs) => assert!(rs.is_empty()),
-                    ResultList::Anon(_) => unreachable!(),
-                }
-                Ok(Results::Anon(Type::Id(id)))
-            }
+    fn resolve_results(&mut self, results: &ResultList<'_>) -> Result<Results> {
+        match results {
+            ResultList::Named(rs) => Ok(Results::Named(self.resolve_params(rs)?)),
+            ResultList::Anon(ty) => Ok(Results::Anon(self.resolve_type(ty)?)),
         }
     }
 }
@@ -1384,11 +1024,6 @@ fn collect_deps<'a>(ty: &ast::Type<'a>, deps: &mut Vec<ast::Id<'a>>) {
         | ast::Type::Enum(_) => {}
         ast::Type::Name(name) => deps.push(name.clone()),
         ast::Type::List(list) => collect_deps(list, deps),
-        ast::Type::Handle(handle) => match handle {
-            ast::Handle::Own { resource } => deps.push(resource.clone()),
-            ast::Handle::Borrow { resource } => deps.push(resource.clone()),
-        },
-        ast::Type::Resource(_) => {}
         ast::Type::Record(record) => {
             for field in record.fields.iter() {
                 collect_deps(&field.ty, deps);
diff --git a/crates/wit-parser/src/ast/toposort.rs b/crates/wit-parser/src/ast/toposort.rs
index 0a43dc03..bf0b150a 100644
--- a/crates/wit-parser/src/ast/toposort.rs
+++ b/crates/wit-parser/src/ast/toposort.rs
@@ -64,30 +64,22 @@ pub fn toposort<'a>(
     let mut heap = BinaryHeap::new();
 
     // Seed the `heap` with edges that have no outbound edges
-    //
-    // The heap here is keyed by `(usize, &str, usize)` where the first `usize`
-    // is unique which is what determines the order of the heap. The other two
-    // fields are metadata used when pulling from the heap. The first `usize` is
-    // the index of the item within the original dependency map which should
-    // reflect the original source order of the item. Note that this is stored
-    // in reverse order to ensure that when there are multiple items in the heap
-    // the first item in the original order is popped first.
     for (i, dep) in deps.keys().enumerate() {
         if states[i].outbound_remaining == 0 {
-            heap.push((deps.len() - i, *dep, i));
+            heap.push((*dep, i));
         }
     }
 
     // Drain the binary heap which represents all nodes that have had all their
     // dependencies processed. Iteratively add to the heap as well as nodes are
     // removed.
-    while let Some((_order, node, i)) = heap.pop() {
+    while let Some((node, i)) = heap.pop() {
         order.push(node);
         for i in mem::take(&mut states[i].reverse_deps) {
             states[i].outbound_remaining -= 1;
             if states[i].outbound_remaining == 0 {
                 let (dep, _) = deps.get_index(i).unwrap();
-                heap.push((deps.len() - i, *dep, i));
+                heap.push((*dep, i));
             }
         }
     }
@@ -209,17 +201,4 @@ mod tests {
         two.insert("a", vec![]);
         assert_eq!(toposort("", &two).unwrap(), ["a", "b"]);
     }
-
-    #[test]
-    fn preserve_order() {
-        let mut order = IndexMap::new();
-        order.insert("a", vec![]);
-        order.insert("b", vec![]);
-        assert_eq!(toposort("", &order).unwrap(), ["a", "b"]);
-
-        let mut order = IndexMap::new();
-        order.insert("b", vec![]);
-        order.insert("a", vec![]);
-        assert_eq!(toposort("", &order).unwrap(), ["b", "a"]);
-    }
 }
diff --git a/crates/wit-parser/src/lib.rs b/crates/wit-parser/src/lib.rs
index 99b14819..e477a180 100644
--- a/crates/wit-parser/src/lib.rs
+++ b/crates/wit-parser/src/lib.rs
@@ -1,7 +1,6 @@
-use anyhow::{Context, Result};
+use anyhow::{anyhow, Context, Result};
 use id_arena::{Arena, Id};
 use indexmap::IndexMap;
-use semver::Version;
 use std::borrow::Cow;
 use std::fmt;
 use std::path::Path;
@@ -26,6 +25,7 @@ pub fn validate_id(s: &str) -> Result<()> {
 pub type WorldId = Id<World>;
 pub type InterfaceId = Id<Interface>;
 pub type TypeId = Id<TypeDef>;
+pub type DocumentId = Id<Document>;
 
 /// Representation of a parsed WIT package which has not resolved external
 /// dependencies yet.
@@ -54,8 +54,15 @@ pub type TypeId = Id<TypeDef>;
 /// performing this resolution themselves.
 #[derive(Clone)]
 pub struct UnresolvedPackage {
-    /// The namespace, name, and version information for this package.
-    pub name: PackageName,
+    /// Local name for this package.
+    pub name: String,
+
+    /// Optionally-specified URL for this package.
+    ///
+    /// Must be specified for non-local dependencies. Note that this is never
+    /// automatically set from [`UnresolvedPackage::parse`] methods, and it must
+    /// be manually configured in the return value.
+    pub url: Option<String>,
 
     /// All worlds from all documents within this package.
     ///
@@ -78,68 +85,28 @@ pub struct UnresolvedPackage {
     /// other types transitively that are already iterated over.
     pub types: Arena<TypeDef>,
 
+    /// All documents found within this package.
+    ///
+    /// Documents are sorted topologically in this arena with respect to imports
+    /// between them.
+    pub documents: Arena<Document>,
+
     /// All foreign dependencies that this package depends on.
     ///
     /// These foreign dependencies must be resolved to convert this unresolved
     /// package into a `Resolve`. The map here is keyed by the name of the
-    /// foreign package that this depends on, and the sub-map is keyed by an
-    /// interface name followed by the identifier within `self.interfaces`. The
-    /// fields of `self.interfaces` describes the required types that are from
-    /// each foreign interface.
-    pub foreign_deps: IndexMap<PackageName, IndexMap<String, AstItem>>,
+    /// foreign package that this depends on, and the sub-map is keyed by a
+    /// document name followed by the identifier within `self.documents`. The
+    /// fields of `self.documents` describes the required types, interfaces,
+    /// etc, that are required from each foreign package.
+    pub foreign_deps: IndexMap<String, IndexMap<String, DocumentId>>,
 
     unknown_type_spans: Vec<Span>,
-    world_item_spans: Vec<(Vec<Span>, Vec<Span>)>,
+    world_spans: Vec<(Vec<Span>, Vec<Span>)>,
+    document_spans: Vec<Span>,
     interface_spans: Vec<Span>,
-    world_spans: Vec<Span>,
     foreign_dep_spans: Vec<Span>,
     source_map: SourceMap,
-    include_world_spans: Vec<Span>,
-    required_resource_types: Vec<(TypeId, Span)>,
-}
-
-#[derive(Debug, Copy, Clone)]
-pub enum AstItem {
-    Interface(InterfaceId),
-    World(WorldId),
-}
-
-/// A structure used to keep track of the name of a package, containing optional
-/// information such as a namespace and version information.
-///
-/// This is directly encoded as an "ID" in the binary component representation
-/// with an interfaced tacked on as well.
-#[derive(Debug, Clone, Hash, Eq, PartialEq, Ord, PartialOrd)]
-pub struct PackageName {
-    /// A namespace such as `wasi` in `wasi:foo/bar`
-    pub namespace: String,
-    /// The kebab-name of this package, which is always specified.
-    pub name: String,
-    /// Optional major/minor version information.
-    pub version: Option<Version>,
-}
-
-impl PackageName {
-    /// Returns the ID that this package name would assign the `interface` name
-    /// specified.
-    pub fn interface_id(&self, interface: &str) -> String {
-        let mut s = String::new();
-        s.push_str(&format!("{}:{}/{interface}", self.namespace, self.name));
-        if let Some(version) = &self.version {
-            s.push_str(&format!("@{version}"));
-        }
-        s
-    }
-}
-
-impl fmt::Display for PackageName {
-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
-        write!(f, "{}:{}", self.namespace, self.name)?;
-        if let Some(version) = &self.version {
-            write!(f, "@{version}")?;
-        }
-        Ok(())
-    }
 }
 
 #[derive(Debug)]
@@ -163,8 +130,16 @@ impl UnresolvedPackage {
     /// will not be able to use `pkg` use paths to other documents.
     pub fn parse(path: &Path, contents: &str) -> Result<Self> {
         let mut map = SourceMap::default();
-        map.push(path, contents);
-        map.parse()
+        let name = path
+            .file_name()
+            .and_then(|s| s.to_str())
+            .ok_or_else(|| anyhow!("path doesn't end in a valid package name {path:?}"))?;
+        let name = match name.find('.') {
+            Some(i) => &name[..i],
+            None => name,
+        };
+        map.push(path, name, contents);
+        map.parse(name, None)
     }
 
     /// Parse a WIT package at the provided path.
@@ -196,6 +171,10 @@ impl UnresolvedPackage {
     /// `path` into the returned package.
     pub fn parse_dir(path: &Path) -> Result<Self> {
         let mut map = SourceMap::default();
+        let name = path
+            .file_name()
+            .and_then(|s| s.to_str())
+            .ok_or_else(|| anyhow!("path doesn't end in a valid package name {path:?}"))?;
         let cx = || format!("failed to read directory {path:?}");
         for entry in path.read_dir().with_context(&cx)? {
             let entry = entry.with_context(&cx)?;
@@ -218,7 +197,7 @@ impl UnresolvedPackage {
             }
             map.push_file(&path)?;
         }
-        map.parse()
+        map.parse(name, None)
     }
 
     /// Returns an iterator over the list of source files that were read when
@@ -228,61 +207,53 @@ impl UnresolvedPackage {
     }
 }
 
+/// Represents the result of parsing a wit document.
 #[derive(Debug, Clone)]
-pub struct World {
-    /// The WIT identifier name of this world.
+pub struct Document {
     pub name: String,
 
-    /// Documentation associated with this world declaration.
-    pub docs: Docs,
-
-    /// All imported items into this interface, both worlds and functions.
-    pub imports: IndexMap<WorldKey, WorldItem>,
+    /// The top-level interfaces contained in the document.
+    ///
+    /// The interfaces here are listed in topological order of the
+    /// dependencies between them.
+    pub interfaces: IndexMap<String, InterfaceId>,
 
-    /// All exported items from this interface, both worlds and functions.
-    pub exports: IndexMap<WorldKey, WorldItem>,
+    /// The worlds contained in the document.
+    pub worlds: IndexMap<String, WorldId>,
 
-    /// The package that owns this world.
-    pub package: Option<PackageId>,
+    /// The default interface of this document, if any.
+    ///
+    /// This interface will also be listed in `self.interfaces`
+    pub default_interface: Option<InterfaceId>,
 
-    /// All the included worlds from this world. Empty if this is fully resolved
-    pub includes: Vec<WorldId>,
+    /// The default world of this document, if any.
+    ///
+    /// This will also be listed in `self.worlds`.
+    pub default_world: Option<WorldId>,
 
-    /// All the included worlds names. Empty if this is fully resolved
-    pub include_names: Vec<Vec<IncludeName>>,
+    /// The package that this document belongs to.
+    pub package: Option<PackageId>,
 }
 
 #[derive(Debug, Clone)]
-pub struct IncludeName {
-    /// The name of the item
+pub struct World {
+    /// The WIT identifier name of this world.
     pub name: String,
 
-    /// The name to be replaced with
-    pub as_: String,
-}
+    /// Documentation associated with this world declaration.
+    pub docs: Docs,
 
-/// The key to the import/export maps of a world. Either a kebab-name or a
-/// unique interface.
-#[derive(Debug, Clone, PartialEq, Eq, Hash)]
-pub enum WorldKey {
-    /// A kebab-name.
-    Name(String),
-    /// An interface which is assigned no kebab-name.
-    Interface(InterfaceId),
-}
+    /// All imported items into this interface, both worlds and functions.
+    pub imports: IndexMap<String, WorldItem>,
 
-impl WorldKey {
-    /// Asserts that this is `WorldKey::Name` and returns the name.
-    #[track_caller]
-    pub fn unwrap_name(self) -> String {
-        match self {
-            WorldKey::Name(name) => name,
-            WorldKey::Interface(_) => panic!("expected a name, found interface"),
-        }
-    }
+    /// All exported items from this interface, both worlds and functions.
+    pub exports: IndexMap<String, WorldItem>,
+
+    /// The document that owns this world.
+    pub document: DocumentId,
 }
 
-#[derive(Debug, Clone, PartialEq)]
+#[derive(Debug, Clone)]
 pub enum WorldItem {
     /// An interface is being imported or exported from a world, indicating that
     /// it's a namespace of functions.
@@ -316,8 +287,8 @@ pub struct Interface {
     /// Exported functions from this interface.
     pub functions: IndexMap<String, Function>,
 
-    /// The package that owns this interface.
-    pub package: Option<PackageId>,
+    /// The document that this interface belongs to.
+    pub document: DocumentId,
 }
 
 #[derive(Debug, Clone, PartialEq)]
@@ -331,8 +302,6 @@ pub struct TypeDef {
 #[derive(Debug, Clone, PartialEq)]
 pub enum TypeDefKind {
     Record(Record),
-    Resource,
-    Handle(Handle),
     Flags(Flags),
     Tuple(Tuple),
     Variant(Variant),
@@ -353,32 +322,7 @@ pub enum TypeDefKind {
     Unknown,
 }
 
-impl TypeDefKind {
-    pub fn as_str(&self) -> &'static str {
-        match self {
-            TypeDefKind::Record(_) => "record",
-            TypeDefKind::Resource => "resource",
-            TypeDefKind::Handle(handle) => match handle {
-                Handle::Own(_) => "own",
-                Handle::Borrow(_) => "borrow",
-            },
-            TypeDefKind::Flags(_) => "flags",
-            TypeDefKind::Tuple(_) => "tuple",
-            TypeDefKind::Variant(_) => "variant",
-            TypeDefKind::Enum(_) => "enum",
-            TypeDefKind::Option(_) => "option",
-            TypeDefKind::Result(_) => "result",
-            TypeDefKind::Union(_) => "union",
-            TypeDefKind::List(_) => "list",
-            TypeDefKind::Future(_) => "future",
-            TypeDefKind::Stream(_) => "stream",
-            TypeDefKind::Type(_) => "type",
-            TypeDefKind::Unknown => "unknown",
-        }
-    }
-}
-
-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
+#[derive(Debug, Copy, Clone, PartialEq)]
 pub enum TypeOwner {
     /// This type was defined within a `world` block.
     World(WorldId),
@@ -389,12 +333,6 @@ pub enum TypeOwner {
     None,
 }
 
-#[derive(Debug, PartialEq, Eq, Hash, Copy, Clone)]
-pub enum Handle {
-    Own(TypeId),
-    Borrow(TypeId),
-}
-
 #[derive(Debug, PartialEq, Eq, Hash, Copy, Clone)]
 pub enum Type {
     Bool,
@@ -556,7 +494,7 @@ pub struct Stream {
     pub end: Option<Type>,
 }
 
-#[derive(Clone, Default, Debug, PartialEq, Eq)]
+#[derive(Clone, Default, Debug, PartialEq)]
 pub struct Docs {
     pub contents: Option<String>,
 }
@@ -628,7 +566,7 @@ impl Results {
     }
 }
 
-#[derive(Debug, Clone, PartialEq, Eq)]
+#[derive(Debug, Clone, PartialEq)]
 pub struct Function {
     pub docs: Docs,
     pub name: String,
@@ -637,22 +575,15 @@ pub struct Function {
     pub results: Results,
 }
 
-#[derive(Debug, Clone, PartialEq, Eq)]
+#[derive(Debug, Clone, PartialEq)]
 pub enum FunctionKind {
     Freestanding,
-    Method(TypeId),
-    Static(TypeId),
-    Constructor(TypeId),
 }
 
 impl Function {
     pub fn item_name(&self) -> &str {
         match &self.kind {
             FunctionKind::Freestanding => &self.name,
-            FunctionKind::Method(_) | FunctionKind::Static(_) => {
-                &self.name[self.name.find('.').unwrap() + 1..]
-            }
-            FunctionKind::Constructor(_) => "constructor",
         }
     }
 
diff --git a/crates/wit-parser/src/live.rs b/crates/wit-parser/src/live.rs
index 52332976..2536f6af 100644
--- a/crates/wit-parser/src/live.rs
+++ b/crates/wit-parser/src/live.rs
@@ -1,4 +1,6 @@
-use crate::{Function, InterfaceId, Resolve, Type, TypeDefKind, TypeId, WorldId, WorldItem};
+use crate::{
+    DocumentId, Function, InterfaceId, Resolve, Type, TypeDefKind, TypeId, WorldId, WorldItem,
+};
 use indexmap::IndexSet;
 
 #[derive(Default)]
@@ -8,13 +10,25 @@ pub struct LiveTypes {
 
 impl LiveTypes {
     pub fn iter(&self) -> impl Iterator<Item = TypeId> + '_ {
-        self.set.iter().copied()
+        // Note the reverse iteration order to ensure that everything is visited
+        // in a topological order.
+        self.set.iter().rev().copied()
     }
 
     pub fn len(&self) -> usize {
         self.set.len()
     }
 
+    pub fn add_document(&mut self, resolve: &Resolve, doc: DocumentId) {
+        let doc = &resolve.documents[doc];
+        for (_, id) in doc.interfaces.iter() {
+            self.add_interface(resolve, *id);
+        }
+        for (_, id) in doc.worlds.iter() {
+            self.add_world(resolve, *id);
+        }
+    }
+
     pub fn add_interface(&mut self, resolve: &Resolve, iface: InterfaceId) {
         let iface = &resolve.interfaces[iface];
         for (_, id) in iface.types.iter() {
@@ -50,7 +64,7 @@ impl LiveTypes {
     }
 
     pub fn add_type_id(&mut self, resolve: &Resolve, ty: TypeId) {
-        if self.set.contains(&ty) {
+        if !self.set.insert(ty) {
             return;
         }
         match &resolve.types[ty].kind {
@@ -58,11 +72,6 @@ impl LiveTypes {
             | TypeDefKind::List(t)
             | TypeDefKind::Option(t)
             | TypeDefKind::Future(Some(t)) => self.add_type(resolve, t),
-            TypeDefKind::Handle(handle) => match handle {
-                crate::Handle::Own(ty) => self.add_type_id(resolve, *ty),
-                crate::Handle::Borrow(ty) => self.add_type_id(resolve, *ty),
-            },
-            TypeDefKind::Resource => {}
             TypeDefKind::Record(r) => {
                 for field in r.fields.iter() {
                     self.add_type(resolve, &field.ty);
@@ -104,7 +113,6 @@ impl LiveTypes {
             TypeDefKind::Flags(_) | TypeDefKind::Enum(_) | TypeDefKind::Future(None) => {}
             TypeDefKind::Unknown => unreachable!(),
         }
-        assert!(self.set.insert(ty));
     }
 
     pub fn add_type(&mut self, resolve: &Resolve, ty: &Type) {
diff --git a/crates/wit-parser/src/resolve.rs b/crates/wit-parser/src/resolve.rs
index fb2f4ffa..4bdca989 100644
--- a/crates/wit-parser/src/resolve.rs
+++ b/crates/wit-parser/src/resolve.rs
@@ -1,16 +1,16 @@
 use crate::ast::lex::Span;
-use crate::ast::{parse_use_path, AstUsePath};
 use crate::{
-    AstItem, Error, Function, FunctionKind, Handle, IncludeName, Interface, InterfaceId,
-    PackageName, Results, Type, TypeDef, TypeDefKind, TypeId, TypeOwner, UnresolvedPackage, World,
-    WorldId, WorldItem, WorldKey,
+    Document, DocumentId, Error, Function, Interface, InterfaceId, Results, Type, TypeDef,
+    TypeDefKind, TypeId, TypeOwner, UnresolvedPackage, World, WorldId, WorldItem,
 };
 use anyhow::{anyhow, bail, Context, Result};
 use id_arena::{Arena, Id};
 use indexmap::{IndexMap, IndexSet};
-use std::collections::{BTreeMap, HashMap, HashSet};
+use std::collections::{HashMap, HashSet};
+use std::fmt::Write;
 use std::mem;
 use std::path::{Path, PathBuf};
+use url::Url;
 
 /// Representation of a fully resolved set of WIT packages.
 ///
@@ -30,26 +30,21 @@ pub struct Resolve {
     pub worlds: Arena<World>,
     pub interfaces: Arena<Interface>,
     pub types: Arena<TypeDef>,
+    pub documents: Arena<Document>,
     pub packages: Arena<Package>,
-    pub package_names: IndexMap<PackageName, PackageId>,
 }
 
-/// A WIT package within a `Resolve`.
-///
-/// A package is a collection of interfaces and worlds. Packages additionally
-/// have a unique identifier that affects generated components and uniquely
-/// identifiers this particular package.
 #[derive(Clone)]
 pub struct Package {
-    /// A unique name corresponding to this package.
-    pub name: PackageName,
+    /// Locally-known name of this package.
+    pub name: String,
 
-    /// All interfaces contained in this packaged, keyed by the interface's
-    /// name.
-    pub interfaces: IndexMap<String, InterfaceId>,
+    /// Optionally-specified URL of this package, must be specified for remote
+    /// dependencies.
+    pub url: Option<String>,
 
-    /// All worlds contained in this package, keyed by the world's name.
-    pub worlds: IndexMap<String, WorldId>,
+    /// Documents contained within this package, organized by name.
+    pub documents: IndexMap<String, DocumentId>,
 }
 
 pub type PackageId = Id<Package>;
@@ -63,100 +58,119 @@ impl Resolve {
     /// Parses the filesystem directory at `path` as a WIT package and returns
     /// the fully resolved [`PackageId`] as a result.
     ///
+    /// This method is intended for testing and convenience for now and isn't
+    /// the only way to push packages into this [`Resolve`]. This will
+    /// interpret `path` as a directory where all `*.wit` files in that
+    /// directory are members of the package.
+    ///
     /// Dependencies referenced by the WIT package at `path` will be loaded from
-    /// a `deps/..` directory under `path`. All directories under `deps/` will
-    /// be parsed as a WIT package. The directory name containing each package
-    /// is not used as each package is otherwise self-identifying.
+    /// a `deps/$name` directory under `path` where `$name` is the name of the
+    /// dependency loaded. If `deps/$name` does not exist then an error will be
+    /// returned indicating that the dependency is not defined. All dependencies
+    /// are listed in a flat namespace under `$path/deps` so they can refer to
+    /// each other.
     ///
     /// This function returns the [`PackageId`] of the root parsed package at
     /// `path`, along with a list of all paths that were consumed during parsing
     /// for the root package and all dependency packages.
     pub fn push_dir(&mut self, path: &Path) -> Result<(PackageId, Vec<PathBuf>)> {
-        let pkg = UnresolvedPackage::parse_dir(path)
-            .with_context(|| format!("failed to parse package: {}", path.display()))?;
+        // Maintain a `to_parse` stack of packages that have yet to be parsed
+        // along with an `enqueued` set of all the prior parsed packages and
+        // packages enqueued to be parsed. These are then used to fill the
+        // `packages` map with parsed, but unresolved, packages. The `pkg_deps`
+        // map then tracks dependencies between packages.
+        let mut to_parse = Vec::new();
+        let mut enqueued = HashSet::new();
+        let mut packages = IndexMap::new();
+        let mut pkg_deps = IndexMap::new();
+        to_parse.push((path.to_path_buf(), None));
+        enqueued.insert(path.to_path_buf());
+        while let Some((pkg_root, url)) = to_parse.pop() {
+            let mut pkg = UnresolvedPackage::parse_dir(&pkg_root)
+                .with_context(|| format!("failed to parse package: {}", path.display()))?;
+            pkg.url = url;
+
+            let mut deps = Vec::new();
+            pkg.source_map.rewrite_error(|| {
+                for (i, (dep, _)) in pkg.foreign_deps.iter().enumerate() {
+                    let path = path.join("deps").join(dep);
+                    let span = pkg.foreign_dep_spans[i];
+                    // If this is the first request to parse `path` then push it
+                    // onto our stack, otherwise it's already there so skip it.
+                    if enqueued.insert(path.clone()) {
+                        if !path.is_dir() {
+                            bail!(Error {
+                                span,
+                                msg: format!(
+                                    "dependency on `{dep}` doesn't exist at: {}",
+                                    path.display()
+                                ),
+                            })
+                        }
+                        let url = Some(format!("path:/{dep}"));
+                        to_parse.push((path.clone(), url));
+                    }
+                    deps.push((path, span));
+                }
+                Ok(())
+            })?;
 
-        let deps = path.join("deps");
-        let mut deps = parse_deps_dir(&deps)
-            .with_context(|| format!("failed to parse dependency directory: {}", deps.display()))?;
+            let prev = packages.insert(pkg_root.clone(), pkg);
+            assert!(prev.is_none());
+            pkg_deps.insert(pkg_root, deps);
+        }
 
         // Perform a simple topological sort which will bail out on cycles
         // and otherwise determine the order that packages must be added to
         // this `Resolve`.
         let mut order = IndexSet::new();
         let mut visiting = HashSet::new();
-        for pkg in deps.values().chain([&pkg]) {
-            visit(&pkg, &deps, &mut order, &mut visiting)?;
+        for (dep, _) in pkg_deps.iter() {
+            visit(dep, &pkg_deps, &packages, &mut order, &mut visiting)?;
         }
 
         // Using the topological ordering insert each package incrementally.
         // Additionally note that the last item visited here is the root
         // package, which is the one returned here.
+        let mut package_ids = IndexMap::new();
         let mut last = None;
         let mut files = Vec::new();
-        let mut pkg = Some(pkg);
-        for name in order {
-            let pkg = deps.remove(&name).unwrap_or_else(|| pkg.take().unwrap());
+        for path in order {
+            let pkg = packages.remove(path).unwrap();
+            let mut deps = HashMap::new();
+            for ((dep, _), (path, _span)) in pkg.foreign_deps.iter().zip(&pkg_deps[path]) {
+                deps.insert(dep.clone(), package_ids[&**path]);
+            }
             files.extend(pkg.source_files().map(|p| p.to_path_buf()));
-            let pkgid = self.push(pkg)?;
+            let pkgid = self.push(pkg, &deps)?;
+            package_ids.insert(path, pkgid);
             last = Some(pkgid);
         }
 
         return Ok((last.unwrap(), files));
 
-        fn parse_deps_dir(path: &Path) -> Result<BTreeMap<PackageName, UnresolvedPackage>> {
-            let mut ret = BTreeMap::new();
-            // If there's no `deps` dir, then there's no deps, so return the
-            // empty set.
-            if !path.exists() {
-                return Ok(ret);
-            }
-            for dep in path.read_dir().context("failed to read directory")? {
-                let dep = dep.context("failed to read directory iterator")?;
-                let path = dep.path();
-
-                // Files in deps dir are ignored for now to avoid accidentally
-                // including things like `.DS_Store` files in the call below to
-                // `parse_dir`.
-                if path.is_file() {
-                    continue;
-                }
-
-                let pkg = UnresolvedPackage::parse_dir(&path)
-                    .with_context(|| format!("failed to parse package: {}", path.display()))?;
-                let prev = ret.insert(pkg.name.clone(), pkg);
-                if let Some(prev) = prev {
-                    bail!("duplicate definitions of package `{}` found", prev.name);
-                }
-            }
-            Ok(ret)
-        }
-
         fn visit<'a>(
-            pkg: &'a UnresolvedPackage,
-            deps: &'a BTreeMap<PackageName, UnresolvedPackage>,
-            order: &mut IndexSet<PackageName>,
-            visiting: &mut HashSet<&'a PackageName>,
+            path: &'a Path,
+            deps: &'a IndexMap<PathBuf, Vec<(PathBuf, Span)>>,
+            pkgs: &IndexMap<PathBuf, UnresolvedPackage>,
+            order: &mut IndexSet<&'a Path>,
+            visiting: &mut HashSet<&'a Path>,
         ) -> Result<()> {
-            if order.contains(&pkg.name) {
+            if order.contains(path) {
                 return Ok(());
             }
-            pkg.source_map.rewrite_error(|| {
-                for (i, (dep, _)) in pkg.foreign_deps.iter().enumerate() {
-                    let span = pkg.foreign_dep_spans[i];
+            pkgs[path].source_map.rewrite_error(|| {
+                for (dep, span) in deps[path].iter() {
                     if !visiting.insert(dep) {
                         bail!(Error {
-                            span,
+                            span: *span,
                             msg: format!("package depends on itself"),
                         });
                     }
-                    let dep = deps.get(dep).ok_or_else(|| Error {
-                        span,
-                        msg: format!("failed to find package `{dep}` in `deps` directory"),
-                    })?;
-                    visit(dep, deps, order, visiting)?;
-                    assert!(visiting.remove(&dep.name));
+                    visit(dep, deps, pkgs, order, visiting)?;
+                    assert!(visiting.remove(&**dep));
                 }
-                assert!(order.insert(pkg.name.clone()));
+                assert!(order.insert(path));
                 Ok(())
             })
         }
@@ -170,9 +184,13 @@ impl Resolve {
     ///
     /// Any dependency resolution error or otherwise world-elaboration error
     /// will be returned here. If successful a package identifier is returned.
-    pub fn push(&mut self, mut unresolved: UnresolvedPackage) -> Result<PackageId> {
+    pub fn push(
+        &mut self,
+        mut unresolved: UnresolvedPackage,
+        deps: &HashMap<String, PackageId>,
+    ) -> Result<PackageId> {
         let source_map = mem::take(&mut unresolved.source_map);
-        source_map.rewrite_error(|| Remap::default().append(self, unresolved))
+        source_map.rewrite_error(|| Remap::default().append(self, unresolved, deps))
     }
 
     pub fn all_bits_valid(&self, ty: &Type) -> bool {
@@ -200,13 +218,6 @@ impl Resolve {
                 | TypeDefKind::Stream(_)
                 | TypeDefKind::Union(_) => false,
                 TypeDefKind::Type(t) => self.all_bits_valid(t),
-
-                TypeDefKind::Handle(h) => match h {
-                    crate::Handle::Own(_) => true,
-                    crate::Handle::Borrow(_) => true,
-                },
-
-                TypeDefKind::Resource => false,
                 TypeDefKind::Record(r) => r.fields.iter().all(|f| self.all_bits_valid(&f.ty)),
                 TypeDefKind::Tuple(t) => t.types.iter().all(|t| self.all_bits_valid(t)),
 
@@ -223,145 +234,74 @@ impl Resolve {
     /// Merges all the contents of a different `Resolve` into this one. The
     /// `Remap` structure returned provides a mapping from all old indices to
     /// new indices
-    ///
-    /// This operation can fail if `resolve` disagrees with `self` about the
-    /// packages being inserted. Otherwise though this will additionally attempt
-    /// to "union" packages found in `resolve` with those found in `self`.
-    /// Unioning packages is keyed on the name/url of packages for those with
-    /// URLs present. If found then it's assumed that both `Resolve` instances
-    /// were originally created from the same contents and are two views
-    /// of the same package.
-    pub fn merge(&mut self, resolve: Resolve) -> Result<Remap> {
-        log::trace!(
-            "merging {} packages into {} packages",
-            resolve.packages.len(),
-            self.packages.len()
-        );
-
-        let mut map = MergeMap::new(&resolve, &self)?;
-        map.build()?;
-        let MergeMap {
-            package_map,
-            interface_map,
-            type_map,
-            world_map,
-            interfaces_to_add,
-            worlds_to_add,
-            ..
-        } = map;
-
-        // With a set of maps from ids in `resolve` to ids in `self` the next
-        // operation is to start moving over items and building a `Remap` to
-        // update ids.
-        //
-        // Each component field of `resolve` is moved into `self` so long as
-        // its ID is not within one of the maps above. If it's present in a map
-        // above then that means the item is already present in `self` so a new
-        // one need not be added. If it's not present in a map that means it's
-        // not present in `self` so it must be added to an arena.
-        //
-        // When adding an item to an arena one of the `remap.update_*` methods
-        // is additionally called to update all identifiers from pointers within
-        // `resolve` to becoming pointers within `self`.
-        //
-        // Altogether this should weave all the missing items in `self` from
-        // `resolve` into one structure while updating all identifiers to
-        // be local within `self`.
-
+    pub fn merge(&mut self, resolve: Resolve) -> Remap {
         let mut remap = Remap::default();
         let Resolve {
             types,
             worlds,
             interfaces,
+            documents,
             packages,
-            package_names,
         } = resolve;
 
-        let mut moved_types = Vec::new();
         for (id, mut ty) in types {
-            let new_id = type_map.get(&id).copied().unwrap_or_else(|| {
-                moved_types.push(id);
-                remap.update_typedef(self, &mut ty);
-                self.types.alloc(ty)
-            });
+            remap.update_typedef(&mut ty);
+            let new_id = self.types.alloc(ty);
             assert_eq!(remap.types.len(), id.index());
             remap.types.push(new_id);
         }
 
-        let mut moved_interfaces = Vec::new();
         for (id, mut iface) in interfaces {
-            let new_id = interface_map.get(&id).copied().unwrap_or_else(|| {
-                moved_interfaces.push(id);
-                remap.update_interface(self, &mut iface);
-                self.interfaces.alloc(iface)
-            });
+            remap.update_interface(&mut iface);
+            let new_id = self.interfaces.alloc(iface);
             assert_eq!(remap.interfaces.len(), id.index());
             remap.interfaces.push(new_id);
         }
 
-        let mut moved_worlds = Vec::new();
         for (id, mut world) in worlds {
-            let new_id = world_map.get(&id).copied().unwrap_or_else(|| {
-                moved_worlds.push(id);
-                let mut update = |map: &mut IndexMap<WorldKey, WorldItem>| {
-                    for (mut name, mut item) in mem::take(map) {
-                        remap.update_world_key(&mut name);
-                        match &mut item {
-                            WorldItem::Function(f) => remap.update_function(self, f),
-                            WorldItem::Interface(i) => *i = remap.interfaces[i.index()],
-                            WorldItem::Type(i) => *i = remap.types[i.index()],
-                        }
-                        map.insert(name, item);
-                    }
-                };
-                update(&mut world.imports);
-                update(&mut world.exports);
-                self.worlds.alloc(world)
-            });
+            for (_, item) in world.imports.iter_mut().chain(&mut world.exports) {
+                match item {
+                    WorldItem::Function(f) => remap.update_function(f),
+                    WorldItem::Interface(i) => *i = remap.interfaces[i.index()],
+                    WorldItem::Type(i) => *i = remap.types[i.index()],
+                }
+            }
+            let new_id = self.worlds.alloc(world);
             assert_eq!(remap.worlds.len(), id.index());
             remap.worlds.push(new_id);
         }
 
+        for (id, mut doc) in documents {
+            remap.update_document(&mut doc);
+            let new_id = self.documents.alloc(doc);
+            assert_eq!(remap.documents.len(), id.index());
+            remap.documents.push(new_id);
+        }
+
         for (id, mut pkg) in packages {
-            let new_id = package_map.get(&id).copied().unwrap_or_else(|| {
-                for (_, id) in pkg.interfaces.iter_mut() {
-                    *id = remap.interfaces[id.index()];
-                }
-                for (_, id) in pkg.worlds.iter_mut() {
-                    *id = remap.worlds[id.index()];
-                }
-                self.packages.alloc(pkg)
-            });
+            for (_, doc) in pkg.documents.iter_mut() {
+                *doc = remap.documents[doc.index()];
+            }
+            let new_id = self.packages.alloc(pkg);
             assert_eq!(remap.packages.len(), id.index());
             remap.packages.push(new_id);
         }
 
-        for (name, id) in package_names {
-            let id = remap.packages[id.index()];
-            if let Some(prev) = self.package_names.insert(name, id) {
-                assert_eq!(prev, id);
+        // Fixup all "parent" links now
+        for id in remap.documents.iter().copied() {
+            if let Some(pkg) = &mut self.documents[id].package {
+                *pkg = remap.packages[pkg.index()];
             }
         }
-
-        // Fixup all "parent" links now.
-        //
-        // Note that this is only done for items that are actually moved from
-        // `resolve` into `self`, which is tracked by the various `moved_*`
-        // lists built incrementally above. The ids in the `moved_*` lists
-        // are ids within `resolve`, so they're translated through `remap` to
-        // ids within `self`.
-        for id in moved_worlds {
-            let id = remap.worlds[id.index()];
-            let pkg = self.worlds[id].package.as_mut().unwrap();
-            *pkg = remap.packages[pkg.index()];
+        for id in remap.worlds.iter().copied() {
+            let doc = &mut self.worlds[id].document;
+            *doc = remap.documents[doc.index()];
         }
-        for id in moved_interfaces {
-            let id = remap.interfaces[id.index()];
-            let pkg = self.interfaces[id].package.as_mut().unwrap();
-            *pkg = remap.packages[pkg.index()];
+        for id in remap.interfaces.iter().copied() {
+            let doc = &mut self.interfaces[id].document;
+            *doc = remap.documents[doc.index()];
         }
-        for id in moved_types {
-            let id = remap.types[id.index()];
+        for id in remap.types.iter().copied() {
             match &mut self.types[id].owner {
                 TypeOwner::Interface(id) => *id = remap.interfaces[id.index()],
                 TypeOwner::World(id) => *id = remap.worlds[id.index()],
@@ -369,25 +309,7 @@ impl Resolve {
             }
         }
 
-        // And finally process items that were present in `resolve` but were
-        // not present in `self`. This is only done for merged packages as
-        // documents may be added to `self.documents` but wouldn't otherwise be
-        // present in the `documents` field of the corresponding package.
-        for (name, pkg, iface) in interfaces_to_add {
-            let prev = self.packages[pkg]
-                .interfaces
-                .insert(name, remap.interfaces[iface.index()]);
-            assert!(prev.is_none());
-        }
-        for (name, pkg, world) in worlds_to_add {
-            let prev = self.packages[pkg]
-                .worlds
-                .insert(name, remap.worlds[world.index()]);
-            assert!(prev.is_none());
-        }
-
-        log::trace!("now have {} packages", self.packages.len());
-        Ok(remap)
+        remap
     }
 
     /// Merges the world `from` into the world `into`.
@@ -400,184 +322,117 @@ impl Resolve {
     /// interface.
     ///
     /// This operation can fail if the imports/exports overlap.
+    //
+    // TODO: overlap shouldn't be a hard error here, there should be some form
+    // of comparing names/urls/deep merging or such to get this working.
     pub fn merge_worlds(&mut self, from: WorldId, into: WorldId) -> Result<()> {
         let mut new_imports = Vec::new();
         let mut new_exports = Vec::new();
 
         let from_world = &self.worlds[from];
         let into_world = &self.worlds[into];
-
-        // Build a map of the imports/exports in `into` going the reverse
-        // direction from what's listed. This is then consulted below to ensure
-        // that the same item isn't exported or imported under two different
-        // names which isn't allowed in the component model.
-        let mut into_imports_by_id = HashMap::new();
-        let mut into_exports_by_id = HashMap::new();
-        for (name, import) in into_world.imports.iter() {
-            if let WorldItem::Interface(id) = *import {
-                let prev = into_imports_by_id.insert(id, name);
-                assert!(prev.is_none());
-            }
-        }
-        for (name, export) in into_world.exports.iter() {
-            if let WorldItem::Interface(id) = *export {
-                let prev = into_exports_by_id.insert(id, name);
-                assert!(prev.is_none());
-            }
-        }
         for (name, import) in from_world.imports.iter() {
-            // If the "from" world imports an interface which is already
-            // imported by the "into" world then this is allowed if the names
-            // are the same. Importing the same interface under different names
-            // isn't allowed, but otherwise merging imports of
-            // same-named-interfaces is allowed to merge them together.
-            if let WorldItem::Interface(id) = import {
-                if let Some(prev) = into_imports_by_id.get(id) {
-                    if *prev != name {
-                        let name = self.name_world_key(name);
-                        let prev = self.name_world_key(prev);
-                        bail!("import `{name}` conflicts with previous name of `{prev}`");
-                    }
-                }
-            }
-        }
-        for (name, export) in from_world.exports.iter() {
-            // Note that unlike imports same-named exports are not handled here
-            // since if something is exported twice there's no way to "unify" it
-            // so it's left as an error.
-            if let WorldItem::Interface(id) = export {
-                if let Some(prev) = into_exports_by_id.get(id) {
-                    let name = self.name_world_key(name);
-                    let prev = self.name_world_key(prev);
-                    bail!("export `{name}` conflicts with previous name of `{prev}`");
-                }
-            }
-        }
-
-        // Next walk over the interfaces imported into `from_world` and queue up
-        // imports to get inserted into `into_world`.
-        for (name, from_import) in from_world.imports.iter() {
             match into_world.imports.get(name) {
-                Some(into_import) => match (from_import, into_import) {
-                    // If these imports, which have the same name, are of the
-                    // same interface then union them together at this point.
-                    (WorldItem::Interface(from), WorldItem::Interface(into)) if from == into => {
-                        continue
-                    }
-                    _ => {
-                        let name = self.name_world_key(name);
-                        bail!("duplicate import found for interface `{name}`");
-                    }
-                },
-                None => new_imports.push((name.clone(), from_import.clone())),
+                Some(_) => bail!("duplicate import found for interface `{name}`"),
+                None => new_imports.push((name.clone(), import.clone())),
             }
         }
-
-        // All exports at this time must be unique. For example the same
-        // interface exported from two locations can't really be resolved to one
-        // canonical definition, so make sure that merging worlds only succeeds
-        // if the worlds have disjoint sets of exports.
         for (name, export) in from_world.exports.iter() {
             match into_world.exports.get(name) {
-                Some(_) => {
-                    let name = self.name_world_key(name);
-                    bail!("duplicate export found for interface `{name}`");
-                }
+                Some(_) => bail!("duplicate export found for interface `{name}`"),
                 None => new_exports.push((name.clone(), export.clone())),
             }
         }
 
-        // Insert any new imports and new exports found first.
         let into = &mut self.worlds[into];
         for (name, import) in new_imports {
             let prev = into.imports.insert(name, import);
             assert!(prev.is_none());
         }
-        for (name, export) in new_exports {
-            let prev = into.exports.insert(name, export);
+        for (name, import) in new_exports {
+            let prev = into.exports.insert(name, import);
             assert!(prev.is_none());
         }
 
         Ok(())
     }
 
-    /// Returns the ID of the specified `interface`.
+    /// Returns the URL of the specified `interface`, if available.
+    ///
+    /// This currently creates a URL based on the URL of the package that
+    /// `interface` resides in. If the package owner of `interface` does not
+    /// specify a URL then `None` will be returned.
     ///
-    /// Returns `None` for unnamed interfaces.
-    pub fn id_of(&self, interface: InterfaceId) -> Option<String> {
+    /// If the `interface` specified does not have a name then `None` will be
+    /// returned as well.
+    pub fn url_of(&self, interface: InterfaceId) -> Option<String> {
         let interface = &self.interfaces[interface];
-        let package = &self.packages[interface.package.unwrap()];
-        let mut base = String::new();
-        base.push_str(&package.name.namespace);
-        base.push_str(":");
-        base.push_str(&package.name.name);
-        base.push_str("/");
-        base.push_str(interface.name.as_ref()?);
-        if let Some(version) = &package.name.version {
-            base.push_str(&format!("@{version}"));
-        }
-        Some(base)
+        let doc = &self.documents[interface.document];
+        let package = &self.packages[doc.package.unwrap()];
+        let mut base = Url::parse(package.url.as_ref()?).unwrap();
+        base.path_segments_mut()
+            .unwrap()
+            .push(&doc.name)
+            .push(interface.name.as_ref()?);
+        Some(base.to_string())
     }
 
-    /// Attempts to locate a world given the "default" package `pkg` and the
-    /// optional string specifier `world`.
-    ///
-    /// This method is intended to be used by bindings generation tools to
-    /// select a world from either `pkg` or a package in this `Resolve`.
-    ///
-    /// If `world` is `None` then `pkg` must have precisely one world which will
-    /// be returned.
+    /// Attempts to locate a default world for the `pkg` specified within this
+    /// [`Resolve`]. Optionally takes a string-based `world` "specifier" to
+    /// resolve the world.
     ///
-    /// If `world` is `Some` then it can either be:
+    /// This is intended for use by bindings generators and such as the default
+    /// logic for locating a world within a package used for binding. The
+    /// `world` argument is typically a user-specified argument (which again is
+    /// optional and not required) where the `pkg` is determined ambiently by
+    /// the integration.
     ///
-    /// * A kebab-name of a world contained within `pkg` which is being
-    ///   selected, such as `"the-world"`.
-    ///
-    /// * An ID-based form of a world which is selected within this `Resolve`,
-    ///   ignoring `pkg`. For example `"wasi:http/proxy"`.
-    ///
-    /// If successful the corresponding `WorldId` is returned, otherwise an
-    /// error is returned.
+    /// If `world` is `None` (e.g. not specified by a user) then the package
+    /// must have exactly one `default world` within its documents, otherwise an
+    /// error will be returned. If `world` is `Some` then it's a `.`-separated
+    /// name where the first element is the name of the document and the second,
+    /// optional, element is the name of the `world`. For example the name `foo`
+    /// would mean the `default world` of the `foo` document. The name `foo.bar`
+    /// would mean the world named `bar` in the `foo` document.
     pub fn select_world(&self, pkg: PackageId, world: Option<&str>) -> Result<WorldId> {
-        let world = match world {
-            Some(world) => world,
-            None => {
-                let pkg = &self.packages[pkg];
-                match pkg.worlds.len() {
-                    0 => bail!("no worlds found in package `{}`", pkg.name),
-                    1 => return Ok(*pkg.worlds.values().next().unwrap()),
-                    _ => bail!(
-                        "multiple worlds found in package `{}`: one must be explicitly chosen",
-                        pkg.name
-                    ),
+        match world {
+            Some(world) => {
+                let mut parts = world.splitn(2, '.');
+                let doc = parts.next().unwrap();
+                let world = parts.next();
+                let doc = *self.packages[pkg]
+                    .documents
+                    .get(doc)
+                    .ok_or_else(|| anyhow!("no document named `{doc}` in package"))?;
+                match world {
+                    Some(name) => self.documents[doc]
+                        .worlds
+                        .get(name)
+                        .copied()
+                        .ok_or_else(|| anyhow!("no world named `{name}` in document")),
+                    None => self.documents[doc]
+                        .default_world
+                        .ok_or_else(|| anyhow!("no default world in document")),
                 }
             }
-        };
+            None => {
+                if self.packages[pkg].documents.is_empty() {
+                    bail!("no documents found in package")
+                }
 
-        let path = parse_use_path(world)
-            .with_context(|| format!("failed to parse world specifier `{world}`"))?;
-        let (pkg, world) = match path {
-            AstUsePath::Name(name) => (pkg, name),
-            AstUsePath::Package(pkg, interface) => (
-                *self
-                    .package_names
-                    .get(&pkg)
-                    .ok_or_else(|| anyhow!("unknown package `{pkg}`"))?,
-                interface,
-            ),
-        };
-        let pkg = &self.packages[pkg];
-        pkg.worlds
-            .get(&world)
-            .copied()
-            .ok_or_else(|| anyhow!("no world named `{world}` in package"))
-    }
+                let mut unique_default_world = None;
+                for (_name, doc) in &self.documents {
+                    if let Some(default_world) = doc.default_world {
+                        if unique_default_world.is_some() {
+                            bail!("multiple default worlds found in package, one must be specified")
+                        } else {
+                            unique_default_world = Some(default_world);
+                        }
+                    }
+                }
 
-    /// Assigns a human readable name to the `WorldKey` specified.
-    pub fn name_world_key(&self, key: &WorldKey) -> String {
-        match key {
-            WorldKey::Name(s) => s.to_string(),
-            WorldKey::Interface(i) => self.id_of(*i).expect("unexpected anonymous interface"),
+                unique_default_world.ok_or_else(|| anyhow!("no default world in package"))
+            }
         }
     }
 }
@@ -589,18 +444,8 @@ pub struct Remap {
     pub types: Vec<TypeId>,
     pub interfaces: Vec<InterfaceId>,
     pub worlds: Vec<WorldId>,
+    pub documents: Vec<DocumentId>,
     pub packages: Vec<PackageId>,
-
-    /// A cache of anonymous `own<T>` handles for resource types.
-    ///
-    /// The appending operation of `Remap` is the one responsible for
-    /// translating references to `T` where `T` is a resource into `own<T>`
-    /// instead. This map is used to deduplicate the `own<T>` types generated
-    /// to generate as few as possible.
-    ///
-    /// The key of this map is the resource id `T` in the new resolve, and
-    /// the value is the `own<T>` type pointing to `T`.
-    own_handles: HashMap<TypeId, TypeId>,
 }
 
 impl Remap {
@@ -608,11 +453,13 @@ impl Remap {
         &mut self,
         resolve: &mut Resolve,
         unresolved: UnresolvedPackage,
+        deps: &HashMap<String, PackageId>,
     ) -> Result<PackageId> {
-        self.process_foreign_deps(resolve, &unresolved)?;
+        self.process_foreign_deps(resolve, &unresolved, deps)?;
 
         let foreign_types = self.types.len();
         let foreign_interfaces = self.interfaces.len();
+        let foreign_documents = self.documents.len();
         let foreign_worlds = self.worlds.len();
 
         // Copy over all types first, updating any intra-type references. Note
@@ -621,33 +468,16 @@ impl Remap {
         // owner of a type isn't updated here due to interfaces not being known
         // yet.
         for (id, mut ty) in unresolved.types.into_iter().skip(foreign_types) {
-            self.update_typedef(resolve, &mut ty);
+            self.update_typedef(&mut ty);
             let new_id = resolve.types.alloc(ty);
             assert_eq!(self.types.len(), id.index());
-
-            let new_id = match resolve.types[new_id] {
-                // If this is an `own<T>` handle then either replace it with a
-                // preexisting `own<T>` handle which may have been generated in
-                // `update_ty`. If that doesn't exist though then insert it into
-                // the `own_handles` cache.
-                TypeDef {
-                    name: None,
-                    owner: TypeOwner::None,
-                    kind: TypeDefKind::Handle(Handle::Own(id)),
-                    docs: _,
-                } => *self.own_handles.entry(id).or_insert(new_id),
-
-                // Everything not-related to `own<T>` doesn't get its ID
-                // modified.
-                _ => new_id,
-            };
             self.types.push(new_id);
         }
 
         // Next transfer all interfaces into `Resolve`, updating type ids
         // referenced along the way.
         for (id, mut iface) in unresolved.interfaces.into_iter().skip(foreign_interfaces) {
-            self.update_interface(resolve, &mut iface);
+            self.update_interface(&mut iface);
             let new_id = resolve.interfaces.alloc(iface);
             assert_eq!(self.interfaces.len(), id.index());
             self.interfaces.push(new_id);
@@ -669,22 +499,14 @@ impl Remap {
         // This is done after types/interfaces are fully settled so the
         // transitive relation between interfaces, through types, is understood
         // here.
-        assert_eq!(unresolved.worlds.len(), unresolved.world_item_spans.len());
-        let include_world_spans = unresolved.include_world_spans;
+        assert_eq!(unresolved.worlds.len(), unresolved.world_spans.len());
         for ((id, mut world), (import_spans, export_spans)) in unresolved
             .worlds
             .into_iter()
-            .zip(unresolved.world_item_spans)
             .skip(foreign_worlds)
+            .zip(unresolved.world_spans)
         {
-            self.update_world(
-                &mut world,
-                resolve,
-                &import_spans,
-                &export_spans,
-                &include_world_spans,
-            )?;
-
+            self.update_world(&mut world, resolve, &import_spans, &export_spans)?;
             let new_id = resolve.worlds.alloc(world);
             assert_eq!(self.worlds.len(), id.index());
             self.worlds.push(new_id);
@@ -698,30 +520,37 @@ impl Remap {
             }
         }
 
-        // Fixup "parent" ids now that everything has been identified
-        let pkgid = resolve.packages.alloc(Package {
-            name: unresolved.name.clone(),
-            interfaces: Default::default(),
-            worlds: Default::default(),
-        });
-        let prev = resolve.package_names.insert(unresolved.name.clone(), pkgid);
-        assert!(prev.is_none());
+        // And the final major step is transferring documents to `Resolve`
+        // which is just updating a few identifiers here and there.
+        for (id, mut doc) in unresolved.documents.into_iter().skip(foreign_documents) {
+            self.update_document(&mut doc);
+            let new_id = resolve.documents.alloc(doc);
+            assert_eq!(self.documents.len(), id.index());
+            self.documents.push(new_id);
+        }
+
+        // Fixup "parent" ids now that everything has been identifier
         for id in self.interfaces.iter().skip(foreign_interfaces) {
-            let iface = &mut resolve.interfaces[*id];
-            iface.package = Some(pkgid);
-            if let Some(name) = &iface.name {
-                let prev = resolve.packages[pkgid].interfaces.insert(name.clone(), *id);
-                assert!(prev.is_none());
-            }
+            let doc = &mut resolve.interfaces[*id].document;
+            *doc = self.documents[doc.index()];
         }
         for id in self.worlds.iter().skip(foreign_worlds) {
-            let world = &mut resolve.worlds[*id];
-            world.package = Some(pkgid);
-            let prev = resolve.packages[pkgid]
-                .worlds
-                .insert(world.name.clone(), *id);
+            let doc = &mut resolve.worlds[*id].document;
+            *doc = self.documents[doc.index()];
+        }
+        let mut documents = IndexMap::new();
+        for id in self.documents.iter().skip(foreign_documents) {
+            let prev = documents.insert(resolve.documents[*id].name.clone(), *id);
             assert!(prev.is_none());
         }
+        let pkgid = resolve.packages.alloc(Package {
+            name: unresolved.name,
+            url: unresolved.url,
+            documents,
+        });
+        for (_, id) in resolve.packages[pkgid].documents.iter() {
+            resolve.documents[*id].package = Some(pkgid);
+        }
         Ok(pkgid)
     }
 
@@ -729,156 +558,85 @@ impl Remap {
         &mut self,
         resolve: &mut Resolve,
         unresolved: &UnresolvedPackage,
+        deps: &HashMap<String, PackageId>,
     ) -> Result<()> {
-        // Invert the `foreign_deps` map to be keyed by world id to get
-        // used in the loops below.
-        let mut world_to_package = HashMap::new();
-        let mut interface_to_package = HashMap::new();
-        for (i, (pkg_name, worlds_or_ifaces)) in unresolved.foreign_deps.iter().enumerate() {
-            for (name, item) in worlds_or_ifaces {
-                match item {
-                    AstItem::Interface(unresolved_interface_id) => {
-                        let prev = interface_to_package.insert(
-                            *unresolved_interface_id,
-                            (pkg_name, name, unresolved.foreign_dep_spans[i]),
-                        );
-                        assert!(prev.is_none());
-                    }
-                    AstItem::World(unresolved_world_id) => {
-                        let prev = world_to_package.insert(
-                            *unresolved_world_id,
-                            (pkg_name, name, unresolved.foreign_dep_spans[i]),
-                        );
-                        assert!(prev.is_none());
-                    }
-                }
+        // First, connect all references to foreign documents to actual
+        // documents within `resolve`, building up the initial entries of
+        // the `self.documents` mapping.
+        let mut document_to_package = HashMap::new();
+        for (i, (pkg, docs)) in unresolved.foreign_deps.iter().enumerate() {
+            for (doc, unresolved_doc_id) in docs {
+                let prev = document_to_package.insert(
+                    *unresolved_doc_id,
+                    (pkg, doc, unresolved.foreign_dep_spans[i]),
+                );
+                assert!(prev.is_none());
             }
         }
+        for (unresolved_doc_id, _doc) in unresolved.documents.iter() {
+            let (pkg, doc, span) = match document_to_package.get(&unresolved_doc_id) {
+                Some(items) => *items,
+                None => break,
+            };
+            let pkgid = *deps.get(pkg).ok_or_else(|| Error {
+                span,
+                msg: format!("no package dependency specified for `{pkg}`"),
+            })?;
+            let package = &resolve.packages[pkgid];
 
-        // Connect all interfaces referred to in `interface_to_package`, which
-        // are at the front of `unresolved.interfaces`, to interfaces already
-        // contained within `resolve`.
-        self.process_foreign_interfaces(unresolved, &interface_to_package, resolve)?;
-
-        // Connect all worlds referred to in `world_to_package`, which
-        // are at the front of `unresolved.worlds`, to worlds already
-        // contained within `resolve`.
-        self.process_foreign_worlds(unresolved, &world_to_package, resolve)?;
+            let docid = *package.documents.get(doc).ok_or_else(|| Error {
+                span: unresolved.document_spans[unresolved_doc_id.index()],
+                msg: format!("package `{pkg}` does not define document `{doc}`"),
+            })?;
 
-        // Finally, iterate over all foreign-defined types and determine
-        // what they map to.
-        self.process_foreign_types(unresolved, resolve)?;
-
-        for (id, span) in unresolved.required_resource_types.iter() {
-            let mut id = self.types[id.index()];
-            loop {
-                match resolve.types[id].kind {
-                    TypeDefKind::Type(Type::Id(i)) => id = i,
-                    TypeDefKind::Resource => break,
-                    _ => bail!(Error {
-                        span: *span,
-                        msg: format!("type used in a handle must be a resource"),
-                    }),
-                }
-            }
+            assert_eq!(self.documents.len(), unresolved_doc_id.index());
+            self.documents.push(docid);
+        }
+        for (id, _) in unresolved.documents.iter().skip(self.documents.len()) {
+            assert!(
+                document_to_package.get(&id).is_none(),
+                "found foreign document after local documents"
+            );
         }
 
-        Ok(())
-    }
-
-    fn process_foreign_interfaces(
-        &mut self,
-        unresolved: &UnresolvedPackage,
-        interface_to_package: &HashMap<Id<Interface>, (&PackageName, &String, Span)>,
-        resolve: &mut Resolve,
-    ) -> Result<(), anyhow::Error> {
+        // Next, for all documents that are referenced in this `Resolve`
+        // determine the mapping of all interfaces that they refer to.
         for (unresolved_iface_id, unresolved_iface) in unresolved.interfaces.iter() {
-            let (pkg_name, interface, span) = match interface_to_package.get(&unresolved_iface_id) {
-                Some(items) => *items,
+            let doc_id = match self.documents.get(unresolved_iface.document.index()) {
+                Some(i) => *i,
                 // All foreign interfaces are defined first, so the first one
                 // which is defined in a non-foreign document means that all
                 // further interfaces will be non-foreign as well.
                 None => break,
             };
-            let pkgid = resolve
-                .package_names
-                .get(pkg_name)
-                .copied()
-                .ok_or_else(|| Error {
-                    span,
-                    msg: format!("package not found"),
-                })?;
 
             // Functions can't be imported so this should be empty.
             assert!(unresolved_iface.functions.is_empty());
 
-            let pkg = &resolve.packages[pkgid];
+            let document = &resolve.documents[doc_id];
             let span = unresolved.interface_spans[unresolved_iface_id.index()];
-            let iface_id = pkg
-                .interfaces
-                .get(interface)
-                .copied()
-                .ok_or_else(|| Error {
+            let iface_id = match &unresolved_iface.name {
+                Some(name) => *document.interfaces.get(name).ok_or_else(|| Error {
                     span,
-                    msg: format!("interface not found in package"),
-                })?;
+                    msg: format!("interface not defined in document"),
+                })?,
+                None => document.default_interface.ok_or_else(|| Error {
+                    span,
+                    msg: format!("default interface not specified in document"),
+                })?,
+            };
             assert_eq!(self.interfaces.len(), unresolved_iface_id.index());
             self.interfaces.push(iface_id);
         }
-        for (id, _) in unresolved.interfaces.iter().skip(self.interfaces.len()) {
-            assert!(
-                interface_to_package.get(&id).is_none(),
-                "found foreign interface after local interface"
-            );
-        }
-        Ok(())
-    }
-
-    fn process_foreign_worlds(
-        &mut self,
-        unresolved: &UnresolvedPackage,
-        world_to_package: &HashMap<Id<World>, (&PackageName, &String, Span)>,
-        resolve: &mut Resolve,
-    ) -> Result<(), anyhow::Error> {
-        for (unresolved_world_id, _) in unresolved.worlds.iter() {
-            let (pkg_name, world, span) = match world_to_package.get(&unresolved_world_id) {
-                Some(items) => *items,
-                // Same as above, all worlds are foreign until we find a
-                // non-foreign one.
-                None => break,
-            };
 
-            let pkgid = resolve
-                .package_names
-                .get(pkg_name)
-                .copied()
-                .ok_or_else(|| Error {
-                    span,
-                    msg: format!("package not found"),
-                })?;
-            let pkg = &resolve.packages[pkgid];
-            let span = unresolved.world_spans[unresolved_world_id.index()];
-            let world_id = pkg.worlds.get(world).copied().ok_or_else(|| Error {
-                span,
-                msg: format!("world not found in package"),
-            })?;
-            assert_eq!(self.worlds.len(), unresolved_world_id.index());
-            self.worlds.push(world_id);
-        }
-        for (id, _) in unresolved.worlds.iter().skip(self.worlds.len()) {
-            assert!(
-                world_to_package.get(&id).is_none(),
-                "found foreign world after local world"
-            );
+        for (_, iface) in unresolved.interfaces.iter().skip(self.interfaces.len()) {
+            if self.documents.get(iface.document.index()).is_some() {
+                panic!("found foreign interface after local interfaces");
+            }
         }
-        Ok(())
-    }
 
-    fn process_foreign_types(
-        &mut self,
-        unresolved: &UnresolvedPackage,
-        resolve: &mut Resolve,
-    ) -> Result<(), anyhow::Error> {
+        // And finally iterate over all foreign-defined types and determine
+        // what they map to.
         for (unresolved_type_id, unresolved_ty) in unresolved.types.iter() {
             // All "Unknown" types should appear first so once we're no longer
             // in unknown territory it's package-defined types so break out of
@@ -899,76 +657,68 @@ impl Remap {
                 .get(name)
                 .ok_or_else(|| Error {
                     span,
-                    msg: format!("type `{name}` not defined in interface"),
+                    msg: format!("type not defined in interface"),
                 })?;
             assert_eq!(self.types.len(), unresolved_type_id.index());
             self.types.push(type_id);
         }
+
         for (_, ty) in unresolved.types.iter().skip(self.types.len()) {
             if let TypeDefKind::Unknown = ty.kind {
                 panic!("unknown type after defined type");
             }
         }
+
         Ok(())
     }
 
-    fn update_typedef(&mut self, resolve: &mut Resolve, ty: &mut TypeDef) {
+    fn update_typedef(&self, ty: &mut TypeDef) {
         // NB: note that `ty.owner` is not updated here since interfaces
         // haven't been mapped yet and that's done in a separate step.
         use crate::TypeDefKind::*;
         match &mut ty.kind {
-            Handle(handle) => match handle {
-                crate::Handle::Own(ty) | crate::Handle::Borrow(ty) => self.update_type_id(ty),
-            },
-            Resource => {}
             Record(r) => {
                 for field in r.fields.iter_mut() {
-                    self.update_ty(resolve, &mut field.ty);
+                    self.update_ty(&mut field.ty);
                 }
             }
             Tuple(t) => {
                 for ty in t.types.iter_mut() {
-                    self.update_ty(resolve, ty);
+                    self.update_ty(ty);
                 }
             }
             Variant(v) => {
                 for case in v.cases.iter_mut() {
                     if let Some(t) = &mut case.ty {
-                        self.update_ty(resolve, t);
+                        self.update_ty(t);
                     }
                 }
             }
-            Option(t) => self.update_ty(resolve, t),
+            Option(t) => self.update_ty(t),
             Result(r) => {
                 if let Some(ty) = &mut r.ok {
-                    self.update_ty(resolve, ty);
+                    self.update_ty(ty);
                 }
                 if let Some(ty) = &mut r.err {
-                    self.update_ty(resolve, ty);
+                    self.update_ty(ty);
                 }
             }
             Union(u) => {
                 for case in u.cases.iter_mut() {
-                    self.update_ty(resolve, &mut case.ty);
+                    self.update_ty(&mut case.ty);
                 }
             }
-            List(t) => self.update_ty(resolve, t),
-            Future(Some(t)) => self.update_ty(resolve, t),
+            List(t) => self.update_ty(t),
+            Future(Some(t)) => self.update_ty(t),
             Stream(t) => {
                 if let Some(ty) = &mut t.element {
-                    self.update_ty(resolve, ty);
+                    self.update_ty(ty);
                 }
                 if let Some(ty) = &mut t.end {
-                    self.update_ty(resolve, ty);
+                    self.update_ty(ty);
                 }
             }
-
-            // Note that `update_ty` is specifically not used here as typedefs
-            // because for the `type a = b` form that doesn't force `a` to be a
-            // handle type if `b` is a resource type, instead `a` is
-            // simultaneously usable as a resource and a handle type
-            Type(crate::Type::Id(id)) => self.update_type_id(id),
-            Type(_) => {}
+            Type(t) => self.update_ty(t),
 
             // nothing to do for these as they're just names or empty
             Flags(_) | Enum(_) | Future(None) => {}
@@ -977,80 +727,43 @@ impl Remap {
         }
     }
 
-    fn update_ty(&mut self, resolve: &mut Resolve, ty: &mut Type) {
-        let id = match ty {
-            Type::Id(id) => id,
-            _ => return,
-        };
-        self.update_type_id(id);
-
-        // If `id` points to a `Resource` type then this means that what was
-        // just discovered was a reference to what will implicitly become an
-        // `own<T>` handle. This `own` handle is implicitly allocated here
-        // and handled during the merging process.
-        let mut cur = *id;
-        let points_to_resource = loop {
-            match resolve.types[cur].kind {
-                TypeDefKind::Type(Type::Id(id)) => cur = id,
-                TypeDefKind::Resource => break true,
-                _ => break false,
-            }
-        };
-
-        if points_to_resource {
-            *id = *self.own_handles.entry(*id).or_insert_with(|| {
-                resolve.types.alloc(TypeDef {
-                    name: None,
-                    owner: TypeOwner::None,
-                    kind: TypeDefKind::Handle(Handle::Own(*id)),
-                    docs: Default::default(),
-                })
-            });
+    fn update_ty(&self, ty: &mut Type) {
+        if let Type::Id(id) = ty {
+            *id = self.types[id.index()];
         }
     }
 
-    fn update_type_id(&self, id: &mut TypeId) {
-        *id = self.types[id.index()];
-    }
-
-    fn update_interface(&mut self, resolve: &mut Resolve, iface: &mut Interface) {
+    fn update_interface(&self, iface: &mut Interface) {
         // NB: note that `iface.doc` is not updated here since interfaces
         // haven't been mapped yet and that's done in a separate step.
         for (_name, ty) in iface.types.iter_mut() {
-            self.update_type_id(ty);
+            *ty = self.types[ty.index()];
         }
         for (_, func) in iface.functions.iter_mut() {
-            self.update_function(resolve, func);
+            self.update_function(func);
         }
     }
 
-    fn update_function(&mut self, resolve: &mut Resolve, func: &mut Function) {
-        match &mut func.kind {
-            FunctionKind::Freestanding => {}
-            FunctionKind::Method(id) | FunctionKind::Constructor(id) | FunctionKind::Static(id) => {
-                self.update_type_id(id);
-            }
-        }
+    fn update_function(&self, func: &mut Function) {
         for (_, ty) in func.params.iter_mut() {
-            self.update_ty(resolve, ty);
+            self.update_ty(ty);
         }
         match &mut func.results {
             Results::Named(named) => {
                 for (_, ty) in named.iter_mut() {
-                    self.update_ty(resolve, ty);
+                    self.update_ty(ty);
                 }
             }
-            Results::Anon(ty) => self.update_ty(resolve, ty),
+            Results::Anon(ty) => self.update_ty(ty),
         }
     }
 
     fn update_world(
-        &mut self,
+        &self,
         world: &mut World,
-        resolve: &mut Resolve,
+        resolve: &Resolve,
         import_spans: &[Span],
         export_spans: &[Span],
-        include_world_spans: &[Span],
     ) -> Result<()> {
         // NB: this function is more more complicated than the prior versions
         // of merging an item because this is the location that elaboration of
@@ -1068,94 +781,93 @@ impl Remap {
         // Here each import of an interface is recorded and then additionally
         // explicitly named imports of interfaces are recorded as well for
         // determining names later on.
+        let mut explicit_import_names = HashMap::new();
+        let mut explicit_export_names = HashMap::new();
+        let mut imports = Vec::new();
+        let mut exports = Vec::new();
         let mut import_funcs = Vec::new();
+        let mut export_funcs = Vec::new();
         let mut import_types = Vec::new();
-        for ((mut name, item), span) in mem::take(&mut world.imports).into_iter().zip(import_spans)
-        {
-            self.update_world_key(&mut name);
+        for ((name, item), span) in mem::take(&mut world.imports).into_iter().zip(import_spans) {
             match item {
                 WorldItem::Interface(id) => {
                     let id = self.interfaces[id.index()];
-                    self.add_world_import(resolve, world, name, id);
+                    imports.push((id, *span));
+                    let prev = explicit_import_names.insert(id, name);
+                    assert!(prev.is_none());
                 }
                 WorldItem::Function(mut f) => {
-                    self.update_function(resolve, &mut f);
-                    import_funcs.push((name.unwrap_name(), f, *span));
+                    self.update_function(&mut f);
+                    import_funcs.push((name, f, *span));
                 }
                 WorldItem::Type(id) => {
                     let id = self.types[id.index()];
-                    import_types.push((name.unwrap_name(), id, *span));
-                }
-            }
-        }
-
-        for (_name, id, _span) in import_types.iter() {
-            if let TypeDefKind::Type(Type::Id(other)) = resolve.types[*id].kind {
-                if let TypeOwner::Interface(owner) = resolve.types[other].owner {
-                    let name = WorldKey::Interface(owner);
-                    self.add_world_import(resolve, world, name, owner);
+                    import_types.push((name, id, *span));
                 }
             }
         }
-
-        let mut export_funcs = Vec::new();
-        let mut export_interfaces = IndexMap::new();
-        for ((mut name, item), span) in mem::take(&mut world.exports).into_iter().zip(export_spans)
-        {
-            self.update_world_key(&mut name);
+        for ((name, item), span) in mem::take(&mut world.exports).into_iter().zip(export_spans) {
             match item {
                 WorldItem::Interface(id) => {
                     let id = self.interfaces[id.index()];
-                    let prev = export_interfaces.insert(id, (name, *span));
+                    exports.push((id, *span));
+                    let prev = explicit_export_names.insert(id, name);
                     assert!(prev.is_none());
                 }
                 WorldItem::Function(mut f) => {
-                    self.update_function(resolve, &mut f);
-                    let name = match name {
-                        WorldKey::Name(name) => name,
-                        WorldKey::Interface(_) => unreachable!(),
-                    };
+                    self.update_function(&mut f);
                     export_funcs.push((name, f, *span));
                 }
                 WorldItem::Type(_) => unreachable!(),
             }
         }
 
-        self.add_world_exports(resolve, world, &export_interfaces)?;
-
-        // Resolve all includes of the world
-        let includes = mem::take(&mut world.includes);
-        let include_names = mem::take(&mut world.include_names);
-        for (index, include_world) in includes.into_iter().enumerate() {
-            let span = include_world_spans[index];
-            let names = &include_names[index];
-            self.resolve_include(world, include_world, names, span, resolve)?;
+        // Next all imports and their transitive imports are processed. This
+        // is done through a `stack` of `Action` items which is processed in
+        // LIFO order, meaning that an action of processing the dependencies
+        // is pushed after processing the node itself. The dependency processing
+        // will push more items onto the stack as necessary.
+        let mut elaborate = WorldElaborator {
+            resolve,
+            world,
+            imports_processed: Default::default(),
+            exports_processed: Default::default(),
+            resolving_stack: Default::default(),
+            explicit_import_names: &explicit_import_names,
+            explicit_export_names: &explicit_export_names,
+            names: Default::default(),
+        };
+        for (id, span) in imports {
+            elaborate.import(id, span)?;
+        }
+        for (_name, id, span) in import_types.iter() {
+            if let TypeDefKind::Type(Type::Id(other)) = resolve.types[*id].kind {
+                if let TypeOwner::Interface(owner) = resolve.types[other].owner {
+                    elaborate.import(owner, *span)?;
+                }
+            }
+        }
+        for (id, span) in exports {
+            elaborate.export(id, span)?;
         }
 
         for (name, id, span) in import_types {
-            let prev = world
+            let prev = elaborate
+                .world
                 .imports
-                .insert(WorldKey::Name(name.clone()), WorldItem::Type(id));
+                .insert(name.clone(), WorldItem::Type(id));
             if prev.is_some() {
                 bail!(Error {
                     msg: format!("export of type `{name}` shadows previously imported interface"),
                     span,
                 })
             }
-
-            // check if this type has name conflict with any of the exported item.
-            if world.exports.contains_key(&WorldKey::Name(name.clone())) {
-                bail!(Error {
-                    msg: format!("import type `{name}` conflicts with prior export of interface",),
-                    span,
-                })
-            }
         }
 
         for (name, func, span) in import_funcs {
             let prev = world
                 .imports
-                .insert(WorldKey::Name(name.clone()), WorldItem::Function(func));
+                .insert(name.clone(), WorldItem::Function(func));
             if prev.is_some() {
                 bail!(Error {
                     msg: format!(
@@ -1164,23 +876,12 @@ impl Remap {
                     span,
                 })
             }
-
-            // check if this function has name conflict with any of the exported item.
-            if world.exports.contains_key(&WorldKey::Name(name.clone())) {
-                bail!(Error {
-                    msg: format!(
-                        "import of function `{name}` conflicts with prior export of interface",
-                    ),
-                    span,
-                })
-            }
         }
-
         for (name, func, span) in export_funcs {
             let prev = world
                 .exports
-                .insert(WorldKey::Name(name.clone()), WorldItem::Function(func));
-            if prev.is_some() || world.imports.contains_key(&WorldKey::Name(name.clone())) {
+                .insert(name.clone(), WorldItem::Function(func));
+            if prev.is_some() {
                 bail!(Error {
                     msg: format!(
                         "export of function `{name}` shadows previously exported interface"
@@ -1188,16 +889,6 @@ impl Remap {
                     span,
                 })
             }
-
-            // check if this function has name conflict with any of the import item.
-            if world.imports.contains_key(&WorldKey::Name(name.clone())) {
-                bail!(Error {
-                    msg: format!(
-                        "export of function `{name}` conflicts with prior import of interface",
-                    ),
-                    span,
-                })
-            }
         }
 
         log::trace!("imports = {:?}", world.imports);
@@ -1206,538 +897,128 @@ impl Remap {
         Ok(())
     }
 
-    fn update_world_key(&self, key: &mut WorldKey) {
-        match key {
-            WorldKey::Name(_) => {}
-            WorldKey::Interface(id) => {
-                *id = self.interfaces[id.index()];
-            }
+    fn update_document(&self, doc: &mut Document) {
+        for (_name, iface) in doc.interfaces.iter_mut() {
+            *iface = self.interfaces[iface.index()];
         }
-    }
-
-    fn add_world_import(
-        &self,
-        resolve: &Resolve,
-        world: &mut World,
-        key: WorldKey,
-        id: InterfaceId,
-    ) {
-        if world.imports.contains_key(&key) {
-            return;
-        }
-        let ok = foreach_interface_dep(resolve, id, |dep| {
-            self.add_world_import(resolve, world, WorldKey::Interface(dep), dep);
-            true
-        });
-        assert!(ok);
-        let prev = world.imports.insert(key, WorldItem::Interface(id));
-        assert!(prev.is_none());
-    }
-
-    /// This function adds all of the interfaces in `export_interfaces` to the
-    /// list of exports of the `world` specified.
-    ///
-    /// This method is more involved than adding imports because it is fallible.
-    /// Chiefly what can happen is that the dependencies of all exports must be
-    /// satisfied by other exports or imports, but not both. For example given a
-    /// situation such as:
-    ///
-    /// ```wit
-    /// interface a {
-    ///     type t = u32
-    /// }
-    /// interface b {
-    ///     use a.{t}
-    /// }
-    /// interface c {
-    ///     use a.{t}
-    ///     use b.{t as t2}
-    /// }
-    /// ```
-    ///
-    /// where `c` depends on `b` and `a` where `b` depends on `a`, then the
-    /// purpose of this method is to reject this world:
-    ///
-    /// ```wit
-    /// world foo {
-    ///     export a
-    ///     export c
-    /// }
-    /// ```
-    ///
-    /// The reasoning here is unfortunately subtle and is additionally the
-    /// subject of WebAssembly/component-model#208. Effectively the `c`
-    /// interface depends on `b`, but it's not listed explicitly as an import,
-    /// so it's then implicitly added as an import. This then transitively
-    /// depends on `a` so it's also added as an import. At this point though `c`
-    /// also depends on `a`, and it's also exported, so naively it should depend
-    /// on the export and not implicitly add an import. This means though that
-    /// `c` has access to two copies of `a`, one imported and one exported. This
-    /// is not valid, especially in the face of resource types.
-    ///
-    /// Overall this method is tasked with rejecting the above world by walking
-    /// over all the exports and adding their dependencies. Each dependency is
-    /// recorded with whether it's required to be imported, and then if an
-    /// export is added for something that's required to be an error then the
-    /// operation fails.
-    fn add_world_exports(
-        &self,
-        resolve: &Resolve,
-        world: &mut World,
-        export_interfaces: &IndexMap<InterfaceId, (WorldKey, Span)>,
-    ) -> Result<()> {
-        let mut required_imports = HashSet::new();
-        for (id, (key, span)) in export_interfaces.iter() {
-            let ok = add_world_export(
-                resolve,
-                world,
-                export_interfaces,
-                &mut required_imports,
-                *id,
-                key,
-                true,
-            );
-            if !ok {
-                bail!(Error {
-                    // FIXME: this is not a great error message and basically no
-                    // one will know what to do when it gets printed. Improving
-                    // this error message, however, is a chunk of work that may
-                    // not be best spent doing this at this time, so I'm writing
-                    // this comment instead.
-                    //
-                    // More-or-less what should happen here is that a "path"
-                    // from this interface to the conflicting interface should
-                    // be printed. It should be explained why an import is being
-                    // injected, why that's conflicting with an export, and
-                    // ideally with a suggestion of "add this interface to the
-                    // export list to fix this error".
-                    //
-                    // That's a lot of info that's not easy to get at without
-                    // more refactoring, so it's left to a future date in the
-                    // hopes that most folks won't actually run into this for
-                    // the time being.
-                    msg: format!(
-                        "interface transitively depends on an interface in \
-                         incompatible ways",
-                    ),
-                    span: *span,
-                });
-            }
-        }
-        return Ok(());
-
-        fn add_world_export(
-            resolve: &Resolve,
-            world: &mut World,
-            export_interfaces: &IndexMap<InterfaceId, (WorldKey, Span)>,
-            required_imports: &mut HashSet<InterfaceId>,
-            id: InterfaceId,
-            key: &WorldKey,
-            add_export: bool,
-        ) -> bool {
-            if world.exports.contains_key(key) {
-                if add_export {
-                    return true;
-                } else {
-                    return false;
-                }
-            }
-            // If this is an import and it's already in the `required_imports`
-            // set then we can skip it as we've already visited this interface.
-            if !add_export && required_imports.contains(&id) {
-                return true;
-            }
-            let ok = foreach_interface_dep(resolve, id, |dep| {
-                let key = WorldKey::Interface(dep);
-                let add_export = add_export && export_interfaces.contains_key(&dep);
-                add_world_export(
-                    resolve,
-                    world,
-                    export_interfaces,
-                    required_imports,
-                    dep,
-                    &key,
-                    add_export,
-                )
-            });
-            if !ok {
-                return false;
-            }
-            if add_export {
-                if required_imports.contains(&id) {
-                    return false;
-                }
-                world.exports.insert(key.clone(), WorldItem::Interface(id));
-            } else {
-                required_imports.insert(id);
-                world.imports.insert(key.clone(), WorldItem::Interface(id));
-            }
-            true
-        }
-    }
-
-    fn resolve_include(
-        &self,
-        world: &mut World,
-        include_world: WorldId,
-        names: &[IncludeName],
-        span: Span,
-        resolve: &Resolve,
-    ) -> Result<()> {
-        let include_world_id = self.worlds[include_world.index()];
-        let include_world = &resolve.worlds[include_world_id];
-        let mut names_ = names.to_owned();
-
-        // remove all imports and exports that match the names we're including
-        for import in include_world.imports.iter() {
-            self.remove_matching_name(import, &mut names_);
-        }
-        for export in include_world.exports.iter() {
-            self.remove_matching_name(export, &mut names_);
-        }
-        if !names_.is_empty() {
-            bail!(Error {
-                msg: format!("no import or export kebab-name `{}`. Note that an ID does not support renaming", names_[0].name),
-                span: span,
-            });
-        }
-
-        // copy the imports and exports from the included world into the current world
-        for import in include_world.imports.iter() {
-            self.resolve_include_item(names, &mut world.imports, import, span, "import")?;
-        }
-
-        for export in include_world.exports.iter() {
-            self.resolve_include_item(names, &mut world.exports, export, span, "export")?;
+        for (_name, world) in doc.worlds.iter_mut() {
+            *world = self.worlds[world.index()];
         }
-        Ok(())
-    }
-
-    fn resolve_include_item(
-        &self,
-        names: &[IncludeName],
-        items: &mut IndexMap<WorldKey, WorldItem>,
-        item: (&WorldKey, &WorldItem),
-        span: Span,
-        item_type: &str,
-    ) -> Result<()> {
-        match item.0 {
-            WorldKey::Name(n) => {
-                let n = if let Some(found) = names
-                    .into_iter()
-                    .find(|include_name| include_name.name == n.clone())
-                {
-                    found.as_.clone()
-                } else {
-                    n.clone()
-                };
-
-                let prev = items.insert(WorldKey::Name(n.clone()), item.1.clone());
-                if prev.is_some() {
-                    bail!(Error {
-                        msg: format!("{item_type} of `{n}` shadows previously {item_type}ed items"),
-                        span,
-                    })
-                }
-            }
-            key => {
-                let prev = items.insert(key.clone(), item.1.clone());
-                if let Some(prev) = prev {
-                    assert_eq!(prev, item.1.clone());
-                }
-            }
-        };
-        Ok(())
-    }
-
-    fn remove_matching_name(&self, item: (&WorldKey, &WorldItem), names: &mut Vec<IncludeName>) {
-        match item.0 {
-            WorldKey::Name(n) => {
-                names.retain(|name| name.name != n.clone());
-            }
-            _ => {}
+        if let Some(default) = &mut doc.default_interface {
+            *default = self.interfaces[default.index()];
         }
-    }
-}
-
-fn foreach_interface_dep(
-    resolve: &Resolve,
-    interface: InterfaceId,
-    mut f: impl FnMut(InterfaceId) -> bool,
-) -> bool {
-    for (_, ty) in resolve.interfaces[interface].types.iter() {
-        let ty = match resolve.types[*ty].kind {
-            TypeDefKind::Type(Type::Id(id)) => id,
-            _ => continue,
-        };
-        let dep = match resolve.types[ty].owner {
-            TypeOwner::None => continue,
-            TypeOwner::Interface(other) => other,
-            TypeOwner::World(_) => unreachable!(),
-        };
-        if dep != interface {
-            if !f(dep) {
-                return false;
-            }
+        if let Some(default) = &mut doc.default_world {
+            *default = self.worlds[default.index()];
         }
     }
-    true
 }
 
-struct MergeMap<'a> {
-    /// A map of package ids in `from` to those in `into` for those that are
-    /// found to be equivalent.
-    package_map: HashMap<PackageId, PackageId>,
-
-    /// A map of interface ids in `from` to those in `into` for those that are
-    /// found to be equivalent.
-    interface_map: HashMap<InterfaceId, InterfaceId>,
-
-    /// A map of type ids in `from` to those in `into` for those that are
-    /// found to be equivalent.
-    type_map: HashMap<TypeId, TypeId>,
-
-    /// A map of world ids in `from` to those in `into` for those that are
-    /// found to be equivalent.
-    world_map: HashMap<WorldId, WorldId>,
-
-    /// A list of documents that need to be added to packages in `into`.
-    ///
-    /// The elements here are:
-    ///
-    /// * The name of the interface/world
-    /// * The ID within `into` of the package being added to
-    /// * The ID within `from` of the item being added.
-    interfaces_to_add: Vec<(String, PackageId, InterfaceId)>,
-    worlds_to_add: Vec<(String, PackageId, WorldId)>,
-
-    /// Which `Resolve` is being merged from.
-    from: &'a Resolve,
-
-    /// Which `Resolve` is being merged into.
-    into: &'a Resolve,
+struct WorldElaborator<'a, 'b> {
+    resolve: &'a Resolve,
+    world: &'b mut World,
+    explicit_import_names: &'a HashMap<InterfaceId, String>,
+    explicit_export_names: &'a HashMap<InterfaceId, String>,
+    names: HashMap<String, bool>,
+
+    /// Set of imports which are either imported into the world already or in
+    /// the `stack` to get processed, used to ensure the same dependency isn't
+    /// pushed multiple times into the stack.
+    imports_processed: HashSet<InterfaceId>,
+    exports_processed: HashSet<InterfaceId>,
+
+    /// Dependency chain of why we're importing the top of `stack`, used to
+    /// print an error message.
+    resolving_stack: Vec<(InterfaceId, bool)>,
 }
 
-impl<'a> MergeMap<'a> {
-    fn new(from: &'a Resolve, into: &'a Resolve) -> Result<MergeMap<'a>> {
-        Ok(MergeMap {
-            package_map: Default::default(),
-            interface_map: Default::default(),
-            type_map: Default::default(),
-            world_map: Default::default(),
-            interfaces_to_add: Default::default(),
-            worlds_to_add: Default::default(),
-            from,
-            into,
-        })
+impl<'a> WorldElaborator<'a, '_> {
+    fn import(&mut self, id: InterfaceId, span: Span) -> Result<()> {
+        self.recurse(id, span, true)
     }
 
-    fn build(&mut self) -> Result<()> {
-        for (from_id, from) in self.from.packages.iter() {
-            let into_id = match self.into.package_names.get(&from.name) {
-                Some(id) => *id,
-
-                // This package, according to its name and url, is not present
-                // in `self` so it needs to get added below.
-                None => {
-                    log::trace!("adding unique package {}", from.name);
-                    continue;
-                }
-            };
-            log::trace!("merging duplicate package {}", from.name);
-
-            self.build_package(from_id, into_id).with_context(|| {
-                format!("failed to merge package `{}` into existing copy", from.name)
-            })?;
-        }
-
-        Ok(())
+    fn export(&mut self, id: InterfaceId, span: Span) -> Result<()> {
+        self.recurse(id, span, false)
     }
 
-    fn build_package(&mut self, from_id: PackageId, into_id: PackageId) -> Result<()> {
-        let prev = self.package_map.insert(from_id, into_id);
-        assert!(prev.is_none());
-
-        let from = &self.from.packages[from_id];
-        let into = &self.into.packages[into_id];
-
-        // If an interface is present in `from_id` but not present in `into_id`
-        // then it can be copied over wholesale. That copy is scheduled to
-        // happen within the `self.interfaces_to_add` list.
-        for (name, from_interface_id) in from.interfaces.iter() {
-            let into_interface_id = match into.interfaces.get(name) {
-                Some(id) => *id,
-                None => {
-                    self.interfaces_to_add
-                        .push((name.clone(), into_id, *from_interface_id));
-                    continue;
-                }
-            };
-
-            self.build_interface(*from_interface_id, into_interface_id)
-                .with_context(|| format!("failed to merge interface `{name}`"))?;
+    fn recurse(&mut self, id: InterfaceId, span: Span, import: bool) -> Result<()> {
+        let processed = if import {
+            &mut self.imports_processed
+        } else {
+            &mut self.exports_processed
+        };
+        if !processed.insert(id) {
+            return Ok(());
         }
 
-        for (name, from_world_id) in from.worlds.iter() {
-            let into_world_id = match into.worlds.get(name) {
-                Some(id) => *id,
-                None => {
-                    self.worlds_to_add
-                        .push((name.clone(), into_id, *from_world_id));
-                    continue;
-                }
+        self.resolving_stack.push((id, import));
+        for (_, ty) in self.resolve.interfaces[id].types.iter() {
+            let ty = match self.resolve.types[*ty].kind {
+                TypeDefKind::Type(Type::Id(id)) => id,
+                _ => continue,
+            };
+            let dep = match self.resolve.types[ty].owner {
+                TypeOwner::None => continue,
+                TypeOwner::Interface(other) => other,
+                TypeOwner::World(_) => unreachable!(),
             };
+            let import = import || !self.explicit_export_names.contains_key(&dep);
 
-            self.build_world(*from_world_id, into_world_id)
-                .with_context(|| format!("failed to merge world `{name}`"))?;
+            self.recurse(dep, span, import)?;
         }
+        assert_eq!(self.resolving_stack.pop(), Some((id, import)));
 
-        Ok(())
-    }
-
-    fn build_interface(&mut self, from_id: InterfaceId, into_id: InterfaceId) -> Result<()> {
-        let prev = self.interface_map.insert(from_id, into_id);
-        assert!(prev.is_none());
+        let name = self.name_of(id, import);
+        let prev = self.names.insert(name.clone(), import);
 
-        let from_interface = &self.from.interfaces[from_id];
-        let into_interface = &self.into.interfaces[into_id];
-
-        // Unlike documents/interfaces above if an interface in `from`
-        // differs from the interface in `into` then that's considered an
-        // error. Changing interfaces can reflect changes in imports/exports
-        // which may not be expected so it's currently required that all
-        // interfaces, when merged, exactly match.
-        //
-        // One case to consider here, for example, is that if a world in
-        // `into` exports the interface `into_id` then if `from_id` were to
-        // add more items into `into` then it would unexpectedly require more
-        // items to be exported which may not work. In an import context this
-        // might work since it's "just more items available for import", but
-        // for now a conservative route of "interfaces must match" is taken.
-
-        for (name, from_type_id) in from_interface.types.iter() {
-            let into_type_id = *into_interface
-                .types
-                .get(name)
-                .ok_or_else(|| anyhow!("expected type `{name}` to be present"))?;
-            let prev = self.type_map.insert(*from_type_id, into_type_id);
+        if prev.is_none() {
+            let set = if import {
+                &mut self.world.imports
+            } else {
+                &mut self.world.exports
+            };
+            let prev = set.insert(name.clone(), WorldItem::Interface(id));
             assert!(prev.is_none());
-
-            // FIXME: ideally the types should be "structurally
-            // equal" but that's not trivial to do in the face of
-            // resources.
+            return Ok(());
         }
 
-        for (name, _) in from_interface.functions.iter() {
-            if !into_interface.functions.contains_key(name) {
-                bail!("expected function `{name}` to be present");
+        let desc = |import: bool| {
+            if import {
+                "import"
+            } else {
+                "export"
             }
+        };
 
-            // FIXME: ideally the functions should be "structurally
-            // equal" but that's not trivial to do in the face of
-            // resources.
-        }
-
-        Ok(())
-    }
-
-    fn build_world(&mut self, from_id: WorldId, into_id: WorldId) -> Result<()> {
-        let prev = self.world_map.insert(from_id, into_id);
-        assert!(prev.is_none());
-
-        let from_world = &self.from.worlds[from_id];
-        let into_world = &self.into.worlds[into_id];
-
-        // Same as interfaces worlds are expected to exactly match to avoid
-        // unexpectedly changing a particular component's view of imports and
-        // exports.
-        //
-        // FIXME: this should probably share functionality with
-        // `Resolve::merge_worlds` to support adding imports but not changing
-        // exports.
-
-        if from_world.imports.len() != into_world.imports.len() {
-            bail!("world contains different number of imports than expected");
-        }
-        if from_world.exports.len() != into_world.exports.len() {
-            bail!("world contains different number of exports than expected");
-        }
-
-        for (from_name, from) in from_world.imports.iter() {
-            let into_name = self.map_name(from_name);
-            let name_str = self.from.name_world_key(from_name);
-            let into = into_world
-                .imports
-                .get(&into_name)
-                .ok_or_else(|| anyhow!("import `{name_str}` not found in target world"))?;
-            self.match_world_item(from, into)
-                .with_context(|| format!("import `{name_str}` didn't match target world"))?;
-        }
-
-        for (from_name, from) in from_world.exports.iter() {
-            let into_name = self.map_name(from_name);
-            let name_str = self.from.name_world_key(from_name);
-            let into = into_world
-                .exports
-                .get(&into_name)
-                .ok_or_else(|| anyhow!("export `{name_str}` not found in target world"))?;
-            self.match_world_item(from, into)
-                .with_context(|| format!("export `{name_str}` didn't match target world"))?;
-        }
-
-        Ok(())
-    }
-
-    fn map_name(&self, from_name: &WorldKey) -> WorldKey {
-        match from_name {
-            WorldKey::Name(s) => WorldKey::Name(s.clone()),
-            WorldKey::Interface(id) => {
-                WorldKey::Interface(self.interface_map.get(id).copied().unwrap_or(*id))
-            }
-        }
+        let mut msg = format!("{} of `{}`", desc(import), self.name_of(id, import));
+        if self.resolving_stack.is_empty() {
+            msg.push_str(" ");
+        } else {
+            msg.push_str("\n");
+        }
+        for (i, import) in self.resolving_stack.iter().rev() {
+            writeln!(
+                msg,
+                "  .. which is depended on by {} `{}`",
+                desc(*import),
+                self.name_of(*i, *import)
+            )
+            .unwrap();
+        }
+        writeln!(
+            msg,
+            "conflicts with a previous interface using the name `{name}`",
+        )
+        .unwrap();
+        bail!(Error { span, msg })
     }
 
-    fn match_world_item(&mut self, from: &WorldItem, into: &WorldItem) -> Result<()> {
-        match (from, into) {
-            (WorldItem::Interface(from), WorldItem::Interface(into)) => {
-                match (
-                    &self.from.interfaces[*from].name,
-                    &self.into.interfaces[*into].name,
-                ) {
-                    // If one interface is unnamed then they must both be
-                    // unnamed and they must both have the same structure for
-                    // now.
-                    (None, None) => self.build_interface(*from, *into)?,
-
-                    // Otherwise both interfaces must be named and they must
-                    // have been previously found to be equivalent. Note that
-                    // if either is unnamed it won't be present in
-                    // `interface_map` so this'll return an error.
-                    _ => {
-                        if self.interface_map.get(&from) != Some(&into) {
-                            bail!("interfaces are not the same");
-                        }
-                    }
-                }
-            }
-            (WorldItem::Function(from), WorldItem::Function(into)) => {
-                let _ = (from, into);
-                // FIXME: should assert an check that `from` structurally
-                // matches `into`
-            }
-            (WorldItem::Type(from), WorldItem::Type(into)) => {
-                // FIXME: should assert an check that `from` structurally
-                // matches `into`
-                let prev = self.type_map.insert(*from, *into);
-                assert!(prev.is_none());
-            }
-
-            (WorldItem::Interface(_), _)
-            | (WorldItem::Function(_), _)
-            | (WorldItem::Type(_), _) => {
-                bail!("world items do not have the same type")
-            }
-        }
-        Ok(())
+    fn name_of(&self, id: InterfaceId, import: bool) -> &'a String {
+        let set = if import {
+            &self.explicit_import_names
+        } else {
+            &self.explicit_export_names
+        };
+        set.get(&id)
+            .unwrap_or_else(|| self.resolve.interfaces[id].name.as_ref().unwrap())
     }
 }
diff --git a/crates/wit-parser/src/sizealign.rs b/crates/wit-parser/src/sizealign.rs
index c82268ca..fe2052d7 100644
--- a/crates/wit-parser/src/sizealign.rs
+++ b/crates/wit-parser/src/sizealign.rs
@@ -30,15 +30,10 @@ impl SizeAlign {
             TypeDefKind::Option(t) => self.variant(Int::U8, [Some(t)]),
             TypeDefKind::Result(r) => self.variant(Int::U8, [r.ok.as_ref(), r.err.as_ref()]),
             TypeDefKind::Union(u) => self.variant(u.tag(), u.cases.iter().map(|c| Some(&c.ty))),
-            // A resource is represented as an index.
-            TypeDefKind::Handle(_) => (4, 4),
             // A future is represented as an index.
             TypeDefKind::Future(_) => (4, 4),
             // A stream is represented as an index.
             TypeDefKind::Stream(_) => (4, 4),
-            // This shouldn't be used for anything since raw resources aren't part of the ABI -- just handles to
-            // them.
-            TypeDefKind::Resource => (usize::MAX, usize::MAX),
             TypeDefKind::Unknown => unreachable!(),
         }
     }
diff --git a/crates/wit-parser/tests/all.rs b/crates/wit-parser/tests/all.rs
index c1c1132c..8e41fc5b 100644
--- a/crates/wit-parser/tests/all.rs
+++ b/crates/wit-parser/tests/all.rs
@@ -106,7 +106,7 @@ impl Runner<'_> {
         let result = if test.is_dir() {
             resolve.push_dir(test).map(|(id, _)| id)
         } else {
-            UnresolvedPackage::parse_file(test).and_then(|p| resolve.push(p))
+            UnresolvedPackage::parse_file(test).and_then(|p| resolve.push(p, &Default::default()))
         };
 
         let result = if test.iter().any(|s| s == "parse-fail") {
diff --git a/crates/wit-parser/tests/ui/comments.wit b/crates/wit-parser/tests/ui/comments.wit
index bb899d06..9b38918e 100644
--- a/crates/wit-parser/tests/ui/comments.wit
+++ b/crates/wit-parser/tests/ui/comments.wit
@@ -1,5 +1,3 @@
-package foo:comments
-
 // hello
 // world
 // why, yes
diff --git a/crates/wit-parser/tests/ui/complex-include/deps/bar/root.wit b/crates/wit-parser/tests/ui/complex-include/deps/bar/root.wit
deleted file mode 100644
index 1fa78730..00000000
--- a/crates/wit-parser/tests/ui/complex-include/deps/bar/root.wit
+++ /dev/null
@@ -1,9 +0,0 @@
-package foo:bar
-
-interface a {}
-interface b {}
-
-world bar-a {
-    import a
-    import b
-}
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/complex-include/deps/baz/root.wit b/crates/wit-parser/tests/ui/complex-include/deps/baz/root.wit
deleted file mode 100644
index 08662ebb..00000000
--- a/crates/wit-parser/tests/ui/complex-include/deps/baz/root.wit
+++ /dev/null
@@ -1,9 +0,0 @@
-package foo:baz
-
-interface a {}
-interface b {}
-
-world baz-a {
-    import a
-    import b
-}
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/complex-include/root.wit b/crates/wit-parser/tests/ui/complex-include/root.wit
deleted file mode 100644
index 4acf1145..00000000
--- a/crates/wit-parser/tests/ui/complex-include/root.wit
+++ /dev/null
@@ -1,26 +0,0 @@
-package foo:root
-
-interface ai {}
-interface bi {}
-
-world a {
-    import ai
-    import bi
-}
-
-world b {
-    include foo:bar/bar-a
-}
-
-world c {
-    include b
-    include foo:bar/bar-a
-}
-
-world union-world {
-    include a
-    include b
-    include c
-    include foo:bar/bar-a
-    include foo:baz/baz-a
-}
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/cross-package-resource/deps/foo/foo.wit b/crates/wit-parser/tests/ui/cross-package-resource/deps/foo/foo.wit
deleted file mode 100644
index ff24cb01..00000000
--- a/crates/wit-parser/tests/ui/cross-package-resource/deps/foo/foo.wit
+++ /dev/null
@@ -1,5 +0,0 @@
-package some:dep
-
-interface foo {
-  resource r
-}
diff --git a/crates/wit-parser/tests/ui/cross-package-resource/foo.wit b/crates/wit-parser/tests/ui/cross-package-resource/foo.wit
deleted file mode 100644
index bf2e3a89..00000000
--- a/crates/wit-parser/tests/ui/cross-package-resource/foo.wit
+++ /dev/null
@@ -1,7 +0,0 @@
-package foo:bar
-
-interface foo {
-  use some:dep/foo.{r}
-
-  type t = own<r>
-}
diff --git a/crates/wit-parser/tests/ui/diamond1/deps/dep1/types.wit b/crates/wit-parser/tests/ui/diamond1/deps/dep1/types.wit
deleted file mode 100644
index 9e7afb30..00000000
--- a/crates/wit-parser/tests/ui/diamond1/deps/dep1/types.wit
+++ /dev/null
@@ -1,2 +0,0 @@
-package foo:dep1
-interface types {}
diff --git a/crates/wit-parser/tests/ui/diamond1/deps/dep2/types.wit b/crates/wit-parser/tests/ui/diamond1/deps/dep2/types.wit
deleted file mode 100644
index 8825ffb0..00000000
--- a/crates/wit-parser/tests/ui/diamond1/deps/dep2/types.wit
+++ /dev/null
@@ -1,2 +0,0 @@
-package foo:dep2
-interface types {}
diff --git a/crates/wit-parser/tests/ui/diamond1/join.wit b/crates/wit-parser/tests/ui/diamond1/join.wit
deleted file mode 100644
index a6c4208f..00000000
--- a/crates/wit-parser/tests/ui/diamond1/join.wit
+++ /dev/null
@@ -1,6 +0,0 @@
-package foo:foo
-
-world foo {
-  import foo:dep1/types
-  import foo:dep2/types
-}
diff --git a/crates/wit-parser/tests/ui/disambiguate-diamond/shared1.wit b/crates/wit-parser/tests/ui/disambiguate-diamond/shared1.wit
index f655d9b0..e65165ac 100644
--- a/crates/wit-parser/tests/ui/disambiguate-diamond/shared1.wit
+++ b/crates/wit-parser/tests/ui/disambiguate-diamond/shared1.wit
@@ -1,3 +1,3 @@
-interface shared1 {
+default interface shared {
   type the-type = u32
 }
diff --git a/crates/wit-parser/tests/ui/disambiguate-diamond/shared2.wit b/crates/wit-parser/tests/ui/disambiguate-diamond/shared2.wit
index 4e191924..e65165ac 100644
--- a/crates/wit-parser/tests/ui/disambiguate-diamond/shared2.wit
+++ b/crates/wit-parser/tests/ui/disambiguate-diamond/shared2.wit
@@ -1,3 +1,3 @@
-interface shared2 {
+default interface shared {
   type the-type = u32
 }
diff --git a/crates/wit-parser/tests/ui/disambiguate-diamond/world.wit b/crates/wit-parser/tests/ui/disambiguate-diamond/world.wit
index f9021b73..80ab9be4 100644
--- a/crates/wit-parser/tests/ui/disambiguate-diamond/world.wit
+++ b/crates/wit-parser/tests/ui/disambiguate-diamond/world.wit
@@ -1,13 +1,11 @@
-package foo:diamond
-
 world foo {
   import foo: interface {
-    use shared1.{the-type}
+    use pkg.shared1.{the-type}
   }
   import bar: interface {
-    use shared2.{the-type}
+    use pkg.shared2.{the-type}
   }
 
-  import shared1
-  import shared2
+  import shared1: pkg.shared1
+  import shared2: pkg.shared2
 }
diff --git a/crates/wit-parser/tests/ui/embedded.wit.md b/crates/wit-parser/tests/ui/embedded.wit.md
index 4bfaa2a3..e9ea8591 100644
--- a/crates/wit-parser/tests/ui/embedded.wit.md
+++ b/crates/wit-parser/tests/ui/embedded.wit.md
@@ -3,8 +3,6 @@
 containing stuff, and also some code blocks, wit and other.
 
 ```wit
-package foo:foo
-
 interface foo {
 ```
 
diff --git a/crates/wit-parser/tests/ui/empty.wit b/crates/wit-parser/tests/ui/empty.wit
index cfc0ac5b..e69de29b 100644
--- a/crates/wit-parser/tests/ui/empty.wit
+++ b/crates/wit-parser/tests/ui/empty.wit
@@ -1 +0,0 @@
-package foo:empty
diff --git a/crates/wit-parser/tests/ui/foreign-deps-union/deps/another-pkg/other-doc.wit b/crates/wit-parser/tests/ui/foreign-deps-union/deps/another-pkg/other-doc.wit
deleted file mode 100644
index dc584c63..00000000
--- a/crates/wit-parser/tests/ui/foreign-deps-union/deps/another-pkg/other-doc.wit
+++ /dev/null
@@ -1,3 +0,0 @@
-package foo:another-pkg
-
-interface other-interface {}
diff --git a/crates/wit-parser/tests/ui/foreign-deps-union/deps/corp/saas.wit b/crates/wit-parser/tests/ui/foreign-deps-union/deps/corp/saas.wit
deleted file mode 100644
index f476b526..00000000
--- a/crates/wit-parser/tests/ui/foreign-deps-union/deps/corp/saas.wit
+++ /dev/null
@@ -1,4 +0,0 @@
-package foo:corp
-
-interface saas {
-}
diff --git a/crates/wit-parser/tests/ui/foreign-deps-union/deps/different-pkg/the-doc.wit b/crates/wit-parser/tests/ui/foreign-deps-union/deps/different-pkg/the-doc.wit
deleted file mode 100644
index ddeeab87..00000000
--- a/crates/wit-parser/tests/ui/foreign-deps-union/deps/different-pkg/the-doc.wit
+++ /dev/null
@@ -1,2 +0,0 @@
-package foo:different-pkg
-interface i {}
diff --git a/crates/wit-parser/tests/ui/foreign-deps-union/deps/foreign-pkg/the-doc.wit b/crates/wit-parser/tests/ui/foreign-deps-union/deps/foreign-pkg/the-doc.wit
deleted file mode 100644
index cba7a70e..00000000
--- a/crates/wit-parser/tests/ui/foreign-deps-union/deps/foreign-pkg/the-doc.wit
+++ /dev/null
@@ -1,5 +0,0 @@
-package foo:foreign-pkg
-
-interface the-default {
-  type some-type = u32
-}
diff --git a/crates/wit-parser/tests/ui/foreign-deps-union/deps/some-pkg/some-doc.wit b/crates/wit-parser/tests/ui/foreign-deps-union/deps/some-pkg/some-doc.wit
deleted file mode 100644
index 3bad202e..00000000
--- a/crates/wit-parser/tests/ui/foreign-deps-union/deps/some-pkg/some-doc.wit
+++ /dev/null
@@ -1,13 +0,0 @@
-package foo:some-pkg
-
-interface the-default {
-  type from-default = string
-}
-
-interface some-interface {
-  type another-type = u32
-}
-
-interface another-interface {
-  type yet-another-type = u8
-}
diff --git a/crates/wit-parser/tests/ui/foreign-deps-union/deps/wasi/clocks.wit b/crates/wit-parser/tests/ui/foreign-deps-union/deps/wasi/clocks.wit
deleted file mode 100644
index 0ea67674..00000000
--- a/crates/wit-parser/tests/ui/foreign-deps-union/deps/wasi/clocks.wit
+++ /dev/null
@@ -1,5 +0,0 @@
-package foo:wasi
-
-interface clocks {
-  type timestamp = u64
-}
diff --git a/crates/wit-parser/tests/ui/foreign-deps-union/deps/wasi/filesystem.wit b/crates/wit-parser/tests/ui/foreign-deps-union/deps/wasi/filesystem.wit
deleted file mode 100644
index 1ed63e3d..00000000
--- a/crates/wit-parser/tests/ui/foreign-deps-union/deps/wasi/filesystem.wit
+++ /dev/null
@@ -1,7 +0,0 @@
-package foo:wasi
-
-interface filesystem {
-  record stat {
-    ino: u64
-  }
-}
diff --git a/crates/wit-parser/tests/ui/foreign-deps-union/deps/wasi/wasi.wit b/crates/wit-parser/tests/ui/foreign-deps-union/deps/wasi/wasi.wit
deleted file mode 100644
index 09bcd3ca..00000000
--- a/crates/wit-parser/tests/ui/foreign-deps-union/deps/wasi/wasi.wit
+++ /dev/null
@@ -1,6 +0,0 @@
-package foo:wasi
-
-world wasi {
-    import filesystem
-    import clocks
-}
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/foreign-deps-union/root.wit b/crates/wit-parser/tests/ui/foreign-deps-union/root.wit
deleted file mode 100644
index 787cff09..00000000
--- a/crates/wit-parser/tests/ui/foreign-deps-union/root.wit
+++ /dev/null
@@ -1,50 +0,0 @@
-package foo:root
-
-interface foo {
-  use foo:wasi/clocks.{timestamp}
-  use foo:wasi/filesystem.{stat}
-}
-
-world my-world {
-  import foo:wasi/filesystem
-  import foo:wasi/clocks
-
-  export foo:corp/saas
-}
-
-use foo:wasi/filesystem as filesystem
-use foo:wasi/clocks as clocks
-
-world my-world2 {
-  import filesystem
-  import clocks
-  export foo
-  export foo:corp/saas
-}
-
-interface bar {
-  use filesystem.{}
-  use foo:some-pkg/the-default.{from-default}
-  use foo:some-pkg/some-interface.{another-type}
-  use foo:some-pkg/some-interface.{}
-  use foo:some-pkg/another-interface.{yet-another-type}
-  use foo:different-pkg/i.{}
-}
-
-world bars-world {
-  import foo:some-pkg/the-default
-  import foo:another-pkg/other-interface
-}
-
-interface use1 {
-  use foo:foreign-pkg/the-default.{some-type}
-}
-interface use2 {
-  use foo:foreign-pkg/the-default.{some-type}
-}
-
-world unionw-world {
-  include my-world
-  include my-world2
-  include foo:wasi/wasi
-}
diff --git a/crates/wit-parser/tests/ui/foreign-deps/deps/another-pkg/other-doc.wit b/crates/wit-parser/tests/ui/foreign-deps/deps/another-pkg/other-doc.wit
index dc584c63..04933294 100644
--- a/crates/wit-parser/tests/ui/foreign-deps/deps/another-pkg/other-doc.wit
+++ b/crates/wit-parser/tests/ui/foreign-deps/deps/another-pkg/other-doc.wit
@@ -1,3 +1 @@
-package foo:another-pkg
-
 interface other-interface {}
diff --git a/crates/wit-parser/tests/ui/foreign-deps/deps/corp/saas.wit b/crates/wit-parser/tests/ui/foreign-deps/deps/corp/saas.wit
index f476b526..5a2b10d0 100644
--- a/crates/wit-parser/tests/ui/foreign-deps/deps/corp/saas.wit
+++ b/crates/wit-parser/tests/ui/foreign-deps/deps/corp/saas.wit
@@ -1,4 +1,2 @@
-package foo:corp
-
-interface saas {
+default interface saas {
 }
diff --git a/crates/wit-parser/tests/ui/foreign-deps/deps/different-pkg/the-doc.wit b/crates/wit-parser/tests/ui/foreign-deps/deps/different-pkg/the-doc.wit
index ddeeab87..f192837f 100644
--- a/crates/wit-parser/tests/ui/foreign-deps/deps/different-pkg/the-doc.wit
+++ b/crates/wit-parser/tests/ui/foreign-deps/deps/different-pkg/the-doc.wit
@@ -1,2 +1 @@
-package foo:different-pkg
-interface i {}
+default interface i {}
diff --git a/crates/wit-parser/tests/ui/foreign-deps/deps/foreign-pkg/the-doc.wit b/crates/wit-parser/tests/ui/foreign-deps/deps/foreign-pkg/the-doc.wit
index cba7a70e..1fb9bad8 100644
--- a/crates/wit-parser/tests/ui/foreign-deps/deps/foreign-pkg/the-doc.wit
+++ b/crates/wit-parser/tests/ui/foreign-deps/deps/foreign-pkg/the-doc.wit
@@ -1,5 +1,3 @@
-package foo:foreign-pkg
-
-interface the-default {
+default interface the-default {
   type some-type = u32
 }
diff --git a/crates/wit-parser/tests/ui/foreign-deps/deps/some-pkg/some-doc.wit b/crates/wit-parser/tests/ui/foreign-deps/deps/some-pkg/some-doc.wit
index 3bad202e..8228c1d6 100644
--- a/crates/wit-parser/tests/ui/foreign-deps/deps/some-pkg/some-doc.wit
+++ b/crates/wit-parser/tests/ui/foreign-deps/deps/some-pkg/some-doc.wit
@@ -1,6 +1,4 @@
-package foo:some-pkg
-
-interface the-default {
+default interface the-default {
   type from-default = string
 }
 
diff --git a/crates/wit-parser/tests/ui/foreign-deps/deps/wasi/clocks.wit b/crates/wit-parser/tests/ui/foreign-deps/deps/wasi/clocks.wit
index 0ea67674..18a35756 100644
--- a/crates/wit-parser/tests/ui/foreign-deps/deps/wasi/clocks.wit
+++ b/crates/wit-parser/tests/ui/foreign-deps/deps/wasi/clocks.wit
@@ -1,5 +1,3 @@
-package foo:wasi
-
-interface clocks {
+default interface wasi-clocks {
   type timestamp = u64
 }
diff --git a/crates/wit-parser/tests/ui/foreign-deps/deps/wasi/filesystem.wit b/crates/wit-parser/tests/ui/foreign-deps/deps/wasi/filesystem.wit
index 1ed63e3d..b0a97a6c 100644
--- a/crates/wit-parser/tests/ui/foreign-deps/deps/wasi/filesystem.wit
+++ b/crates/wit-parser/tests/ui/foreign-deps/deps/wasi/filesystem.wit
@@ -1,6 +1,4 @@
-package foo:wasi
-
-interface filesystem {
+default interface wasi-filesystem {
   record stat {
     ino: u64
   }
diff --git a/crates/wit-parser/tests/ui/foreign-deps/root.wit b/crates/wit-parser/tests/ui/foreign-deps/root.wit
index 557cbda2..d2325e85 100644
--- a/crates/wit-parser/tests/ui/foreign-deps/root.wit
+++ b/crates/wit-parser/tests/ui/foreign-deps/root.wit
@@ -1,44 +1,31 @@
-package foo:root
-
 interface foo {
-  use foo:wasi/clocks.{timestamp}
-  use foo:wasi/filesystem.{stat}
+  use wasi.clocks.{timestamp}
+  use wasi.filesystem.{stat}
 }
 
 world my-world {
-  import foo:wasi/filesystem
-  import foo:wasi/clocks
-
-  export foo:corp/saas
-}
-
-use foo:wasi/filesystem as filesystem
-use foo:wasi/clocks as clocks
+  import wasi-fs: wasi.filesystem
+  import wasi-clocks: wasi.clocks
 
-world my-world2 {
-  import filesystem
-  import clocks
-  export foo
-  export foo:corp/saas
+  export saas: corp.saas
 }
 
 interface bar {
-  use filesystem.{}
-  use foo:some-pkg/the-default.{from-default}
-  use foo:some-pkg/some-interface.{another-type}
-  use foo:some-pkg/some-interface.{}
-  use foo:some-pkg/another-interface.{yet-another-type}
-  use foo:different-pkg/i.{}
+  use some-pkg.some-doc.{from-default}
+  use some-pkg.some-doc.some-interface.{another-type}
+  use some-pkg.some-doc.some-interface.{}
+  use some-pkg.some-doc.another-interface.{yet-another-type}
+  use different-pkg.the-doc.{}
 }
 
 world bars-world {
-  import foo:some-pkg/the-default
-  import foo:another-pkg/other-interface
+  import foo: some-pkg.some-doc
+  import bar: another-pkg.other-doc.other-interface
 }
 
 interface use1 {
-  use foo:foreign-pkg/the-default.{some-type}
+  use foreign-pkg.the-doc.{some-type}
 }
 interface use2 {
-  use foo:foreign-pkg/the-default.{some-type}
+  use foreign-pkg.the-doc.{some-type}
 }
diff --git a/crates/wit-parser/tests/ui/functions.wit b/crates/wit-parser/tests/ui/functions.wit
index b08183a9..4ff518ac 100644
--- a/crates/wit-parser/tests/ui/functions.wit
+++ b/crates/wit-parser/tests/ui/functions.wit
@@ -1,5 +1,3 @@
-package foo:functions
-
 interface functions {
   f1: func()
   f2: func(a: u32)
diff --git a/crates/wit-parser/tests/ui/ignore-files-deps/deps/bar/types.wit b/crates/wit-parser/tests/ui/ignore-files-deps/deps/bar/types.wit
deleted file mode 100644
index 22d08739..00000000
--- a/crates/wit-parser/tests/ui/ignore-files-deps/deps/bar/types.wit
+++ /dev/null
@@ -1,2 +0,0 @@
-package foo:bar
-interface types {}
diff --git a/crates/wit-parser/tests/ui/ignore-files-deps/deps/ignore-me.txt b/crates/wit-parser/tests/ui/ignore-files-deps/deps/ignore-me.txt
deleted file mode 100644
index 48a897f5..00000000
--- a/crates/wit-parser/tests/ui/ignore-files-deps/deps/ignore-me.txt
+++ /dev/null
@@ -1 +0,0 @@
-this file should be ignored by the parser
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/ignore-files-deps/world.wit b/crates/wit-parser/tests/ui/ignore-files-deps/world.wit
deleted file mode 100644
index 8b51988f..00000000
--- a/crates/wit-parser/tests/ui/ignore-files-deps/world.wit
+++ /dev/null
@@ -1,5 +0,0 @@
-package foo:foo
-
-world foo {
-  import foo:bar/types
-}
diff --git a/crates/wit-parser/tests/ui/include-reps.wit b/crates/wit-parser/tests/ui/include-reps.wit
deleted file mode 100644
index 20717302..00000000
--- a/crates/wit-parser/tests/ui/include-reps.wit
+++ /dev/null
@@ -1,15 +0,0 @@
-package foo:foo
-
-interface a {}
-interface b {}
-
-world bar {
-    import a
-    export b
-}
-
-world foo {
-  include bar
-  include bar
-  include bar
-}
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/kebab-name-include-with.wit b/crates/wit-parser/tests/ui/kebab-name-include-with.wit
deleted file mode 100644
index 08a35f02..00000000
--- a/crates/wit-parser/tests/ui/kebab-name-include-with.wit
+++ /dev/null
@@ -1,8 +0,0 @@
-package foo:foo
-
-world foo { import a: func() }
-world bar { import a: func() }
-world baz { 
-    include foo with { a as b }
-    include bar
-}
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/many-names/a.wit b/crates/wit-parser/tests/ui/many-names/a.wit
deleted file mode 100644
index e3f9eab0..00000000
--- a/crates/wit-parser/tests/ui/many-names/a.wit
+++ /dev/null
@@ -1,2 +0,0 @@
-interface x {}
-use x as name
diff --git a/crates/wit-parser/tests/ui/many-names/b.wit b/crates/wit-parser/tests/ui/many-names/b.wit
deleted file mode 100644
index b603f176..00000000
--- a/crates/wit-parser/tests/ui/many-names/b.wit
+++ /dev/null
@@ -1,5 +0,0 @@
-package foo:name
-
-world name {
-  import name: interface {}
-}
diff --git a/crates/wit-parser/tests/ui/multi-file/bar.wit b/crates/wit-parser/tests/ui/multi-file/bar.wit
index 67f33432..9946d4ba 100644
--- a/crates/wit-parser/tests/ui/multi-file/bar.wit
+++ b/crates/wit-parser/tests/ui/multi-file/bar.wit
@@ -1,11 +1,9 @@
-package foo:multi-file
-
-interface irrelevant-name {
+default interface irrelevant-name {
   record a-name {}
 }
 
 interface depends-on-later-item {
-  use depend-on-me.{x}
+  use self.depend-on-me.{x}
 }
 
 interface depend-on-me {
@@ -13,8 +11,8 @@ interface depend-on-me {
 }
 
 world more-depends-on-later-things {
-  import later-interface
-  export later-interface
+  import foo: self.later-interface
+  export bar: self.later-interface
 }
 
 interface later-interface {
diff --git a/crates/wit-parser/tests/ui/multi-file/cycle-a.wit b/crates/wit-parser/tests/ui/multi-file/cycle-a.wit
deleted file mode 100644
index 559ee392..00000000
--- a/crates/wit-parser/tests/ui/multi-file/cycle-a.wit
+++ /dev/null
@@ -1,7 +0,0 @@
-interface cycle1 {
-  type t = u32
-}
-
-interface cycle3 {
-  use cycle2.{t}
-}
diff --git a/crates/wit-parser/tests/ui/multi-file/cycle-b.wit b/crates/wit-parser/tests/ui/multi-file/cycle-b.wit
deleted file mode 100644
index 85f26129..00000000
--- a/crates/wit-parser/tests/ui/multi-file/cycle-b.wit
+++ /dev/null
@@ -1,3 +0,0 @@
-interface cycle2 {
-  use cycle1.{t}
-}
diff --git a/crates/wit-parser/tests/ui/multi-file/foo.wit b/crates/wit-parser/tests/ui/multi-file/foo.wit
index 7992d2ef..cf9e621b 100644
--- a/crates/wit-parser/tests/ui/multi-file/foo.wit
+++ b/crates/wit-parser/tests/ui/multi-file/foo.wit
@@ -1,31 +1,15 @@
-package foo:multi-file
-
 interface foo {
   type x = u32
 }
 
-use foo as foo2
-
-interface something-else {
+default interface something-else {
   type y = u64
 }
 
-use depend-on-me as a-different-name
-
 interface bar {
-  use foo.{x}
-  use foo.{x as x2}
-  use foo2.{x as x3}
-  use a-different-name.{x as x4}
-  use something-else.{y}
-  use something-else.{y as y2}
-  use irrelevant-name.{a-name}
-}
-
-world the-world {
-  import a-different-name
-
-  use a-different-name.{x}
-
-  import foo: func() -> x
+  use self.foo.{x}
+  use pkg.foo.foo.{x as x2}
+  use pkg.foo.{y}
+  use self.something-else.{y as y2}
+  use pkg.bar.{a-name}
 }
diff --git a/crates/wit-parser/tests/ui/name-both-resource-and-type/deps/dep/foo.wit b/crates/wit-parser/tests/ui/name-both-resource-and-type/deps/dep/foo.wit
deleted file mode 100644
index 50e5e97b..00000000
--- a/crates/wit-parser/tests/ui/name-both-resource-and-type/deps/dep/foo.wit
+++ /dev/null
@@ -1,5 +0,0 @@
-package some:dep
-
-interface foo {
-  resource a
-}
diff --git a/crates/wit-parser/tests/ui/name-both-resource-and-type/foo.wit b/crates/wit-parser/tests/ui/name-both-resource-and-type/foo.wit
deleted file mode 100644
index fa617495..00000000
--- a/crates/wit-parser/tests/ui/name-both-resource-and-type/foo.wit
+++ /dev/null
@@ -1,9 +0,0 @@
-package foo:bar
-
-interface foo {
-  use some:dep/foo.{a}
-
-  type t1 = a
-  type t2 = borrow<a>
-  type t3 = borrow<t1>
-}
diff --git a/crates/wit-parser/tests/ui/package-syntax1.wit b/crates/wit-parser/tests/ui/package-syntax1.wit
deleted file mode 100644
index 5a649110..00000000
--- a/crates/wit-parser/tests/ui/package-syntax1.wit
+++ /dev/null
@@ -1 +0,0 @@
-package foo:foo
diff --git a/crates/wit-parser/tests/ui/package-syntax3.wit b/crates/wit-parser/tests/ui/package-syntax3.wit
deleted file mode 100644
index 4e7ea6c5..00000000
--- a/crates/wit-parser/tests/ui/package-syntax3.wit
+++ /dev/null
@@ -1 +0,0 @@
-package foo:bar
diff --git a/crates/wit-parser/tests/ui/package-syntax4.wit b/crates/wit-parser/tests/ui/package-syntax4.wit
deleted file mode 100644
index 08a4d024..00000000
--- a/crates/wit-parser/tests/ui/package-syntax4.wit
+++ /dev/null
@@ -1 +0,0 @@
-package foo:bar@2.0.0
diff --git a/crates/wit-parser/tests/ui/parse-fail/alias-no-type.wit.result b/crates/wit-parser/tests/ui/parse-fail/alias-no-type.wit.result
index d25b316c..6b9c20d9 100644
--- a/crates/wit-parser/tests/ui/parse-fail/alias-no-type.wit.result
+++ b/crates/wit-parser/tests/ui/parse-fail/alias-no-type.wit.result
@@ -1 +1,5 @@
-no `package` header was found in any WIT file for this package
\ No newline at end of file
+type `bar` does not exist
+     --> tests/ui/parse-fail/alias-no-type.wit:3:14
+      |
+    3 |   type foo = bar
+      |              ^--
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/bad-diamond.wit.result b/crates/wit-parser/tests/ui/parse-fail/bad-diamond.wit.result
new file mode 100644
index 00000000..71c65721
--- /dev/null
+++ b/crates/wit-parser/tests/ui/parse-fail/bad-diamond.wit.result
@@ -0,0 +1,8 @@
+import of `shared`
+  .. which is depended on by import `b`
+conflicts with a previous interface using the name `shared`
+
+     --> tests/ui/parse-fail/bad-diamond/join.wit:3:10
+      |
+    3 |   import b: pkg.b
+      |          ^
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/bad-diamond/a.wit b/crates/wit-parser/tests/ui/parse-fail/bad-diamond/a.wit
new file mode 100644
index 00000000..0c33f977
--- /dev/null
+++ b/crates/wit-parser/tests/ui/parse-fail/bad-diamond/a.wit
@@ -0,0 +1,9 @@
+interface shared {
+  type foo = u32
+}
+
+default interface a {
+  use self.shared.{foo}
+
+  a: func() -> foo
+}
diff --git a/crates/wit-parser/tests/ui/parse-fail/bad-diamond/b.wit b/crates/wit-parser/tests/ui/parse-fail/bad-diamond/b.wit
new file mode 100644
index 00000000..3aeda1af
--- /dev/null
+++ b/crates/wit-parser/tests/ui/parse-fail/bad-diamond/b.wit
@@ -0,0 +1,9 @@
+interface shared {
+  type foo = u32
+}
+
+default interface b {
+  use self.shared.{foo}
+
+  a: func() -> foo
+}
diff --git a/crates/wit-parser/tests/ui/parse-fail/bad-diamond/join.wit b/crates/wit-parser/tests/ui/parse-fail/bad-diamond/join.wit
new file mode 100644
index 00000000..289cf6df
--- /dev/null
+++ b/crates/wit-parser/tests/ui/parse-fail/bad-diamond/join.wit
@@ -0,0 +1,4 @@
+world foo {
+  import a: pkg.a
+  import b: pkg.b
+}
diff --git a/crates/wit-parser/tests/ui/parse-fail/bad-function.wit b/crates/wit-parser/tests/ui/parse-fail/bad-function.wit
index 2c25621b..202abb5a 100644
--- a/crates/wit-parser/tests/ui/parse-fail/bad-function.wit
+++ b/crates/wit-parser/tests/ui/parse-fail/bad-function.wit
@@ -1,7 +1,5 @@
 // parse-fail
 
-package foo:foo
-
 interface foo {
   x: func(param: nonexistent)
 }
diff --git a/crates/wit-parser/tests/ui/parse-fail/bad-function.wit.result b/crates/wit-parser/tests/ui/parse-fail/bad-function.wit.result
index 79120745..a5c199de 100644
--- a/crates/wit-parser/tests/ui/parse-fail/bad-function.wit.result
+++ b/crates/wit-parser/tests/ui/parse-fail/bad-function.wit.result
@@ -1,5 +1,5 @@
 name `nonexistent` is not defined
-     --> tests/ui/parse-fail/bad-function.wit:6:18
+     --> tests/ui/parse-fail/bad-function.wit:4:18
       |
-    6 |   x: func(param: nonexistent)
+    4 |   x: func(param: nonexistent)
       |                  ^----------
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/bad-function2.wit b/crates/wit-parser/tests/ui/parse-fail/bad-function2.wit
index ed121e28..c80e3e67 100644
--- a/crates/wit-parser/tests/ui/parse-fail/bad-function2.wit
+++ b/crates/wit-parser/tests/ui/parse-fail/bad-function2.wit
@@ -1,7 +1,5 @@
 // parse-fail
 
-package foo:foo
-
 interface foo {
   x: func() -> nonexistent
 }
diff --git a/crates/wit-parser/tests/ui/parse-fail/bad-function2.wit.result b/crates/wit-parser/tests/ui/parse-fail/bad-function2.wit.result
index 910a88f4..e2ea68da 100644
--- a/crates/wit-parser/tests/ui/parse-fail/bad-function2.wit.result
+++ b/crates/wit-parser/tests/ui/parse-fail/bad-function2.wit.result
@@ -1,5 +1,5 @@
 name `nonexistent` is not defined
-     --> tests/ui/parse-fail/bad-function2.wit:6:16
+     --> tests/ui/parse-fail/bad-function2.wit:4:16
       |
-    6 |   x: func() -> nonexistent
+    4 |   x: func() -> nonexistent
       |                ^----------
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/bad-include1.wit b/crates/wit-parser/tests/ui/parse-fail/bad-include1.wit
deleted file mode 100644
index 555ee0fd..00000000
--- a/crates/wit-parser/tests/ui/parse-fail/bad-include1.wit
+++ /dev/null
@@ -1,5 +0,0 @@
-package foo:foo
-
-world foo {
-  include non-existance
-}
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/bad-include1.wit.result b/crates/wit-parser/tests/ui/parse-fail/bad-include1.wit.result
deleted file mode 100644
index 76aff050..00000000
--- a/crates/wit-parser/tests/ui/parse-fail/bad-include1.wit.result
+++ /dev/null
@@ -1,5 +0,0 @@
-interface or world `non-existance` not found in package
-     --> tests/ui/parse-fail/bad-include1.wit:4:11
-      |
-    4 |   include non-existance
-      |           ^------------
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/bad-include2.wit b/crates/wit-parser/tests/ui/parse-fail/bad-include2.wit
deleted file mode 100644
index 5b5aff80..00000000
--- a/crates/wit-parser/tests/ui/parse-fail/bad-include2.wit
+++ /dev/null
@@ -1,9 +0,0 @@
-package foo:foo
-
-world bar {
-    include foo
-}
-
-world foo {
-    include bar
-}
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/bad-include2.wit.result b/crates/wit-parser/tests/ui/parse-fail/bad-include2.wit.result
deleted file mode 100644
index 7ccd0180..00000000
--- a/crates/wit-parser/tests/ui/parse-fail/bad-include2.wit.result
+++ /dev/null
@@ -1,5 +0,0 @@
-interface or world `foo` depends on itself
-     --> tests/ui/parse-fail/bad-include2.wit:7:7
-      |
-    7 | world foo {
-      |       ^--
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/bad-include3.wit b/crates/wit-parser/tests/ui/parse-fail/bad-include3.wit
deleted file mode 100644
index 3503ac5f..00000000
--- a/crates/wit-parser/tests/ui/parse-fail/bad-include3.wit
+++ /dev/null
@@ -1,5 +0,0 @@
-package foo:foo
-
-world foo {
-  include foo
-}
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/bad-include3.wit.result b/crates/wit-parser/tests/ui/parse-fail/bad-include3.wit.result
deleted file mode 100644
index 2ced2f67..00000000
--- a/crates/wit-parser/tests/ui/parse-fail/bad-include3.wit.result
+++ /dev/null
@@ -1,5 +0,0 @@
-interface or world `foo` depends on itself
-     --> tests/ui/parse-fail/bad-include3.wit:3:7
-      |
-    3 | world foo {
-      |       ^--
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/bad-pkg1.wit.result b/crates/wit-parser/tests/ui/parse-fail/bad-pkg1.wit.result
index 04611d28..b55b5e36 100644
--- a/crates/wit-parser/tests/ui/parse-fail/bad-pkg1.wit.result
+++ b/crates/wit-parser/tests/ui/parse-fail/bad-pkg1.wit.result
@@ -1,8 +1,5 @@
-failed to parse package: tests/ui/parse-fail/bad-pkg1
-
-Caused by:
-    interface or world `nonexistent` not found in package
-         --> tests/ui/parse-fail/bad-pkg1/root.wit:4:7
-          |
-        4 |   use nonexistent.{}
-          |       ^----------
\ No newline at end of file
+dependency on `nonexistent` doesn't exist at: tests/ui/parse-fail/bad-pkg1/deps/nonexistent
+     --> tests/ui/parse-fail/bad-pkg1/root.wit:2:7
+      |
+    2 |   use nonexistent.foo.{}
+      |       ^----------
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/bad-pkg1/root.wit b/crates/wit-parser/tests/ui/parse-fail/bad-pkg1/root.wit
index b93a1249..7b0d8a0f 100644
--- a/crates/wit-parser/tests/ui/parse-fail/bad-pkg1/root.wit
+++ b/crates/wit-parser/tests/ui/parse-fail/bad-pkg1/root.wit
@@ -1,5 +1,3 @@
-package foo:foo
-
 interface foo {
-  use nonexistent.{}
+  use nonexistent.foo.{}
 }
diff --git a/crates/wit-parser/tests/ui/parse-fail/bad-pkg2.wit.result b/crates/wit-parser/tests/ui/parse-fail/bad-pkg2.wit.result
index 8b7201ea..9cd96bd7 100644
--- a/crates/wit-parser/tests/ui/parse-fail/bad-pkg2.wit.result
+++ b/crates/wit-parser/tests/ui/parse-fail/bad-pkg2.wit.result
@@ -1,5 +1,5 @@
-interface not found in package
-     --> tests/ui/parse-fail/bad-pkg2/root.wit:4:15
+package `bar` does not define document `nonexistent`
+     --> tests/ui/parse-fail/bad-pkg2/root.wit:2:11
       |
-    4 |   use foo:bar/nonexistent.{}
-      |               ^----------
\ No newline at end of file
+    2 |   use bar.nonexistent.{}
+      |           ^----------
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/non-existance-world-include/deps/bar/.gitkeep b/crates/wit-parser/tests/ui/parse-fail/bad-pkg2/deps/bar/.gitkeep
similarity index 100%
rename from crates/wit-parser/tests/ui/parse-fail/non-existance-world-include/deps/bar/.gitkeep
rename to crates/wit-parser/tests/ui/parse-fail/bad-pkg2/deps/bar/.gitkeep
diff --git a/crates/wit-parser/tests/ui/parse-fail/bad-pkg2/deps/bar/empty.wit b/crates/wit-parser/tests/ui/parse-fail/bad-pkg2/deps/bar/empty.wit
deleted file mode 100644
index 4e7ea6c5..00000000
--- a/crates/wit-parser/tests/ui/parse-fail/bad-pkg2/deps/bar/empty.wit
+++ /dev/null
@@ -1 +0,0 @@
-package foo:bar
diff --git a/crates/wit-parser/tests/ui/parse-fail/bad-pkg2/root.wit b/crates/wit-parser/tests/ui/parse-fail/bad-pkg2/root.wit
index eb653b44..eee96640 100644
--- a/crates/wit-parser/tests/ui/parse-fail/bad-pkg2/root.wit
+++ b/crates/wit-parser/tests/ui/parse-fail/bad-pkg2/root.wit
@@ -1,5 +1,3 @@
-package foo:foo
-
 interface foo {
-  use foo:bar/nonexistent.{}
+  use bar.nonexistent.{}
 }
diff --git a/crates/wit-parser/tests/ui/parse-fail/bad-pkg3.wit.result b/crates/wit-parser/tests/ui/parse-fail/bad-pkg3.wit.result
index f2e6683b..432a7dff 100644
--- a/crates/wit-parser/tests/ui/parse-fail/bad-pkg3.wit.result
+++ b/crates/wit-parser/tests/ui/parse-fail/bad-pkg3.wit.result
@@ -1,5 +1,5 @@
-interface not found in package
-     --> tests/ui/parse-fail/bad-pkg3/root.wit:4:15
+default interface not specified in document
+     --> tests/ui/parse-fail/bad-pkg3/root.wit:2:11
       |
-    4 |   use foo:bar/baz.{}
-      |               ^--
\ No newline at end of file
+    2 |   use bar.baz.{}
+      |           ^--
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/bad-pkg3/deps/bar/baz.wit b/crates/wit-parser/tests/ui/parse-fail/bad-pkg3/deps/bar/baz.wit
index 80ffc36d..e69de29b 100644
--- a/crates/wit-parser/tests/ui/parse-fail/bad-pkg3/deps/bar/baz.wit
+++ b/crates/wit-parser/tests/ui/parse-fail/bad-pkg3/deps/bar/baz.wit
@@ -1,2 +0,0 @@
-package foo:bar
-world baz {}
diff --git a/crates/wit-parser/tests/ui/parse-fail/bad-pkg3/root.wit b/crates/wit-parser/tests/ui/parse-fail/bad-pkg3/root.wit
index 7c76fc54..5bc31123 100644
--- a/crates/wit-parser/tests/ui/parse-fail/bad-pkg3/root.wit
+++ b/crates/wit-parser/tests/ui/parse-fail/bad-pkg3/root.wit
@@ -1,5 +1,3 @@
-package foo:foo
-
 interface foo {
-  use foo:bar/baz.{}
+  use bar.baz.{}
 }
diff --git a/crates/wit-parser/tests/ui/parse-fail/bad-pkg4.wit.result b/crates/wit-parser/tests/ui/parse-fail/bad-pkg4.wit.result
index 3657cd14..cdf2fba8 100644
--- a/crates/wit-parser/tests/ui/parse-fail/bad-pkg4.wit.result
+++ b/crates/wit-parser/tests/ui/parse-fail/bad-pkg4.wit.result
@@ -1,5 +1,5 @@
-type `a-name` not defined in interface
-     --> tests/ui/parse-fail/bad-pkg4/root.wit:3:20
+type not defined in interface
+     --> tests/ui/parse-fail/bad-pkg4/root.wit:2:16
       |
-    3 |   use foo:bar/baz.{a-name}
-      |                    ^-----
\ No newline at end of file
+    2 |   use bar.baz.{a-name}
+      |                ^-----
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/bad-pkg4/deps/bar/baz.wit b/crates/wit-parser/tests/ui/parse-fail/bad-pkg4/deps/bar/baz.wit
index 239ac3bd..baa21857 100644
--- a/crates/wit-parser/tests/ui/parse-fail/bad-pkg4/deps/bar/baz.wit
+++ b/crates/wit-parser/tests/ui/parse-fail/bad-pkg4/deps/bar/baz.wit
@@ -1,4 +1,3 @@
-package foo:bar
-interface baz {
+default interface irrelevant-name {
   a-name: func()
 }
diff --git a/crates/wit-parser/tests/ui/parse-fail/bad-pkg4/root.wit b/crates/wit-parser/tests/ui/parse-fail/bad-pkg4/root.wit
index 5de0ff6b..f1af5052 100644
--- a/crates/wit-parser/tests/ui/parse-fail/bad-pkg4/root.wit
+++ b/crates/wit-parser/tests/ui/parse-fail/bad-pkg4/root.wit
@@ -1,4 +1,3 @@
-package foo:foo
 interface foo {
-  use foo:bar/baz.{a-name}
+  use bar.baz.{a-name}
 }
diff --git a/crates/wit-parser/tests/ui/parse-fail/bad-pkg5.wit.result b/crates/wit-parser/tests/ui/parse-fail/bad-pkg5.wit.result
index 500d74cf..da07d927 100644
--- a/crates/wit-parser/tests/ui/parse-fail/bad-pkg5.wit.result
+++ b/crates/wit-parser/tests/ui/parse-fail/bad-pkg5.wit.result
@@ -1,5 +1,5 @@
-type `nonexistent` not defined in interface
-     --> tests/ui/parse-fail/bad-pkg5/root.wit:3:20
+type not defined in interface
+     --> tests/ui/parse-fail/bad-pkg5/root.wit:2:16
       |
-    3 |   use foo:bar/baz.{nonexistent}
-      |                    ^----------
\ No newline at end of file
+    2 |   use bar.baz.{nonexistent}
+      |                ^----------
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/bad-pkg5/deps/bar/baz.wit b/crates/wit-parser/tests/ui/parse-fail/bad-pkg5/deps/bar/baz.wit
index 6bdda5bb..65ffc3ac 100644
--- a/crates/wit-parser/tests/ui/parse-fail/bad-pkg5/deps/bar/baz.wit
+++ b/crates/wit-parser/tests/ui/parse-fail/bad-pkg5/deps/bar/baz.wit
@@ -1,3 +1,2 @@
-package foo:bar
-interface baz {
+default interface irrelevant-name {
 }
diff --git a/crates/wit-parser/tests/ui/parse-fail/bad-pkg5/root.wit b/crates/wit-parser/tests/ui/parse-fail/bad-pkg5/root.wit
index f4d8ea56..0f19c0cc 100644
--- a/crates/wit-parser/tests/ui/parse-fail/bad-pkg5/root.wit
+++ b/crates/wit-parser/tests/ui/parse-fail/bad-pkg5/root.wit
@@ -1,4 +1,3 @@
-package foo:foo
 interface foo {
-  use foo:bar/baz.{nonexistent}
+  use bar.baz.{nonexistent}
 }
diff --git a/crates/wit-parser/tests/ui/parse-fail/bad-pkg6.wit.result b/crates/wit-parser/tests/ui/parse-fail/bad-pkg6.wit.result
index 73c73a9b..91c24db6 100644
--- a/crates/wit-parser/tests/ui/parse-fail/bad-pkg6.wit.result
+++ b/crates/wit-parser/tests/ui/parse-fail/bad-pkg6.wit.result
@@ -1,5 +1,5 @@
-failed to find package `foo:bar` in `deps` directory
-     --> tests/ui/parse-fail/bad-pkg6/root.wit:3:7
+interface not defined in document
+     --> tests/ui/parse-fail/bad-pkg6/root.wit:2:15
       |
-    3 |   use foo:bar/baz.{}
-      |       ^------
\ No newline at end of file
+    2 |   use bar.baz.nonexistent.{}
+      |               ^----------
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/bad-pkg6/deps/bar/baz.wit b/crates/wit-parser/tests/ui/parse-fail/bad-pkg6/deps/bar/baz.wit
index 195539f4..e69de29b 100644
--- a/crates/wit-parser/tests/ui/parse-fail/bad-pkg6/deps/bar/baz.wit
+++ b/crates/wit-parser/tests/ui/parse-fail/bad-pkg6/deps/bar/baz.wit
@@ -1,4 +0,0 @@
-package foo:baz
-
-interface bar {}
-
diff --git a/crates/wit-parser/tests/ui/parse-fail/bad-pkg6/root.wit b/crates/wit-parser/tests/ui/parse-fail/bad-pkg6/root.wit
index 7c3602d6..7c244a4d 100644
--- a/crates/wit-parser/tests/ui/parse-fail/bad-pkg6/root.wit
+++ b/crates/wit-parser/tests/ui/parse-fail/bad-pkg6/root.wit
@@ -1,4 +1,3 @@
-package foo:foo
 interface foo {
-  use foo:bar/baz.{}
+  use bar.baz.nonexistent.{}
 }
diff --git a/crates/wit-parser/tests/ui/parse-fail/bad-resource1.wit b/crates/wit-parser/tests/ui/parse-fail/bad-resource1.wit
deleted file mode 100644
index b7de8fc7..00000000
--- a/crates/wit-parser/tests/ui/parse-fail/bad-resource1.wit
+++ /dev/null
@@ -1,5 +0,0 @@
-package foo:bar
-
-interface foo {
-  type t = borrow<u32>
-}
diff --git a/crates/wit-parser/tests/ui/parse-fail/bad-resource1.wit.result b/crates/wit-parser/tests/ui/parse-fail/bad-resource1.wit.result
deleted file mode 100644
index de95a19a..00000000
--- a/crates/wit-parser/tests/ui/parse-fail/bad-resource1.wit.result
+++ /dev/null
@@ -1,5 +0,0 @@
-expected an identifier or string, found keyword `u32`
-     --> tests/ui/parse-fail/bad-resource1.wit:4:19
-      |
-    4 |   type t = borrow<u32>
-      |                   ^--
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/bad-resource10.wit b/crates/wit-parser/tests/ui/parse-fail/bad-resource10.wit
deleted file mode 100644
index 9786d149..00000000
--- a/crates/wit-parser/tests/ui/parse-fail/bad-resource10.wit
+++ /dev/null
@@ -1,5 +0,0 @@
-package foo:bar
-
-interface foo {
-  type t = own<u32>
-}
diff --git a/crates/wit-parser/tests/ui/parse-fail/bad-resource10.wit.result b/crates/wit-parser/tests/ui/parse-fail/bad-resource10.wit.result
deleted file mode 100644
index 46728d7c..00000000
--- a/crates/wit-parser/tests/ui/parse-fail/bad-resource10.wit.result
+++ /dev/null
@@ -1,5 +0,0 @@
-expected an identifier or string, found keyword `u32`
-     --> tests/ui/parse-fail/bad-resource10.wit:4:16
-      |
-    4 |   type t = own<u32>
-      |                ^--
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/bad-resource11.wit b/crates/wit-parser/tests/ui/parse-fail/bad-resource11.wit
deleted file mode 100644
index dbe433fb..00000000
--- a/crates/wit-parser/tests/ui/parse-fail/bad-resource11.wit
+++ /dev/null
@@ -1,5 +0,0 @@
-package foo:bar
-
-interface foo {
-  type t = own<foo>
-}
diff --git a/crates/wit-parser/tests/ui/parse-fail/bad-resource11.wit.result b/crates/wit-parser/tests/ui/parse-fail/bad-resource11.wit.result
deleted file mode 100644
index df298ce9..00000000
--- a/crates/wit-parser/tests/ui/parse-fail/bad-resource11.wit.result
+++ /dev/null
@@ -1,5 +0,0 @@
-type `foo` does not exist
-     --> tests/ui/parse-fail/bad-resource11.wit:4:16
-      |
-    4 |   type t = own<foo>
-      |                ^--
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/bad-resource12.wit b/crates/wit-parser/tests/ui/parse-fail/bad-resource12.wit
deleted file mode 100644
index 6f84b3a5..00000000
--- a/crates/wit-parser/tests/ui/parse-fail/bad-resource12.wit
+++ /dev/null
@@ -1,6 +0,0 @@
-package foo:bar
-
-interface foo {
-  foo: func()
-  type t = own<foo>
-}
diff --git a/crates/wit-parser/tests/ui/parse-fail/bad-resource12.wit.result b/crates/wit-parser/tests/ui/parse-fail/bad-resource12.wit.result
deleted file mode 100644
index 56286c9b..00000000
--- a/crates/wit-parser/tests/ui/parse-fail/bad-resource12.wit.result
+++ /dev/null
@@ -1,5 +0,0 @@
-type `foo` does not exist
-     --> tests/ui/parse-fail/bad-resource12.wit:5:16
-      |
-    5 |   type t = own<foo>
-      |                ^--
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/bad-resource13.wit b/crates/wit-parser/tests/ui/parse-fail/bad-resource13.wit
deleted file mode 100644
index 3fe73608..00000000
--- a/crates/wit-parser/tests/ui/parse-fail/bad-resource13.wit
+++ /dev/null
@@ -1,6 +0,0 @@
-package foo:bar
-
-interface foo {
-  type foo = u32
-  type t = own<foo>
-}
diff --git a/crates/wit-parser/tests/ui/parse-fail/bad-resource13.wit.result b/crates/wit-parser/tests/ui/parse-fail/bad-resource13.wit.result
deleted file mode 100644
index 9aa5852e..00000000
--- a/crates/wit-parser/tests/ui/parse-fail/bad-resource13.wit.result
+++ /dev/null
@@ -1,5 +0,0 @@
-type `foo` used in a handle must be a resource
-     --> tests/ui/parse-fail/bad-resource13.wit:5:16
-      |
-    5 |   type t = own<foo>
-      |                ^--
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/bad-resource14.wit b/crates/wit-parser/tests/ui/parse-fail/bad-resource14.wit
deleted file mode 100644
index 78e97894..00000000
--- a/crates/wit-parser/tests/ui/parse-fail/bad-resource14.wit
+++ /dev/null
@@ -1,7 +0,0 @@
-package foo:bar
-
-interface foo {
-  resource a {}
-  type t = own<a>
-  type b = own<t>
-}
diff --git a/crates/wit-parser/tests/ui/parse-fail/bad-resource14.wit.result b/crates/wit-parser/tests/ui/parse-fail/bad-resource14.wit.result
deleted file mode 100644
index 03ea800b..00000000
--- a/crates/wit-parser/tests/ui/parse-fail/bad-resource14.wit.result
+++ /dev/null
@@ -1,5 +0,0 @@
-type `t` used in a handle must be a resource
-     --> tests/ui/parse-fail/bad-resource14.wit:6:16
-      |
-    6 |   type b = own<t>
-      |                ^
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/bad-resource15.wit.result b/crates/wit-parser/tests/ui/parse-fail/bad-resource15.wit.result
deleted file mode 100644
index 35ac5e60..00000000
--- a/crates/wit-parser/tests/ui/parse-fail/bad-resource15.wit.result
+++ /dev/null
@@ -1,5 +0,0 @@
-type used in a handle must be a resource
-     --> tests/ui/parse-fail/bad-resource15/foo.wit:6:16
-      |
-    6 |   type t = own<r>
-      |                ^
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/bad-resource15/deps/foo/foo.wit b/crates/wit-parser/tests/ui/parse-fail/bad-resource15/deps/foo/foo.wit
deleted file mode 100644
index 5659a277..00000000
--- a/crates/wit-parser/tests/ui/parse-fail/bad-resource15/deps/foo/foo.wit
+++ /dev/null
@@ -1,5 +0,0 @@
-package some:dep
-
-interface foo {
-  type r = u32
-}
diff --git a/crates/wit-parser/tests/ui/parse-fail/bad-resource15/foo.wit b/crates/wit-parser/tests/ui/parse-fail/bad-resource15/foo.wit
deleted file mode 100644
index bf2e3a89..00000000
--- a/crates/wit-parser/tests/ui/parse-fail/bad-resource15/foo.wit
+++ /dev/null
@@ -1,7 +0,0 @@
-package foo:bar
-
-interface foo {
-  use some:dep/foo.{r}
-
-  type t = own<r>
-}
diff --git a/crates/wit-parser/tests/ui/parse-fail/bad-resource2.wit b/crates/wit-parser/tests/ui/parse-fail/bad-resource2.wit
deleted file mode 100644
index c07e5fe7..00000000
--- a/crates/wit-parser/tests/ui/parse-fail/bad-resource2.wit
+++ /dev/null
@@ -1,5 +0,0 @@
-package foo:bar
-
-interface foo {
-  type t = borrow<foo>
-}
diff --git a/crates/wit-parser/tests/ui/parse-fail/bad-resource2.wit.result b/crates/wit-parser/tests/ui/parse-fail/bad-resource2.wit.result
deleted file mode 100644
index 21514a30..00000000
--- a/crates/wit-parser/tests/ui/parse-fail/bad-resource2.wit.result
+++ /dev/null
@@ -1,5 +0,0 @@
-type `foo` does not exist
-     --> tests/ui/parse-fail/bad-resource2.wit:4:19
-      |
-    4 |   type t = borrow<foo>
-      |                   ^--
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/bad-resource3.wit b/crates/wit-parser/tests/ui/parse-fail/bad-resource3.wit
deleted file mode 100644
index 419bd6a3..00000000
--- a/crates/wit-parser/tests/ui/parse-fail/bad-resource3.wit
+++ /dev/null
@@ -1,6 +0,0 @@
-package foo:bar
-
-interface foo {
-  foo: func()
-  type t = borrow<foo>
-}
diff --git a/crates/wit-parser/tests/ui/parse-fail/bad-resource3.wit.result b/crates/wit-parser/tests/ui/parse-fail/bad-resource3.wit.result
deleted file mode 100644
index 214781d9..00000000
--- a/crates/wit-parser/tests/ui/parse-fail/bad-resource3.wit.result
+++ /dev/null
@@ -1,5 +0,0 @@
-type `foo` does not exist
-     --> tests/ui/parse-fail/bad-resource3.wit:5:19
-      |
-    5 |   type t = borrow<foo>
-      |                   ^--
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/bad-resource4.wit b/crates/wit-parser/tests/ui/parse-fail/bad-resource4.wit
deleted file mode 100644
index d7f99d2a..00000000
--- a/crates/wit-parser/tests/ui/parse-fail/bad-resource4.wit
+++ /dev/null
@@ -1,6 +0,0 @@
-package foo:bar
-
-interface foo {
-  type foo = u32
-  type t = borrow<foo>
-}
diff --git a/crates/wit-parser/tests/ui/parse-fail/bad-resource4.wit.result b/crates/wit-parser/tests/ui/parse-fail/bad-resource4.wit.result
deleted file mode 100644
index cb0f8162..00000000
--- a/crates/wit-parser/tests/ui/parse-fail/bad-resource4.wit.result
+++ /dev/null
@@ -1,5 +0,0 @@
-type `foo` used in a handle must be a resource
-     --> tests/ui/parse-fail/bad-resource4.wit:5:19
-      |
-    5 |   type t = borrow<foo>
-      |                   ^--
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/bad-resource5.wit b/crates/wit-parser/tests/ui/parse-fail/bad-resource5.wit
deleted file mode 100644
index 0dd97682..00000000
--- a/crates/wit-parser/tests/ui/parse-fail/bad-resource5.wit
+++ /dev/null
@@ -1,7 +0,0 @@
-package foo:bar
-
-interface foo {
-  resource a {}
-  type t = borrow<a>
-  type b = borrow<t>
-}
diff --git a/crates/wit-parser/tests/ui/parse-fail/bad-resource5.wit.result b/crates/wit-parser/tests/ui/parse-fail/bad-resource5.wit.result
deleted file mode 100644
index 453dc187..00000000
--- a/crates/wit-parser/tests/ui/parse-fail/bad-resource5.wit.result
+++ /dev/null
@@ -1,5 +0,0 @@
-type `t` used in a handle must be a resource
-     --> tests/ui/parse-fail/bad-resource5.wit:6:19
-      |
-    6 |   type b = borrow<t>
-      |                   ^
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/bad-resource6.wit b/crates/wit-parser/tests/ui/parse-fail/bad-resource6.wit
deleted file mode 100644
index 030c31b9..00000000
--- a/crates/wit-parser/tests/ui/parse-fail/bad-resource6.wit
+++ /dev/null
@@ -1,7 +0,0 @@
-package foo:bar
-
-interface foo {
-  resource a {
-    constructor() -> u32
-  }
-}
diff --git a/crates/wit-parser/tests/ui/parse-fail/bad-resource6.wit.result b/crates/wit-parser/tests/ui/parse-fail/bad-resource6.wit.result
deleted file mode 100644
index e28c20eb..00000000
--- a/crates/wit-parser/tests/ui/parse-fail/bad-resource6.wit.result
+++ /dev/null
@@ -1,5 +0,0 @@
-expected `constructor` or identifier, found `->`
-     --> tests/ui/parse-fail/bad-resource6.wit:5:19
-      |
-    5 |     constructor() -> u32
-      |                   ^-
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/bad-resource7.wit b/crates/wit-parser/tests/ui/parse-fail/bad-resource7.wit
deleted file mode 100644
index 40d9eeeb..00000000
--- a/crates/wit-parser/tests/ui/parse-fail/bad-resource7.wit
+++ /dev/null
@@ -1,8 +0,0 @@
-package foo:bar
-
-interface foo {
-  resource a {
-    constructor()
-    constructor()
-  }
-}
diff --git a/crates/wit-parser/tests/ui/parse-fail/bad-resource7.wit.result b/crates/wit-parser/tests/ui/parse-fail/bad-resource7.wit.result
deleted file mode 100644
index 72e9a3ed..00000000
--- a/crates/wit-parser/tests/ui/parse-fail/bad-resource7.wit.result
+++ /dev/null
@@ -1,5 +0,0 @@
-duplicate constructors
-     --> tests/ui/parse-fail/bad-resource7.wit:6:5
-      |
-    6 |     constructor()
-      |     ^----------
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/bad-resource8.wit b/crates/wit-parser/tests/ui/parse-fail/bad-resource8.wit
deleted file mode 100644
index 73b4d179..00000000
--- a/crates/wit-parser/tests/ui/parse-fail/bad-resource8.wit
+++ /dev/null
@@ -1,8 +0,0 @@
-package foo:bar
-
-interface foo {
-  resource a {
-    a: func()
-    a: static func()
-  }
-}
diff --git a/crates/wit-parser/tests/ui/parse-fail/bad-resource8.wit.result b/crates/wit-parser/tests/ui/parse-fail/bad-resource8.wit.result
deleted file mode 100644
index 77b8cc29..00000000
--- a/crates/wit-parser/tests/ui/parse-fail/bad-resource8.wit.result
+++ /dev/null
@@ -1,5 +0,0 @@
-duplicate function name `a`
-     --> tests/ui/parse-fail/bad-resource8.wit:6:5
-      |
-    6 |     a: static func()
-      |     ^
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/bad-resource9.wit b/crates/wit-parser/tests/ui/parse-fail/bad-resource9.wit
deleted file mode 100644
index 17d341d3..00000000
--- a/crates/wit-parser/tests/ui/parse-fail/bad-resource9.wit
+++ /dev/null
@@ -1,7 +0,0 @@
-package foo:bar
-
-interface foo {
-  resource a {
-    interface foo {}
-  }
-}
diff --git a/crates/wit-parser/tests/ui/parse-fail/bad-resource9.wit.result b/crates/wit-parser/tests/ui/parse-fail/bad-resource9.wit.result
deleted file mode 100644
index 368808cb..00000000
--- a/crates/wit-parser/tests/ui/parse-fail/bad-resource9.wit.result
+++ /dev/null
@@ -1,5 +0,0 @@
-expected `constructor` or identifier, found keyword `interface`
-     --> tests/ui/parse-fail/bad-resource9.wit:5:5
-      |
-    5 |     interface foo {}
-      |     ^--------
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/bad-world-type1.wit b/crates/wit-parser/tests/ui/parse-fail/bad-world-type1.wit
index 6c5a1537..0fbd79fd 100644
--- a/crates/wit-parser/tests/ui/parse-fail/bad-world-type1.wit
+++ b/crates/wit-parser/tests/ui/parse-fail/bad-world-type1.wit
@@ -1,4 +1,3 @@
-package foo:foo
 world a {
   type a = u32
   import a: func()
diff --git a/crates/wit-parser/tests/ui/parse-fail/bad-world-type1.wit.result b/crates/wit-parser/tests/ui/parse-fail/bad-world-type1.wit.result
index 2b32378d..3c993d17 100644
--- a/crates/wit-parser/tests/ui/parse-fail/bad-world-type1.wit.result
+++ b/crates/wit-parser/tests/ui/parse-fail/bad-world-type1.wit.result
@@ -1,5 +1,5 @@
 import `a` conflicts with prior import of same name
-     --> tests/ui/parse-fail/bad-world-type1.wit:4:10
+     --> tests/ui/parse-fail/bad-world-type1.wit:3:10
       |
-    4 |   import a: func()
+    3 |   import a: func()
       |          ^
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/world-iface-no-collide.wit b/crates/wit-parser/tests/ui/parse-fail/bad-world-type2.wit
similarity index 69%
rename from crates/wit-parser/tests/ui/world-iface-no-collide.wit
rename to crates/wit-parser/tests/ui/parse-fail/bad-world-type2.wit
index 62d17852..42cd3248 100644
--- a/crates/wit-parser/tests/ui/world-iface-no-collide.wit
+++ b/crates/wit-parser/tests/ui/parse-fail/bad-world-type2.wit
@@ -1,11 +1,9 @@
-package foo:foo
-
 interface foo {
   type t = u32
 }
 
 world bar {
-  use foo.{t}
+  use self.foo.{t}
 
   import foo: func()
 }
diff --git a/crates/wit-parser/tests/ui/parse-fail/bad-world-type2.wit.result b/crates/wit-parser/tests/ui/parse-fail/bad-world-type2.wit.result
new file mode 100644
index 00000000..05438232
--- /dev/null
+++ b/crates/wit-parser/tests/ui/parse-fail/bad-world-type2.wit.result
@@ -0,0 +1,5 @@
+import of function `foo` shadows previously imported interface
+     --> tests/ui/parse-fail/bad-world-type2.wit:8:10
+      |
+    8 |   import foo: func()
+      |          ^--
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/conflicting-package.wit.result b/crates/wit-parser/tests/ui/parse-fail/conflicting-package.wit.result
deleted file mode 100644
index 2b18334f..00000000
--- a/crates/wit-parser/tests/ui/parse-fail/conflicting-package.wit.result
+++ /dev/null
@@ -1,8 +0,0 @@
-failed to parse package: tests/ui/parse-fail/conflicting-package
-
-Caused by:
-    package identifier `foo:b` does not match previous package name of `foo:a`
-         --> tests/ui/parse-fail/conflicting-package/b.wit:1:9
-          |
-        1 | package foo:b
-          |         ^----
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/conflicting-package/a.wit b/crates/wit-parser/tests/ui/parse-fail/conflicting-package/a.wit
deleted file mode 100644
index 9cd1c0ec..00000000
--- a/crates/wit-parser/tests/ui/parse-fail/conflicting-package/a.wit
+++ /dev/null
@@ -1 +0,0 @@
-package foo:a
diff --git a/crates/wit-parser/tests/ui/parse-fail/conflicting-package/b.wit b/crates/wit-parser/tests/ui/parse-fail/conflicting-package/b.wit
deleted file mode 100644
index 860805c6..00000000
--- a/crates/wit-parser/tests/ui/parse-fail/conflicting-package/b.wit
+++ /dev/null
@@ -1 +0,0 @@
-package foo:b
diff --git a/crates/wit-parser/tests/ui/parse-fail/cycle.wit b/crates/wit-parser/tests/ui/parse-fail/cycle.wit
index 335595d8..707477b7 100644
--- a/crates/wit-parser/tests/ui/parse-fail/cycle.wit
+++ b/crates/wit-parser/tests/ui/parse-fail/cycle.wit
@@ -1,5 +1,4 @@
 // parse-fail
-package foo:foo
 
 interface foo {
   type foo = foo
diff --git a/crates/wit-parser/tests/ui/parse-fail/cycle.wit.result b/crates/wit-parser/tests/ui/parse-fail/cycle.wit.result
index 3639b3c2..fbb1a645 100644
--- a/crates/wit-parser/tests/ui/parse-fail/cycle.wit.result
+++ b/crates/wit-parser/tests/ui/parse-fail/cycle.wit.result
@@ -1,5 +1,5 @@
 type `foo` depends on itself
-     --> tests/ui/parse-fail/cycle.wit:5:14
+     --> tests/ui/parse-fail/cycle.wit:4:14
       |
-    5 |   type foo = foo
+    4 |   type foo = foo
       |              ^--
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/cycle2.wit b/crates/wit-parser/tests/ui/parse-fail/cycle2.wit
index 65aab1a8..28e6b6aa 100644
--- a/crates/wit-parser/tests/ui/parse-fail/cycle2.wit
+++ b/crates/wit-parser/tests/ui/parse-fail/cycle2.wit
@@ -1,5 +1,4 @@
 // parse-fail
-package foo:foo
 
 interface foo {
   type foo = bar
diff --git a/crates/wit-parser/tests/ui/parse-fail/cycle2.wit.result b/crates/wit-parser/tests/ui/parse-fail/cycle2.wit.result
index 2e4a5290..946175ab 100644
--- a/crates/wit-parser/tests/ui/parse-fail/cycle2.wit.result
+++ b/crates/wit-parser/tests/ui/parse-fail/cycle2.wit.result
@@ -1,5 +1,5 @@
 type `bar` depends on itself
-     --> tests/ui/parse-fail/cycle2.wit:5:14
+     --> tests/ui/parse-fail/cycle2.wit:4:14
       |
-    5 |   type foo = bar
+    4 |   type foo = bar
       |              ^--
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/cycle3.wit b/crates/wit-parser/tests/ui/parse-fail/cycle3.wit
index 59a42a32..8bcc5666 100644
--- a/crates/wit-parser/tests/ui/parse-fail/cycle3.wit
+++ b/crates/wit-parser/tests/ui/parse-fail/cycle3.wit
@@ -1,5 +1,4 @@
 // parse-fail
-package foo:foo
 
 interface foo {
   type foo = bar
diff --git a/crates/wit-parser/tests/ui/parse-fail/cycle3.wit.result b/crates/wit-parser/tests/ui/parse-fail/cycle3.wit.result
index ffdfec0a..facc6386 100644
--- a/crates/wit-parser/tests/ui/parse-fail/cycle3.wit.result
+++ b/crates/wit-parser/tests/ui/parse-fail/cycle3.wit.result
@@ -1,5 +1,5 @@
 type `bar` depends on itself
-     --> tests/ui/parse-fail/cycle3.wit:5:14
+     --> tests/ui/parse-fail/cycle3.wit:4:14
       |
-    5 |   type foo = bar
+    4 |   type foo = bar
       |              ^--
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/cycle4.wit b/crates/wit-parser/tests/ui/parse-fail/cycle4.wit
index 716ac832..39c6d4bf 100644
--- a/crates/wit-parser/tests/ui/parse-fail/cycle4.wit
+++ b/crates/wit-parser/tests/ui/parse-fail/cycle4.wit
@@ -1,5 +1,4 @@
 // parse-fail
-package foo:foo
 
 interface foo {
   type foo = bar
diff --git a/crates/wit-parser/tests/ui/parse-fail/cycle4.wit.result b/crates/wit-parser/tests/ui/parse-fail/cycle4.wit.result
index 67325b77..45e9c17a 100644
--- a/crates/wit-parser/tests/ui/parse-fail/cycle4.wit.result
+++ b/crates/wit-parser/tests/ui/parse-fail/cycle4.wit.result
@@ -1,5 +1,5 @@
 type `bar` depends on itself
-     --> tests/ui/parse-fail/cycle4.wit:5:14
+     --> tests/ui/parse-fail/cycle4.wit:4:14
       |
-    5 |   type foo = bar
+    4 |   type foo = bar
       |              ^--
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/cycle5.wit b/crates/wit-parser/tests/ui/parse-fail/cycle5.wit
index 2aa73441..3c26d9b2 100644
--- a/crates/wit-parser/tests/ui/parse-fail/cycle5.wit
+++ b/crates/wit-parser/tests/ui/parse-fail/cycle5.wit
@@ -1,5 +1,4 @@
 // parse-fail
-package foo:foo
 
 interface foo {
   type foo = bar
diff --git a/crates/wit-parser/tests/ui/parse-fail/cycle5.wit.result b/crates/wit-parser/tests/ui/parse-fail/cycle5.wit.result
index 22064dac..0fd4f5c8 100644
--- a/crates/wit-parser/tests/ui/parse-fail/cycle5.wit.result
+++ b/crates/wit-parser/tests/ui/parse-fail/cycle5.wit.result
@@ -1,5 +1,5 @@
 type `bar` depends on itself
-     --> tests/ui/parse-fail/cycle5.wit:5:14
+     --> tests/ui/parse-fail/cycle5.wit:4:14
       |
-    5 |   type foo = bar
+    4 |   type foo = bar
       |              ^--
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/default-interface1.wit b/crates/wit-parser/tests/ui/parse-fail/default-interface1.wit
new file mode 100644
index 00000000..c6c42388
--- /dev/null
+++ b/crates/wit-parser/tests/ui/parse-fail/default-interface1.wit
@@ -0,0 +1,3 @@
+// parse-fail
+default interface foo {}
+default interface bar {}
diff --git a/crates/wit-parser/tests/ui/parse-fail/default-interface1.wit.result b/crates/wit-parser/tests/ui/parse-fail/default-interface1.wit.result
new file mode 100644
index 00000000..a98ae7d3
--- /dev/null
+++ b/crates/wit-parser/tests/ui/parse-fail/default-interface1.wit.result
@@ -0,0 +1,5 @@
+cannot specify more than one `default` interface
+     --> tests/ui/parse-fail/default-interface1.wit:3:19
+      |
+    3 | default interface bar {}
+      |                   ^--
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/default-world1.wit b/crates/wit-parser/tests/ui/parse-fail/default-world1.wit
new file mode 100644
index 00000000..df2d36e2
--- /dev/null
+++ b/crates/wit-parser/tests/ui/parse-fail/default-world1.wit
@@ -0,0 +1,3 @@
+// parse-fail
+default world foo {}
+default world bar {}
diff --git a/crates/wit-parser/tests/ui/parse-fail/default-world1.wit.result b/crates/wit-parser/tests/ui/parse-fail/default-world1.wit.result
new file mode 100644
index 00000000..e46b2538
--- /dev/null
+++ b/crates/wit-parser/tests/ui/parse-fail/default-world1.wit.result
@@ -0,0 +1,5 @@
+cannot specify more than one `default` world
+     --> tests/ui/parse-fail/default-world1.wit:3:15
+      |
+    3 | default world bar {}
+      |               ^--
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/duplicate-functions.wit b/crates/wit-parser/tests/ui/parse-fail/duplicate-functions.wit
index b581d731..6b63355e 100644
--- a/crates/wit-parser/tests/ui/parse-fail/duplicate-functions.wit
+++ b/crates/wit-parser/tests/ui/parse-fail/duplicate-functions.wit
@@ -1,7 +1,5 @@
 // parse-fail
 
-package foo:foo
-
 interface foo {
   foo: func()
   foo: func()
diff --git a/crates/wit-parser/tests/ui/parse-fail/duplicate-functions.wit.result b/crates/wit-parser/tests/ui/parse-fail/duplicate-functions.wit.result
index 30ec5002..c0ab243f 100644
--- a/crates/wit-parser/tests/ui/parse-fail/duplicate-functions.wit.result
+++ b/crates/wit-parser/tests/ui/parse-fail/duplicate-functions.wit.result
@@ -1,5 +1,5 @@
 name `foo` is defined more than once
-     --> tests/ui/parse-fail/duplicate-functions.wit:7:3
+     --> tests/ui/parse-fail/duplicate-functions.wit:5:3
       |
-    7 |   foo: func()
+    5 |   foo: func()
       |   ^--
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/duplicate-interface.wit b/crates/wit-parser/tests/ui/parse-fail/duplicate-interface.wit
index c5fecdd7..c58d11fa 100644
--- a/crates/wit-parser/tests/ui/parse-fail/duplicate-interface.wit
+++ b/crates/wit-parser/tests/ui/parse-fail/duplicate-interface.wit
@@ -1,6 +1,4 @@
 // parse-fail
 
-package foo:foo
-
 interface foo {}
 interface foo {}
diff --git a/crates/wit-parser/tests/ui/parse-fail/duplicate-interface.wit.result b/crates/wit-parser/tests/ui/parse-fail/duplicate-interface.wit.result
index f6351f30..293005fe 100644
--- a/crates/wit-parser/tests/ui/parse-fail/duplicate-interface.wit.result
+++ b/crates/wit-parser/tests/ui/parse-fail/duplicate-interface.wit.result
@@ -1,5 +1,5 @@
-duplicate item named `foo`
-     --> tests/ui/parse-fail/duplicate-interface.wit:6:11
+name `foo` previously defined in document
+     --> tests/ui/parse-fail/duplicate-interface.wit:4:11
       |
-    6 | interface foo {}
+    4 | interface foo {}
       |           ^--
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/duplicate-interface2.wit.result b/crates/wit-parser/tests/ui/parse-fail/duplicate-interface2.wit.result
deleted file mode 100644
index 7ed7ec2b..00000000
--- a/crates/wit-parser/tests/ui/parse-fail/duplicate-interface2.wit.result
+++ /dev/null
@@ -1,8 +0,0 @@
-failed to parse package: tests/ui/parse-fail/duplicate-interface2
-
-Caused by:
-    duplicate item named `foo`
-         --> tests/ui/parse-fail/duplicate-interface2/foo2.wit:3:11
-          |
-        3 | interface foo {}
-          |           ^--
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/duplicate-interface2/foo.wit b/crates/wit-parser/tests/ui/parse-fail/duplicate-interface2/foo.wit
deleted file mode 100644
index f8a9027d..00000000
--- a/crates/wit-parser/tests/ui/parse-fail/duplicate-interface2/foo.wit
+++ /dev/null
@@ -1,3 +0,0 @@
-package foo:foo
-
-interface foo {}
diff --git a/crates/wit-parser/tests/ui/parse-fail/duplicate-interface2/foo2.wit b/crates/wit-parser/tests/ui/parse-fail/duplicate-interface2/foo2.wit
deleted file mode 100644
index f8a9027d..00000000
--- a/crates/wit-parser/tests/ui/parse-fail/duplicate-interface2/foo2.wit
+++ /dev/null
@@ -1,3 +0,0 @@
-package foo:foo
-
-interface foo {}
diff --git a/crates/wit-parser/tests/ui/parse-fail/duplicate-type.wit b/crates/wit-parser/tests/ui/parse-fail/duplicate-type.wit
index 7284164b..7b23f438 100644
--- a/crates/wit-parser/tests/ui/parse-fail/duplicate-type.wit
+++ b/crates/wit-parser/tests/ui/parse-fail/duplicate-type.wit
@@ -1,5 +1,4 @@
 // parse-fail
-package foo:foo
 
 interface foo {
   type foo = s32
diff --git a/crates/wit-parser/tests/ui/parse-fail/duplicate-type.wit.result b/crates/wit-parser/tests/ui/parse-fail/duplicate-type.wit.result
index 09187e9f..9efd0d2c 100644
--- a/crates/wit-parser/tests/ui/parse-fail/duplicate-type.wit.result
+++ b/crates/wit-parser/tests/ui/parse-fail/duplicate-type.wit.result
@@ -1,5 +1,5 @@
 name `foo` is defined more than once
-     --> tests/ui/parse-fail/duplicate-type.wit:6:8
+     --> tests/ui/parse-fail/duplicate-type.wit:5:8
       |
-    6 |   type foo = s32
+    5 |   type foo = s32
       |        ^--
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/empty-enum.wit b/crates/wit-parser/tests/ui/parse-fail/empty-enum.wit
index 2b957777..abf7c119 100644
--- a/crates/wit-parser/tests/ui/parse-fail/empty-enum.wit
+++ b/crates/wit-parser/tests/ui/parse-fail/empty-enum.wit
@@ -1,5 +1,4 @@
 // parse-fail
-package foo:foo
 
 interface foo {
   enum t {}
diff --git a/crates/wit-parser/tests/ui/parse-fail/empty-enum.wit.result b/crates/wit-parser/tests/ui/parse-fail/empty-enum.wit.result
index 894a82a0..9347fca4 100644
--- a/crates/wit-parser/tests/ui/parse-fail/empty-enum.wit.result
+++ b/crates/wit-parser/tests/ui/parse-fail/empty-enum.wit.result
@@ -1,5 +1,5 @@
 empty enum
-     --> tests/ui/parse-fail/empty-enum.wit:5:8
+     --> tests/ui/parse-fail/empty-enum.wit:4:8
       |
-    5 |   enum t {}
+    4 |   enum t {}
       |        ^
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/empty-union.wit b/crates/wit-parser/tests/ui/parse-fail/empty-union.wit
index 1128fd1e..84e8f9ec 100644
--- a/crates/wit-parser/tests/ui/parse-fail/empty-union.wit
+++ b/crates/wit-parser/tests/ui/parse-fail/empty-union.wit
@@ -1,5 +1,4 @@
 // parse-fail
-package foo:foo
 
 interface foo {
   union t {}
diff --git a/crates/wit-parser/tests/ui/parse-fail/empty-union.wit.result b/crates/wit-parser/tests/ui/parse-fail/empty-union.wit.result
index 14189756..af11fb72 100644
--- a/crates/wit-parser/tests/ui/parse-fail/empty-union.wit.result
+++ b/crates/wit-parser/tests/ui/parse-fail/empty-union.wit.result
@@ -1,5 +1,5 @@
 empty union
-     --> tests/ui/parse-fail/empty-union.wit:5:9
+     --> tests/ui/parse-fail/empty-union.wit:4:9
       |
-    5 |   union t {}
+    4 |   union t {}
       |         ^
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/empty-variant1.wit b/crates/wit-parser/tests/ui/parse-fail/empty-variant1.wit
index 23ba7e18..8081a45a 100644
--- a/crates/wit-parser/tests/ui/parse-fail/empty-variant1.wit
+++ b/crates/wit-parser/tests/ui/parse-fail/empty-variant1.wit
@@ -1,5 +1,4 @@
 // parse-fail
-package foo:foo
 
 interface foo {
   variant t {}
diff --git a/crates/wit-parser/tests/ui/parse-fail/empty-variant1.wit.result b/crates/wit-parser/tests/ui/parse-fail/empty-variant1.wit.result
index 9c42ba4c..68bdc008 100644
--- a/crates/wit-parser/tests/ui/parse-fail/empty-variant1.wit.result
+++ b/crates/wit-parser/tests/ui/parse-fail/empty-variant1.wit.result
@@ -1,5 +1,5 @@
 empty variant
-     --> tests/ui/parse-fail/empty-variant1.wit:5:11
+     --> tests/ui/parse-fail/empty-variant1.wit:4:11
       |
-    5 |   variant t {}
+    4 |   variant t {}
       |           ^
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/export-twice.wit b/crates/wit-parser/tests/ui/parse-fail/export-twice.wit
deleted file mode 100644
index eaeb478c..00000000
--- a/crates/wit-parser/tests/ui/parse-fail/export-twice.wit
+++ /dev/null
@@ -1,8 +0,0 @@
-package foo:foo
-
-interface foo {}
-
-world bar {
-  export foo
-  export foo
-}
diff --git a/crates/wit-parser/tests/ui/parse-fail/export-twice.wit.result b/crates/wit-parser/tests/ui/parse-fail/export-twice.wit.result
deleted file mode 100644
index d796998a..00000000
--- a/crates/wit-parser/tests/ui/parse-fail/export-twice.wit.result
+++ /dev/null
@@ -1,5 +0,0 @@
-interface cannot be exported more than once
-     --> tests/ui/parse-fail/export-twice.wit:7:10
-      |
-    7 |   export foo
-      |          ^--
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/import-and-export1.wit.result b/crates/wit-parser/tests/ui/parse-fail/import-and-export1.wit.result
deleted file mode 100644
index 76f51e65..00000000
--- a/crates/wit-parser/tests/ui/parse-fail/import-and-export1.wit.result
+++ /dev/null
@@ -1,5 +0,0 @@
-interface transitively depends on an interface in incompatible ways
-     --> tests/ui/parse-fail/import-and-export1.wit:16:10
-      |
-   16 |   export i3
-      |          ^-
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/import-and-export2.wit b/crates/wit-parser/tests/ui/parse-fail/import-and-export2.wit
deleted file mode 100644
index 14deb182..00000000
--- a/crates/wit-parser/tests/ui/parse-fail/import-and-export2.wit
+++ /dev/null
@@ -1,18 +0,0 @@
-package foo:foo
-
-interface foo {
-  type t = u32
-}
-
-interface bar {
-  use foo.{t}
-}
-
-world baz {
-  export foo
-  import bar
-  export anon: interface {
-    use foo.{t}
-    use bar.{t as t2}
-  }
-}
diff --git a/crates/wit-parser/tests/ui/parse-fail/import-and-export2.wit.result b/crates/wit-parser/tests/ui/parse-fail/import-and-export2.wit.result
deleted file mode 100644
index 85777bfc..00000000
--- a/crates/wit-parser/tests/ui/parse-fail/import-and-export2.wit.result
+++ /dev/null
@@ -1,5 +0,0 @@
-interface transitively depends on an interface in incompatible ways
-     --> tests/ui/parse-fail/import-and-export2.wit:14:10
-      |
-   14 |   export anon: interface {
-      |          ^---
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/import-and-export3.wit b/crates/wit-parser/tests/ui/parse-fail/import-and-export3.wit
deleted file mode 100644
index aa8014b8..00000000
--- a/crates/wit-parser/tests/ui/parse-fail/import-and-export3.wit
+++ /dev/null
@@ -1,37 +0,0 @@
-package foo:foo
-
-interface foo {}
-interface bar {}
-
-world the-world {
-  import foo
-  import bar
-  import baz: interface {
-    foo: func()
-  }
-  export foo
-  export bar
-  export baz2: interface {
-    foo: func()
-  }
-}
-
-world a-different-world {
-  import foo
-}
-
-interface i1 {
-  type t = u32
-}
-interface i2 {
-  use i1.{t}
-}
-interface i3 {
-  use i2.{t}
-}
-
-world test {
-  import i3
-  export i1
-  export i3
-}
diff --git a/crates/wit-parser/tests/ui/parse-fail/import-and-export3.wit.result b/crates/wit-parser/tests/ui/parse-fail/import-and-export3.wit.result
deleted file mode 100644
index cd7d94ea..00000000
--- a/crates/wit-parser/tests/ui/parse-fail/import-and-export3.wit.result
+++ /dev/null
@@ -1,5 +0,0 @@
-interface transitively depends on an interface in incompatible ways
-     --> tests/ui/parse-fail/import-and-export3.wit:36:10
-      |
-   36 |   export i3
-      |          ^-
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/import-and-export4.wit b/crates/wit-parser/tests/ui/parse-fail/import-and-export4.wit
deleted file mode 100644
index de4594a8..00000000
--- a/crates/wit-parser/tests/ui/parse-fail/import-and-export4.wit
+++ /dev/null
@@ -1,44 +0,0 @@
-package foo:foo
-
-
-world union-world {
-  include test
-  include a-different-world
-  include the-world
-}
-
-interface foo {}
-interface bar {}
-
-world the-world {
-  import foo
-  import bar
-  import baz: interface {
-    foo: func()
-  }
-  export foo
-  export bar
-  export baz2: interface {
-    foo: func()
-  }
-}
-
-world a-different-world {
-  import foo
-}
-
-interface i1 {
-  type t = u32
-}
-interface i2 {
-  use i1.{t}
-}
-interface i3 {
-  use i2.{t}
-}
-
-world test {
-  import i3
-  export i1
-  export i3
-}
diff --git a/crates/wit-parser/tests/ui/parse-fail/import-and-export4.wit.result b/crates/wit-parser/tests/ui/parse-fail/import-and-export4.wit.result
deleted file mode 100644
index 69710534..00000000
--- a/crates/wit-parser/tests/ui/parse-fail/import-and-export4.wit.result
+++ /dev/null
@@ -1,5 +0,0 @@
-interface transitively depends on an interface in incompatible ways
-     --> tests/ui/parse-fail/import-and-export4.wit:43:10
-      |
-   43 |   export i3
-      |          ^-
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/import-and-export5.wit b/crates/wit-parser/tests/ui/parse-fail/import-and-export5.wit
deleted file mode 100644
index 1a3e2306..00000000
--- a/crates/wit-parser/tests/ui/parse-fail/import-and-export5.wit
+++ /dev/null
@@ -1,18 +0,0 @@
-package foo:bar
-
-interface a {
-  record x {
-  }
-}
-
-interface b {
-  use a.{x}
-}
-
-world w {
-  export anon: interface {
-    use b.{x as x2}
-    use a.{x}
-  }
-  export a
-}
diff --git a/crates/wit-parser/tests/ui/parse-fail/import-and-export5.wit.result b/crates/wit-parser/tests/ui/parse-fail/import-and-export5.wit.result
deleted file mode 100644
index 6e86b74c..00000000
--- a/crates/wit-parser/tests/ui/parse-fail/import-and-export5.wit.result
+++ /dev/null
@@ -1,5 +0,0 @@
-interface transitively depends on an interface in incompatible ways
-     --> tests/ui/parse-fail/import-and-export5.wit:13:10
-      |
-   13 |   export anon: interface {
-      |          ^---
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/import-export-overlap1.wit b/crates/wit-parser/tests/ui/parse-fail/import-export-overlap1.wit
index ac0e8e4d..4e865f90 100644
--- a/crates/wit-parser/tests/ui/parse-fail/import-export-overlap1.wit
+++ b/crates/wit-parser/tests/ui/parse-fail/import-export-overlap1.wit
@@ -1,4 +1,3 @@
-package foo:foo
 world foo {
   import a: func()
   export a: func()
diff --git a/crates/wit-parser/tests/ui/parse-fail/import-export-overlap1.wit.result b/crates/wit-parser/tests/ui/parse-fail/import-export-overlap1.wit.result
index 27caf399..838baa6e 100644
--- a/crates/wit-parser/tests/ui/parse-fail/import-export-overlap1.wit.result
+++ b/crates/wit-parser/tests/ui/parse-fail/import-export-overlap1.wit.result
@@ -1,5 +1,5 @@
 export `a` conflicts with prior import of same name
-     --> tests/ui/parse-fail/import-export-overlap1.wit:4:10
+     --> tests/ui/parse-fail/import-export-overlap1.wit:3:10
       |
-    4 |   export a: func()
+    3 |   export a: func()
       |          ^
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/import-export-overlap2.wit b/crates/wit-parser/tests/ui/parse-fail/import-export-overlap2.wit
index 4622babb..1680efeb 100644
--- a/crates/wit-parser/tests/ui/parse-fail/import-export-overlap2.wit
+++ b/crates/wit-parser/tests/ui/parse-fail/import-export-overlap2.wit
@@ -1,4 +1,3 @@
-package foo:foo
 world foo {
   import a: func()
   export a: interface {}
diff --git a/crates/wit-parser/tests/ui/parse-fail/import-export-overlap2.wit.result b/crates/wit-parser/tests/ui/parse-fail/import-export-overlap2.wit.result
index 88ca1c19..af16080e 100644
--- a/crates/wit-parser/tests/ui/parse-fail/import-export-overlap2.wit.result
+++ b/crates/wit-parser/tests/ui/parse-fail/import-export-overlap2.wit.result
@@ -1,5 +1,5 @@
 export `a` conflicts with prior import of same name
-     --> tests/ui/parse-fail/import-export-overlap2.wit:4:10
+     --> tests/ui/parse-fail/import-export-overlap2.wit:3:10
       |
-    4 |   export a: interface {}
+    3 |   export a: interface {}
       |          ^
\ No newline at end of file
diff --git a/crates/wit-component/tests/merge/bad-world1/from/deps/foo/a.wit b/crates/wit-parser/tests/ui/parse-fail/import-export-overlap3.wit
similarity index 50%
rename from crates/wit-component/tests/merge/bad-world1/from/deps/foo/a.wit
rename to crates/wit-parser/tests/ui/parse-fail/import-export-overlap3.wit
index f5721840..183e9915 100644
--- a/crates/wit-component/tests/merge/bad-world1/from/deps/foo/a.wit
+++ b/crates/wit-parser/tests/ui/parse-fail/import-export-overlap3.wit
@@ -1,11 +1,11 @@
-package foo:foo
-
 interface a {
-  type a = u32
+  type t = u32
 }
 
 world foo {
   import b: interface {
-    type a = u32
+    use self.a.{t}
   }
+  export a: interface {}
 }
+
diff --git a/crates/wit-parser/tests/ui/parse-fail/import-export-overlap3.wit.result b/crates/wit-parser/tests/ui/parse-fail/import-export-overlap3.wit.result
new file mode 100644
index 00000000..677d5a96
--- /dev/null
+++ b/crates/wit-parser/tests/ui/parse-fail/import-export-overlap3.wit.result
@@ -0,0 +1,6 @@
+export of `a` conflicts with a previous interface using the name `a`
+
+     --> tests/ui/parse-fail/import-export-overlap3.wit:9:10
+      |
+    9 |   export a: interface {}
+      |          ^
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/import-twice.wit b/crates/wit-parser/tests/ui/parse-fail/import-twice.wit
deleted file mode 100644
index 7d9a6d8c..00000000
--- a/crates/wit-parser/tests/ui/parse-fail/import-twice.wit
+++ /dev/null
@@ -1,8 +0,0 @@
-package foo:foo
-
-interface foo {}
-
-world bar {
-  import foo
-  import foo
-}
diff --git a/crates/wit-parser/tests/ui/parse-fail/import-twice.wit.result b/crates/wit-parser/tests/ui/parse-fail/import-twice.wit.result
deleted file mode 100644
index 7dfe127a..00000000
--- a/crates/wit-parser/tests/ui/parse-fail/import-twice.wit.result
+++ /dev/null
@@ -1,5 +0,0 @@
-interface cannot be imported more than once
-     --> tests/ui/parse-fail/import-twice.wit:7:10
-      |
-    7 |   import foo
-      |          ^--
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/include-cycle.wit b/crates/wit-parser/tests/ui/parse-fail/include-cycle.wit
deleted file mode 100644
index b11971b0..00000000
--- a/crates/wit-parser/tests/ui/parse-fail/include-cycle.wit
+++ /dev/null
@@ -1,9 +0,0 @@
-package foo:foo
-
-world a {
-    include b
-}
-
-world b {
-    include a
-}
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/include-cycle.wit.result b/crates/wit-parser/tests/ui/parse-fail/include-cycle.wit.result
deleted file mode 100644
index a89a1fc9..00000000
--- a/crates/wit-parser/tests/ui/parse-fail/include-cycle.wit.result
+++ /dev/null
@@ -1,5 +0,0 @@
-interface or world `b` depends on itself
-     --> tests/ui/parse-fail/include-cycle.wit:7:7
-      |
-    7 | world b {
-      |       ^
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/include-foreign.wit.result b/crates/wit-parser/tests/ui/parse-fail/include-foreign.wit.result
deleted file mode 100644
index eac7974f..00000000
--- a/crates/wit-parser/tests/ui/parse-fail/include-foreign.wit.result
+++ /dev/null
@@ -1,5 +0,0 @@
-world not found in package
-     --> tests/ui/parse-fail/include-foreign/root.wit:4:19
-      |
-    4 |   include foo:bar/bar
-      |                   ^--
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/include-foreign/deps/bar/empty.wit b/crates/wit-parser/tests/ui/parse-fail/include-foreign/deps/bar/empty.wit
deleted file mode 100644
index b6da2120..00000000
--- a/crates/wit-parser/tests/ui/parse-fail/include-foreign/deps/bar/empty.wit
+++ /dev/null
@@ -1,3 +0,0 @@
-package foo:bar
-
-interface bar {}
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/include-foreign/root.wit b/crates/wit-parser/tests/ui/parse-fail/include-foreign/root.wit
deleted file mode 100644
index 739532fa..00000000
--- a/crates/wit-parser/tests/ui/parse-fail/include-foreign/root.wit
+++ /dev/null
@@ -1,5 +0,0 @@
-package foo:foo
-
-world foo {
-  include foo:bar/bar
-}
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/include-with-id.wit b/crates/wit-parser/tests/ui/parse-fail/include-with-id.wit
deleted file mode 100644
index 77016c3b..00000000
--- a/crates/wit-parser/tests/ui/parse-fail/include-with-id.wit
+++ /dev/null
@@ -1,11 +0,0 @@
-package foo:foo
-
-interface foo {}
-
-world a {
-    import foo
-}
-
-world b {
-    include a with { foo:foo/foo as foo2 }
-}
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/include-with-id.wit.result b/crates/wit-parser/tests/ui/parse-fail/include-with-id.wit.result
deleted file mode 100644
index 587e9a66..00000000
--- a/crates/wit-parser/tests/ui/parse-fail/include-with-id.wit.result
+++ /dev/null
@@ -1,5 +0,0 @@
-expected keyword `as`, found ':'
-     --> tests/ui/parse-fail/include-with-id.wit:10:25
-      |
-   10 |     include a with { foo:foo/foo as foo2 }
-      |                         ^
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/include-with-on-id.wit b/crates/wit-parser/tests/ui/parse-fail/include-with-on-id.wit
deleted file mode 100644
index 2cb8c570..00000000
--- a/crates/wit-parser/tests/ui/parse-fail/include-with-on-id.wit
+++ /dev/null
@@ -1,11 +0,0 @@
-package foo:foo
-
-interface foo {}
-
-world a {
-    import foo
-}
-
-world b {
-    include a with { foo as foo2 }
-}
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/include-with-on-id.wit.result b/crates/wit-parser/tests/ui/parse-fail/include-with-on-id.wit.result
deleted file mode 100644
index 732f000b..00000000
--- a/crates/wit-parser/tests/ui/parse-fail/include-with-on-id.wit.result
+++ /dev/null
@@ -1,5 +0,0 @@
-no import or export kebab-name `foo`. Note that an ID does not support renaming
-     --> tests/ui/parse-fail/include-with-on-id.wit:10:13
-      |
-   10 |     include a with { foo as foo2 }
-      |             ^
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/invalid-md.wit.result b/crates/wit-parser/tests/ui/parse-fail/invalid-md.wit.result
index ed4f7e1c..6a5becd6 100644
--- a/crates/wit-parser/tests/ui/parse-fail/invalid-md.wit.result
+++ b/crates/wit-parser/tests/ui/parse-fail/invalid-md.wit.result
@@ -1,4 +1,4 @@
-expected `world`, `interface` or `use`, found keyword `type`
+expected `default`, `world` or `interface`, found keyword `type`
      --> tests/ui/parse-fail/invalid-md.md:6:1
       |
     6 | type foo = bar
diff --git a/crates/wit-parser/tests/ui/parse-fail/invalid-type-reference.wit b/crates/wit-parser/tests/ui/parse-fail/invalid-type-reference.wit
index 512837e6..da928672 100644
--- a/crates/wit-parser/tests/ui/parse-fail/invalid-type-reference.wit
+++ b/crates/wit-parser/tests/ui/parse-fail/invalid-type-reference.wit
@@ -1,5 +1,3 @@
-package foo:foo
-
 interface foo {
   x: func()
 
diff --git a/crates/wit-parser/tests/ui/parse-fail/invalid-type-reference.wit.result b/crates/wit-parser/tests/ui/parse-fail/invalid-type-reference.wit.result
index d7861f14..1c872a1c 100644
--- a/crates/wit-parser/tests/ui/parse-fail/invalid-type-reference.wit.result
+++ b/crates/wit-parser/tests/ui/parse-fail/invalid-type-reference.wit.result
@@ -1,5 +1,5 @@
 type `x` does not exist
-     --> tests/ui/parse-fail/invalid-type-reference.wit:8:8
+     --> tests/ui/parse-fail/invalid-type-reference.wit:6:8
       |
-    8 |     a: x
+    6 |     a: x
       |        ^
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/invalid-type-reference2.wit b/crates/wit-parser/tests/ui/parse-fail/invalid-type-reference2.wit
index 694ccbc2..c2f7393c 100644
--- a/crates/wit-parser/tests/ui/parse-fail/invalid-type-reference2.wit
+++ b/crates/wit-parser/tests/ui/parse-fail/invalid-type-reference2.wit
@@ -1,5 +1,3 @@
-package foo:foo
-
 interface foo {
   x: func()
   y: func() -> x
diff --git a/crates/wit-parser/tests/ui/parse-fail/invalid-type-reference2.wit.result b/crates/wit-parser/tests/ui/parse-fail/invalid-type-reference2.wit.result
index f3899ab5..6637a36a 100644
--- a/crates/wit-parser/tests/ui/parse-fail/invalid-type-reference2.wit.result
+++ b/crates/wit-parser/tests/ui/parse-fail/invalid-type-reference2.wit.result
@@ -1,5 +1,5 @@
 cannot use function `x` as a type
-     --> tests/ui/parse-fail/invalid-type-reference2.wit:5:16
+     --> tests/ui/parse-fail/invalid-type-reference2.wit:3:16
       |
-    5 |   y: func() -> x
+    3 |   y: func() -> x
       |                ^
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/missing-package.wit b/crates/wit-parser/tests/ui/parse-fail/invalid@filename.wit
similarity index 100%
rename from crates/wit-parser/tests/ui/parse-fail/missing-package.wit
rename to crates/wit-parser/tests/ui/parse-fail/invalid@filename.wit
diff --git a/crates/wit-parser/tests/ui/parse-fail/invalid@filename.wit.result b/crates/wit-parser/tests/ui/parse-fail/invalid@filename.wit.result
new file mode 100644
index 00000000..461cca9d
--- /dev/null
+++ b/crates/wit-parser/tests/ui/parse-fail/invalid@filename.wit.result
@@ -0,0 +1,4 @@
+failed to start resolving path: tests/ui/parse-fail/invalid@filename.wit
+
+Caused by:
+    name of document isn't a valid WIT identifier `invalid@filename`: invalid character in identifier '@'
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/kebab-name-include-not-found.wit b/crates/wit-parser/tests/ui/parse-fail/kebab-name-include-not-found.wit
deleted file mode 100644
index 506d37be..00000000
--- a/crates/wit-parser/tests/ui/parse-fail/kebab-name-include-not-found.wit
+++ /dev/null
@@ -1,8 +0,0 @@
-package foo:foo
-
-world foo { import a: func() }
-world bar { import a: func() }
-world baz { 
-    include foo with { b1 as b2 }
-    include bar with { a as b }
-}
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/kebab-name-include-not-found.wit.result b/crates/wit-parser/tests/ui/parse-fail/kebab-name-include-not-found.wit.result
deleted file mode 100644
index 5416037a..00000000
--- a/crates/wit-parser/tests/ui/parse-fail/kebab-name-include-not-found.wit.result
+++ /dev/null
@@ -1,5 +0,0 @@
-no import or export kebab-name `b1`. Note that an ID does not support renaming
-     --> tests/ui/parse-fail/kebab-name-include-not-found.wit:6:13
-      |
-    6 |     include foo with { b1 as b2 }
-      |             ^--
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/kebab-name-include.wit b/crates/wit-parser/tests/ui/parse-fail/kebab-name-include.wit
deleted file mode 100644
index 59c2fae5..00000000
--- a/crates/wit-parser/tests/ui/parse-fail/kebab-name-include.wit
+++ /dev/null
@@ -1,8 +0,0 @@
-package foo:foo
-
-world foo { import a: func() }
-world bar { import a: func() }
-world baz { 
-    include foo 
-    include bar 
-}
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/kebab-name-include.wit.result b/crates/wit-parser/tests/ui/parse-fail/kebab-name-include.wit.result
deleted file mode 100644
index d9f901c7..00000000
--- a/crates/wit-parser/tests/ui/parse-fail/kebab-name-include.wit.result
+++ /dev/null
@@ -1,5 +0,0 @@
-import of `a` shadows previously imported items
-     --> tests/ui/parse-fail/kebab-name-include.wit:7:13
-      |
-    7 |     include bar 
-      |             ^--
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/missing-package.wit.result b/crates/wit-parser/tests/ui/parse-fail/missing-package.wit.result
deleted file mode 100644
index d25b316c..00000000
--- a/crates/wit-parser/tests/ui/parse-fail/missing-package.wit.result
+++ /dev/null
@@ -1 +0,0 @@
-no `package` header was found in any WIT file for this package
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/no-access-to-sibling-use.wit.result b/crates/wit-parser/tests/ui/parse-fail/no-access-to-sibling-use.wit.result
deleted file mode 100644
index fa297480..00000000
--- a/crates/wit-parser/tests/ui/parse-fail/no-access-to-sibling-use.wit.result
+++ /dev/null
@@ -1,8 +0,0 @@
-failed to parse package: tests/ui/parse-fail/no-access-to-sibling-use
-
-Caused by:
-    interface or world `bar-renamed` does not exist
-         --> tests/ui/parse-fail/no-access-to-sibling-use/foo.wit:3:5
-          |
-        3 | use bar-renamed
-          |     ^----------
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/no-access-to-sibling-use/bar.wit b/crates/wit-parser/tests/ui/parse-fail/no-access-to-sibling-use/bar.wit
deleted file mode 100644
index a08b2305..00000000
--- a/crates/wit-parser/tests/ui/parse-fail/no-access-to-sibling-use/bar.wit
+++ /dev/null
@@ -1 +0,0 @@
-use bar as bar-renamed
diff --git a/crates/wit-parser/tests/ui/parse-fail/no-access-to-sibling-use/foo.wit b/crates/wit-parser/tests/ui/parse-fail/no-access-to-sibling-use/foo.wit
deleted file mode 100644
index 01778b73..00000000
--- a/crates/wit-parser/tests/ui/parse-fail/no-access-to-sibling-use/foo.wit
+++ /dev/null
@@ -1,5 +0,0 @@
-package foo:foo
-
-use bar-renamed
-
-interface bar {}
diff --git a/crates/wit-parser/tests/ui/parse-fail/non-existance-world-include.wit.result b/crates/wit-parser/tests/ui/parse-fail/non-existance-world-include.wit.result
deleted file mode 100644
index 756ac8f4..00000000
--- a/crates/wit-parser/tests/ui/parse-fail/non-existance-world-include.wit.result
+++ /dev/null
@@ -1,5 +0,0 @@
-world not found in package
-     --> tests/ui/parse-fail/non-existance-world-include/root.wit:4:19
-      |
-    4 |   include foo:baz/non-existance
-      |                   ^------------
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/non-existance-world-include/deps/bar/baz.wit b/crates/wit-parser/tests/ui/parse-fail/non-existance-world-include/deps/bar/baz.wit
deleted file mode 100644
index 195539f4..00000000
--- a/crates/wit-parser/tests/ui/parse-fail/non-existance-world-include/deps/bar/baz.wit
+++ /dev/null
@@ -1,4 +0,0 @@
-package foo:baz
-
-interface bar {}
-
diff --git a/crates/wit-parser/tests/ui/parse-fail/non-existance-world-include/root.wit b/crates/wit-parser/tests/ui/parse-fail/non-existance-world-include/root.wit
deleted file mode 100644
index 6bc8e5f9..00000000
--- a/crates/wit-parser/tests/ui/parse-fail/non-existance-world-include/root.wit
+++ /dev/null
@@ -1,5 +0,0 @@
-package foo:foo
-
-world foo {
-  include foo:baz/non-existance
-}
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/pkg-cycle.wit.result b/crates/wit-parser/tests/ui/parse-fail/pkg-cycle.wit.result
index fa1777f5..d7fbbe11 100644
--- a/crates/wit-parser/tests/ui/parse-fail/pkg-cycle.wit.result
+++ b/crates/wit-parser/tests/ui/parse-fail/pkg-cycle.wit.result
@@ -1,5 +1,5 @@
 package depends on itself
-     --> tests/ui/parse-fail/pkg-cycle/deps/a1/root.wit:3:7
+     --> tests/ui/parse-fail/pkg-cycle/deps/a1/root.wit:2:7
       |
-    3 |   use foo:a1/foo.{}
-      |       ^-----
\ No newline at end of file
+    2 |   use a1.foo.{}
+      |       ^-
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/pkg-cycle/deps/a1/root.wit b/crates/wit-parser/tests/ui/parse-fail/pkg-cycle/deps/a1/root.wit
index fc18ee3a..9a23dbfd 100644
--- a/crates/wit-parser/tests/ui/parse-fail/pkg-cycle/deps/a1/root.wit
+++ b/crates/wit-parser/tests/ui/parse-fail/pkg-cycle/deps/a1/root.wit
@@ -1,4 +1,3 @@
-package foo:a1
 interface foo {
-  use foo:a1/foo.{}
+  use a1.foo.{}
 }
diff --git a/crates/wit-parser/tests/ui/parse-fail/pkg-cycle/root.wit b/crates/wit-parser/tests/ui/parse-fail/pkg-cycle/root.wit
index 1eae3231..9a23dbfd 100644
--- a/crates/wit-parser/tests/ui/parse-fail/pkg-cycle/root.wit
+++ b/crates/wit-parser/tests/ui/parse-fail/pkg-cycle/root.wit
@@ -1,4 +1,3 @@
-package foo:foo
 interface foo {
-  use foo:a1/foo.{}
+  use a1.foo.{}
 }
diff --git a/crates/wit-parser/tests/ui/parse-fail/pkg-cycle2.wit.result b/crates/wit-parser/tests/ui/parse-fail/pkg-cycle2.wit.result
index e5216858..b7ccf5a0 100644
--- a/crates/wit-parser/tests/ui/parse-fail/pkg-cycle2.wit.result
+++ b/crates/wit-parser/tests/ui/parse-fail/pkg-cycle2.wit.result
@@ -1,5 +1,5 @@
 package depends on itself
-     --> tests/ui/parse-fail/pkg-cycle2/deps/a1/root.wit:3:7
+     --> tests/ui/parse-fail/pkg-cycle2/deps/a2/root.wit:2:7
       |
-    3 |   use foo:a2/foo.{}
-      |       ^-----
\ No newline at end of file
+    2 |   use a1.foo.{}
+      |       ^-
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/pkg-cycle2/deps/a1/root.wit b/crates/wit-parser/tests/ui/parse-fail/pkg-cycle2/deps/a1/root.wit
index ff53a7eb..9e8ae2bb 100644
--- a/crates/wit-parser/tests/ui/parse-fail/pkg-cycle2/deps/a1/root.wit
+++ b/crates/wit-parser/tests/ui/parse-fail/pkg-cycle2/deps/a1/root.wit
@@ -1,4 +1,3 @@
-package foo:a1
 interface foo {
-  use foo:a2/foo.{}
+  use a2.foo.{}
 }
diff --git a/crates/wit-parser/tests/ui/parse-fail/pkg-cycle2/deps/a2/root.wit b/crates/wit-parser/tests/ui/parse-fail/pkg-cycle2/deps/a2/root.wit
index b52fe402..9a23dbfd 100644
--- a/crates/wit-parser/tests/ui/parse-fail/pkg-cycle2/deps/a2/root.wit
+++ b/crates/wit-parser/tests/ui/parse-fail/pkg-cycle2/deps/a2/root.wit
@@ -1,4 +1,3 @@
-package foo:a2
 interface foo {
-  use foo:a1/foo.{}
+  use a1.foo.{}
 }
diff --git a/crates/wit-parser/tests/ui/parse-fail/pkg-cycle2/root.wit b/crates/wit-parser/tests/ui/parse-fail/pkg-cycle2/root.wit
index 45c0d225..9a23dbfd 100644
--- a/crates/wit-parser/tests/ui/parse-fail/pkg-cycle2/root.wit
+++ b/crates/wit-parser/tests/ui/parse-fail/pkg-cycle2/root.wit
@@ -1,4 +1,3 @@
-package foo:root
 interface foo {
-  use foo:a1/foo.{}
+  use a1.foo.{}
 }
diff --git a/crates/wit-parser/tests/ui/parse-fail/type-and-resource-same-name.wit.result b/crates/wit-parser/tests/ui/parse-fail/type-and-resource-same-name.wit.result
deleted file mode 100644
index 92159eba..00000000
--- a/crates/wit-parser/tests/ui/parse-fail/type-and-resource-same-name.wit.result
+++ /dev/null
@@ -1,5 +0,0 @@
-type used in a handle must be a resource
-     --> tests/ui/parse-fail/type-and-resource-same-name/foo.wit:7:20
-      |
-    7 |   type t2 = borrow<a>
-      |                    ^
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/type-and-resource-same-name/deps/dep/foo.wit b/crates/wit-parser/tests/ui/parse-fail/type-and-resource-same-name/deps/dep/foo.wit
deleted file mode 100644
index dd21d5c8..00000000
--- a/crates/wit-parser/tests/ui/parse-fail/type-and-resource-same-name/deps/dep/foo.wit
+++ /dev/null
@@ -1,5 +0,0 @@
-package some:dep
-
-interface foo {
-  type a = u32
-}
diff --git a/crates/wit-parser/tests/ui/parse-fail/type-and-resource-same-name/foo.wit b/crates/wit-parser/tests/ui/parse-fail/type-and-resource-same-name/foo.wit
deleted file mode 100644
index 767c231e..00000000
--- a/crates/wit-parser/tests/ui/parse-fail/type-and-resource-same-name/foo.wit
+++ /dev/null
@@ -1,8 +0,0 @@
-package foo:bar
-
-interface foo {
-  use some:dep/foo.{a}
-
-  type t1 = a
-  type t2 = borrow<a>
-}
diff --git a/crates/wit-parser/tests/ui/parse-fail/undefined-typed.wit b/crates/wit-parser/tests/ui/parse-fail/undefined-typed.wit
index 46eff1d7..7467f94d 100644
--- a/crates/wit-parser/tests/ui/parse-fail/undefined-typed.wit
+++ b/crates/wit-parser/tests/ui/parse-fail/undefined-typed.wit
@@ -1,5 +1,4 @@
 // parse-fail
-package foo:foo
 
 interface foo {
   type foo = bar
diff --git a/crates/wit-parser/tests/ui/parse-fail/undefined-typed.wit.result b/crates/wit-parser/tests/ui/parse-fail/undefined-typed.wit.result
index 162404ae..aba06b4b 100644
--- a/crates/wit-parser/tests/ui/parse-fail/undefined-typed.wit.result
+++ b/crates/wit-parser/tests/ui/parse-fail/undefined-typed.wit.result
@@ -1,5 +1,5 @@
 type `bar` does not exist
-     --> tests/ui/parse-fail/undefined-typed.wit:5:14
+     --> tests/ui/parse-fail/undefined-typed.wit:4:14
       |
-    5 |   type foo = bar
+    4 |   type foo = bar
       |              ^--
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/union-fuzz-2.wit b/crates/wit-parser/tests/ui/parse-fail/union-fuzz-2.wit
deleted file mode 100644
index 8e7bf637..00000000
--- a/crates/wit-parser/tests/ui/parse-fail/union-fuzz-2.wit
+++ /dev/null
@@ -1,12 +0,0 @@
-package foo:bar
-
-world foo {
-    export foo: func() -> (%name2: float32)
-}
-    
-
-world bar {
-    include foo
-    
-    record foo {}
-}
diff --git a/crates/wit-parser/tests/ui/parse-fail/union-fuzz-2.wit.result b/crates/wit-parser/tests/ui/parse-fail/union-fuzz-2.wit.result
deleted file mode 100644
index a2d50f62..00000000
--- a/crates/wit-parser/tests/ui/parse-fail/union-fuzz-2.wit.result
+++ /dev/null
@@ -1,5 +0,0 @@
-import type `foo` conflicts with prior export of interface
-     --> tests/ui/parse-fail/union-fuzz-2.wit:11:12
-      |
-   11 |     record foo {}
-      |            ^--
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/unknown-interface.wit b/crates/wit-parser/tests/ui/parse-fail/unknown-interface.wit
index 3f735e53..8fe521bf 100644
--- a/crates/wit-parser/tests/ui/parse-fail/unknown-interface.wit
+++ b/crates/wit-parser/tests/ui/parse-fail/unknown-interface.wit
@@ -1,7 +1,5 @@
 // parse-fail
 
-package foo:foo
-
 world foo {
-  import bar
+  import bar: self.bar
 }
diff --git a/crates/wit-parser/tests/ui/parse-fail/unknown-interface.wit.result b/crates/wit-parser/tests/ui/parse-fail/unknown-interface.wit.result
index bb72a5b5..14385225 100644
--- a/crates/wit-parser/tests/ui/parse-fail/unknown-interface.wit.result
+++ b/crates/wit-parser/tests/ui/parse-fail/unknown-interface.wit.result
@@ -1,5 +1,5 @@
-interface or world `bar` does not exist
-     --> tests/ui/parse-fail/unknown-interface.wit:6:10
+interface does not exist
+     --> tests/ui/parse-fail/unknown-interface.wit:4:20
       |
-    6 |   import bar
-      |          ^--
\ No newline at end of file
+    4 |   import bar: self.bar
+      |                    ^--
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/unresolved-interface1.wit b/crates/wit-parser/tests/ui/parse-fail/unresolved-interface1.wit
index 12167a22..cc1b6ae3 100644
--- a/crates/wit-parser/tests/ui/parse-fail/unresolved-interface1.wit
+++ b/crates/wit-parser/tests/ui/parse-fail/unresolved-interface1.wit
@@ -1,7 +1,5 @@
 // parse-fail
 
-package foo:foo
-
 world foo {
-  import foo
+  import foo: self.foo
 }
diff --git a/crates/wit-parser/tests/ui/parse-fail/unresolved-interface1.wit.result b/crates/wit-parser/tests/ui/parse-fail/unresolved-interface1.wit.result
index 13bfe932..dc6cea3c 100644
--- a/crates/wit-parser/tests/ui/parse-fail/unresolved-interface1.wit.result
+++ b/crates/wit-parser/tests/ui/parse-fail/unresolved-interface1.wit.result
@@ -1,5 +1,5 @@
 name `foo` is defined as a world, not an interface
-     --> tests/ui/parse-fail/unresolved-interface1.wit:6:10
+     --> tests/ui/parse-fail/unresolved-interface1.wit:4:20
       |
-    6 |   import foo
-      |          ^--
\ No newline at end of file
+    4 |   import foo: self.foo
+      |                    ^--
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/unresolved-interface2.wit b/crates/wit-parser/tests/ui/parse-fail/unresolved-interface2.wit
index 5aa93b23..8a67d92f 100644
--- a/crates/wit-parser/tests/ui/parse-fail/unresolved-interface2.wit
+++ b/crates/wit-parser/tests/ui/parse-fail/unresolved-interface2.wit
@@ -1,8 +1,6 @@
 // parse-fail
 
-package foo:foo
-
 world foo {
-  import bar
+  import foo: self.bar
 }
 
diff --git a/crates/wit-parser/tests/ui/parse-fail/unresolved-interface2.wit.result b/crates/wit-parser/tests/ui/parse-fail/unresolved-interface2.wit.result
index 448a9775..f230df6e 100644
--- a/crates/wit-parser/tests/ui/parse-fail/unresolved-interface2.wit.result
+++ b/crates/wit-parser/tests/ui/parse-fail/unresolved-interface2.wit.result
@@ -1,5 +1,5 @@
-interface or world `bar` does not exist
-     --> tests/ui/parse-fail/unresolved-interface2.wit:6:10
+interface does not exist
+     --> tests/ui/parse-fail/unresolved-interface2.wit:4:20
       |
-    6 |   import bar
-      |          ^--
\ No newline at end of file
+    4 |   import foo: self.bar
+      |                    ^--
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/unresolved-interface3.wit b/crates/wit-parser/tests/ui/parse-fail/unresolved-interface3.wit
index f799bfb7..61683dde 100644
--- a/crates/wit-parser/tests/ui/parse-fail/unresolved-interface3.wit
+++ b/crates/wit-parser/tests/ui/parse-fail/unresolved-interface3.wit
@@ -1,5 +1,5 @@
 // parse-fail
 
-package foo:foo
-
-use bar as foo
+world foo {
+  import foo: pkg.foo.bar
+}
diff --git a/crates/wit-parser/tests/ui/parse-fail/unresolved-interface3.wit.result b/crates/wit-parser/tests/ui/parse-fail/unresolved-interface3.wit.result
index 828f9c20..b7c4ba67 100644
--- a/crates/wit-parser/tests/ui/parse-fail/unresolved-interface3.wit.result
+++ b/crates/wit-parser/tests/ui/parse-fail/unresolved-interface3.wit.result
@@ -1,5 +1,5 @@
-interface or world `bar` does not exist
-     --> tests/ui/parse-fail/unresolved-interface3.wit:5:5
+document `foo` does not exist
+     --> tests/ui/parse-fail/unresolved-interface3.wit:4:19
       |
-    5 | use bar as foo
-      |     ^--
\ No newline at end of file
+    4 |   import foo: pkg.foo.bar
+      |                   ^--
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/unresolved-interface4.wit b/crates/wit-parser/tests/ui/parse-fail/unresolved-interface4.wit
index 63ea8b92..29817a23 100644
--- a/crates/wit-parser/tests/ui/parse-fail/unresolved-interface4.wit
+++ b/crates/wit-parser/tests/ui/parse-fail/unresolved-interface4.wit
@@ -1,7 +1,5 @@
 // parse-fail
 
-package foo:foo
-
 world foo {
-  import some:dependency/iface
+  import foo: pkg.unresolved-interface4
 }
diff --git a/crates/wit-parser/tests/ui/parse-fail/unresolved-interface4.wit.result b/crates/wit-parser/tests/ui/parse-fail/unresolved-interface4.wit.result
index 3e772ae6..e3f55f5b 100644
--- a/crates/wit-parser/tests/ui/parse-fail/unresolved-interface4.wit.result
+++ b/crates/wit-parser/tests/ui/parse-fail/unresolved-interface4.wit.result
@@ -1,5 +1,5 @@
-package not found
-     --> tests/ui/parse-fail/unresolved-interface4.wit:6:10
+document does not specify a default interface
+     --> tests/ui/parse-fail/unresolved-interface4.wit:4:19
       |
-    6 |   import some:dependency/iface
-      |          ^--------------
\ No newline at end of file
+    4 |   import foo: pkg.unresolved-interface4
+      |                   ^--------------------
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/unresolved-interface5.wit b/crates/wit-parser/tests/ui/parse-fail/unresolved-interface5.wit
new file mode 100644
index 00000000..fa943c2a
--- /dev/null
+++ b/crates/wit-parser/tests/ui/parse-fail/unresolved-interface5.wit
@@ -0,0 +1,5 @@
+// parse-fail
+
+world foo {
+  import foo: pkg.unresolved-interface5.bar
+}
diff --git a/crates/wit-parser/tests/ui/parse-fail/unresolved-interface5.wit.result b/crates/wit-parser/tests/ui/parse-fail/unresolved-interface5.wit.result
new file mode 100644
index 00000000..fc5a01ae
--- /dev/null
+++ b/crates/wit-parser/tests/ui/parse-fail/unresolved-interface5.wit.result
@@ -0,0 +1,5 @@
+interface does not exist
+     --> tests/ui/parse-fail/unresolved-interface5.wit:4:41
+      |
+    4 |   import foo: pkg.unresolved-interface5.bar
+      |                                         ^--
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/unresolved-use1.wit b/crates/wit-parser/tests/ui/parse-fail/unresolved-use1.wit
index 745b44b9..f4b7dd5b 100644
--- a/crates/wit-parser/tests/ui/parse-fail/unresolved-use1.wit
+++ b/crates/wit-parser/tests/ui/parse-fail/unresolved-use1.wit
@@ -1,7 +1,5 @@
 // parse-fail
 
-package foo:foo
-
 interface foo {
-  use bar.{x}
+  use self.bar.{x}
 }
diff --git a/crates/wit-parser/tests/ui/parse-fail/unresolved-use1.wit.result b/crates/wit-parser/tests/ui/parse-fail/unresolved-use1.wit.result
index adfee891..33708bc6 100644
--- a/crates/wit-parser/tests/ui/parse-fail/unresolved-use1.wit.result
+++ b/crates/wit-parser/tests/ui/parse-fail/unresolved-use1.wit.result
@@ -1,5 +1,5 @@
-interface or world `bar` not found in package
-     --> tests/ui/parse-fail/unresolved-use1.wit:6:7
+interface `bar` does not exist
+     --> tests/ui/parse-fail/unresolved-use1.wit:4:12
       |
-    6 |   use bar.{x}
-      |       ^--
\ No newline at end of file
+    4 |   use self.bar.{x}
+      |            ^--
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/unresolved-use10.wit.result b/crates/wit-parser/tests/ui/parse-fail/unresolved-use10.wit.result
index df68a387..bb1504e2 100644
--- a/crates/wit-parser/tests/ui/parse-fail/unresolved-use10.wit.result
+++ b/crates/wit-parser/tests/ui/parse-fail/unresolved-use10.wit.result
@@ -1,8 +1,8 @@
 failed to parse package: tests/ui/parse-fail/unresolved-use10
 
 Caused by:
-    name `thing` is not defined
-         --> tests/ui/parse-fail/unresolved-use10/bar.wit:4:12
+    document does not specify a default interface
+         --> tests/ui/parse-fail/unresolved-use10/bar.wit:2:11
           |
-        4 |   use foo.{thing}
-          |            ^----
\ No newline at end of file
+        2 |   use pkg.foo.{thing}
+          |           ^--
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/unresolved-use10/bar.wit b/crates/wit-parser/tests/ui/parse-fail/unresolved-use10/bar.wit
index e6c479bc..82806f68 100644
--- a/crates/wit-parser/tests/ui/parse-fail/unresolved-use10/bar.wit
+++ b/crates/wit-parser/tests/ui/parse-fail/unresolved-use10/bar.wit
@@ -1,5 +1,3 @@
-package foo:foo
-
 interface bar {
-  use foo.{thing}
+  use pkg.foo.{thing}
 }
diff --git a/crates/wit-parser/tests/ui/parse-fail/unresolved-use11.wit.result b/crates/wit-parser/tests/ui/parse-fail/unresolved-use11.wit.result
new file mode 100644
index 00000000..afdbcf6f
--- /dev/null
+++ b/crates/wit-parser/tests/ui/parse-fail/unresolved-use11.wit.result
@@ -0,0 +1,8 @@
+failed to parse package: tests/ui/parse-fail/unresolved-use11
+
+Caused by:
+    name `thing` is not defined
+         --> tests/ui/parse-fail/unresolved-use11/bar.wit:2:16
+          |
+        2 |   use pkg.foo.{thing}
+          |                ^----
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/unresolved-use11/bar.wit b/crates/wit-parser/tests/ui/parse-fail/unresolved-use11/bar.wit
new file mode 100644
index 00000000..82806f68
--- /dev/null
+++ b/crates/wit-parser/tests/ui/parse-fail/unresolved-use11/bar.wit
@@ -0,0 +1,3 @@
+interface bar {
+  use pkg.foo.{thing}
+}
diff --git a/crates/wit-parser/tests/ui/parse-fail/unresolved-use11/foo.wit b/crates/wit-parser/tests/ui/parse-fail/unresolved-use11/foo.wit
new file mode 100644
index 00000000..3e6a7e9c
--- /dev/null
+++ b/crates/wit-parser/tests/ui/parse-fail/unresolved-use11/foo.wit
@@ -0,0 +1,2 @@
+default interface foo {
+}
diff --git a/crates/wit-parser/tests/ui/parse-fail/unresolved-use2.wit b/crates/wit-parser/tests/ui/parse-fail/unresolved-use2.wit
index 69ae75f0..402c72b6 100644
--- a/crates/wit-parser/tests/ui/parse-fail/unresolved-use2.wit
+++ b/crates/wit-parser/tests/ui/parse-fail/unresolved-use2.wit
@@ -1,9 +1,7 @@
 // parse-fail
 
-package foo:foo
-
 interface foo {
-  use bar.{x}
+  use self.bar.{x}
 }
 
 interface bar {
diff --git a/crates/wit-parser/tests/ui/parse-fail/unresolved-use2.wit.result b/crates/wit-parser/tests/ui/parse-fail/unresolved-use2.wit.result
index f44ca7cf..3a43a8fe 100644
--- a/crates/wit-parser/tests/ui/parse-fail/unresolved-use2.wit.result
+++ b/crates/wit-parser/tests/ui/parse-fail/unresolved-use2.wit.result
@@ -1,5 +1,5 @@
 name `x` is not defined
-     --> tests/ui/parse-fail/unresolved-use2.wit:6:12
+     --> tests/ui/parse-fail/unresolved-use2.wit:4:17
       |
-    6 |   use bar.{x}
-      |            ^
\ No newline at end of file
+    4 |   use self.bar.{x}
+      |                 ^
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/unresolved-use3.wit b/crates/wit-parser/tests/ui/parse-fail/unresolved-use3.wit
index 9064ef83..6b34d6ca 100644
--- a/crates/wit-parser/tests/ui/parse-fail/unresolved-use3.wit
+++ b/crates/wit-parser/tests/ui/parse-fail/unresolved-use3.wit
@@ -1,9 +1,7 @@
 // parse-fail
 
-package foo:foo
-
 interface foo {
-  use bar.{x}
+  use self.bar.{x}
 }
 
 interface bar {
diff --git a/crates/wit-parser/tests/ui/parse-fail/unresolved-use3.wit.result b/crates/wit-parser/tests/ui/parse-fail/unresolved-use3.wit.result
index 9f29adbd..3d82f081 100644
--- a/crates/wit-parser/tests/ui/parse-fail/unresolved-use3.wit.result
+++ b/crates/wit-parser/tests/ui/parse-fail/unresolved-use3.wit.result
@@ -1,5 +1,5 @@
 cannot import function `x`
-     --> tests/ui/parse-fail/unresolved-use3.wit:6:12
+     --> tests/ui/parse-fail/unresolved-use3.wit:4:17
       |
-    6 |   use bar.{x}
-      |            ^
\ No newline at end of file
+    4 |   use self.bar.{x}
+      |                 ^
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/unresolved-use4.wit b/crates/wit-parser/tests/ui/parse-fail/unresolved-use4.wit
new file mode 100644
index 00000000..a82a94b4
--- /dev/null
+++ b/crates/wit-parser/tests/ui/parse-fail/unresolved-use4.wit
@@ -0,0 +1,5 @@
+// parse-fail
+
+interface foo {
+  use pkg.something-that-does-not-exist.{x}
+}
diff --git a/crates/wit-parser/tests/ui/parse-fail/unresolved-use4.wit.result b/crates/wit-parser/tests/ui/parse-fail/unresolved-use4.wit.result
new file mode 100644
index 00000000..43bffdde
--- /dev/null
+++ b/crates/wit-parser/tests/ui/parse-fail/unresolved-use4.wit.result
@@ -0,0 +1,5 @@
+document `something-that-does-not-exist` does not exist
+     --> tests/ui/parse-fail/unresolved-use4.wit:4:11
+      |
+    4 |   use pkg.something-that-does-not-exist.{x}
+      |           ^----------------------------
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/unresolved-use5.wit b/crates/wit-parser/tests/ui/parse-fail/unresolved-use5.wit
new file mode 100644
index 00000000..f349f39f
--- /dev/null
+++ b/crates/wit-parser/tests/ui/parse-fail/unresolved-use5.wit
@@ -0,0 +1,6 @@
+// parse-fail
+
+interface foo {
+  use pkg.unresolved-use5.{x}
+}
+
diff --git a/crates/wit-parser/tests/ui/parse-fail/unresolved-use5.wit.result b/crates/wit-parser/tests/ui/parse-fail/unresolved-use5.wit.result
new file mode 100644
index 00000000..e361c989
--- /dev/null
+++ b/crates/wit-parser/tests/ui/parse-fail/unresolved-use5.wit.result
@@ -0,0 +1,5 @@
+no `default` interface in document to use from
+     --> tests/ui/parse-fail/unresolved-use5.wit:4:11
+      |
+    4 |   use pkg.unresolved-use5.{x}
+      |           ^--------------
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/unresolved-use6.wit b/crates/wit-parser/tests/ui/parse-fail/unresolved-use6.wit
new file mode 100644
index 00000000..125b2e3d
--- /dev/null
+++ b/crates/wit-parser/tests/ui/parse-fail/unresolved-use6.wit
@@ -0,0 +1,5 @@
+// parse-fail
+
+interface foo {
+  use pkg.unresolved-use6.nonexistent.{x}
+}
diff --git a/crates/wit-parser/tests/ui/parse-fail/unresolved-use6.wit.result b/crates/wit-parser/tests/ui/parse-fail/unresolved-use6.wit.result
new file mode 100644
index 00000000..e174fa54
--- /dev/null
+++ b/crates/wit-parser/tests/ui/parse-fail/unresolved-use6.wit.result
@@ -0,0 +1,5 @@
+interface `nonexistent` does not exist
+     --> tests/ui/parse-fail/unresolved-use6.wit:4:27
+      |
+    4 |   use pkg.unresolved-use6.nonexistent.{x}
+      |                           ^----------
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/unresolved-use7.wit b/crates/wit-parser/tests/ui/parse-fail/unresolved-use7.wit
index 69ae75f0..c08f4909 100644
--- a/crates/wit-parser/tests/ui/parse-fail/unresolved-use7.wit
+++ b/crates/wit-parser/tests/ui/parse-fail/unresolved-use7.wit
@@ -1,9 +1,7 @@
 // parse-fail
 
-package foo:foo
-
 interface foo {
-  use bar.{x}
+  use pkg.unresolved-use7.bar.{x}
 }
 
 interface bar {
diff --git a/crates/wit-parser/tests/ui/parse-fail/unresolved-use7.wit.result b/crates/wit-parser/tests/ui/parse-fail/unresolved-use7.wit.result
index acb4720e..418dd27c 100644
--- a/crates/wit-parser/tests/ui/parse-fail/unresolved-use7.wit.result
+++ b/crates/wit-parser/tests/ui/parse-fail/unresolved-use7.wit.result
@@ -1,5 +1,5 @@
 name `x` is not defined
-     --> tests/ui/parse-fail/unresolved-use7.wit:6:12
+     --> tests/ui/parse-fail/unresolved-use7.wit:4:32
       |
-    6 |   use bar.{x}
-      |            ^
\ No newline at end of file
+    4 |   use pkg.unresolved-use7.bar.{x}
+      |                                ^
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/unresolved-use8.wit b/crates/wit-parser/tests/ui/parse-fail/unresolved-use8.wit
index b0c9db91..dad0d2eb 100644
--- a/crates/wit-parser/tests/ui/parse-fail/unresolved-use8.wit
+++ b/crates/wit-parser/tests/ui/parse-fail/unresolved-use8.wit
@@ -1,9 +1,7 @@
 // parse-fail
 
-package foo:foo
-
 world foo {
   import foo: interface {
-    use foo.{i32}
+    use self.foo.{i32}
   }
 }
diff --git a/crates/wit-parser/tests/ui/parse-fail/unresolved-use8.wit.result b/crates/wit-parser/tests/ui/parse-fail/unresolved-use8.wit.result
index 5ebb30c8..8ed30723 100644
--- a/crates/wit-parser/tests/ui/parse-fail/unresolved-use8.wit.result
+++ b/crates/wit-parser/tests/ui/parse-fail/unresolved-use8.wit.result
@@ -1,5 +1,5 @@
 name `foo` is defined as a world, not an interface
-     --> tests/ui/parse-fail/unresolved-use8.wit:7:9
+     --> tests/ui/parse-fail/unresolved-use8.wit:5:14
       |
-    7 |     use foo.{i32}
-      |         ^--
\ No newline at end of file
+    5 |     use self.foo.{i32}
+      |              ^--
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/unresolved-use9.wit b/crates/wit-parser/tests/ui/parse-fail/unresolved-use9.wit
index 5fc2b384..83ba81ad 100644
--- a/crates/wit-parser/tests/ui/parse-fail/unresolved-use9.wit
+++ b/crates/wit-parser/tests/ui/parse-fail/unresolved-use9.wit
@@ -1,9 +1,7 @@
 // parse-fail
 
-package foo:foo
-
 world foo {
   import foo: interface {
-    use bar.{i32}
+    use self.bar.{i32}
   }
 }
diff --git a/crates/wit-parser/tests/ui/parse-fail/unresolved-use9.wit.result b/crates/wit-parser/tests/ui/parse-fail/unresolved-use9.wit.result
index f72d33d8..7bcfad2e 100644
--- a/crates/wit-parser/tests/ui/parse-fail/unresolved-use9.wit.result
+++ b/crates/wit-parser/tests/ui/parse-fail/unresolved-use9.wit.result
@@ -1,5 +1,5 @@
-interface or world `bar` does not exist
-     --> tests/ui/parse-fail/unresolved-use9.wit:7:9
+interface does not exist
+     --> tests/ui/parse-fail/unresolved-use9.wit:5:14
       |
-    7 |     use bar.{i32}
-      |         ^--
\ No newline at end of file
+    5 |     use self.bar.{i32}
+      |              ^--
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/use-and-include-world.wit.result b/crates/wit-parser/tests/ui/parse-fail/use-and-include-world.wit.result
deleted file mode 100644
index b1de64f6..00000000
--- a/crates/wit-parser/tests/ui/parse-fail/use-and-include-world.wit.result
+++ /dev/null
@@ -1,8 +0,0 @@
-failed to parse package: tests/ui/parse-fail/use-and-include-world
-
-Caused by:
-    name `bar` is defined as an interface, not a world
-         --> tests/ui/parse-fail/use-and-include-world/root.wit:6:21
-          |
-        6 |     include foo:baz/bar
-          |                     ^--
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/use-and-include-world/deps/bar/.gitkeep b/crates/wit-parser/tests/ui/parse-fail/use-and-include-world/deps/bar/.gitkeep
deleted file mode 100644
index e69de29b..00000000
diff --git a/crates/wit-parser/tests/ui/parse-fail/use-and-include-world/deps/bar/baz.wit b/crates/wit-parser/tests/ui/parse-fail/use-and-include-world/deps/bar/baz.wit
deleted file mode 100644
index 50160910..00000000
--- a/crates/wit-parser/tests/ui/parse-fail/use-and-include-world/deps/bar/baz.wit
+++ /dev/null
@@ -1,4 +0,0 @@
-package foo:baz
-
-world bar {}
-
diff --git a/crates/wit-parser/tests/ui/parse-fail/use-and-include-world/root.wit b/crates/wit-parser/tests/ui/parse-fail/use-and-include-world/root.wit
deleted file mode 100644
index 19c318be..00000000
--- a/crates/wit-parser/tests/ui/parse-fail/use-and-include-world/root.wit
+++ /dev/null
@@ -1,7 +0,0 @@
-package foo:foo
-
-use foo:baz/bar
-
-world foo {
-    include foo:baz/bar
-}
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/use-conflict.wit b/crates/wit-parser/tests/ui/parse-fail/use-conflict.wit
index 266723ef..20e158e1 100644
--- a/crates/wit-parser/tests/ui/parse-fail/use-conflict.wit
+++ b/crates/wit-parser/tests/ui/parse-fail/use-conflict.wit
@@ -1,11 +1,9 @@
 // parse-fail
 
-package foo:foo
-
 interface foo {
   type x = u32
 }
 
 interface bar {
-  use foo.{x, x}
+  use self.foo.{x, x}
 }
diff --git a/crates/wit-parser/tests/ui/parse-fail/use-conflict.wit.result b/crates/wit-parser/tests/ui/parse-fail/use-conflict.wit.result
index aab7474e..2cbe95d2 100644
--- a/crates/wit-parser/tests/ui/parse-fail/use-conflict.wit.result
+++ b/crates/wit-parser/tests/ui/parse-fail/use-conflict.wit.result
@@ -1,5 +1,5 @@
 name `x` is defined more than once
-     --> tests/ui/parse-fail/use-conflict.wit:10:15
+     --> tests/ui/parse-fail/use-conflict.wit:8:20
       |
-   10 |   use foo.{x, x}
-      |               ^
\ No newline at end of file
+    8 |   use self.foo.{x, x}
+      |                    ^
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/use-conflict2.wit b/crates/wit-parser/tests/ui/parse-fail/use-conflict2.wit
index 94116902..11a16519 100644
--- a/crates/wit-parser/tests/ui/parse-fail/use-conflict2.wit
+++ b/crates/wit-parser/tests/ui/parse-fail/use-conflict2.wit
@@ -1,13 +1,11 @@
 // parse-fail
 
-package foo:foo
-
 interface foo {
   type x = u32
 }
 
 interface bar {
-  use foo.{x}
+  use self.foo.{x}
 
   type x = s64
 }
diff --git a/crates/wit-parser/tests/ui/parse-fail/use-conflict2.wit.result b/crates/wit-parser/tests/ui/parse-fail/use-conflict2.wit.result
index 623febee..3c70f634 100644
--- a/crates/wit-parser/tests/ui/parse-fail/use-conflict2.wit.result
+++ b/crates/wit-parser/tests/ui/parse-fail/use-conflict2.wit.result
@@ -1,5 +1,5 @@
 name `x` is defined more than once
-     --> tests/ui/parse-fail/use-conflict2.wit:12:8
+     --> tests/ui/parse-fail/use-conflict2.wit:10:8
       |
-   12 |   type x = s64
+   10 |   type x = s64
       |        ^
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/use-conflict3.wit b/crates/wit-parser/tests/ui/parse-fail/use-conflict3.wit
index 5f2d418f..53a85b03 100644
--- a/crates/wit-parser/tests/ui/parse-fail/use-conflict3.wit
+++ b/crates/wit-parser/tests/ui/parse-fail/use-conflict3.wit
@@ -1,13 +1,11 @@
 // parse-fail
 
-package foo:foo
-
 interface foo {
   type x = u32
 }
 
 interface bar {
-  use foo.{x}
+  use self.foo.{x}
 
   x: func()
 }
diff --git a/crates/wit-parser/tests/ui/parse-fail/use-conflict3.wit.result b/crates/wit-parser/tests/ui/parse-fail/use-conflict3.wit.result
index 2928d26a..c9e7e41e 100644
--- a/crates/wit-parser/tests/ui/parse-fail/use-conflict3.wit.result
+++ b/crates/wit-parser/tests/ui/parse-fail/use-conflict3.wit.result
@@ -1,5 +1,5 @@
 name `x` is defined more than once
-     --> tests/ui/parse-fail/use-conflict3.wit:12:3
+     --> tests/ui/parse-fail/use-conflict3.wit:10:3
       |
-   12 |   x: func()
+   10 |   x: func()
       |   ^
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/use-cycle1.wit b/crates/wit-parser/tests/ui/parse-fail/use-cycle1.wit
index b961b8db..a1abaeca 100644
--- a/crates/wit-parser/tests/ui/parse-fail/use-cycle1.wit
+++ b/crates/wit-parser/tests/ui/parse-fail/use-cycle1.wit
@@ -1,7 +1,5 @@
 // parse-fail
 
-package foo:foo
-
 interface foo {
-  use foo.{bar}
+  use self.foo.{bar}
 }
diff --git a/crates/wit-parser/tests/ui/parse-fail/use-cycle1.wit.result b/crates/wit-parser/tests/ui/parse-fail/use-cycle1.wit.result
index 984ecb59..8c7950ed 100644
--- a/crates/wit-parser/tests/ui/parse-fail/use-cycle1.wit.result
+++ b/crates/wit-parser/tests/ui/parse-fail/use-cycle1.wit.result
@@ -1,5 +1,5 @@
-interface or world `foo` depends on itself
-     --> tests/ui/parse-fail/use-cycle1.wit:5:11
+interface `foo` depends on itself
+     --> tests/ui/parse-fail/use-cycle1.wit:4:12
       |
-    5 | interface foo {
-      |           ^--
\ No newline at end of file
+    4 |   use self.foo.{bar}
+      |            ^--
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/use-cycle2.wit b/crates/wit-parser/tests/ui/parse-fail/use-cycle2.wit
new file mode 100644
index 00000000..7d416e30
--- /dev/null
+++ b/crates/wit-parser/tests/ui/parse-fail/use-cycle2.wit
@@ -0,0 +1,5 @@
+// parse-fail
+
+interface foo {
+  use pkg.use-cycle2.foo.{bar}
+}
diff --git a/crates/wit-parser/tests/ui/parse-fail/use-cycle2.wit.result b/crates/wit-parser/tests/ui/parse-fail/use-cycle2.wit.result
new file mode 100644
index 00000000..8af25543
--- /dev/null
+++ b/crates/wit-parser/tests/ui/parse-fail/use-cycle2.wit.result
@@ -0,0 +1,5 @@
+interface `foo` depends on itself
+     --> tests/ui/parse-fail/use-cycle2.wit:4:22
+      |
+    4 |   use pkg.use-cycle2.foo.{bar}
+      |                      ^--
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/use-cycle3.wit b/crates/wit-parser/tests/ui/parse-fail/use-cycle3.wit
new file mode 100644
index 00000000..7edf7822
--- /dev/null
+++ b/crates/wit-parser/tests/ui/parse-fail/use-cycle3.wit
@@ -0,0 +1,6 @@
+// parse-fail
+
+default interface foo {
+  // TODO: this could use a better error message
+  use pkg.use-cycle3.{bar}
+}
diff --git a/crates/wit-parser/tests/ui/parse-fail/use-cycle3.wit.result b/crates/wit-parser/tests/ui/parse-fail/use-cycle3.wit.result
new file mode 100644
index 00000000..ff6d459c
--- /dev/null
+++ b/crates/wit-parser/tests/ui/parse-fail/use-cycle3.wit.result
@@ -0,0 +1,5 @@
+interface `foo` depends on itself
+     --> tests/ui/parse-fail/use-cycle3.wit:5:11
+      |
+    5 |   use pkg.use-cycle3.{bar}
+      |           ^---------
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/use-cycle4.wit b/crates/wit-parser/tests/ui/parse-fail/use-cycle4.wit
index f8bef245..9fe1fbae 100644
--- a/crates/wit-parser/tests/ui/parse-fail/use-cycle4.wit
+++ b/crates/wit-parser/tests/ui/parse-fail/use-cycle4.wit
@@ -1,14 +1,13 @@
 // parse-fail
-package foo:foo
 
 interface foo {
-  use bar.{y}
+  use self.bar.{y}
 
   type x = u32
 }
 
 interface bar {
-  use foo.{x}
+  use self.foo.{x}
 
   type y = u32
 }
diff --git a/crates/wit-parser/tests/ui/parse-fail/use-cycle4.wit.result b/crates/wit-parser/tests/ui/parse-fail/use-cycle4.wit.result
index 11ece35a..65b73941 100644
--- a/crates/wit-parser/tests/ui/parse-fail/use-cycle4.wit.result
+++ b/crates/wit-parser/tests/ui/parse-fail/use-cycle4.wit.result
@@ -1,5 +1,5 @@
-interface or world `bar` depends on itself
-     --> tests/ui/parse-fail/use-cycle4.wit:10:11
+interface `bar` depends on itself
+     --> tests/ui/parse-fail/use-cycle4.wit:4:12
       |
-   10 | interface bar {
-      |           ^--
\ No newline at end of file
+    4 |   use self.bar.{y}
+      |            ^--
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/use-from-package-world.wit b/crates/wit-parser/tests/ui/parse-fail/use-from-package-world.wit
new file mode 100644
index 00000000..5fdf01a2
--- /dev/null
+++ b/crates/wit-parser/tests/ui/parse-fail/use-from-package-world.wit
@@ -0,0 +1,8 @@
+// parse-fail
+
+world foo {
+}
+
+interface bar {
+  use pkg.use-from-package-world.foo.{x}
+}
diff --git a/crates/wit-parser/tests/ui/parse-fail/use-from-package-world.wit.result b/crates/wit-parser/tests/ui/parse-fail/use-from-package-world.wit.result
new file mode 100644
index 00000000..e1dc970f
--- /dev/null
+++ b/crates/wit-parser/tests/ui/parse-fail/use-from-package-world.wit.result
@@ -0,0 +1,5 @@
+interface does not exist
+     --> tests/ui/parse-fail/use-from-package-world.wit:7:34
+      |
+    7 |   use pkg.use-from-package-world.foo.{x}
+      |                                  ^--
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/use-from-package-world2.wit.result b/crates/wit-parser/tests/ui/parse-fail/use-from-package-world2.wit.result
new file mode 100644
index 00000000..95608cfb
--- /dev/null
+++ b/crates/wit-parser/tests/ui/parse-fail/use-from-package-world2.wit.result
@@ -0,0 +1,8 @@
+failed to parse package: tests/ui/parse-fail/use-from-package-world2
+
+Caused by:
+    cannot import from world `foo`
+         --> tests/ui/parse-fail/use-from-package-world2/bar.wit:2:15
+          |
+        2 |   use pkg.foo.foo.{thing}
+          |               ^--
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/use-from-package-world2/bar.wit b/crates/wit-parser/tests/ui/parse-fail/use-from-package-world2/bar.wit
new file mode 100644
index 00000000..078c0c34
--- /dev/null
+++ b/crates/wit-parser/tests/ui/parse-fail/use-from-package-world2/bar.wit
@@ -0,0 +1,3 @@
+interface bar {
+  use pkg.foo.foo.{thing}
+}
diff --git a/crates/wit-parser/tests/ui/parse-fail/use-from-package-world2/foo.wit b/crates/wit-parser/tests/ui/parse-fail/use-from-package-world2/foo.wit
new file mode 100644
index 00000000..c2e6c53e
--- /dev/null
+++ b/crates/wit-parser/tests/ui/parse-fail/use-from-package-world2/foo.wit
@@ -0,0 +1,2 @@
+world foo {
+}
diff --git a/crates/wit-parser/tests/ui/parse-fail/use-shadow1.wit b/crates/wit-parser/tests/ui/parse-fail/use-shadow1.wit
deleted file mode 100644
index 29b3cf63..00000000
--- a/crates/wit-parser/tests/ui/parse-fail/use-shadow1.wit
+++ /dev/null
@@ -1,7 +0,0 @@
-package foo:foo
-
-use foo as bar
-
-interface foo {}
-
-interface bar {}
diff --git a/crates/wit-parser/tests/ui/parse-fail/use-shadow1.wit.result b/crates/wit-parser/tests/ui/parse-fail/use-shadow1.wit.result
deleted file mode 100644
index cdce8b4c..00000000
--- a/crates/wit-parser/tests/ui/parse-fail/use-shadow1.wit.result
+++ /dev/null
@@ -1,5 +0,0 @@
-duplicate name `bar` in this file
-     --> tests/ui/parse-fail/use-shadow1.wit:7:11
-      |
-    7 | interface bar {}
-      |           ^--
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/use-world.wit.result b/crates/wit-parser/tests/ui/parse-fail/use-world.wit.result
deleted file mode 100644
index a3a57d46..00000000
--- a/crates/wit-parser/tests/ui/parse-fail/use-world.wit.result
+++ /dev/null
@@ -1,5 +0,0 @@
-interface not found in package
-     --> tests/ui/parse-fail/use-world/root.wit:3:13
-      |
-    3 | use foo:baz/bar
-      |             ^--
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/use-world/deps/bar/.gitkeep b/crates/wit-parser/tests/ui/parse-fail/use-world/deps/bar/.gitkeep
deleted file mode 100644
index e69de29b..00000000
diff --git a/crates/wit-parser/tests/ui/parse-fail/use-world/deps/bar/baz.wit b/crates/wit-parser/tests/ui/parse-fail/use-world/deps/bar/baz.wit
deleted file mode 100644
index 50160910..00000000
--- a/crates/wit-parser/tests/ui/parse-fail/use-world/deps/bar/baz.wit
+++ /dev/null
@@ -1,4 +0,0 @@
-package foo:baz
-
-world bar {}
-
diff --git a/crates/wit-parser/tests/ui/parse-fail/use-world/root.wit b/crates/wit-parser/tests/ui/parse-fail/use-world/root.wit
deleted file mode 100644
index e11dcae5..00000000
--- a/crates/wit-parser/tests/ui/parse-fail/use-world/root.wit
+++ /dev/null
@@ -1,7 +0,0 @@
-package foo:foo
-
-use foo:baz/bar
-
-world foo {
-  
-}
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/world-implicit-import1.wit b/crates/wit-parser/tests/ui/parse-fail/world-implicit-import1.wit
similarity index 77%
rename from crates/wit-parser/tests/ui/world-implicit-import1.wit
rename to crates/wit-parser/tests/ui/parse-fail/world-implicit-import1.wit
index ea679ccc..cbaedc8b 100644
--- a/crates/wit-parser/tests/ui/world-implicit-import1.wit
+++ b/crates/wit-parser/tests/ui/parse-fail/world-implicit-import1.wit
@@ -1,12 +1,10 @@
-package foo:foo
-
 interface foo {
   type a = u32
 }
 
 world the-world {
   import bar: interface {
-    use foo.{a}
+    use self.foo.{a}
   }
   import foo: interface {}
 }
diff --git a/crates/wit-parser/tests/ui/parse-fail/world-implicit-import1.wit.result b/crates/wit-parser/tests/ui/parse-fail/world-implicit-import1.wit.result
new file mode 100644
index 00000000..a8e23a5c
--- /dev/null
+++ b/crates/wit-parser/tests/ui/parse-fail/world-implicit-import1.wit.result
@@ -0,0 +1,6 @@
+import of `foo` conflicts with a previous interface using the name `foo`
+
+     --> tests/ui/parse-fail/world-implicit-import1.wit:9:10
+      |
+    9 |   import foo: interface {}
+      |          ^--
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/world-interface-clash.wit b/crates/wit-parser/tests/ui/parse-fail/world-interface-clash.wit
index dbc015b2..edc358f0 100644
--- a/crates/wit-parser/tests/ui/parse-fail/world-interface-clash.wit
+++ b/crates/wit-parser/tests/ui/parse-fail/world-interface-clash.wit
@@ -1,3 +1,2 @@
-package foo:foo
 interface foo {}
 world foo {}
diff --git a/crates/wit-parser/tests/ui/parse-fail/world-interface-clash.wit.result b/crates/wit-parser/tests/ui/parse-fail/world-interface-clash.wit.result
index c8159d3e..396ada61 100644
--- a/crates/wit-parser/tests/ui/parse-fail/world-interface-clash.wit.result
+++ b/crates/wit-parser/tests/ui/parse-fail/world-interface-clash.wit.result
@@ -1,5 +1,5 @@
-duplicate item named `foo
-     --> tests/ui/parse-fail/world-interface-clash.wit:3:7
+name `foo` previously defined in document
+     --> tests/ui/parse-fail/world-interface-clash.wit:2:7
       |
-    3 | world foo {}
+    2 | world foo {}
       |       ^--
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/world-same-fields.wit b/crates/wit-parser/tests/ui/parse-fail/world-same-fields.wit
new file mode 100644
index 00000000..8906f0d5
--- /dev/null
+++ b/crates/wit-parser/tests/ui/parse-fail/world-same-fields.wit
@@ -0,0 +1,9 @@
+// parse-fail
+
+interface foo {}
+interface bar {}
+
+world a {
+  import foo: self.foo
+  import foo: self.bar
+}
diff --git a/crates/wit-parser/tests/ui/parse-fail/world-same-fields.wit.result b/crates/wit-parser/tests/ui/parse-fail/world-same-fields.wit.result
new file mode 100644
index 00000000..a21a34d8
--- /dev/null
+++ b/crates/wit-parser/tests/ui/parse-fail/world-same-fields.wit.result
@@ -0,0 +1,5 @@
+import `foo` conflicts with prior import of same name
+     --> tests/ui/parse-fail/world-same-fields.wit:8:10
+      |
+    8 |   import foo: self.bar
+      |          ^--
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/world-same-fields2.wit b/crates/wit-parser/tests/ui/parse-fail/world-same-fields2.wit
index c39cdc52..5fc043a0 100644
--- a/crates/wit-parser/tests/ui/parse-fail/world-same-fields2.wit
+++ b/crates/wit-parser/tests/ui/parse-fail/world-same-fields2.wit
@@ -1,7 +1,5 @@
 // parse-fail
 
-package foo:foo
-
 world a {
   import foo: interface {}
   import foo: interface {}
diff --git a/crates/wit-parser/tests/ui/parse-fail/world-same-fields2.wit.result b/crates/wit-parser/tests/ui/parse-fail/world-same-fields2.wit.result
index 3498be11..fbf18162 100644
--- a/crates/wit-parser/tests/ui/parse-fail/world-same-fields2.wit.result
+++ b/crates/wit-parser/tests/ui/parse-fail/world-same-fields2.wit.result
@@ -1,5 +1,5 @@
 import `foo` conflicts with prior import of same name
-     --> tests/ui/parse-fail/world-same-fields2.wit:7:10
+     --> tests/ui/parse-fail/world-same-fields2.wit:5:10
       |
-    7 |   import foo: interface {}
+    5 |   import foo: interface {}
       |          ^--
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/world-same-fields3.wit b/crates/wit-parser/tests/ui/parse-fail/world-same-fields3.wit
index e7e2d8e7..e48a2aed 100644
--- a/crates/wit-parser/tests/ui/parse-fail/world-same-fields3.wit
+++ b/crates/wit-parser/tests/ui/parse-fail/world-same-fields3.wit
@@ -1,7 +1,5 @@
 // parse-fail
 
-package foo:foo
-
 world a {
   export foo: interface {}
   export foo: interface {}
diff --git a/crates/wit-parser/tests/ui/parse-fail/world-same-fields3.wit.result b/crates/wit-parser/tests/ui/parse-fail/world-same-fields3.wit.result
index bf4a4bc6..60b1d3c5 100644
--- a/crates/wit-parser/tests/ui/parse-fail/world-same-fields3.wit.result
+++ b/crates/wit-parser/tests/ui/parse-fail/world-same-fields3.wit.result
@@ -1,5 +1,5 @@
 export `foo` conflicts with prior export of same name
-     --> tests/ui/parse-fail/world-same-fields3.wit:7:10
+     --> tests/ui/parse-fail/world-same-fields3.wit:5:10
       |
-    7 |   export foo: interface {}
+    5 |   export foo: interface {}
       |          ^--
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/world-same-fields4.wit b/crates/wit-parser/tests/ui/parse-fail/world-same-fields4.wit
new file mode 100644
index 00000000..766d29fb
--- /dev/null
+++ b/crates/wit-parser/tests/ui/parse-fail/world-same-fields4.wit
@@ -0,0 +1,11 @@
+interface shared {
+  type a = u32
+}
+
+world foo {
+  import shared: interface {}
+  export a-name: interface {
+    use self.shared.{a}
+  }
+}
+
diff --git a/crates/wit-parser/tests/ui/parse-fail/world-same-fields4.wit.result b/crates/wit-parser/tests/ui/parse-fail/world-same-fields4.wit.result
new file mode 100644
index 00000000..26d54e61
--- /dev/null
+++ b/crates/wit-parser/tests/ui/parse-fail/world-same-fields4.wit.result
@@ -0,0 +1,8 @@
+import of `shared`
+  .. which is depended on by export `a-name`
+conflicts with a previous interface using the name `shared`
+
+     --> tests/ui/parse-fail/world-same-fields4.wit:7:10
+      |
+    7 |   export a-name: interface {
+      |          ^-----
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/world-same-import.wit b/crates/wit-parser/tests/ui/parse-fail/world-same-import.wit
new file mode 100644
index 00000000..fedaaa76
--- /dev/null
+++ b/crates/wit-parser/tests/ui/parse-fail/world-same-import.wit
@@ -0,0 +1,6 @@
+interface foo {}
+
+world bar {
+  import foo: self.foo
+  import bar: self.foo
+}
diff --git a/crates/wit-parser/tests/ui/parse-fail/world-same-import.wit.result b/crates/wit-parser/tests/ui/parse-fail/world-same-import.wit.result
new file mode 100644
index 00000000..750845b7
--- /dev/null
+++ b/crates/wit-parser/tests/ui/parse-fail/world-same-import.wit.result
@@ -0,0 +1,5 @@
+interface `bar` cannot be imported more than once
+     --> tests/ui/parse-fail/world-same-import.wit:5:10
+      |
+    5 |   import bar: self.foo
+      |          ^--
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/world-top-level-func.wit b/crates/wit-parser/tests/ui/parse-fail/world-top-level-func.wit
index 813bb957..7bf7e5fc 100644
--- a/crates/wit-parser/tests/ui/parse-fail/world-top-level-func.wit
+++ b/crates/wit-parser/tests/ui/parse-fail/world-top-level-func.wit
@@ -1,4 +1,3 @@
-package foo:foo
 world foo {
   import foo: func()
   import foo: func()
diff --git a/crates/wit-parser/tests/ui/parse-fail/world-top-level-func.wit.result b/crates/wit-parser/tests/ui/parse-fail/world-top-level-func.wit.result
index 8eb1cc53..4a54d901 100644
--- a/crates/wit-parser/tests/ui/parse-fail/world-top-level-func.wit.result
+++ b/crates/wit-parser/tests/ui/parse-fail/world-top-level-func.wit.result
@@ -1,5 +1,5 @@
 import `foo` conflicts with prior import of same name
-     --> tests/ui/parse-fail/world-top-level-func.wit:4:10
+     --> tests/ui/parse-fail/world-top-level-func.wit:3:10
       |
-    4 |   import foo: func()
+    3 |   import foo: func()
       |          ^--
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/world-top-level-func2.wit b/crates/wit-parser/tests/ui/parse-fail/world-top-level-func2.wit
index f2c06efa..d872f067 100644
--- a/crates/wit-parser/tests/ui/parse-fail/world-top-level-func2.wit
+++ b/crates/wit-parser/tests/ui/parse-fail/world-top-level-func2.wit
@@ -1,4 +1,3 @@
-package foo:foo
 world foo {
   import foo: func(a: b)
 }
diff --git a/crates/wit-parser/tests/ui/parse-fail/world-top-level-func2.wit.result b/crates/wit-parser/tests/ui/parse-fail/world-top-level-func2.wit.result
index 1fe06a93..8e845ca0 100644
--- a/crates/wit-parser/tests/ui/parse-fail/world-top-level-func2.wit.result
+++ b/crates/wit-parser/tests/ui/parse-fail/world-top-level-func2.wit.result
@@ -1,5 +1,5 @@
 name `b` is not defined
-     --> tests/ui/parse-fail/world-top-level-func2.wit:3:23
+     --> tests/ui/parse-fail/world-top-level-func2.wit:2:23
       |
-    3 |   import foo: func(a: b)
+    2 |   import foo: func(a: b)
       |                       ^
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/parse-fail/import-and-export1.wit b/crates/wit-parser/tests/ui/parse-fail/worlds-same-fields5.wit
similarity index 58%
rename from crates/wit-parser/tests/ui/parse-fail/import-and-export1.wit
rename to crates/wit-parser/tests/ui/parse-fail/worlds-same-fields5.wit
index 1c682641..f460e1f5 100644
--- a/crates/wit-parser/tests/ui/parse-fail/import-and-export1.wit
+++ b/crates/wit-parser/tests/ui/parse-fail/worlds-same-fields5.wit
@@ -1,17 +1,16 @@
-package foo:foo
 interface i1 {
   type t = u32
 }
 interface i2 {
-  use i1.{t}
+  use self.i1.{t}
 }
 interface i3 {
-  use i2.{t}
+  use self.i2.{t}
 }
 
 world test {
   import i1: interface {}
 
-  export i1
-  export i3
+  export i4: self.i1
+  export i5: self.i3
 }
diff --git a/crates/wit-parser/tests/ui/parse-fail/worlds-same-fields5.wit.result b/crates/wit-parser/tests/ui/parse-fail/worlds-same-fields5.wit.result
new file mode 100644
index 00000000..cc854dab
--- /dev/null
+++ b/crates/wit-parser/tests/ui/parse-fail/worlds-same-fields5.wit.result
@@ -0,0 +1,9 @@
+import of `i1`
+  .. which is depended on by import `i2`
+  .. which is depended on by export `i5`
+conflicts with a previous interface using the name `i1`
+
+     --> tests/ui/parse-fail/worlds-same-fields5.wit:15:10
+      |
+   15 |   export i5: self.i3
+      |          ^-
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/resources-empty.wit b/crates/wit-parser/tests/ui/resources-empty.wit
deleted file mode 100644
index bb559f2d..00000000
--- a/crates/wit-parser/tests/ui/resources-empty.wit
+++ /dev/null
@@ -1,10 +0,0 @@
-package foo:resources-empty
-
-interface resources-empty {
-  t1: func(a: own<r1>) -> ()
-  t2: func(a: borrow<r1>) -> ()
-
-  resource r1 {
-  }
-}
-
diff --git a/crates/wit-parser/tests/ui/resources-multiple-returns-borrow.wit b/crates/wit-parser/tests/ui/resources-multiple-returns-borrow.wit
deleted file mode 100644
index 39887ed0..00000000
--- a/crates/wit-parser/tests/ui/resources-multiple-returns-borrow.wit
+++ /dev/null
@@ -1,10 +0,0 @@
-package foo:resources1
-
-interface resources1 {
-  t1: func(a: borrow<r1>) -> ()
-
-  resource r1 {
-    f1: func() -> (a: s32, handle: borrow<r1>)
-  }
-}
-
diff --git a/crates/wit-parser/tests/ui/resources-multiple-returns-own.wit b/crates/wit-parser/tests/ui/resources-multiple-returns-own.wit
deleted file mode 100644
index 751c0fdb..00000000
--- a/crates/wit-parser/tests/ui/resources-multiple-returns-own.wit
+++ /dev/null
@@ -1,10 +0,0 @@
-package foo:resources1
-
-interface resources1 {
-  t1: func(a: own<r1>) -> ()
-
-  resource r1 {
-    f1: func() -> (a: s32, handle: own<r1>)
-  }
-}
-
diff --git a/crates/wit-parser/tests/ui/resources-multiple.wit b/crates/wit-parser/tests/ui/resources-multiple.wit
deleted file mode 100644
index 67370f38..00000000
--- a/crates/wit-parser/tests/ui/resources-multiple.wit
+++ /dev/null
@@ -1,20 +0,0 @@
-package foo:resources-multiple
-
-interface resources-multiple {
-  t1: func(a: borrow<r1>) -> ()
-  t2: func(a: own<r1>) -> ()
-
-  resource r1 {
-    f1: func()
-    f2: func(a: u32)
-    f3: func(a: u32,)
-    f4: func() -> u32
-    f6: func() -> tuple<u32, u32>
-    f7: func(a: float32, b: float32) -> tuple<u32, u32>
-    f8: func(a: option<u32>) -> result<u32, float32>
-    f9: func() -> (u: u32, f: float32)
-    f10: func() -> (u: u32)
-    f11: func() -> ()
-  }
-}
-
diff --git a/crates/wit-parser/tests/ui/resources-return-borrow.wit b/crates/wit-parser/tests/ui/resources-return-borrow.wit
deleted file mode 100644
index ac08282c..00000000
--- a/crates/wit-parser/tests/ui/resources-return-borrow.wit
+++ /dev/null
@@ -1,10 +0,0 @@
-package foo:resources1
-
-interface resources1 {
-  t1: func(a: borrow<r1>) -> ()
-
-  resource r1 {
-    f1: func() -> borrow<r1>
-  }
-}
-
diff --git a/crates/wit-parser/tests/ui/resources-return-own.wit b/crates/wit-parser/tests/ui/resources-return-own.wit
deleted file mode 100644
index 830c70df..00000000
--- a/crates/wit-parser/tests/ui/resources-return-own.wit
+++ /dev/null
@@ -1,10 +0,0 @@
-package foo:resources1
-
-interface resources1 {
-  t1: func(a: own<r1>) -> ()
-
-  resource r1 {
-    f1: func() -> own<r1>
-  }
-}
-
diff --git a/crates/wit-parser/tests/ui/resources.wit b/crates/wit-parser/tests/ui/resources.wit
deleted file mode 100644
index cdda5909..00000000
--- a/crates/wit-parser/tests/ui/resources.wit
+++ /dev/null
@@ -1,47 +0,0 @@
-package foo:bar
-
-interface foo {
-  resource a {
-  }
-
-  resource b {
-    constructor()
-  }
-
-  resource c {
-    constructor(x: u32)
-  }
-
-  resource d {
-    constructor(x: u32)
-
-    a: func()
-
-    b: static func()
-  }
-
-  resource e {
-    constructor(other: own<e>, other2: borrow<e>)
-
-    method: func(thing: own<e>, thing2: borrow<e>)
-  }
-}
-
-world w {
-  resource a
-
-  resource b {
-  }
-
-  resource c {
-    constructor()
-  }
-}
-
-interface i {
-  resource a
-
-  type t1 = a
-  type t2 = borrow<a>
-  type t3 = borrow<t1>
-}
diff --git a/crates/wit-parser/tests/ui/resources1.wit b/crates/wit-parser/tests/ui/resources1.wit
deleted file mode 100644
index 9b8b6712..00000000
--- a/crates/wit-parser/tests/ui/resources1.wit
+++ /dev/null
@@ -1,12 +0,0 @@
-package foo:resources1
-
-interface resources1 {
-  t1: func(a: borrow<r1>) -> ()
-  t2: func(a: own<r1>) -> ()
-  t3: func(a: r1) -> ()
-
-  resource r1 {
-    f1: func()
-  }
-}
-
diff --git a/crates/wit-parser/tests/ui/shared-types.wit b/crates/wit-parser/tests/ui/shared-types.wit
index e839c919..be072d9e 100644
--- a/crates/wit-parser/tests/ui/shared-types.wit
+++ b/crates/wit-parser/tests/ui/shared-types.wit
@@ -1,5 +1,3 @@
-package foo:shared-items
-
 world foo {
   import foo: interface {
     a: func() -> list<u8>
diff --git a/crates/wit-parser/tests/ui/stress-export-elaborate.wit b/crates/wit-parser/tests/ui/stress-export-elaborate.wit
deleted file mode 100644
index b731452c..00000000
--- a/crates/wit-parser/tests/ui/stress-export-elaborate.wit
+++ /dev/null
@@ -1,54 +0,0 @@
-package foo:bar
-
-interface i1 {
-  type t1 = u32
-  type t2 = u32
-  type t3 = u32
-  type t4 = u32
-  type t5 = u32
-  type t6 = u32
-  type t7 = u32
-  type t8 = u32
-  type t9 = u32
-  type t10 = u32
-}
-
-interface i2 {
-  use i1.{t1, t2, t3, t4, t5, t6, t7, t8, t9, t10}
-}
-
-interface i3 {
-  use i2.{t1, t2, t3, t4, t5, t6, t7, t8, t9, t10}
-}
-
-interface i4 {
-  use i3.{t1, t2, t3, t4, t5, t6, t7, t8, t9, t10}
-}
-
-interface i5 {
-  use i4.{t1, t2, t3, t4, t5, t6, t7, t8, t9, t10}
-}
-
-interface i6 {
-  use i5.{t1, t2, t3, t4, t5, t6, t7, t8, t9, t10}
-}
-
-interface i7 {
-  use i6.{t1, t2, t3, t4, t5, t6, t7, t8, t9, t10}
-}
-
-interface i8 {
-  use i7.{t1, t2, t3, t4, t5, t6, t7, t8, t9, t10}
-}
-
-interface i9 {
-  use i8.{t1, t2, t3, t4, t5, t6, t7, t8, t9, t10}
-}
-
-interface i10 {
-  use i9.{t1, t2, t3, t4, t5, t6, t7, t8, t9, t10}
-}
-
-world foo {
-  export i10
-}
diff --git a/crates/wit-parser/tests/ui/type-then-eof.wit b/crates/wit-parser/tests/ui/type-then-eof.wit
index a15f263a..e4c45439 100644
--- a/crates/wit-parser/tests/ui/type-then-eof.wit
+++ b/crates/wit-parser/tests/ui/type-then-eof.wit
@@ -1,5 +1,3 @@
-package foo:foo
-
 interface foo {
   foo: func() -> string
 }
diff --git a/crates/wit-parser/tests/ui/types.wit b/crates/wit-parser/tests/ui/types.wit
index bee74acf..c9082389 100644
--- a/crates/wit-parser/tests/ui/types.wit
+++ b/crates/wit-parser/tests/ui/types.wit
@@ -1,5 +1,3 @@
-package foo:types
-
 interface types {
   type t1 = u8
   type t2 = u16
diff --git a/crates/wit-parser/tests/ui/union-fuzz-1.wit b/crates/wit-parser/tests/ui/union-fuzz-1.wit
deleted file mode 100644
index efa86251..00000000
--- a/crates/wit-parser/tests/ui/union-fuzz-1.wit
+++ /dev/null
@@ -1,9 +0,0 @@
-package foo:bar
-
-world xo {}
-
-world name {}
-
-world x {
-    include name
-}
\ No newline at end of file
diff --git a/crates/wit-parser/tests/ui/use-chain.wit b/crates/wit-parser/tests/ui/use-chain.wit
deleted file mode 100644
index 6191ebb0..00000000
--- a/crates/wit-parser/tests/ui/use-chain.wit
+++ /dev/null
@@ -1,11 +0,0 @@
-package foo:name
-
-interface foo {
-  record foo {}
-}
-
-use foo as bar
-
-interface name {
-  use bar.{foo}
-}
diff --git a/crates/wit-parser/tests/ui/use.wit b/crates/wit-parser/tests/ui/use.wit
index 24856692..af27a7c3 100644
--- a/crates/wit-parser/tests/ui/use.wit
+++ b/crates/wit-parser/tests/ui/use.wit
@@ -1,7 +1,5 @@
-package foo:foo
-
 interface foo {
-  use bar.{the-type}
+  use self.bar.{the-type}
 }
 
 interface bar {
@@ -9,26 +7,27 @@ interface bar {
 }
 
 interface baz {
-  use foo.{the-type}
-  use bar.{the-type as test}
+  use self.foo.{the-type}
+  use self.bar.{the-type as test}
 }
 
 interface empty {
 }
 
 interface use-from-empty {
-  use empty.{}
-  use empty.{}
+  use self.empty.{}
+  use pkg.%use.empty.{}
 }
 
+
 interface use-multiple {
-  use baz.{the-type, test}
+  use self.baz.{the-type, test}
 
   some-function: func(x: the-type) -> test
 }
 
 interface trailing-comma {
-  use foo.{the-type,}
+  use self.foo.{the-type,}
 
   record the-foo { a: the-type }
 }
diff --git a/crates/wit-parser/tests/ui/versions/deps/a1/foo.wit b/crates/wit-parser/tests/ui/versions/deps/a1/foo.wit
deleted file mode 100644
index dbf54149..00000000
--- a/crates/wit-parser/tests/ui/versions/deps/a1/foo.wit
+++ /dev/null
@@ -1,5 +0,0 @@
-package a:a@1.0.0
-
-interface foo {
-  type t = u32
-}
diff --git a/crates/wit-parser/tests/ui/versions/deps/a2/foo.wit b/crates/wit-parser/tests/ui/versions/deps/a2/foo.wit
deleted file mode 100644
index dfd6625f..00000000
--- a/crates/wit-parser/tests/ui/versions/deps/a2/foo.wit
+++ /dev/null
@@ -1,5 +0,0 @@
-package a:a@2.0.0
-
-interface foo {
-  type t = u32
-}
diff --git a/crates/wit-parser/tests/ui/versions/foo.wit b/crates/wit-parser/tests/ui/versions/foo.wit
deleted file mode 100644
index 5dfab680..00000000
--- a/crates/wit-parser/tests/ui/versions/foo.wit
+++ /dev/null
@@ -1,7 +0,0 @@
-package foo:versions
-
-interface foo {
-  use a:a/foo@1.0.0.{t}
-  use a:a/foo@2.0.0.{t as t2}
-}
-
diff --git a/crates/wit-parser/tests/ui/wasi.wit b/crates/wit-parser/tests/ui/wasi.wit
index df2bf0f4..4edfbaee 100644
--- a/crates/wit-parser/tests/ui/wasi.wit
+++ b/crates/wit-parser/tests/ui/wasi.wit
@@ -1,5 +1,3 @@
-package wasi:filesystem
-
 interface wasi {
   enum clockid {
     // The clock measuring real time. Time value zero corresponds with
diff --git a/crates/wit-parser/tests/ui/world-diamond.wit b/crates/wit-parser/tests/ui/world-diamond.wit
index 6dd4ce88..5de78b35 100644
--- a/crates/wit-parser/tests/ui/world-diamond.wit
+++ b/crates/wit-parser/tests/ui/world-diamond.wit
@@ -1,22 +1,20 @@
-package foo:foo
-
-interface shared-items {
+interface shared {
   type foo = u32
 }
 
 interface i1 {
-  use shared-items.{foo}
+  use self.shared.{foo}
 
   a: func() -> foo
 }
 
 interface i2 {
-  use shared-items.{foo}
+  use self.shared.{foo}
 
   a: func() -> foo
 }
 
 world the-world {
-  import i1
-  import i2
+  import i1: self.i1
+  import i2: self.i2
 }
diff --git a/crates/wit-parser/tests/ui/world-implicit-import2.wit b/crates/wit-parser/tests/ui/world-implicit-import2.wit
deleted file mode 100644
index 4079ace9..00000000
--- a/crates/wit-parser/tests/ui/world-implicit-import2.wit
+++ /dev/null
@@ -1,11 +0,0 @@
-package foo:foo
-
-interface foo {
-  type g = char
-}
-
-world w {
-  use foo.{g}
-
-  import foo: func() -> g
-}
diff --git a/crates/wit-parser/tests/ui/world-implicit-import3.wit b/crates/wit-parser/tests/ui/world-implicit-import3.wit
deleted file mode 100644
index 29f4e780..00000000
--- a/crates/wit-parser/tests/ui/world-implicit-import3.wit
+++ /dev/null
@@ -1,11 +0,0 @@
-package foo:foo
-
-interface foo {
-  type g = char
-}
-
-world w {
-  use foo.{g}
-
-  export foo: func() -> g
-}
diff --git a/crates/wit-parser/tests/ui/world-same-fields4.wit b/crates/wit-parser/tests/ui/world-same-fields4.wit
deleted file mode 100644
index 4ee79817..00000000
--- a/crates/wit-parser/tests/ui/world-same-fields4.wit
+++ /dev/null
@@ -1,13 +0,0 @@
-package foo:foo
-
-interface shared-items {
-  type a = u32
-}
-
-world foo {
-  import shared-items: interface {}
-  export a-name: interface {
-    use shared-items.{a}
-  }
-}
-
diff --git a/crates/wit-parser/tests/ui/world-top-level-funcs.wit b/crates/wit-parser/tests/ui/world-top-level-funcs.wit
index f54f4388..afcd693c 100644
--- a/crates/wit-parser/tests/ui/world-top-level-funcs.wit
+++ b/crates/wit-parser/tests/ui/world-top-level-funcs.wit
@@ -1,5 +1,3 @@
-package foo:foo
-
 world foo {
   import foo: func()
   export foo2: func()
diff --git a/crates/wit-parser/tests/ui/world-top-level-resources.wit b/crates/wit-parser/tests/ui/world-top-level-resources.wit
deleted file mode 100644
index ddc2d582..00000000
--- a/crates/wit-parser/tests/ui/world-top-level-resources.wit
+++ /dev/null
@@ -1,24 +0,0 @@
-package foo:foo
-
-interface types {
-  resource request {
-    foo: func()
-    bar: func(arg: list<u32>)
-  }
-
-  resource response {
-    foo: func()
-    bar: func(arg: list<u32>)
-  }
-}
-
-interface handler {
-  use types.{request, response}
-  handle: func(some: borrow<request>) -> borrow<response>
-  handle-owned: func(some: own<request>) -> own<response>
-}
-
-world proxy {
-  import handler
-  export handler
-}
diff --git a/crates/wit-parser/tests/ui/worlds-union-dedup.wit b/crates/wit-parser/tests/ui/worlds-union-dedup.wit
deleted file mode 100644
index 88e2d0e3..00000000
--- a/crates/wit-parser/tests/ui/worlds-union-dedup.wit
+++ /dev/null
@@ -1,23 +0,0 @@
-package foo:foo
-
-interface a1 { }
-interface a2 { }
-interface b1 { }
-interface b2 { }
-interface c { }
-interface d { }
-
-world my-world-a {
-    import a1
-    import b1
-}
-
-world my-world-b {
-    import a1
-    import b1
-}
-
-world union-my-world {
-    include my-world-a
-    include my-world-b
-}
diff --git a/crates/wit-parser/tests/ui/worlds-with-types.wit b/crates/wit-parser/tests/ui/worlds-with-types.wit
index 30f96aa9..3ca4903a 100644
--- a/crates/wit-parser/tests/ui/worlds-with-types.wit
+++ b/crates/wit-parser/tests/ui/worlds-with-types.wit
@@ -1,5 +1,3 @@
-package foo:foo
-
 world foo {
   type a = u32
   type b = a
@@ -13,9 +11,9 @@ interface disambiguate {
 }
 
 world bar {
-  import disambiguate
+  import disambiguate2: self.disambiguate
 
-  use disambiguate.{t}
+  use self.disambiguate.{t}
 
   export foo: func() -> t
 }
diff --git a/crates/wit-parser/tests/ui/worlds.wit b/crates/wit-parser/tests/ui/worlds.wit
new file mode 100644
index 00000000..a42b5224
--- /dev/null
+++ b/crates/wit-parser/tests/ui/worlds.wit
@@ -0,0 +1,40 @@
+interface foo {}
+interface bar {}
+
+world the-world {
+  import foo: self.foo
+  import bar: self.bar
+  import baz: interface {
+    foo: func()
+  }
+  export foo2: self.foo
+  export bar2: self.bar
+  export baz2: interface {
+    foo: func()
+  }
+}
+
+default world a-different-world {
+  import foo: self.foo
+}
+
+interface i1 {
+  type t = u32
+}
+interface i2 {
+  use self.i1.{t}
+}
+interface i3 {
+  use self.i2.{t}
+}
+
+world test {
+  import i3: self.i3
+
+  export i4: self.i1
+
+  // This should insert an implicit dependency on `i2` as an import, and then
+  // i2's dependency on i1 should be wired up to i3's implicit imported
+  // dependency on i1.
+  export i5: self.i3
+}
diff --git a/crates/wit-smith/Cargo.toml b/crates/wit-smith/Cargo.toml
deleted file mode 100644
index 2a053699..00000000
--- a/crates/wit-smith/Cargo.toml
+++ /dev/null
@@ -1,17 +0,0 @@
-[package]
-description = "A WIT test case generator"
-documentation = "https://docs.rs/wit-smith"
-edition.workspace = true
-license = "Apache-2.0 WITH LLVM-exception"
-name = "wit-smith"
-repository = "https://github.com/bytecodealliance/wasm-tools/tree/main/crates/wit-smith"
-version = "0.1.6"
-
-[dependencies]
-arbitrary = { workspace = true, features = ["derive"] }
-wit-component = { workspace = true }
-wit-parser = { workspace = true }
-clap = { workspace = true, optional = true }
-indexmap = { workspace = true }
-log = { workspace = true }
-semver = { workspace = true }
diff --git a/crates/wit-smith/src/config.rs b/crates/wit-smith/src/config.rs
deleted file mode 100644
index ea837c5c..00000000
--- a/crates/wit-smith/src/config.rs
+++ /dev/null
@@ -1,52 +0,0 @@
-use arbitrary::{Arbitrary, Result, Unstructured};
-
-#[derive(Debug, Clone)]
-#[cfg_attr(feature = "clap", derive(clap::Parser))]
-pub struct Config {
-    #[cfg_attr(feature = "clap", clap(long, default_value_t = Config::default().max_packages))]
-    pub max_packages: usize,
-    #[cfg_attr(feature = "clap", clap(long, default_value_t = Config::default().max_type_size))]
-    pub max_type_size: usize,
-    #[cfg_attr(feature = "clap", clap(long, default_value_t = Config::default().max_interface_items))]
-    pub max_interface_items: usize,
-    #[cfg_attr(feature = "clap", clap(long, default_value_t = Config::default().max_world_items))]
-    pub max_world_items: usize,
-    #[cfg_attr(feature = "clap", clap(long, default_value_t = Config::default().max_pkg_items))]
-    pub max_pkg_items: usize,
-    #[cfg_attr(feature = "clap", clap(long, default_value_t = Config::default().max_type_parts))]
-    pub max_type_parts: usize,
-    #[cfg_attr(feature = "clap", clap(long, default_value_t = Config::default().max_files_per_package))]
-    pub max_files_per_package: usize,
-    #[cfg_attr(feature = "clap", clap(long, default_value_t = Config::default().max_resource_items))]
-    pub max_resource_items: usize,
-}
-
-impl Default for Config {
-    fn default() -> Config {
-        Config {
-            max_packages: 10,
-            max_type_size: 100,
-            max_interface_items: 10,
-            max_world_items: 10,
-            max_pkg_items: 10,
-            max_type_parts: 10,
-            max_files_per_package: 10,
-            max_resource_items: 10,
-        }
-    }
-}
-
-impl Arbitrary<'_> for Config {
-    fn arbitrary(u: &mut Unstructured<'_>) -> Result<Config> {
-        Ok(Config {
-            max_packages: u.int_in_range(1..=20)?,
-            max_files_per_package: u.int_in_range(1..=10)?,
-            max_type_size: u.int_in_range(0..=1000)?,
-            max_interface_items: u.int_in_range(0..=20)?,
-            max_world_items: u.int_in_range(0..=10)?,
-            max_pkg_items: u.int_in_range(0..=10)?,
-            max_type_parts: u.int_in_range(1..=10)?,
-            max_resource_items: u.int_in_range(0..=10)?,
-        })
-    }
-}
diff --git a/crates/wit-smith/src/generate.rs b/crates/wit-smith/src/generate.rs
deleted file mode 100644
index ac94651b..00000000
--- a/crates/wit-smith/src/generate.rs
+++ /dev/null
@@ -1,1015 +0,0 @@
-use crate::config::Config;
-use arbitrary::{Arbitrary, Result, Unstructured};
-use indexmap::IndexMap;
-use semver::Version;
-use std::collections::hash_map::{Entry, HashMap};
-use std::collections::HashSet;
-use std::fmt::Write;
-use std::rc::Rc;
-use std::str;
-use wit_parser::*;
-
-pub struct Generator {
-    config: Config,
-    packages: PackageList,
-    next_interface_id: u32,
-}
-
-type TypeList = Vec<Type>;
-type InterfaceList = IndexMap<String, FileInterface>;
-type PackageList = Vec<(PackageName, InterfaceList)>;
-
-struct InterfaceGenerator<'a> {
-    gen: &'a Generator,
-    file: &'a mut File,
-    config: &'a Config,
-    unique_names: HashSet<String>,
-    types_in_interface: TypeList,
-}
-
-#[derive(Clone)]
-struct Type {
-    name: String,
-    size: usize,
-    is_resource: bool,
-}
-
-pub struct Package {
-    pub name: PackageName,
-    pub sources: SourceMap,
-}
-
-#[derive(Clone)]
-pub struct PackageName {
-    pub namespace: String,
-    pub name: String,
-    pub version: Option<Version>,
-}
-
-impl Generator {
-    pub fn new(config: Config) -> Generator {
-        Generator {
-            config,
-            packages: Default::default(),
-            next_interface_id: 0,
-        }
-    }
-
-    pub fn gen(&mut self, u: &mut Unstructured<'_>) -> Result<Vec<Package>> {
-        let mut packages = Vec::new();
-        let mut names = HashSet::new();
-        while packages.len() < self.config.max_packages && (packages.is_empty() || u.arbitrary()?) {
-            let (pkg, interfaces) = self.gen_package(u, &mut names)?;
-            if interfaces.len() > 0 {
-                self.packages.push((pkg.name.clone(), interfaces));
-            }
-            packages.push(pkg);
-        }
-        Ok(packages)
-    }
-
-    fn gen_package(
-        &mut self,
-        u: &mut Unstructured<'_>,
-        names: &mut HashSet<String>,
-    ) -> Result<(Package, InterfaceList)> {
-        let namespace = gen_unique_name(u, names)?;
-        let name = gen_unique_name(u, names)?;
-        let version = if u.arbitrary()? {
-            Some(gen_version(u)?)
-        } else {
-            None
-        };
-        let mut ret = Package {
-            name: PackageName {
-                namespace,
-                name,
-                version,
-            },
-            sources: SourceMap::new(),
-        };
-
-        #[derive(Arbitrary)]
-        enum Generate {
-            Interface,
-            Use,
-            World,
-            Done,
-        }
-
-        let mut items = 0;
-        let mut files = vec![File::default()];
-        let mut package_names = HashSet::new();
-        let mut package = File::default();
-        log::debug!("===================== new package ====================");
-        while items < self.config.max_pkg_items && !u.is_empty() {
-            items += 1;
-            let max = if files.len() < self.config.max_files_per_package {
-                files.len() + 1
-            } else {
-                files.len()
-            };
-            let i = u.int_in_range(0..=max)?;
-            let file = match files.get_mut(i) {
-                Some(file) => file,
-                None => {
-                    files.push(File {
-                        items: Vec::new(),
-                        namespace: package
-                            .interfaces
-                            .iter()
-                            .map(|(k, _)| (k.clone(), Definition::Package))
-                            .collect(),
-                        interfaces: package.interfaces.clone(),
-                    });
-                    files.last_mut().unwrap()
-                }
-            };
-            match u.arbitrary()? {
-                Generate::World => {
-                    let name = file.gen_unique_package_name(u, &mut package_names)?;
-                    log::debug!("new world `{name}` in {i}");
-                    let world = self.gen_world(u, &name, file)?;
-                    file.items.push(world);
-                }
-                Generate::Interface => {
-                    let name = file.gen_unique_package_name(u, &mut package_names)?;
-                    log::debug!("new interface `{name}` in {i}");
-                    let id = self.next_interface_id;
-                    self.next_interface_id += 1;
-                    let (src, types) = self.gen_interface(u, Some(&name), file)?;
-                    file.items.push(src);
-                    if types.is_empty() {
-                        continue;
-                    }
-                    let interface = FileInterface {
-                        name,
-                        id,
-                        types: Rc::new(types),
-                    };
-
-                    // This interface is defined at the package level, and it
-                    // must be unique.
-                    let prev = package
-                        .interfaces
-                        .insert(interface.name.clone(), interface.clone());
-                    assert!(prev.is_none());
-
-                    // This is also defined at the file level, and it must be
-                    // unique here too.
-                    let prev = file
-                        .interfaces
-                        .insert(interface.name.clone(), interface.clone());
-                    assert!(prev.is_none());
-
-                    // Insert the definition into all other files as well.
-                    for file in files.iter_mut() {
-                        file.insert_definition(interface.clone());
-                    }
-                }
-                Generate::Use => {
-                    let mut piece = String::new();
-                    piece.push_str("use ");
-                    let (name, id, types) = match self.gen_path(u, &mut package, &mut piece)? {
-                        Some(i) => i,
-                        None => continue,
-                    };
-                    let name = name.to_string();
-                    let types = types.clone();
-                    let name =
-                        if file.namespace.get(&name) == Some(&Definition::File) || u.arbitrary()? {
-                            let name = file.gen_unique_file_name(u)?;
-                            piece.push_str(" as %");
-                            piece.push_str(&name);
-                            name
-                        } else {
-                            file.namespace.insert(name.clone(), Definition::File);
-                            name
-                        };
-                    log::debug!("new use `{name}` in {i}");
-                    file.interfaces
-                        .insert(name.clone(), FileInterface { name, id, types });
-                    file.items.push(piece)
-                }
-                Generate::Done => break,
-            };
-        }
-
-        shuffle(u, &mut files)?;
-        for file in files.iter_mut() {
-            shuffle(u, &mut file.items)?;
-        }
-
-        let mut has_name = false;
-        let len = files.len();
-        for (i, file) in files.iter_mut().enumerate() {
-            let mut s = String::new();
-            if u.arbitrary()? || (!has_name && i == len - 1) {
-                has_name = true;
-                s.push_str("package ");
-                s.push_str("%");
-                s.push_str(&ret.name.namespace);
-                s.push_str(":");
-                s.push_str("%");
-                s.push_str(&ret.name.name);
-                if let Some(version) = &ret.name.version {
-                    s.push_str(&format!("@{version}"));
-                }
-                s.push_str("\n\n");
-            }
-            for piece in file.items.iter() {
-                s.push_str(&piece);
-                s.push_str("\n\n");
-            }
-            log::trace!("===============================================");
-            log::trace!("{s}");
-            ret.sources.push(format!("wit{i}.wit").as_ref(), &s);
-        }
-        Ok((ret, package.interfaces))
-    }
-
-    fn gen_world(
-        &mut self,
-        u: &mut Unstructured<'_>,
-        name: &str,
-        file: &mut File,
-    ) -> Result<String> {
-        InterfaceGenerator::new(self, file).gen_world(u, name)
-    }
-
-    fn gen_interface(
-        &mut self,
-        u: &mut Unstructured<'_>,
-        name: Option<&str>,
-        file: &mut File,
-    ) -> Result<(String, TypeList)> {
-        let mut gen = InterfaceGenerator::new(self, file);
-        let ret = gen.gen_interface(u, name)?;
-        Ok((ret, gen.types_in_interface))
-    }
-
-    fn gen_path<'a>(
-        &'a self,
-        u: &mut Unstructured<'_>,
-        file: &'a mut File,
-        dst: &mut String,
-    ) -> Result<Option<(&'a str, u32, &'a Rc<TypeList>)>> {
-        enum Choice {
-            Interfaces,
-            Packages,
-        }
-        let mut choices = Vec::new();
-        if !file.interfaces.is_empty() {
-            choices.push(Choice::Interfaces);
-        }
-        if !self.packages.is_empty() {
-            choices.push(Choice::Packages);
-        }
-        if choices.is_empty() {
-            return Ok(None);
-        }
-        Ok(match u.choose(&choices)? {
-            Choice::Interfaces => {
-                let i = u.int_in_range(0..=file.interfaces.len() - 1)?;
-                let (name, i) = file.interfaces.get_index(i).unwrap();
-                // Once a name is used from a file's local namespace then it
-                // can't be overridden in that namespace so switch it to a file
-                // definition from whatever it previously was.
-                file.namespace.insert(name.clone(), Definition::File);
-                dst.push_str("%");
-                dst.push_str(&i.name);
-                Some((&i.name, i.id, &i.types))
-            }
-            Choice::Packages => {
-                let (pkg, ifaces) = u.choose(&self.packages)?;
-                dst.push_str("%");
-                dst.push_str(&pkg.namespace);
-                dst.push_str(":");
-                dst.push_str("%");
-                dst.push_str(&pkg.name);
-                dst.push_str("/");
-                let i = u.int_in_range(0..=ifaces.len() - 1)?;
-                let i = &ifaces[i];
-                dst.push_str("%");
-                dst.push_str(&i.name);
-                if let Some(version) = &pkg.version {
-                    dst.push_str(&format!("@{version}"));
-                }
-                Some((&i.name, i.id, &i.types))
-            }
-        })
-    }
-}
-
-impl<'a> InterfaceGenerator<'a> {
-    fn new(gen: &'a Generator, file: &'a mut File) -> InterfaceGenerator<'a> {
-        // Claim the name `memory` to avoid conflicting with the canonical ABI
-        // always using a linear memory named `memory`.
-        let mut unique_names = HashSet::new();
-        unique_names.insert("memory".to_string());
-        InterfaceGenerator {
-            gen,
-            file,
-            config: &gen.config,
-            types_in_interface: Vec::new(),
-            unique_names,
-        }
-    }
-
-    fn gen_interface(&mut self, u: &mut Unstructured<'_>, name: Option<&str>) -> Result<String> {
-        let mut ret = String::new();
-        ret.push_str("interface ");
-        if let Some(name) = name {
-            ret.push_str("%");
-            ret.push_str(name);
-            ret.push_str(" ");
-        }
-        ret.push_str("{\n");
-
-        #[derive(Arbitrary)]
-        enum Generate {
-            Use,
-            Type,
-            Function,
-        }
-
-        let mut parts = Vec::new();
-        while parts.len() < self.config.max_interface_items && u.arbitrary()? {
-            match u.arbitrary()? {
-                Generate::Use => {
-                    let mut part = String::new();
-                    if self.gen_use(u, &mut part)? {
-                        parts.push(part);
-                    }
-                }
-                Generate::Type => {
-                    let name = self.gen_unique_name(u)?;
-                    let (ty, mut typedef) = self.gen_typedef(u, &name)?;
-                    let is_resource = ty.is_resource;
-                    self.types_in_interface.push(ty);
-                    if is_resource && u.arbitrary()? {
-                        typedef.push_str(" {\n");
-                        self.gen_resource_funcs(u, &mut typedef)?;
-                        typedef.push_str("}");
-                    }
-                    parts.push(typedef);
-                }
-                Generate::Function => {
-                    parts.push(self.gen_func(u)?);
-                }
-            }
-        }
-
-        shuffle(u, &mut parts)?;
-        for part in parts {
-            ret.push_str(&part);
-            ret.push_str("\n\n");
-        }
-
-        ret.push_str("}");
-        Ok(ret)
-    }
-
-    fn gen_world(&mut self, u: &mut Unstructured<'_>, name: &str) -> Result<String> {
-        let mut ret = String::new();
-        ret.push_str("world %");
-        ret.push_str(name);
-        ret.push_str(" {\n");
-
-        #[derive(Arbitrary, Copy, Clone)]
-        enum Direction {
-            Import,
-            Export,
-        }
-
-        #[derive(Arbitrary)]
-        enum ItemKind {
-            Func(Direction),
-            Interface(Direction),
-            AnonInterface(Direction),
-            Type,
-            Use,
-        }
-
-        let mut parts = Vec::new();
-        let mut imported_interfaces = HashSet::new();
-        let mut exported_interfaces = HashSet::new();
-
-        while parts.len() < self.config.max_world_items && !u.is_empty() && u.arbitrary()? {
-            let kind = u.arbitrary::<ItemKind>()?;
-            let (direction, named) = match kind {
-                ItemKind::Func(dir) | ItemKind::AnonInterface(dir) => (Some(dir), true),
-                ItemKind::Interface(dir) => (Some(dir), false),
-                ItemKind::Type => (None, true),
-                ItemKind::Use => (None, false),
-            };
-
-            let mut part = String::new();
-            if let Some(dir) = direction {
-                part.push_str(match dir {
-                    Direction::Import => "import ",
-                    Direction::Export => "export ",
-                });
-            }
-
-            let name = if named {
-                let name = gen_unique_name(u, &mut self.unique_names)?;
-                if direction.is_some() {
-                    part.push_str("%");
-                    part.push_str(&name);
-                    part.push_str(": ");
-                }
-                Some(name)
-            } else {
-                None
-            };
-
-            match kind {
-                ItemKind::Func(_) => {
-                    self.gen_func_sig(u, &mut part, false)?;
-                }
-                ItemKind::Interface(dir) => {
-                    let id = match self.gen.gen_path(u, self.file, &mut part)? {
-                        Some((_name, id, _types)) => id,
-                        // If an interface couldn't be chosen or wasn't
-                        // chosen then skip this import. A unique name was
-                        // selecteed above but we just sort of leave that
-                        // floating in the wild to get handled by some other
-                        // test case.
-                        None => continue,
-                    };
-
-                    // If this interface has already been imported or
-                    // exported this document can't do so again. Throw out
-                    // this item in that situation.
-                    let unique = match dir {
-                        Direction::Import => imported_interfaces.insert(id),
-                        Direction::Export => exported_interfaces.insert(id),
-                    };
-                    if !unique {
-                        continue;
-                    }
-                }
-                ItemKind::AnonInterface(_) => {
-                    let iface =
-                        InterfaceGenerator::new(self.gen, self.file).gen_interface(u, None)?;
-                    part.push_str(&iface);
-                }
-
-                ItemKind::Type => {
-                    let name = name.unwrap();
-                    let (ty, typedef) = self.gen_typedef(u, &name)?;
-                    assert!(part.is_empty());
-                    part = typedef;
-                    let is_resource = ty.is_resource;
-                    self.types_in_interface.push(ty);
-
-                    if is_resource && u.arbitrary()? {
-                        part.push_str(" {\n");
-                        self.gen_resource_funcs(u, &mut part)?;
-                        part.push_str("}");
-                    }
-                }
-
-                ItemKind::Use => {
-                    if !self.gen_use(u, &mut part)? {
-                        continue;
-                    }
-                }
-            }
-            parts.push(part);
-        }
-
-        shuffle(u, &mut parts)?;
-
-        for part in parts {
-            ret.push_str(&part);
-            ret.push_str("\n");
-        }
-
-        ret.push_str("}");
-
-        Ok(ret)
-    }
-
-    fn gen_resource_funcs(&mut self, u: &mut Unstructured<'_>, ret: &mut String) -> Result<()> {
-        let mut parts = Vec::new();
-
-        #[derive(Arbitrary)]
-        enum Item {
-            Constructor,
-            Static,
-            Method,
-        }
-
-        let mut has_constructor = false;
-        let mut names = HashSet::new();
-        while parts.len() < self.config.max_resource_items && !u.is_empty() && u.arbitrary()? {
-            match u.arbitrary()? {
-                Item::Constructor if has_constructor => {}
-                Item::Constructor => {
-                    has_constructor = true;
-                    let mut part = format!("constructor");
-                    self.gen_params(u, &mut part, false)?;
-                    parts.push(part);
-                }
-                Item::Static => {
-                    let mut part = format!("%");
-                    part.push_str(&gen_unique_name(u, &mut names)?);
-                    part.push_str(": static ");
-                    self.gen_func_sig(u, &mut part, false)?;
-                    parts.push(part);
-                }
-                Item::Method => {
-                    let mut part = format!("%");
-                    part.push_str(&gen_unique_name(u, &mut names)?);
-                    part.push_str(": ");
-                    self.gen_func_sig(u, &mut part, true)?;
-                    parts.push(part);
-                }
-            }
-        }
-
-        shuffle(u, &mut parts)?;
-
-        for part in parts {
-            ret.push_str(&part);
-            ret.push_str("\n");
-        }
-        Ok(())
-    }
-
-    fn gen_use(&mut self, u: &mut Unstructured<'_>, part: &mut String) -> Result<bool> {
-        let mut path = String::new();
-        let (_name, _id, types) = match self.gen.gen_path(u, self.file, &mut path)? {
-            Some(types) => types,
-            None => return Ok(false),
-        };
-        part.push_str("use ");
-        part.push_str(&path);
-        part.push_str(".{");
-        let ty = u.choose(types)?;
-        part.push_str("%");
-        part.push_str(&ty.name);
-        let size = ty.size;
-        let is_resource = ty.is_resource;
-        let name = if self.unique_names.contains(&ty.name) || u.arbitrary()? {
-            part.push_str(" as %");
-            let name = self.gen_unique_name(u)?;
-            part.push_str(&name);
-            name
-        } else {
-            assert!(self.unique_names.insert(ty.name.clone()));
-            ty.name.clone()
-        };
-        self.types_in_interface.push(Type {
-            name,
-            size,
-            is_resource,
-        });
-        part.push_str("}");
-        Ok(true)
-    }
-
-    fn gen_typedef(&mut self, u: &mut Unstructured<'_>, name: &str) -> Result<(Type, String)> {
-        #[derive(Arbitrary)]
-        pub enum Kind {
-            Record,
-            Flags,
-            Variant,
-            Enum,
-            Union,
-            Anonymous,
-            Resource,
-        }
-
-        let mut fuel = self.config.max_type_size;
-        let mut ret = String::new();
-        let mut is_resource = false;
-        match u.arbitrary()? {
-            Kind::Record => {
-                ret.push_str("record %");
-                ret.push_str(name);
-                ret.push_str(" {\n");
-                for _ in 0..u.int_in_range(0..=self.config.max_type_parts)? {
-                    ret.push_str("  %");
-                    ret.push_str(&self.gen_unique_name(u)?);
-                    ret.push_str(": ");
-                    self.gen_type(u, &mut fuel, &mut ret)?;
-                    ret.push_str(",\n");
-                }
-                ret.push_str("}");
-            }
-            Kind::Variant => {
-                ret.push_str("variant %");
-                ret.push_str(name);
-                ret.push_str(" {\n");
-                for _ in 0..u.int_in_range(1..=self.config.max_type_parts)? {
-                    ret.push_str("  %");
-                    ret.push_str(&self.gen_unique_name(u)?);
-                    if u.arbitrary()? {
-                        ret.push_str("(");
-                        self.gen_type(u, &mut fuel, &mut ret)?;
-                        ret.push_str(")");
-                    }
-                    ret.push_str(",\n");
-                }
-                ret.push_str("}");
-            }
-            Kind::Union => {
-                ret.push_str("union %");
-                ret.push_str(name);
-                ret.push_str(" {\n");
-                for _ in 0..u.int_in_range(1..=self.config.max_type_parts)? {
-                    ret.push_str("  ");
-                    self.gen_type(u, &mut fuel, &mut ret)?;
-                    ret.push_str(",\n");
-                }
-                ret.push_str("}");
-            }
-            Kind::Enum => {
-                ret.push_str("enum %");
-                ret.push_str(name);
-                ret.push_str(" {\n");
-                for _ in 0..u.int_in_range(1..=self.config.max_type_parts)? {
-                    ret.push_str("  %");
-                    ret.push_str(&self.gen_unique_name(u)?);
-                    ret.push_str(",\n");
-                }
-                ret.push_str("}");
-            }
-            Kind::Flags => {
-                ret.push_str("flags %");
-                ret.push_str(name);
-                ret.push_str(" {\n");
-                for _ in 0..u.int_in_range(0..=self.config.max_type_parts)? {
-                    ret.push_str("  %");
-                    ret.push_str(&self.gen_unique_name(u)?);
-                    ret.push_str(",\n");
-                }
-                ret.push_str("}");
-            }
-            Kind::Anonymous => {
-                ret.push_str("type %");
-                ret.push_str(name);
-                ret.push_str(" = ");
-                self.gen_type(u, &mut fuel, &mut ret)?;
-            }
-            Kind::Resource => {
-                is_resource = true;
-                ret.push_str("resource %");
-                ret.push_str(name);
-            }
-        }
-
-        let ty = Type {
-            size: self.config.max_type_size - fuel,
-            is_resource,
-            name: name.to_string(),
-        };
-        Ok((ty, ret))
-    }
-
-    fn gen_type(
-        &mut self,
-        u: &mut Unstructured<'_>,
-        fuel: &mut usize,
-        dst: &mut String,
-    ) -> Result<()> {
-        #[derive(Arbitrary)]
-        enum Kind {
-            Bool,
-            U8,
-            U16,
-            U32,
-            U64,
-            S8,
-            S16,
-            S32,
-            S64,
-            Float32,
-            Float64,
-            Char,
-            String,
-            Id,
-            Tuple,
-            Option,
-            Result,
-            List,
-        }
-
-        *fuel = match fuel.checked_sub(1) {
-            Some(fuel) => fuel,
-            None => {
-                dst.push_str("bool");
-                return Ok(());
-            }
-        };
-        loop {
-            break match u.arbitrary()? {
-                Kind::Bool => dst.push_str("bool"),
-                Kind::U8 => dst.push_str("u8"),
-                Kind::S8 => dst.push_str("s8"),
-                Kind::U16 => dst.push_str("u16"),
-                Kind::S16 => dst.push_str("s16"),
-                Kind::U32 => dst.push_str("u32"),
-                Kind::S32 => dst.push_str("s32"),
-                Kind::U64 => dst.push_str("u64"),
-                Kind::S64 => dst.push_str("s64"),
-                Kind::Float32 => dst.push_str("float32"),
-                Kind::Float64 => dst.push_str("float64"),
-                Kind::Char => dst.push_str("char"),
-                Kind::String => dst.push_str("string"),
-                Kind::Id => {
-                    if self.types_in_interface.is_empty() {
-                        continue;
-                    }
-                    let ty = u.choose(&self.types_in_interface)?;
-                    *fuel = match fuel.checked_sub(ty.size) {
-                        Some(fuel) => fuel,
-                        None => continue,
-                    };
-                    let own_wrapper = if ty.is_resource && u.arbitrary()? {
-                        dst.push_str("own<");
-                        true
-                    } else {
-                        false
-                    };
-                    dst.push_str("%");
-                    dst.push_str(&ty.name);
-                    if own_wrapper {
-                        dst.push_str(">");
-                    }
-                }
-                Kind::Tuple => {
-                    let fields = u.int_in_range(0..=self.config.max_type_parts)?;
-                    *fuel = match fuel.checked_sub(fields) {
-                        Some(fuel) => fuel,
-                        None => continue,
-                    };
-                    dst.push_str("tuple<");
-                    for i in 0..fields {
-                        if i > 0 {
-                            dst.push_str(", ");
-                        }
-                        self.gen_type(u, fuel, dst)?;
-                    }
-                    dst.push_str(">");
-                }
-                Kind::Option => {
-                    *fuel = match fuel.checked_sub(1) {
-                        Some(fuel) => fuel,
-                        None => continue,
-                    };
-                    dst.push_str("option<");
-                    self.gen_type(u, fuel, dst)?;
-                    dst.push_str(">");
-                }
-                Kind::List => {
-                    *fuel = match fuel.checked_sub(1) {
-                        Some(fuel) => fuel,
-                        None => continue,
-                    };
-                    dst.push_str("list<");
-                    self.gen_type(u, fuel, dst)?;
-                    dst.push_str(">");
-                }
-                Kind::Result => {
-                    *fuel = match fuel.checked_sub(2) {
-                        Some(fuel) => fuel,
-                        None => continue,
-                    };
-                    dst.push_str("result");
-                    let ok = u.arbitrary()?;
-                    let err = u.arbitrary()?;
-                    match (ok, err) {
-                        (true, true) => {
-                            dst.push_str("<");
-                            self.gen_type(u, fuel, dst)?;
-                            dst.push_str(", ");
-                            self.gen_type(u, fuel, dst)?;
-                            dst.push_str(">");
-                        }
-                        (true, false) => {
-                            dst.push_str("<");
-                            self.gen_type(u, fuel, dst)?;
-                            dst.push_str(">");
-                        }
-                        (false, true) => {
-                            dst.push_str("<_, ");
-                            self.gen_type(u, fuel, dst)?;
-                            dst.push_str(">");
-                        }
-                        (false, false) => {}
-                    }
-                }
-            };
-        }
-
-        Ok(())
-    }
-
-    fn gen_func(&mut self, u: &mut Unstructured<'_>) -> Result<String> {
-        let mut ret = "%".to_string();
-        ret.push_str(&self.gen_unique_name(u)?);
-        ret.push_str(": ");
-        self.gen_func_sig(u, &mut ret, false)?;
-        Ok(ret)
-    }
-
-    fn gen_func_sig(
-        &mut self,
-        u: &mut Unstructured<'_>,
-        dst: &mut String,
-        method: bool,
-    ) -> Result<()> {
-        dst.push_str("func");
-        self.gen_params(u, dst, method)?;
-        if u.arbitrary()? {
-            dst.push_str(" -> ");
-            self.gen_params(u, dst, false)?;
-        } else if u.arbitrary()? {
-            dst.push_str(" -> ");
-            let mut fuel = self.config.max_type_size;
-            self.gen_type(u, &mut fuel, dst)?;
-        }
-        Ok(())
-    }
-
-    fn gen_params(
-        &mut self,
-        u: &mut Unstructured<'_>,
-        dst: &mut String,
-        method: bool,
-    ) -> Result<()> {
-        dst.push_str("(");
-        let mut names = HashSet::new();
-        if method {
-            names.insert("self".to_string());
-        }
-        let mut fuel = self.config.max_type_size;
-        for i in 0..u.int_in_range(0..=self.config.max_type_parts)? {
-            if i > 0 {
-                dst.push_str(", ");
-            }
-            dst.push_str("%");
-            dst.push_str(&gen_unique_name(u, &mut names)?);
-            dst.push_str(": ");
-            self.gen_type(u, &mut fuel, dst)?;
-        }
-        dst.push_str(")");
-        Ok(())
-    }
-
-    fn gen_unique_name(&mut self, u: &mut Unstructured<'_>) -> Result<String> {
-        gen_unique_name(u, &mut self.unique_names)
-    }
-}
-
-fn gen_unique_name(u: &mut Unstructured<'_>, set: &mut HashSet<String>) -> Result<String> {
-    let mut name = gen_name(u)?;
-    while !set.insert(name.clone()) {
-        write!(&mut name, "{}", set.len()).unwrap();
-    }
-    Ok(name)
-}
-
-fn gen_name(u: &mut Unstructured<'_>) -> Result<String> {
-    let size = u.arbitrary_len::<u8>()?;
-    let size = std::cmp::min(size, 20);
-    let name = match str::from_utf8(u.peek_bytes(size).unwrap()) {
-        Ok(s) => {
-            u.bytes(size).unwrap();
-            s.to_string()
-        }
-        Err(e) => {
-            let i = e.valid_up_to();
-            let valid = u.bytes(i).unwrap();
-            str::from_utf8(valid).unwrap().to_string()
-        }
-    };
-    let name = name
-        .chars()
-        .map(|x| if x.is_ascii_lowercase() { x } else { 'x' })
-        .collect::<String>();
-    Ok(if name.is_empty() {
-        "name".to_string()
-    } else {
-        name
-    })
-}
-
-fn shuffle<T>(u: &mut Unstructured<'_>, mut slice: &mut [T]) -> Result<()> {
-    while slice.len() > 0 {
-        let pos = u.int_in_range(0..=slice.len() - 1)?;
-        slice.swap(0, pos);
-        slice = &mut slice[1..];
-    }
-    Ok(())
-}
-
-#[derive(Default)]
-struct File {
-    items: Vec<String>,
-    namespace: HashMap<String, Definition>,
-    interfaces: IndexMap<String, FileInterface>,
-}
-
-#[derive(Clone)]
-struct FileInterface {
-    name: String,
-    id: u32,
-    types: Rc<TypeList>,
-}
-
-#[derive(PartialEq)]
-enum Definition {
-    Package,
-    File,
-}
-
-impl File {
-    fn gen_unique_package_name(
-        &mut self,
-        u: &mut Unstructured<'_>,
-        names: &mut HashSet<String>,
-    ) -> Result<String> {
-        let mut name = gen_name(u)?;
-        loop {
-            // Find a package-unique name first
-            if !names.insert(name.clone()) {
-                write!(&mut name, "{}", names.len()).unwrap();
-                continue;
-            }
-
-            // Then make sure it's file-unique too
-            if self.claim_file_name(&mut name) {
-                break;
-            }
-        }
-        Ok(name)
-    }
-
-    fn gen_unique_file_name(&mut self, u: &mut Unstructured<'_>) -> Result<String> {
-        let mut name = gen_name(u)?;
-        while !self.claim_file_name(&mut name) {
-            // try again on the next iteration
-        }
-        Ok(name)
-    }
-
-    fn claim_file_name(&mut self, name: &mut String) -> bool {
-        match self.namespace.entry(name.clone()) {
-            Entry::Occupied(mut e) => match e.get() {
-                // If this name is already claimed elsewhere in the package
-                // then that's ok as we're going to shadow it, so switch it
-                // to a file definition.
-                Definition::Package => *e.get_mut() = Definition::File,
-
-                // If it's already defined in the file try to add more stuff
-                // to the name to make the next try not collide.
-                Definition::File => {
-                    name.push_str("y");
-                    write!(name, "{}", self.namespace.len()).unwrap();
-                    return false;
-                }
-            },
-
-            // Not defined? Claim it.
-            Entry::Vacant(v) => {
-                v.insert(Definition::File);
-            }
-        }
-        true
-    }
-
-    fn insert_definition(&mut self, def: FileInterface) {
-        match self.namespace.get(&def.name) {
-            Some(Definition::File) => return,
-            Some(Definition::Package) => unreachable!(),
-            None => {}
-        }
-        let prev = self.namespace.insert(def.name.clone(), Definition::Package);
-        assert!(prev.is_none());
-        let prev = self.interfaces.insert(def.name.clone(), def);
-        assert!(prev.is_none());
-    }
-}
-
-fn gen_version(u: &mut Unstructured<'_>) -> Result<Version> {
-    Ok(Version {
-        major: u.int_in_range(0..=10)?,
-        minor: u.int_in_range(0..=10)?,
-        patch: u.int_in_range(0..=10)?,
-        pre: if u.arbitrary()? {
-            semver::Prerelease::new("alpha.0").unwrap()
-        } else {
-            semver::Prerelease::EMPTY
-        },
-        build: if u.arbitrary()? {
-            semver::BuildMetadata::new("1.2.0").unwrap()
-        } else {
-            semver::BuildMetadata::EMPTY
-        },
-    })
-}
diff --git a/crates/wit-smith/src/lib.rs b/crates/wit-smith/src/lib.rs
deleted file mode 100644
index bbd5e863..00000000
--- a/crates/wit-smith/src/lib.rs
+++ /dev/null
@@ -1,42 +0,0 @@
-//! A small crate to generate arbitrary WIT documents.
-//!
-//! This crate is modeled after the `wasm-smith` crate but is used to generate
-//! WIT documents instead of WebAssembly modules. This crate is intended to
-//! generate "interesting" WIT package structures in addition to interesting
-//! type structures.
-
-use arbitrary::{Result, Unstructured};
-use wit_parser::Resolve;
-
-mod config;
-pub use self::config::Config;
-mod generate;
-
-/// Generates an arbitrary WIT document encoded as a WebAssembly binary.
-///
-/// The `config` guides the generation of the document and the `u` bytes are
-/// used as input to construct the document.
-pub fn smith(config: &Config, u: &mut Unstructured<'_>) -> Result<Vec<u8>> {
-    let pkgs = generate::Generator::new(config.clone()).gen(u)?;
-    let mut resolve = Resolve::default();
-    let mut last = None;
-    for pkg in pkgs {
-        let unresolved = pkg.sources.parse().unwrap();
-        let id = match resolve.push(unresolved) {
-            Ok(id) => id,
-            Err(e) => {
-                if e.to_string().contains(
-                    "interface transitively depends on an interface in \
-                     incompatible ways",
-                ) {
-                    return Err(arbitrary::Error::IncorrectFormat);
-                }
-                panic!("bad wit parse: {e:?}")
-            }
-        };
-        last = Some(id);
-    }
-    let pkg = last.unwrap();
-
-    Ok(wit_component::encode(&resolve, pkg).expect("failed to encode WIT document"))
-}
diff --git a/fuzz/Cargo.toml b/fuzz/Cargo.toml
index 7aa59e05..f7500e60 100644
--- a/fuzz/Cargo.toml
+++ b/fuzz/Cargo.toml
@@ -22,7 +22,6 @@ wasmtime = { workspace = true, optional = true }
 wast = { path = "../crates/wast" }
 wat = { path = "../crates/wat" }
 wit-parser = { path = "../crates/wit-parser" }
-wit-smith = { path = "../crates/wit-smith" }
 wit-component = { path = "../crates/wit-component", features = ['dummy-module'] }
 wasm-encoder = { path = "../crates/wasm-encoder" }
 
diff --git a/fuzz/fuzz_targets/mutate.rs b/fuzz/fuzz_targets/mutate.rs
index b1fb6273..a97cb664 100644
--- a/fuzz/fuzz_targets/mutate.rs
+++ b/fuzz/fuzz_targets/mutate.rs
@@ -179,23 +179,20 @@ mod eval {
             &mut mutated_store,
             mutated_instance,
         );
-        let should_have_same_state = assert_same_calls(
+        assert_same_calls(
+            &orig_module,
+            &mut orig_store,
+            orig_instance,
+            &mut mutated_store,
+            mutated_instance,
+        );
+        assert_same_state(
             &orig_module,
             &mut orig_store,
             orig_instance,
             &mut mutated_store,
             mutated_instance,
         );
-
-        if should_have_same_state {
-            assert_same_state(
-                &orig_module,
-                &mut orig_store,
-                orig_instance,
-                &mut mutated_store,
-                mutated_instance,
-            );
-        }
     }
 
     fn assert_same_state(
@@ -252,7 +249,7 @@ mod eval {
         orig_instance: wasmtime::Instance,
         mutated_store: &mut wasmtime::Store<StoreLimits>,
         mutated_instance: wasmtime::Instance,
-    ) -> bool {
+    ) {
         for export in orig_module.exports() {
             let func_ty = match export.ty() {
                 wasmtime::ExternType::Func(func_ty) => func_ty,
@@ -268,13 +265,16 @@ mod eval {
             let mut orig_results = vec![Val::I32(0); func_ty.results().len()];
             let mut mutated_results = orig_results.clone();
             log::debug!("invoking `{}`", export.name());
+            let prev_consumed = orig_store.fuel_consumed().unwrap();
             match (
                 {
                     orig_store.add_fuel(1_000).unwrap();
                     orig_func.call(&mut *orig_store, &args, &mut orig_results)
                 },
                 {
-                    mutated_store.add_fuel(1000).unwrap();
+                    let consumed = orig_store.fuel_consumed().unwrap() - prev_consumed;
+                    log::debug!("consumed {consumed} fuel");
+                    mutated_store.add_fuel(consumed).unwrap();
                     mutated_func.call(&mut *mutated_store, &args, &mut mutated_results)
                 },
             ) {
@@ -283,28 +283,13 @@ mod eval {
                         assert_val_eq(orig_val, mutated_val);
                     }
                 }
-                // If either test case ran out of fuel then that's ok since
-                // mutation may add code or delete code which causes one side to
-                // take more or less fuel than the other. In this situation,
-                // however, execution has diverged so throw out the test case.
-                (Err(e), _) | (_, Err(e))
-                    if e.downcast_ref() == Some(&wasmtime::Trap::OutOfFuel) =>
-                {
-                    return false
-                }
-                (Err(orig), Err(mutated)) => {
-                    log::debug!("original error {orig:?}");
-                    log::debug!("mutated error {mutated:?}");
-                    continue;
-                }
+                (Err(_), Err(_)) => continue,
                 (orig, mutated) => panic!(
                     "mutated and original Wasm diverged: orig = {:?}; mutated = {:?}",
                     orig, mutated,
                 ),
             }
         }
-
-        true
     }
 
     fn assert_val_eq(orig_val: &wasmtime::Val, mutated_val: &wasmtime::Val) {
diff --git a/fuzz/fuzz_targets/no-traps.rs b/fuzz/fuzz_targets/no-traps.rs
index 74b442e8..9e0f46d2 100644
--- a/fuzz/fuzz_targets/no-traps.rs
+++ b/fuzz/fuzz_targets/no-traps.rs
@@ -25,13 +25,7 @@ fuzz_target!(|data: &[u8]| {
         Ok(m) => m,
         Err(_) => return,
     };
-    validate_module(config.clone(), &wasm_bytes);
-
-    // Tail calls aren't implemented in wasmtime, so don't try to run them
-    // there.
-    if config.tail_call_enabled {
-        return;
-    }
+    validate_module(config, &wasm_bytes);
 
     #[cfg(feature = "wasmtime")]
     {
diff --git a/fuzz/fuzz_targets/roundtrip-wit.rs b/fuzz/fuzz_targets/roundtrip-wit.rs
index c2c5cc3f..332daa83 100644
--- a/fuzz/fuzz_targets/roundtrip-wit.rs
+++ b/fuzz/fuzz_targets/roundtrip-wit.rs
@@ -1,52 +1,64 @@
 #![no_main]
 
 use libfuzzer_sys::fuzz_target;
-use std::borrow::Cow;
+use std::collections::HashMap;
 use std::path::Path;
 use wasm_encoder::{CustomSection, Encode, Section};
 use wit_component::*;
-use wit_parser::{Resolve, SourceMap};
+use wit_parser::{PackageId, Resolve, SourceMap};
 
 fuzz_target!(|data: &[u8]| {
     drop(env_logger::try_init());
 
     let mut u = arbitrary::Unstructured::new(data);
-    let wasm = match u.arbitrary().and_then(|config| {
-        log::debug!("config: {config:#?}");
-        wit_smith::smith(&config, &mut u)
-    }) {
-        Ok(wasm) => wasm,
+    let pkgs = match generate::packages(&mut u) {
+        Ok(doc) => doc,
         Err(_) => return,
     };
-    write_file("doc1.wasm", &wasm);
-    let (resolve, _pkg) = match wit_component::decode(&wasm).unwrap() {
-        DecodedWasm::WitPackage(resolve, pkg) => (resolve, pkg),
-        DecodedWasm::Component(..) => unreachable!(),
-    };
-    roundtrip_through_printing("doc1", &resolve, &wasm);
+    let mut resolve = Resolve::default();
+    let mut deps = HashMap::new();
+    let mut last = None;
+    for pkg in pkgs {
+        let url = format!("my-scheme:/{}", pkg.name);
+        let unresolved = pkg.sources.parse(&pkg.name, Some(&url)).unwrap();
+        let id = match resolve.push(unresolved, &deps) {
+            Ok(id) => id,
+            Err(e) => {
+                let err = e.to_string();
+                if err.contains("conflicts with a previous")
+                    || err.contains("shadows previously imported")
+                {
+                    return;
+                }
+                panic!("bad wit parse: {e:?}")
+            }
+        };
+        let prev = deps.insert(pkg.name, id);
+        assert!(prev.is_none());
+        last = Some(id);
+    }
+    let pkg = last.unwrap();
+    let wasm = roundtrip_through_printing("doc1", &resolve, pkg);
 
-    let (resolve2, pkg2) = match wit_component::decode(&wasm).unwrap() {
+    let name = &resolve.packages[pkg].name;
+    let (resolve2, pkg2) = match wit_component::decode(&name, &wasm).unwrap() {
         DecodedWasm::WitPackage(resolve, pkg) => (resolve, pkg),
         DecodedWasm::Component(..) => unreachable!(),
     };
 
-    let wasm2 = wit_component::encode(&resolve2, pkg2).expect("failed to encode WIT document");
-    write_file("doc2.wasm", &wasm2);
-    roundtrip_through_printing("doc2", &resolve2, &wasm2);
+    let wasm2 = roundtrip_through_printing("doc2", &resolve2, pkg2);
 
     if wasm != wasm2 {
         panic!("roundtrip wasm didn't match");
     }
 
-    // If there's hundreds or thousands of worlds only work with the first few
-    // to avoid timing out this fuzzer with asan enabled.
-    for (id, _world) in resolve.worlds.iter().take(20) {
+    for (id, _world) in resolve.worlds.iter() {
         let mut dummy = wit_component::dummy_module(&resolve, id);
         let metadata =
             wit_component::metadata::encode(&resolve, id, StringEncoding::UTF8, None).unwrap();
         let section = CustomSection {
-            name: "component-type".into(),
-            data: Cow::Borrowed(&metadata),
+            name: "component-type",
+            data: &metadata,
         };
         dummy.push(section.id());
         section.encode(&mut dummy);
@@ -65,23 +77,37 @@ fuzz_target!(|data: &[u8]| {
         .validate_all(&wasm)
         .unwrap();
 
-        wit_component::decode(&wasm).unwrap();
+        wit_component::decode(&name, &wasm).unwrap();
     }
 });
 
-fn roundtrip_through_printing(file: &str, resolve: &Resolve, wasm: &[u8]) {
+fn roundtrip_through_printing(file: &str, resolve: &Resolve, pkg: PackageId) -> Vec<u8> {
+    // Encode `resolve` to wasm as the baseline expectation
+    let wasm = wit_component::encode(resolve, pkg).unwrap();
+    write_file(&format!("{file}.wasm"), &wasm);
+    wasmparser::Validator::new_with_features(wasmparser::WasmFeatures {
+        component_model: true,
+        ..Default::default()
+    })
+    .validate_all(&wasm)
+    .unwrap();
+
     // For all packages in `resolve` print them all to a string, then re-parse
     // them and insert them into a `new_resolve`.
+    let mut new_deps = HashMap::new();
     let mut new_resolve = Resolve::default();
     let mut last = None;
-    for (id, pkg) in resolve.packages.iter() {
+    for (_, pkg) in resolve.packages.iter() {
         let mut map = SourceMap::new();
         let pkg_name = &pkg.name;
-        let doc = WitPrinter::default().print(resolve, id).unwrap();
-        write_file(&format!("{file}-{pkg_name}.wit"), &doc);
-        map.push(format!("{pkg_name}.wit").as_ref(), doc);
-        let unresolved = map.parse().unwrap();
-        let id = new_resolve.push(unresolved).unwrap();
+        for (name, doc) in pkg.documents.iter() {
+            let doc = DocumentPrinter::default().print(resolve, *doc).unwrap();
+            write_file(&format!("{file}-{pkg_name}-{name}.wit"), &doc);
+            map.push(format!("{name}.wit").as_ref(), &name, doc);
+        }
+        let unresolved = map.parse(&pkg.name, pkg.url.as_deref()).unwrap();
+        let id = new_resolve.push(unresolved, &new_deps).unwrap();
+        new_deps.insert(pkg.name.clone(), id);
         last = Some(id);
     }
 
@@ -92,6 +118,8 @@ fn roundtrip_through_printing(file: &str, resolve: &Resolve, wasm: &[u8]) {
     if wasm != wasm2 {
         panic!("failed to roundtrip through text printing");
     }
+
+    wasm
 }
 
 fn write_file(path: &str, contents: impl AsRef<[u8]>) {
@@ -108,3 +136,723 @@ fn write_file(path: &str, contents: impl AsRef<[u8]>) {
         std::fs::write(path, wasmprinter::print_bytes(&contents).unwrap()).unwrap();
     }
 }
+
+mod generate {
+    use arbitrary::{Arbitrary, Result, Unstructured};
+    use std::collections::HashSet;
+    use std::mem;
+    use std::str;
+    use wit_parser::*;
+
+    const MAX_PARTS: usize = 5;
+    const MAX_PACKAGES: usize = 10;
+    const MAX_DOCUMENTS: usize = 10;
+    const MAX_DOC_ITEMS: usize = 10;
+    const MAX_WORLD_ITEMS: usize = 10;
+    const MAX_INTERFACE_ITEMS: usize = 10;
+    const MAX_TYPE_SIZE: usize = 100;
+
+    #[derive(Default)]
+    struct Generator {
+        packages: PackageList,
+        documents: DocumentList,
+        interfaces: InterfaceList,
+        next_interface_id: u32,
+    }
+
+    type TypeList = Vec<(String, usize)>;
+    type InterfaceList = Vec<(String, u32, bool, TypeList)>;
+    type DocumentList = Vec<(String, InterfaceList)>;
+    type PackageList = Vec<(String, DocumentList)>;
+
+    struct InterfaceGenerator<'a> {
+        gen: &'a Generator,
+        unique_names: HashSet<String>,
+        types_in_interface: Vec<(String, usize)>,
+    }
+
+    pub struct Package {
+        pub name: String,
+        pub sources: SourceMap,
+    }
+
+    pub fn packages(u: &mut Unstructured<'_>) -> Result<Vec<Package>> {
+        Generator::default().gen(u)
+    }
+
+    impl Generator {
+        fn gen(&mut self, u: &mut Unstructured<'_>) -> Result<Vec<Package>> {
+            let mut packages = Vec::new();
+            let mut names = HashSet::new();
+            while packages.len() < MAX_PACKAGES && (packages.is_empty() || u.arbitrary()?) {
+                let name = gen_unique_name(u, &mut names)?;
+                let (sources, documents) = self.gen_package(&name, u)?;
+                if documents.len() > 0 {
+                    self.packages.push((name.clone(), documents));
+                }
+                packages.push(Package { name, sources });
+            }
+            Ok(packages)
+        }
+
+        fn gen_package(
+            &mut self,
+            pkg: &str,
+            u: &mut Unstructured<'_>,
+        ) -> Result<(SourceMap, DocumentList)> {
+            let mut map = SourceMap::new();
+            let mut count = 0;
+            let mut names = HashSet::new();
+
+            while count < MAX_DOCUMENTS && (count == 0 || u.arbitrary()?) {
+                let name = gen_unique_name(u, &mut names)?;
+                let (doc, interfaces) = self.gen_document(u)?;
+                super::write_file(format!("orig-{pkg}-{name}.wit").as_ref(), &doc);
+                map.push(format!("{name}.wit").as_ref(), &name, doc);
+                count += 1;
+                if interfaces.len() > 0 {
+                    self.documents.push((name, interfaces));
+                }
+            }
+
+            Ok((map, mem::take(&mut self.documents)))
+        }
+
+        fn gen_document(&mut self, u: &mut Unstructured<'_>) -> Result<(String, InterfaceList)> {
+            #[derive(Arbitrary)]
+            enum Generate {
+                World,
+                Interface,
+                Done,
+            }
+
+            let mut pieces = Vec::new();
+            let mut has_default_interface = false;
+            let mut has_default_world = false;
+            let mut names = HashSet::new();
+            while pieces.len() < MAX_DOC_ITEMS && !u.is_empty() {
+                let name = gen_unique_name(u, &mut names)?;
+                match u.arbitrary()? {
+                    Generate::World => {
+                        pieces.push(self.gen_world(u, &name, &mut has_default_world)?)
+                    }
+                    Generate::Interface => {
+                        let id = self.next_interface_id;
+                        self.next_interface_id += 1;
+                        let (src, types) =
+                            self.gen_interface(u, Some(&name), &mut has_default_interface)?;
+                        if types.len() > 0 {
+                            self.interfaces
+                                .push((name, id, src.starts_with("default"), types));
+                        }
+                        pieces.push(src);
+                    }
+                    Generate::Done => break,
+                }
+            }
+            shuffle(u, &mut pieces)?;
+            let mut ret = String::new();
+            for piece in pieces {
+                ret.push_str(&piece);
+                ret.push_str("\n\n");
+            }
+            Ok((ret, mem::take(&mut self.interfaces)))
+        }
+
+        fn gen_world(
+            &mut self,
+            u: &mut Unstructured<'_>,
+            name: &str,
+            has_default: &mut bool,
+        ) -> Result<String> {
+            InterfaceGenerator::new(self).gen_world(u, name, has_default)
+        }
+
+        fn gen_interface(
+            &mut self,
+            u: &mut Unstructured<'_>,
+            name: Option<&str>,
+            has_default: &mut bool,
+        ) -> Result<(String, TypeList)> {
+            let mut gen = InterfaceGenerator::new(self);
+            let ret = gen.gen_interface(u, name, has_default)?;
+            Ok((ret, gen.types_in_interface))
+        }
+
+        fn gen_path(
+            &self,
+            u: &mut Unstructured<'_>,
+            dst: &mut String,
+        ) -> Result<Option<(u32, &TypeList)>> {
+            enum Choice {
+                Interfaces,
+                Documents,
+                Packages,
+            }
+            let mut choices = Vec::new();
+            if !self.interfaces.is_empty() {
+                choices.push(Choice::Interfaces);
+            }
+            if !self.documents.is_empty() {
+                choices.push(Choice::Documents);
+            }
+            if !self.packages.is_empty() {
+                choices.push(Choice::Packages);
+            }
+            if choices.is_empty() {
+                return Ok(None);
+            }
+            Ok(match u.choose(&choices)? {
+                Choice::Interfaces => {
+                    dst.push_str("self.");
+                    let (name, id, _default, types) = u.choose(&self.interfaces)?;
+                    dst.push_str("%");
+                    dst.push_str(name);
+                    Some((*id, types))
+                }
+                Choice::Documents => {
+                    dst.push_str("pkg.");
+                    let (name, ifaces) = u.choose(&self.documents)?;
+                    dst.push_str("%");
+                    dst.push_str(name);
+                    let (name, id, default, types) = u.choose(ifaces)?;
+                    if !*default || !u.arbitrary()? {
+                        dst.push_str(".");
+                        dst.push_str("%");
+                        dst.push_str(name);
+                    }
+                    Some((*id, types))
+                }
+                Choice::Packages => {
+                    let (name, docs) = u.choose(&self.packages)?;
+                    dst.push_str("%");
+                    dst.push_str(name);
+                    dst.push_str(".");
+                    let (name, ifaces) = u.choose(docs)?;
+                    dst.push_str("%");
+                    dst.push_str(name);
+                    let (name, id, default, types) = u.choose(ifaces)?;
+                    if !*default || !u.arbitrary()? {
+                        dst.push_str(".");
+                        dst.push_str("%");
+                        dst.push_str(name);
+                    }
+                    Some((*id, types))
+                }
+            })
+        }
+    }
+
+    impl<'a> InterfaceGenerator<'a> {
+        fn new(gen: &'a Generator) -> InterfaceGenerator<'a> {
+            InterfaceGenerator {
+                gen,
+                types_in_interface: Vec::new(),
+                unique_names: HashSet::new(),
+            }
+        }
+
+        fn gen_interface(
+            &mut self,
+            u: &mut Unstructured<'_>,
+            name: Option<&str>,
+            has_default: &mut bool,
+        ) -> Result<String> {
+            let mut ret = String::new();
+            if !*has_default && u.arbitrary()? {
+                *has_default = true;
+                ret.push_str("default ");
+            }
+            ret.push_str("interface ");
+            if let Some(name) = name {
+                ret.push_str("%");
+                ret.push_str(name);
+                ret.push_str(" ");
+            }
+            ret.push_str("{\n");
+
+            #[derive(Arbitrary)]
+            enum Generate {
+                Use,
+                Type,
+                Function,
+            }
+
+            let mut parts = Vec::new();
+            while parts.len() < MAX_INTERFACE_ITEMS && u.arbitrary()? {
+                match u.arbitrary()? {
+                    Generate::Use => {
+                        let mut part = String::new();
+                        if self.gen_use(u, &mut part)? {
+                            parts.push(part);
+                        }
+                    }
+                    Generate::Type => {
+                        let name = self.gen_unique_name(u)?;
+                        let (size, typedef) = self.gen_typedef(u, &name)?;
+                        parts.push(typedef);
+                        self.types_in_interface.push((name, size));
+                    }
+                    Generate::Function => {
+                        parts.push(self.gen_func(u)?);
+                    }
+                }
+            }
+
+            shuffle(u, &mut parts)?;
+            for part in parts {
+                ret.push_str(&part);
+                ret.push_str("\n\n");
+            }
+
+            ret.push_str("}");
+            Ok(ret)
+        }
+
+        fn gen_world(
+            &mut self,
+            u: &mut Unstructured<'_>,
+            name: &str,
+            has_default: &mut bool,
+        ) -> Result<String> {
+            let mut ret = String::new();
+            if !*has_default && u.arbitrary()? {
+                *has_default = true;
+                ret.push_str("default ");
+            }
+            ret.push_str("world %");
+            ret.push_str(name);
+            ret.push_str(" {\n");
+
+            #[derive(Arbitrary, Copy, Clone)]
+            enum Direction {
+                Import,
+                Export,
+            }
+
+            #[derive(Arbitrary)]
+            enum ItemKind {
+                Func(Direction),
+                Interface(Direction),
+                AnonInterface(Direction),
+                Type,
+                Use,
+            }
+
+            let mut parts = Vec::new();
+            let mut imported_interfaces = HashSet::new();
+            let mut exported_interfaces = HashSet::new();
+
+            while parts.len() < MAX_WORLD_ITEMS && !u.is_empty() && u.arbitrary()? {
+                let kind = u.arbitrary::<ItemKind>()?;
+                let direction = match kind {
+                    ItemKind::Func(dir)
+                    | ItemKind::Interface(dir)
+                    | ItemKind::AnonInterface(dir) => Some(dir),
+                    ItemKind::Type | ItemKind::Use => None,
+                };
+
+                let mut part = String::new();
+                let name = match direction {
+                    Some(Direction::Import) | None => gen_unique_name(u, &mut self.unique_names)?,
+                    Some(Direction::Export) => gen_unique_name(u, &mut self.unique_names)?,
+                };
+                if let Some(dir) = direction {
+                    part.push_str(match dir {
+                        Direction::Import => "import",
+                        Direction::Export => "export",
+                    });
+                    part.push_str(" %");
+                    part.push_str(&name);
+                    part.push_str(": ");
+                }
+
+                match kind {
+                    ItemKind::Func(_) => {
+                        self.gen_func_sig(u, &mut part)?;
+                    }
+                    ItemKind::Interface(dir) => {
+                        let id = match self.gen.gen_path(u, &mut part)? {
+                            Some((id, _types)) => id,
+                            // If an interface couldn't be chosen or wasn't
+                            // chosen then skip this import. A unique name was
+                            // selecteed above but we just sort of leave that
+                            // floating in the wild to get handled by some other
+                            // test case.
+                            None => continue,
+                        };
+
+                        // If this interface has already been imported or
+                        // exported this document can't do so again. Throw out
+                        // this item in that situation.
+                        let unique = match dir {
+                            Direction::Import => imported_interfaces.insert(id),
+                            Direction::Export => exported_interfaces.insert(id),
+                        };
+                        if !unique {
+                            continue;
+                        }
+                    }
+                    ItemKind::AnonInterface(_) => {
+                        let iface =
+                            InterfaceGenerator::new(self.gen).gen_interface(u, None, &mut true)?;
+                        part.push_str(&iface);
+                    }
+
+                    ItemKind::Type => {
+                        let (size, typedef) = self.gen_typedef(u, &name)?;
+                        assert!(part.is_empty());
+                        part = typedef;
+                        self.types_in_interface.push((name, size));
+                    }
+
+                    ItemKind::Use => {
+                        if !self.gen_use(u, &mut part)? {
+                            continue;
+                        }
+                    }
+                }
+                parts.push(part);
+            }
+
+            shuffle(u, &mut parts)?;
+
+            for part in parts {
+                ret.push_str(&part);
+                ret.push_str("\n");
+            }
+
+            ret.push_str("}");
+
+            Ok(ret)
+        }
+
+        fn gen_use(&mut self, u: &mut Unstructured<'_>, part: &mut String) -> Result<bool> {
+            let mut path = String::new();
+            let (_id, types) = match self.gen.gen_path(u, &mut path)? {
+                Some(types) => types,
+                None => return Ok(false),
+            };
+            part.push_str("use ");
+            part.push_str(&path);
+            part.push_str(".{");
+            let (name, size) = u.choose(types)?;
+            part.push_str("%");
+            part.push_str(name);
+            let name = if self.unique_names.contains(name) || u.arbitrary()? {
+                part.push_str(" as %");
+                let name = self.gen_unique_name(u)?;
+                part.push_str(&name);
+                name
+            } else {
+                assert!(self.unique_names.insert(name.clone()));
+                name.clone()
+            };
+            self.types_in_interface.push((name, *size));
+            part.push_str("}");
+            Ok(true)
+        }
+
+        fn gen_typedef(&mut self, u: &mut Unstructured<'_>, name: &str) -> Result<(usize, String)> {
+            #[derive(Arbitrary)]
+            pub enum Kind {
+                Record,
+                Flags,
+                Variant,
+                Enum,
+                Union,
+                Anonymous,
+            }
+
+            let mut fuel = MAX_TYPE_SIZE;
+            let mut ret = String::new();
+            match u.arbitrary()? {
+                Kind::Record => {
+                    ret.push_str("record %");
+                    ret.push_str(name);
+                    ret.push_str(" {\n");
+                    for _ in 0..u.int_in_range(0..=MAX_PARTS)? {
+                        ret.push_str("  %");
+                        ret.push_str(&self.gen_unique_name(u)?);
+                        ret.push_str(": ");
+                        self.gen_type(u, &mut fuel, &mut ret)?;
+                        ret.push_str(",\n");
+                    }
+                    ret.push_str("}");
+                }
+                Kind::Variant => {
+                    ret.push_str("variant %");
+                    ret.push_str(name);
+                    ret.push_str(" {\n");
+                    for _ in 0..u.int_in_range(1..=MAX_PARTS)? {
+                        ret.push_str("  %");
+                        ret.push_str(&self.gen_unique_name(u)?);
+                        if u.arbitrary()? {
+                            ret.push_str("(");
+                            self.gen_type(u, &mut fuel, &mut ret)?;
+                            ret.push_str(")");
+                        }
+                        ret.push_str(",\n");
+                    }
+                    ret.push_str("}");
+                }
+                Kind::Union => {
+                    ret.push_str("union %");
+                    ret.push_str(name);
+                    ret.push_str(" {\n");
+                    for _ in 0..u.int_in_range(1..=MAX_PARTS)? {
+                        ret.push_str("  ");
+                        self.gen_type(u, &mut fuel, &mut ret)?;
+                        ret.push_str(",\n");
+                    }
+                    ret.push_str("}");
+                }
+                Kind::Enum => {
+                    ret.push_str("enum %");
+                    ret.push_str(name);
+                    ret.push_str(" {\n");
+                    for _ in 0..u.int_in_range(1..=MAX_PARTS)? {
+                        ret.push_str("  %");
+                        ret.push_str(&self.gen_unique_name(u)?);
+                        ret.push_str(",\n");
+                    }
+                    ret.push_str("}");
+                }
+                Kind::Flags => {
+                    ret.push_str("flags %");
+                    ret.push_str(name);
+                    ret.push_str(" {\n");
+                    for _ in 0..u.int_in_range(0..=MAX_PARTS)? {
+                        ret.push_str("  %");
+                        ret.push_str(&self.gen_unique_name(u)?);
+                        ret.push_str(",\n");
+                    }
+                    ret.push_str("}");
+                }
+                Kind::Anonymous => {
+                    ret.push_str("type %");
+                    ret.push_str(name);
+                    ret.push_str(" = ");
+                    self.gen_type(u, &mut fuel, &mut ret)?;
+                }
+            }
+
+            Ok((MAX_TYPE_SIZE - fuel, ret))
+        }
+
+        fn gen_type(
+            &mut self,
+            u: &mut Unstructured<'_>,
+            fuel: &mut usize,
+            dst: &mut String,
+        ) -> Result<()> {
+            #[derive(Arbitrary)]
+            enum Kind {
+                Bool,
+                U8,
+                U16,
+                U32,
+                U64,
+                S8,
+                S16,
+                S32,
+                S64,
+                Float32,
+                Float64,
+                Char,
+                String,
+                Id,
+                Tuple,
+                Option,
+                Result,
+                List,
+            }
+
+            *fuel = match fuel.checked_sub(1) {
+                Some(fuel) => fuel,
+                None => {
+                    dst.push_str("bool");
+                    return Ok(());
+                }
+            };
+            loop {
+                break match u.arbitrary()? {
+                    Kind::Bool => dst.push_str("bool"),
+                    Kind::U8 => dst.push_str("u8"),
+                    Kind::S8 => dst.push_str("s8"),
+                    Kind::U16 => dst.push_str("u16"),
+                    Kind::S16 => dst.push_str("s16"),
+                    Kind::U32 => dst.push_str("u32"),
+                    Kind::S32 => dst.push_str("s32"),
+                    Kind::U64 => dst.push_str("u64"),
+                    Kind::S64 => dst.push_str("s64"),
+                    Kind::Float32 => dst.push_str("float32"),
+                    Kind::Float64 => dst.push_str("float64"),
+                    Kind::Char => dst.push_str("char"),
+                    Kind::String => dst.push_str("string"),
+                    Kind::Id => {
+                        if self.types_in_interface.is_empty() {
+                            continue;
+                        }
+                        let (name, type_size) = u.choose(&self.types_in_interface)?;
+                        *fuel = match fuel.checked_sub(*type_size) {
+                            Some(fuel) => fuel,
+                            None => continue,
+                        };
+                        dst.push_str("%");
+                        dst.push_str(name);
+                    }
+                    Kind::Tuple => {
+                        let fields = u.int_in_range(0..=MAX_PARTS)?;
+                        *fuel = match fuel.checked_sub(fields) {
+                            Some(fuel) => fuel,
+                            None => continue,
+                        };
+                        dst.push_str("tuple<");
+                        for i in 0..fields {
+                            if i > 0 {
+                                dst.push_str(", ");
+                            }
+                            self.gen_type(u, fuel, dst)?;
+                        }
+                        dst.push_str(">");
+                    }
+                    Kind::Option => {
+                        *fuel = match fuel.checked_sub(1) {
+                            Some(fuel) => fuel,
+                            None => continue,
+                        };
+                        dst.push_str("option<");
+                        self.gen_type(u, fuel, dst)?;
+                        dst.push_str(">");
+                    }
+                    Kind::List => {
+                        *fuel = match fuel.checked_sub(1) {
+                            Some(fuel) => fuel,
+                            None => continue,
+                        };
+                        dst.push_str("list<");
+                        self.gen_type(u, fuel, dst)?;
+                        dst.push_str(">");
+                    }
+                    Kind::Result => {
+                        *fuel = match fuel.checked_sub(2) {
+                            Some(fuel) => fuel,
+                            None => continue,
+                        };
+                        dst.push_str("result");
+                        let ok = u.arbitrary()?;
+                        let err = u.arbitrary()?;
+                        match (ok, err) {
+                            (true, true) => {
+                                dst.push_str("<");
+                                self.gen_type(u, fuel, dst)?;
+                                dst.push_str(", ");
+                                self.gen_type(u, fuel, dst)?;
+                                dst.push_str(">");
+                            }
+                            (true, false) => {
+                                dst.push_str("<");
+                                self.gen_type(u, fuel, dst)?;
+                                dst.push_str(">");
+                            }
+                            (false, true) => {
+                                dst.push_str("<_, ");
+                                self.gen_type(u, fuel, dst)?;
+                                dst.push_str(">");
+                            }
+                            (false, false) => {}
+                        }
+                    }
+                };
+            }
+
+            Ok(())
+        }
+
+        fn gen_func(&mut self, u: &mut Unstructured<'_>) -> Result<String> {
+            let mut ret = "%".to_string();
+            ret.push_str(&self.gen_unique_name(u)?);
+            ret.push_str(": ");
+            self.gen_func_sig(u, &mut ret)?;
+            Ok(ret)
+        }
+
+        fn gen_func_sig(&mut self, u: &mut Unstructured<'_>, dst: &mut String) -> Result<()> {
+            dst.push_str("func");
+            self.gen_params(u, dst)?;
+            if u.arbitrary()? {
+                dst.push_str(" -> ");
+                self.gen_params(u, dst)?;
+            } else if u.arbitrary()? {
+                dst.push_str(" -> ");
+                let mut fuel = MAX_TYPE_SIZE;
+                self.gen_type(u, &mut fuel, dst)?;
+            }
+            Ok(())
+        }
+
+        fn gen_params(&mut self, u: &mut Unstructured<'_>, dst: &mut String) -> Result<()> {
+            dst.push_str("(");
+            let mut fuel = MAX_TYPE_SIZE;
+            for i in 0..u.int_in_range(0..=MAX_PARTS)? {
+                if i > 0 {
+                    dst.push_str(", ");
+                }
+                dst.push_str("%");
+                dst.push_str(&self.gen_unique_name(u)?);
+                dst.push_str(": ");
+                self.gen_type(u, &mut fuel, dst)?;
+            }
+            dst.push_str(")");
+            Ok(())
+        }
+
+        fn gen_unique_name(&mut self, u: &mut Unstructured<'_>) -> Result<String> {
+            gen_unique_name(u, &mut self.unique_names)
+        }
+    }
+
+    fn gen_unique_name(u: &mut Unstructured<'_>, set: &mut HashSet<String>) -> Result<String> {
+        use std::fmt::Write;
+        let mut name = gen_name(u)?;
+        while !set.insert(name.clone()) {
+            write!(&mut name, "{}", set.len()).unwrap();
+        }
+        Ok(name)
+    }
+
+    fn gen_name(u: &mut Unstructured<'_>) -> Result<String> {
+        let size = u.arbitrary_len::<u8>()?;
+        let size = std::cmp::min(size, 20);
+        let name = match str::from_utf8(u.peek_bytes(size).unwrap()) {
+            Ok(s) => {
+                u.bytes(size).unwrap();
+                s.to_string()
+            }
+            Err(e) => {
+                let i = e.valid_up_to();
+                let valid = u.bytes(i).unwrap();
+                str::from_utf8(valid).unwrap().to_string()
+            }
+        };
+        let name = name
+            .chars()
+            .map(|x| if x.is_ascii_lowercase() { x } else { 'x' })
+            .collect::<String>();
+        Ok(if name.is_empty() {
+            "name".to_string()
+        } else {
+            name
+        })
+    }
+
+    fn shuffle<T>(u: &mut Unstructured<'_>, mut slice: &mut [T]) -> Result<()> {
+        while slice.len() > 0 {
+            let pos = u.int_in_range(0..=slice.len() - 1)?;
+            slice.swap(0, pos);
+            slice = &mut slice[1..];
+        }
+        Ok(())
+    }
+}
diff --git a/fuzz/fuzz_targets/validate.rs b/fuzz/fuzz_targets/validate.rs
index 02a6357e..ec3358de 100644
--- a/fuzz/fuzz_targets/validate.rs
+++ b/fuzz/fuzz_targets/validate.rs
@@ -38,9 +38,8 @@ fuzz_target!(|data: &[u8]| {
         sign_extension: (byte2 & 0b1000_0000) != 0,
         memory_control: (byte3 & 0b0000_0001) != 0,
         function_references: (byte3 & 0b0000_0010) != 0,
-        gc: (byte3 & 0b0000_0100) != 0,
     });
-    let use_maybe_invalid = byte3 & 0b0000_1000 != 0;
+    let use_maybe_invalid = byte3 & 0b0000_0100 != 0;
 
     let wasm = &data[3..];
     if use_maybe_invalid {
diff --git a/fuzz/src/lib.rs b/fuzz/src/lib.rs
index 78f90866..666f6987 100644
--- a/fuzz/src/lib.rs
+++ b/fuzz/src/lib.rs
@@ -16,7 +16,6 @@ pub fn generate_valid_module(
     config.threads_enabled = u.arbitrary()?;
     config.exceptions_enabled = u.arbitrary()?;
     config.canonicalize_nans = u.arbitrary()?;
-    config.tail_call_enabled = u.arbitrary()?;
 
     configure(&mut config, u)?;
 
diff --git a/src/bin/wasm-tools/addr2line.rs b/src/bin/wasm-tools/addr2line.rs
deleted file mode 100644
index 5478a7cb..00000000
--- a/src/bin/wasm-tools/addr2line.rs
+++ /dev/null
@@ -1,160 +0,0 @@
-use addr2line::{Context, LookupResult};
-use anyhow::{bail, Context as _, Result};
-use gimli::EndianSlice;
-use std::collections::HashMap;
-use std::io::Write;
-use std::u64;
-use wasmparser::{Parser, Payload};
-
-/// Translate a WebAssembly address to a filename and line number using DWARF
-/// debugging information.
-///
-/// WebAssembly binaries compiled with Clang can have DWARF debug information
-/// inserted into them to map from WebAssembly instruction offsets to original
-/// filenames and line numbers. For example when compiling C the `-g` argument
-/// can be used or when compiling Rust the `-Cdebuginfo=1` argument can be used
-/// (or the default `dev` profile for Cargo). This subcommand will parse the
-/// DWARF debugging information and translate a list of addresses to their
-/// original filenames and line numbers.
-///
-/// Each address may have multiple lines printed for it indicating that the
-/// address is an inlined function into another function. Frames are printed
-/// innermost or youngest first.
-#[derive(clap::Parser)]
-pub struct Opts {
-    #[clap(flatten)]
-    io: wasm_tools::InputOutput,
-
-    /// Addresses to convert to filenames and line numbers.
-    ///
-    /// Arguments can be specified as either `0x...` or `@...` in hexadecimal or
-    /// are otherwise parsed as a base-10 address. Addresses should be relative
-    /// to the beginning of the module unless `--code-section-relative` is
-    /// passed in which case they should be relative to the beginning of the
-    /// contents of the code section.
-    addresses: Vec<String>,
-
-    /// Indicates that addresses are code-section-relative instead of offsets
-    /// from the beginning of the module.
-    #[clap(long)]
-    code_section_relative: bool,
-}
-
-impl Opts {
-    pub fn general_opts(&self) -> &wasm_tools::GeneralOpts {
-        self.io.general_opts()
-    }
-
-    pub fn run(&self) -> Result<()> {
-        let wasm = self.io.parse_input_wasm()?;
-
-        let (code_start, custom_sections) = self
-            .parse_custom_sections(&wasm)
-            .context("failed to parse input and read custom sections")?;
-
-        let dwarf = gimli::Dwarf::load(|id| -> Result<_> {
-            let data = custom_sections.get(id.name()).copied().unwrap_or(&[]);
-            Ok(EndianSlice::new(data, gimli::LittleEndian))
-        })?;
-        let cx = Context::from_dwarf(dwarf)
-            .context("failed to create addr2line dwarf mapping context")?;
-
-        let mut output = self.io.output_writer()?;
-
-        for addr in self.addresses.iter() {
-            self.addr2line(&addr, code_start, &cx, &mut output)
-                .with_context(|| format!("failed to find frames for `{addr}`"))?;
-        }
-
-        Ok(())
-    }
-
-    fn parse_custom_sections<'a>(
-        &self,
-        wasm: &'a [u8],
-    ) -> Result<(Option<u64>, HashMap<&'a str, &'a [u8]>)> {
-        let mut ret = HashMap::new();
-        let mut code_start = None;
-        for payload in Parser::new(0).parse_all(wasm) {
-            match payload? {
-                Payload::CustomSection(s) => {
-                    ret.insert(s.name(), s.data());
-                }
-                Payload::CodeSectionStart { range, .. } => {
-                    code_start = Some(range.start as u64);
-                }
-                _ => {}
-            }
-        }
-        Ok((code_start, ret))
-    }
-
-    fn addr2line(
-        &self,
-        addr: &str,
-        code_start: Option<u64>,
-        cx: &Context<EndianSlice<gimli::LittleEndian>>,
-        out: &mut dyn Write,
-    ) -> Result<()> {
-        // Support either `0x` or `@` prefixes for hex addresses since 0x is
-        // standard and @ is used by wasmprinter (and web browsers I think?)
-        let addr = if let Some(hex) = addr.strip_prefix("0x").or_else(|| addr.strip_prefix("@")) {
-            u64::from_str_radix(hex, 16)?
-        } else {
-            addr.parse()?
-        };
-
-        // Addresses in DWARF are relative to the start of the text section, so
-        // factor that in here.
-        let text_relative_addr = if self.code_section_relative {
-            addr
-        } else {
-            match code_start {
-                Some(start) => addr
-                    .checked_sub(start)
-                    .context("address is before the beginning of the text section")?,
-                None => bail!("no code section found in module"),
-            }
-        };
-
-        let mut frames = match cx.find_frames(text_relative_addr) {
-            LookupResult::Output(result) => result?,
-            LookupResult::Load { .. } => {
-                bail!("split-dwarf is not supported yet");
-            }
-        };
-
-        let mut first = true;
-        while let Some(frame) = frames.next()? {
-            if first {
-                write!(out, "{addr:#x}: ")?;
-            } else {
-                write!(out, "\t")?;
-            }
-            first = false;
-            if let Some(func) = &frame.function {
-                write!(out, "{}", func.demangle()?)?;
-            } else {
-                write!(out, "<unnamed>")?;
-            }
-
-            if let Some(loc) = &frame.location {
-                write!(out, " ")?;
-                if let Some(file) = loc.file {
-                    write!(out, "{file}")?;
-                }
-                if let Some(line) = loc.line {
-                    write!(out, ":{line}")?;
-                }
-                if let Some(column) = loc.column {
-                    write!(out, ":{column}")?;
-                }
-            }
-            writeln!(out, "")?;
-        }
-        if first {
-            writeln!(out, "{addr:#x}: no dwarf frames found for this address")?;
-        }
-        Ok(())
-    }
-}
diff --git a/src/bin/wasm-tools/component.rs b/src/bin/wasm-tools/component.rs
index fd837068..89bc9aec 100644
--- a/src/bin/wasm-tools/component.rs
+++ b/src/bin/wasm-tools/component.rs
@@ -1,14 +1,12 @@
 //! The WebAssembly component tool command line interface.
 
-use anyhow::{bail, Context, Result};
+use anyhow::{anyhow, bail, Context, Result};
 use clap::Parser;
-use std::borrow::Cow;
-use std::collections::HashMap;
 use std::io::Read;
 use std::path::{Path, PathBuf};
 use wasm_encoder::{Encode, Section};
 use wasm_tools::Output;
-use wit_component::{ComponentEncoder, DecodedWasm, StringEncoding, WitPrinter};
+use wit_component::{ComponentEncoder, DecodedWasm, DocumentPrinter, StringEncoding};
 use wit_parser::{PackageId, Resolve, UnresolvedPackage};
 
 /// WebAssembly wit-based component tooling.
@@ -17,7 +15,6 @@ pub enum Opts {
     New(NewOpts),
     Wit(WitOpts),
     Embed(EmbedOpts),
-    Targets(TargetsOpts),
 }
 
 impl Opts {
@@ -26,16 +23,6 @@ impl Opts {
             Opts::New(new) => new.run(),
             Opts::Wit(wit) => wit.run(),
             Opts::Embed(embed) => embed.run(),
-            Opts::Targets(targets) => targets.run(),
-        }
-    }
-
-    pub fn general_opts(&self) -> &wasm_tools::GeneralOpts {
-        match self {
-            Opts::New(new) => new.general_opts(),
-            Opts::Wit(wit) => wit.general_opts(),
-            Opts::Embed(embed) => embed.general_opts(),
-            Opts::Targets(targets) => targets.general_opts(),
         }
     }
 }
@@ -47,14 +34,10 @@ fn parse_optionally_name_file(s: &str) -> (&str, &str) {
         Some(path) => (name_or_path, path),
         None => {
             let name = Path::new(name_or_path)
-                .file_name()
+                .file_stem()
                 .unwrap()
                 .to_str()
                 .unwrap();
-            let name = match name.find('.') {
-                Some(i) => &name[..i],
-                None => name,
-            };
             (name, name_or_path)
         }
     }
@@ -107,10 +90,6 @@ pub struct NewOpts {
 }
 
 impl NewOpts {
-    fn general_opts(&self) -> &wasm_tools::GeneralOpts {
-        self.io.general_opts()
-    }
-
     /// Executes the application.
     fn run(self) -> Result<()> {
         let wasm = self.io.parse_input_wasm()?;
@@ -189,20 +168,13 @@ pub struct EmbedOpts {
     /// like to work with an interface in the component model.
     #[clap(long)]
     dummy: bool,
-
-    /// Print the output in the WebAssembly text format instead of binary.
-    #[clap(long, short = 't')]
-    wat: bool,
 }
 
 impl EmbedOpts {
-    fn general_opts(&self) -> &wasm_tools::GeneralOpts {
-        self.io.general_opts()
-    }
-
     /// Executes the application.
     fn run(self) -> Result<()> {
         let wasm = if self.dummy {
+            self.io.init_logger();
             None
         } else {
             Some(self.io.parse_input_wasm()?)
@@ -218,8 +190,8 @@ impl EmbedOpts {
         )?;
 
         let section = wasm_encoder::CustomSection {
-            name: "component-type".into(),
-            data: Cow::Borrowed(&encoded),
+            name: "component-type",
+            data: &encoded,
         };
         let mut wasm = wasm.unwrap_or_else(|| wit_component::dummy_module(&resolve, world));
         wasm.push(section.id());
@@ -227,7 +199,7 @@ impl EmbedOpts {
 
         self.io.output(Output::Wasm {
             bytes: &wasm,
-            wat: self.wat,
+            wat: false,
         })?;
 
         Ok(())
@@ -244,7 +216,7 @@ impl EmbedOpts {
 #[derive(Parser)]
 pub struct WitOpts {
     #[clap(flatten)]
-    general: wasm_tools::GeneralOpts,
+    verbosity: wasm_tools::Verbosity,
 
     /// Input file or directory to process.
     ///
@@ -261,28 +233,40 @@ pub struct WitOpts {
     #[clap(flatten)]
     output: wasm_tools::OutputArg,
 
-    /// Emit a WebAssembly binary representation instead of the WIT text format.
-    #[clap(short, long, conflicts_with = "wat", conflicts_with = "out_dir")]
-    wasm: bool,
+    /// If a WIT package is being parsed, then this is the optionally specified
+    /// name of the WIT package. If not specified this is automatically inferred
+    /// from the filename.
+    #[clap(long)]
+    name: Option<String>,
 
-    /// Emit a WebAssembly textual representation instead of the WIT text
-    /// format.
-    #[clap(short = 't', long, conflicts_with = "wasm", conflicts_with = "out_dir")]
-    wat: bool,
+    /// When printing a WIT package, the default mode, this option is used to
+    /// indicate which document is printed within the package if more than one
+    /// document is present.
+    #[clap(short, long, conflicts_with = "wasm", conflicts_with = "wat")]
+    document: Option<String>,
 
-    /// Emit the entire WIT resolution graph instead of just the "top level"
-    /// package to the output directory specified.
+    /// Emit a full WIT package into the specified directory when printing the
+    /// text form.
     ///
-    /// The output directory will contain textual WIT files which represent all
-    /// packages known from the input.
+    /// This is incompatible with `-o`.
     #[clap(
         long,
+        conflicts_with = "output",
         conflicts_with = "wasm",
         conflicts_with = "wat",
-        conflicts_with = "output"
+        conflicts_with = "document"
     )]
     out_dir: Option<PathBuf>,
 
+    /// Emit a WebAssembly binary representation instead of the WIT text format.
+    #[clap(short, long, conflicts_with = "wat")]
+    wasm: bool,
+
+    /// Emit a WebAssembly textual representation instead of the WIT text
+    /// format.
+    #[clap(short = 't', long, conflicts_with = "wasm")]
+    wat: bool,
+
     /// Skips the validation performed when using the `--wasm` and `--wat`
     /// options.
     #[clap(long)]
@@ -290,12 +274,16 @@ pub struct WitOpts {
 }
 
 impl WitOpts {
-    fn general_opts(&self) -> &wasm_tools::GeneralOpts {
-        &self.general
-    }
-
     /// Executes the application.
     fn run(self) -> Result<()> {
+        let name = match &self.name {
+            Some(name) => name.as_str(),
+            None => match &self.input {
+                Some(path) => path.file_stem().unwrap().to_str().unwrap(),
+                None => "component",
+            },
+        };
+
         // First up determine the actual `DecodedWasm` as the input. This could
         // come from a number of sources:
         //
@@ -314,7 +302,7 @@ impl WitOpts {
             Some(input) => match input.extension().and_then(|s| s.to_str()) {
                 Some("wat") | Some("wasm") => {
                     let bytes = wat::parse_file(&input)?;
-                    decode_wasm(&bytes).context("failed to decode WIT document")?
+                    wit_component::decode(name, &bytes).context("failed to decode WIT document")?
                 }
                 _ => {
                     let (resolve, id) = parse_wit(input)?;
@@ -333,7 +321,7 @@ impl WitOpts {
                         e
                     })?;
 
-                    decode_wasm(&bytes).context("failed to decode WIT document")?
+                    wit_component::decode(name, &bytes).context("failed to decode WIT document")?
                 } else {
                     let stdin = match std::str::from_utf8(&stdin) {
                         Ok(s) => s,
@@ -341,7 +329,7 @@ impl WitOpts {
                     };
                     let mut resolve = Resolve::default();
                     let pkg = UnresolvedPackage::parse("<stdin>".as_ref(), stdin)?;
-                    let id = resolve.push(pkg)?;
+                    let id = resolve.push(pkg, &Default::default())?;
                     DecodedWasm::WitPackage(resolve, id)
                 }
             }
@@ -349,10 +337,36 @@ impl WitOpts {
 
         // Now that the WIT document has been decoded, it's time to emit it.
         // This interprets all of the output options and performs such a task.
-        if self.wasm || self.wat {
-            self.emit_wasm(&decoded)?;
-        } else {
-            self.emit_wit(&decoded)?;
+        match &self.out_dir {
+            Some(dir) => {
+                assert!(self.output.output_path().is_none());
+                assert!(!self.wasm && !self.wat);
+                assert!(self.document.is_none());
+                let package = match &decoded {
+                    DecodedWasm::WitPackage(_, package) => *package,
+
+                    DecodedWasm::Component(resolve, world) => {
+                        let doc = resolve.worlds[*world].document;
+                        resolve.documents[doc].package.unwrap()
+                    }
+                };
+                let resolve = decoded.resolve();
+                std::fs::create_dir_all(&dir)
+                    .with_context(|| format!("failed to create {dir:?}"))?;
+                for (name, doc) in resolve.packages[package].documents.iter() {
+                    let output = DocumentPrinter::default().print(&resolve, *doc)?;
+                    let path = dir.join(format!("{name}.wit"));
+                    std::fs::write(&path, output)
+                        .with_context(|| format!("failed to write {path:?}"))?;
+                }
+            }
+            None => {
+                if self.wasm || self.wat {
+                    self.emit_wasm(&decoded)?;
+                } else {
+                    self.emit_wit(&decoded)?;
+                }
+            }
         }
         Ok(())
     }
@@ -360,8 +374,18 @@ impl WitOpts {
     fn emit_wasm(&self, decoded: &DecodedWasm) -> Result<()> {
         assert!(self.wasm || self.wat);
         assert!(self.out_dir.is_none());
+        assert!(self.document.is_none());
 
-        let bytes = wit_component::encode(decoded.resolve(), decoded.package())?;
+        let pkg = match decoded {
+            DecodedWasm::WitPackage(_resolve, pkg) => *pkg,
+            DecodedWasm::Component(resolve, world) => {
+                let doc = resolve.worlds[*world].document;
+                resolve.documents[doc].package.unwrap()
+            }
+        };
+
+        let resolve = decoded.resolve();
+        let bytes = wit_component::encode(&resolve, pkg)?;
         if !self.skip_validation {
             wasmparser::Validator::new_with_features(wasmparser::WasmFeatures {
                 component_model: true,
@@ -378,97 +402,33 @@ impl WitOpts {
 
     fn emit_wit(&self, decoded: &DecodedWasm) -> Result<()> {
         assert!(!self.wasm && !self.wat);
+        assert!(self.out_dir.is_none());
+        if self.wat {
+            bail!("the `--wat` option can only be combined with `--wasm`");
+        }
 
-        let resolve = decoded.resolve();
-        let main = decoded.package();
-
-        match &self.out_dir {
-            Some(dir) => {
-                assert!(self.output.output_path().is_none());
-                std::fs::create_dir_all(dir)
-                    .with_context(|| format!("failed to create directory: {dir:?}"))?;
-
-                // Classify all packages by name to determine how to name their
-                // output directories.
-                let mut names = HashMap::new();
-                for (_id, pkg) in resolve.packages.iter() {
-                    let cnt = names
-                        .entry(&pkg.name.name)
-                        .or_insert(HashMap::new())
-                        .entry(&pkg.name.namespace)
-                        .or_insert(0);
-                    *cnt += 1;
-                }
-
-                for (id, pkg) in resolve.packages.iter() {
-                    let output = WitPrinter::default().print(resolve, id)?;
-                    let out_dir = if id == main {
-                        dir.clone()
-                    } else {
-                        let dir = dir.join("deps");
-                        let packages_with_same_name = &names[&pkg.name.name];
-                        if packages_with_same_name.len() == 1 {
-                            dir.join(&pkg.name.name)
-                        } else {
-                            let packages_with_same_namespace =
-                                packages_with_same_name[&pkg.name.namespace];
-                            if packages_with_same_namespace == 1 {
-                                dir.join(format!("{}:{}", pkg.name.namespace, pkg.name.name))
-                            } else {
-                                dir.join(pkg.name.to_string())
-                            }
-                        }
-                    };
-                    std::fs::create_dir_all(&out_dir)
-                        .with_context(|| format!("failed to create directory: {out_dir:?}"))?;
-                    let path = out_dir.join("main.wit");
-                    std::fs::write(&path, &output)
-                        .with_context(|| format!("failed to write file: {path:?}"))?;
-                    println!("Writing: {}", path.display());
+        let doc = match decoded {
+            DecodedWasm::WitPackage(resolve, pkg) => {
+                let pkg = &resolve.packages[*pkg];
+                match &self.document {
+                    Some(name) => *pkg
+                        .documents
+                        .get(name)
+                        .ok_or_else(|| anyhow!("no document named `{name}` found in package"))?,
+                    None => match pkg.documents.len() {
+                        1 => *pkg.documents.iter().next().unwrap().1,
+                        _ => bail!(
+                            "more than document found in package, \
+                             specify which to print with `-d name`"
+                        ),
+                    },
                 }
             }
-            None => {
-                let output = WitPrinter::default().print(resolve, main)?;
-                self.output.output(Output::Wat(&output))?;
-            }
-        }
-
-        Ok(())
-    }
-}
-
-/// Tool for verifying whether a component conforms to a world.
-#[derive(Parser)]
-pub struct TargetsOpts {
-    #[clap(flatten)]
-    general: wasm_tools::GeneralOpts,
-
-    /// The WIT package containing the `world` used to test a component for conformance.
-    ///
-    /// This can either be a directory or a path to a single `*.wit` file.
-    wit: PathBuf,
-
-    /// The world used to test whether a component conforms to its signature.
-    #[clap(short, long)]
-    world: Option<String>,
-
-    #[clap(flatten)]
-    input: wasm_tools::InputArg,
-}
-
-impl TargetsOpts {
-    fn general_opts(&self) -> &wasm_tools::GeneralOpts {
-        &self.general
-    }
-
-    /// Executes the application.
-    fn run(self) -> Result<()> {
-        let (resolve, package_id) = parse_wit(&self.wit)?;
-        let world = resolve.select_world(package_id, self.world.as_deref())?;
-        let component_to_test = self.input.parse_wasm()?;
-
-        wit_component::targets(&resolve, world, &component_to_test)?;
+            DecodedWasm::Component(resolve, world) => resolve.worlds[*world].document,
+        };
 
+        let output = DocumentPrinter::default().print(decoded.resolve(), doc)?;
+        self.output.output(Output::Wat(&output))?;
         Ok(())
     }
 }
@@ -485,7 +445,7 @@ fn parse_wit(path: &Path) -> Result<(Resolve, PackageId)> {
                 e.set_path(path);
                 e
             })?;
-            match wit_component::decode(&bytes)? {
+            match wit_component::decode("root-package-name", &bytes)? {
                 DecodedWasm::Component(..) => {
                     bail!("specified path is a component, not a wit package")
                 }
@@ -497,7 +457,7 @@ fn parse_wit(path: &Path) -> Result<(Resolve, PackageId)> {
                 Err(_) => bail!("input file is not valid utf-8"),
             };
             let pkg = UnresolvedPackage::parse(&path, text)?;
-            resolve.push(pkg)?
+            resolve.push(pkg, &Default::default())?
         }
     };
     Ok((resolve, id))
@@ -508,7 +468,7 @@ fn parse_wit(path: &Path) -> Result<(Resolve, PackageId)> {
 /// This briefly lexes past whitespace and comments as a `*.wat` file to see if
 /// we can find a left-paren. If that fails then it's probably `*.wit` instead.
 fn is_wasm(bytes: &[u8]) -> bool {
-    use wast::lexer::{Lexer, TokenKind};
+    use wast::lexer::{Lexer, Token};
 
     if bytes.starts_with(b"\0asm") {
         return true;
@@ -521,23 +481,12 @@ fn is_wasm(bytes: &[u8]) -> bool {
     let mut lexer = Lexer::new(text);
 
     while let Some(next) = lexer.next() {
-        match next.map(|t| t.kind) {
-            Ok(TokenKind::Whitespace)
-            | Ok(TokenKind::BlockComment)
-            | Ok(TokenKind::LineComment) => {}
-            Ok(TokenKind::LParen) => return true,
+        match next {
+            Ok(Token::Whitespace(_)) | Ok(Token::BlockComment(_)) | Ok(Token::LineComment(_)) => {}
+            Ok(Token::LParen(_)) => return true,
             _ => break,
         }
     }
 
     false
 }
-
-fn decode_wasm(bytes: &[u8]) -> Result<DecodedWasm> {
-    if wasmparser::Parser::is_component(bytes) {
-        wit_component::decode(bytes)
-    } else {
-        let (_wasm, bindgen) = wit_component::metadata::decode(bytes)?;
-        Ok(DecodedWasm::Component(bindgen.resolve, bindgen.world))
-    }
-}
diff --git a/src/bin/wasm-tools/compose.rs b/src/bin/wasm-tools/compose.rs
index c9236509..3ebe6ce3 100644
--- a/src/bin/wasm-tools/compose.rs
+++ b/src/bin/wasm-tools/compose.rs
@@ -7,15 +7,12 @@ pub struct Opts {
     #[clap(flatten)]
     cmd: WasmComposeCommand,
     #[clap(flatten)]
-    general: wasm_tools::GeneralOpts,
+    verbosity: wasm_tools::Verbosity,
 }
 
 impl Opts {
-    pub fn general_opts(&self) -> &wasm_tools::GeneralOpts {
-        &self.general
-    }
-
     pub fn run(self) -> Result<()> {
+        self.verbosity.init_logger();
         self.cmd.execute()
     }
 }
diff --git a/src/bin/wasm-tools/demangle.rs b/src/bin/wasm-tools/demangle.rs
index 262ec312..d2e70ec9 100644
--- a/src/bin/wasm-tools/demangle.rs
+++ b/src/bin/wasm-tools/demangle.rs
@@ -19,10 +19,6 @@ pub struct Opts {
 }
 
 impl Opts {
-    pub fn general_opts(&self) -> &wasm_tools::GeneralOpts {
-        self.io.general_opts()
-    }
-
     pub fn run(&self) -> Result<()> {
         let input = self.io.parse_input_wasm()?;
         let mut module = wasm_encoder::Module::new();
@@ -39,9 +35,6 @@ impl Opts {
                         Err(e) => log::debug!("error parsing name section {e:?}"),
                     }
                 }
-                Version { encoding, .. } if *encoding == wasmparser::Encoding::Component => {
-                    bail!("demangling components is not supported");
-                }
                 _ => {}
             }
             if let Some((id, range)) = payload.as_section() {
diff --git a/src/bin/wasm-tools/dump.rs b/src/bin/wasm-tools/dump.rs
index 26b572b5..e1e106d1 100644
--- a/src/bin/wasm-tools/dump.rs
+++ b/src/bin/wasm-tools/dump.rs
@@ -1,7 +1,6 @@
 use anyhow::Result;
 use std::fmt::Write as _;
 use std::io::Write;
-use termcolor::{Color, ColorSpec, WriteColor};
 use wasmparser::*;
 
 /// Debugging utility to dump information about a wasm binary.
@@ -15,10 +14,6 @@ pub struct Opts {
 }
 
 impl Opts {
-    pub fn general_opts(&self) -> &wasm_tools::GeneralOpts {
-        self.io.general_opts()
-    }
-
     pub fn run(&self) -> Result<()> {
         let input = self.io.parse_input_wasm()?;
         let output = self.io.output_writer()?;
@@ -32,7 +27,7 @@ struct Dump<'a> {
     bytes: &'a [u8],
     cur: usize,
     state: String,
-    dst: Box<dyn WriteColor + 'a>,
+    dst: Box<dyn Write + 'a>,
     nesting: u32,
     offset_width: usize,
 }
@@ -62,13 +57,12 @@ enum ComponentTypeKind {
     Component,
     Instance,
     DefinedType,
-    Resource,
 }
 
 const NBYTES: usize = 4;
 
 impl<'a> Dump<'a> {
-    fn new(bytes: &'a [u8], dst: impl WriteColor + 'a) -> Dump<'a> {
+    fn new(bytes: &'a [u8], dst: impl Write + 'a) -> Dump<'a> {
         Dump {
             bytes,
             cur: 0,
@@ -99,7 +93,7 @@ impl<'a> Dump<'a> {
                     range,
                 } => {
                     write!(self.state, "version {} ({:?})", num, encoding)?;
-                    self.color_print(range.end)?;
+                    self.print(range.end)?;
                 }
                 Payload::TypeSection(s) => self.section(s, "type", |me, end, t| {
                     write!(me.state, "[type {}] {:?}", inc(&mut i.core_types), t)?;
@@ -177,7 +171,7 @@ impl<'a> Dump<'a> {
                             table_index,
                             offset_expr,
                         } => {
-                            write!(me.state, " table[{:?}]", table_index)?;
+                            write!(me.state, " table[{}]", table_index)?;
                             me.print(offset_expr.get_binary_reader().original_position())?;
                             me.print_ops(offset_expr.get_operators_reader())?;
                             write!(me.state, "{} items", item_count)?;
@@ -233,7 +227,7 @@ impl<'a> Dump<'a> {
 
                 Payload::CodeSectionStart { count, range, size } => {
                     write!(self.state, "code section")?;
-                    self.color_print(range.start)?;
+                    self.print(range.start)?;
                     write!(self.state, "{} count", count)?;
                     self.print(range.end - size as usize)?;
                 }
@@ -369,7 +363,6 @@ impl<'a> Dump<'a> {
                             ComponentType::Func(_) => ComponentTypeKind::Func,
                             ComponentType::Component(_) => ComponentTypeKind::Component,
                             ComponentType::Instance(_) => ComponentTypeKind::Instance,
-                            ComponentType::Resource { .. } => ComponentTypeKind::Resource,
                         });
                         me.print(end)
                     })?
@@ -396,12 +389,7 @@ impl<'a> Dump<'a> {
                     self.section(s, "canonical function", |me, end, f| {
                         let (name, col) = match &f {
                             CanonicalFunction::Lift { .. } => ("func", &mut i.funcs),
-                            CanonicalFunction::Lower { .. }
-                            | CanonicalFunction::ResourceNew { .. }
-                            | CanonicalFunction::ResourceDrop { .. }
-                            | CanonicalFunction::ResourceRep { .. } => {
-                                ("core func", &mut i.core_funcs)
-                            }
+                            CanonicalFunction::Lower { .. } => ("core func", &mut i.core_funcs),
                         };
 
                         write!(me.state, "[{} {}] {:?}", name, inc(col), f)?;
@@ -425,19 +413,22 @@ impl<'a> Dump<'a> {
 
                 Payload::CustomSection(c) => {
                     write!(self.state, "custom section")?;
-                    self.color_print(c.range().start)?;
+                    self.print(c.range().start)?;
                     write!(self.state, "name: {:?}", c.name())?;
                     self.print(c.data_offset())?;
                     if c.name() == "name" {
-                        let iter = NameSectionReader::new(c.data(), c.data_offset());
-                        self.print_custom_name_section(iter, |me, item, pos| {
-                            me.print_core_name(item, pos)
-                        })?;
+                        let mut iter = NameSectionReader::new(c.data(), c.data_offset());
+                        while let Some(section) = iter.next() {
+                            self.print_custom_name_section(section?, iter.original_position())?;
+                        }
                     } else if c.name() == "component-name" {
-                        let iter = ComponentNameSectionReader::new(c.data(), c.data_offset());
-                        self.print_custom_name_section(iter, |me, item, pos| {
-                            me.print_component_name(item, pos)
-                        })?;
+                        let mut iter = ComponentNameSectionReader::new(c.data(), c.data_offset());
+                        while let Some(section) = iter.next() {
+                            self.print_custom_component_name_section(
+                                section?,
+                                iter.original_position(),
+                            )?;
+                        }
                     } else {
                         self.print_byte_header()?;
                         for _ in 0..NBYTES {
@@ -453,7 +444,7 @@ impl<'a> Dump<'a> {
                     contents,
                 } => {
                     write!(self.state, "unknown section: {}", id)?;
-                    self.color_print(range.start)?;
+                    self.print(range.start)?;
                     self.print_byte_header()?;
                     for _ in 0..NBYTES {
                         write!(self.dst, "---")?;
@@ -492,46 +483,7 @@ impl<'a> Dump<'a> {
         })
     }
 
-    fn print_custom_name_section<'b, T>(
-        &mut self,
-        mut section: Subsections<'b, T>,
-        print_item: impl Fn(&mut Self, T, usize) -> Result<()>,
-    ) -> Result<()>
-    where
-        T: wasmparser::Subsection<'b>,
-    {
-        while let Some(item) = section.next() {
-            let pos = section.original_position();
-
-            let err = match item {
-                Ok(item) => match print_item(self, item, pos) {
-                    Ok(()) => continue,
-                    Err(e) => e.downcast()?,
-                },
-                Err(e) => e,
-            };
-            if self.cur != pos {
-                if self.state.is_empty() {
-                    write!(self.state, "???")?;
-                }
-                self.print(pos)?;
-            }
-            self.print_byte_header()?;
-            for _ in 0..NBYTES {
-                write!(self.dst, "---")?;
-            }
-            let remaining = section.range().end - pos;
-            writeln!(
-                self.dst,
-                "-| ... failed to decode {remaining} more bytes: {err}"
-            )?;
-            self.cur += remaining;
-            break;
-        }
-        Ok(())
-    }
-
-    fn print_core_name(&mut self, name: Name<'_>, end: usize) -> Result<()> {
+    fn print_custom_name_section(&mut self, name: Name<'_>, end: usize) -> Result<()> {
         match name {
             Name::Module { name, name_range } => {
                 write!(self.state, "module name")?;
@@ -557,7 +509,11 @@ impl<'a> Dump<'a> {
         Ok(())
     }
 
-    fn print_component_name(&mut self, name: ComponentName<'_>, end: usize) -> Result<()> {
+    fn print_custom_component_name_section(
+        &mut self,
+        name: ComponentName<'_>,
+        end: usize,
+    ) -> Result<()> {
         match name {
             ComponentName::Component { name, name_range } => {
                 write!(self.state, "component name")?;
@@ -596,7 +552,7 @@ impl<'a> Dump<'a> {
         T: FromReader<'b>,
     {
         write!(self.state, "{} section", name)?;
-        self.color_print(iter.range().start)?;
+        self.print(iter.range().start)?;
         self.print_iter(iter, print)
     }
 
@@ -628,15 +584,7 @@ impl<'a> Dump<'a> {
         Ok(())
     }
 
-    fn color_print(&mut self, end: usize) -> Result<()> {
-        self.print_(end, true)
-    }
-
     fn print(&mut self, end: usize) -> Result<()> {
-        self.print_(end, false)
-    }
-
-    fn print_(&mut self, end: usize, color: bool) -> Result<()> {
         assert!(
             self.cur < end,
             "{:#x} >= {:#x}\ntrying to print: {}",
@@ -664,12 +612,7 @@ impl<'a> Dump<'a> {
             }
             if i == 0 {
                 write!(self.dst, " | ")?;
-                if color {
-                    self.dst
-                        .set_color(ColorSpec::new().set_fg(Some(Color::Green)))?;
-                }
                 write!(self.dst, "{}", &self.state)?;
-                self.dst.set_color(ColorSpec::new().set_fg(None))?;
                 self.state.truncate(0);
             }
             writeln!(self.dst)?;
diff --git a/src/bin/wasm-tools/main.rs b/src/bin/wasm-tools/main.rs
index 70c2849d..d4afc3d4 100644
--- a/src/bin/wasm-tools/main.rs
+++ b/src/bin/wasm-tools/main.rs
@@ -1,17 +1,15 @@
 use anyhow::Result;
 use clap::Parser;
-use std::io::{self, Write};
+use std::io;
 use std::process::ExitCode;
-use termcolor::{Color, ColorChoice, ColorSpec, StandardStream, WriteColor};
 
 macro_rules! subcommands {
     ($(
         $(#[$attr:meta])*
-        ($name:ident, $string:tt $($cfg:tt)*)
+        ($name:ident, $string:tt)
     )*) => {
         $(
             #[cfg(feature = $string)]
-            $($cfg)*
             mod $name;
         )*
 
@@ -21,7 +19,6 @@ macro_rules! subcommands {
         enum WasmTools {
             $(
                 #[cfg(feature = $string)]
-                $($cfg)*
                 $(#[$attr])*
                 $name($name::Opts),
             )*
@@ -32,21 +29,10 @@ macro_rules! subcommands {
                 match self {
                     $(
                         #[cfg(feature = $string)]
-                        $($cfg)*
                         Self::$name(opts) => opts.run(),
                     )*
                 }
             }
-
-            fn general_opts(&self) -> &wasm_tools::GeneralOpts {
-                match *self {
-                    $(
-                        #[cfg(feature = $string)]
-                        $($cfg)*
-                        Self::$name(ref opts) => opts.general_opts(),
-                    )*
-                }
-            }
         }
     }
 }
@@ -56,10 +42,7 @@ subcommands! {
     (validate, "validate")
     (print, "print")
     (smith, "smith")
-    // The shrink subcommand relies on executing new processes to test a
-    // predicate which isn't supported on wasm, so always omit this command on
-    // wasm.
-    (shrink, "shrink" #[cfg(not(target_family = "wasm"))])
+    (shrink, "shrink")
     (mutate, "mutate")
     (dump, "dump")
     (objdump, "objdump")
@@ -70,15 +53,10 @@ subcommands! {
     (component, "component")
     #[command(subcommand)]
     (metadata, "metadata")
-    (wit_smith, "wit-smith")
-    (addr2line, "addr2line")
 }
 
 fn main() -> ExitCode {
-    let args = <WasmTools as Parser>::parse();
-    args.general_opts().init_logger();
-    let color = args.general_opts().color;
-    let err = match args.run() {
+    let err = match <WasmTools as Parser>::parse().run() {
         Ok(()) => return ExitCode::SUCCESS,
         Err(e) => e,
     };
@@ -92,47 +70,10 @@ fn main() -> ExitCode {
             _ => {}
         }
     }
-
-    // ignore errors here since if we fail to print an error it's not like we
-    // can print it again.
-    let _ = print_error(color, err);
+    eprintln!("Error: {:?}", err);
     ExitCode::FAILURE
 }
 
-fn print_error(color: ColorChoice, err: anyhow::Error) -> Result<()> {
-    let color = if color == ColorChoice::Auto && !atty::is(atty::Stream::Stderr) {
-        ColorChoice::Never
-    } else {
-        color
-    };
-    let mut stderr = StandardStream::stderr(color);
-    stderr.set_color(ColorSpec::new().set_fg(Some(Color::Red)).set_bold(true))?;
-    write!(stderr, "error")?;
-    stderr.set_color(ColorSpec::new().set_fg(None).set_bold(true))?;
-    write!(stderr, ": ")?;
-
-    let msg = err.to_string();
-    for (i, line) in msg.lines().enumerate() {
-        writeln!(stderr, "{line}")?;
-        if i == 0 {
-            stderr.set_color(ColorSpec::new().set_reset(true))?;
-        }
-    }
-
-    if err.chain().len() == 1 {
-        return Ok(());
-    }
-    writeln!(stderr, "\nCaused by:")?;
-    for (i, err) in err.chain().skip(1).enumerate() {
-        writeln!(
-            stderr,
-            "{i:>5}: {}",
-            err.to_string().replace("\n", "\n       ")
-        )?;
-    }
-    return Ok(());
-}
-
 /// If CARGO_VERSION_INFO is set, use it, otherwise use CARGO_PKG_VERSION.
 fn version() -> &'static str {
     option_env!("CARGO_VERSION_INFO").unwrap_or(env!("CARGO_PKG_VERSION"))
diff --git a/src/bin/wasm-tools/metadata.rs b/src/bin/wasm-tools/metadata.rs
index 83142db5..041918a0 100644
--- a/src/bin/wasm-tools/metadata.rs
+++ b/src/bin/wasm-tools/metadata.rs
@@ -15,13 +15,6 @@ impl Opts {
             Opts::Add(opts) => opts.run(),
         }
     }
-
-    pub fn general_opts(&self) -> &wasm_tools::GeneralOpts {
-        match self {
-            Opts::Show(opts) => opts.general_opts(),
-            Opts::Add(opts) => opts.general_opts(),
-        }
-    }
 }
 
 /// Read metadata (module name, producers) from a WebAssembly file.
@@ -36,10 +29,6 @@ pub struct ShowOpts {
 }
 
 impl ShowOpts {
-    pub fn general_opts(&self) -> &wasm_tools::GeneralOpts {
-        self.io.general_opts()
-    }
-
     pub fn run(&self) -> Result<()> {
         let input = self.io.parse_input_wasm()?;
         let mut output = self.io.output_writer()?;
@@ -69,10 +58,6 @@ pub struct AddOpts {
 }
 
 impl AddOpts {
-    pub fn general_opts(&self) -> &wasm_tools::GeneralOpts {
-        self.io.general_opts()
-    }
-
     pub fn run(&self) -> Result<()> {
         let input = self.io.parse_input_wasm()?;
 
diff --git a/src/bin/wasm-tools/mutate.rs b/src/bin/wasm-tools/mutate.rs
index acb5a7e4..2dd0f60e 100644
--- a/src/bin/wasm-tools/mutate.rs
+++ b/src/bin/wasm-tools/mutate.rs
@@ -49,10 +49,6 @@ pub struct Opts {
 }
 
 impl Opts {
-    pub fn general_opts(&self) -> &wasm_tools::GeneralOpts {
-        self.io.general_opts()
-    }
-
     pub fn run(mut self) -> Result<()> {
         let input_wasm = self.io.parse_input_wasm()?;
 
diff --git a/src/bin/wasm-tools/objdump.rs b/src/bin/wasm-tools/objdump.rs
index 248fc183..9b7ca332 100644
--- a/src/bin/wasm-tools/objdump.rs
+++ b/src/bin/wasm-tools/objdump.rs
@@ -1,7 +1,6 @@
 use anyhow::Result;
 use std::io::Write;
 use std::ops::Range;
-use termcolor::WriteColor;
 use wasmparser::{Encoding, Parser, Payload::*};
 
 /// Dumps information about sections in a WebAssembly file.
@@ -15,10 +14,6 @@ pub struct Opts {
 }
 
 impl Opts {
-    pub fn general_opts(&self) -> &wasm_tools::GeneralOpts {
-        self.io.general_opts()
-    }
-
     pub fn run(&self) -> Result<()> {
         let input = self.io.parse_input_wasm()?;
 
@@ -95,7 +90,7 @@ struct IndexSpace {
 
 struct Printer {
     indices: Vec<IndexSpace>,
-    output: Box<dyn WriteColor>,
+    output: Box<dyn Write>,
 }
 
 impl Printer {
diff --git a/src/bin/wasm-tools/parse.rs b/src/bin/wasm-tools/parse.rs
index 3274bfbe..4f83358a 100644
--- a/src/bin/wasm-tools/parse.rs
+++ b/src/bin/wasm-tools/parse.rs
@@ -16,10 +16,6 @@ pub struct Opts {
 }
 
 impl Opts {
-    pub fn general_opts(&self) -> &wasm_tools::GeneralOpts {
-        self.io.general_opts()
-    }
-
     pub fn run(&self) -> Result<()> {
         let binary = self.io.parse_input_wasm()?;
         self.io.output(wasm_tools::Output::Wasm {
diff --git a/src/bin/wasm-tools/print.rs b/src/bin/wasm-tools/print.rs
index a7eae6f5..147ca89d 100644
--- a/src/bin/wasm-tools/print.rs
+++ b/src/bin/wasm-tools/print.rs
@@ -11,24 +11,13 @@ pub struct Opts {
     /// as comments for debugging.
     #[clap(short, long)]
     print_offsets: bool,
-
-    /// Indicates that the "skeleton" of a module should be printed where items
-    /// such as function bodies, data segments, and element segments are
-    /// replaced with "..." instead of printing their actual contents.
-    #[clap(long)]
-    skeleton: bool,
 }
 
 impl Opts {
-    pub fn general_opts(&self) -> &wasm_tools::GeneralOpts {
-        self.io.general_opts()
-    }
-
     pub fn run(&self) -> Result<()> {
         let wasm = self.io.parse_input_wasm()?;
         let mut printer = wasmprinter::Printer::new();
         printer.print_offsets(self.print_offsets);
-        printer.print_skeleton(self.skeleton);
         let wat = printer.print(&wasm)?;
         self.io.output(wasm_tools::Output::Wat(&wat))?;
         Ok(())
diff --git a/src/bin/wasm-tools/shrink.rs b/src/bin/wasm-tools/shrink.rs
index c70f550d..b13c0f8f 100644
--- a/src/bin/wasm-tools/shrink.rs
+++ b/src/bin/wasm-tools/shrink.rs
@@ -36,10 +36,6 @@ pub struct Opts {
 }
 
 impl Opts {
-    pub fn general_opts(&self) -> &wasm_tools::GeneralOpts {
-        self.io.general_opts()
-    }
-
     pub fn run(self) -> Result<()> {
         let input = self.io.parse_input_wasm()?;
         let initial_size = input.len();
diff --git a/src/bin/wasm-tools/smith.rs b/src/bin/wasm-tools/smith.rs
index fac3546e..a4bcc02e 100644
--- a/src/bin/wasm-tools/smith.rs
+++ b/src/bin/wasm-tools/smith.rs
@@ -76,7 +76,7 @@ pub struct Opts {
     module_config: Config,
 
     #[clap(flatten)]
-    general: wasm_tools::GeneralOpts,
+    verbosity: wasm_tools::Verbosity,
 }
 
 #[derive(Default, Debug, Parser, Clone, serde::Deserialize)]
@@ -195,11 +195,8 @@ struct Config {
 }
 
 impl Opts {
-    pub fn general_opts(&self) -> &wasm_tools::GeneralOpts {
-        &self.general
-    }
-
     pub fn run(&self) -> Result<()> {
+        self.verbosity.init_logger();
         let seed = match &self.input {
             Some(f) => {
                 std::fs::read(f).with_context(|| format!("failed to read '{}'", f.display()))?
diff --git a/src/bin/wasm-tools/strip.rs b/src/bin/wasm-tools/strip.rs
index 5b66afa2..f68c6782 100644
--- a/src/bin/wasm-tools/strip.rs
+++ b/src/bin/wasm-tools/strip.rs
@@ -27,10 +27,6 @@ pub struct Opts {
 }
 
 impl Opts {
-    pub fn general_opts(&self) -> &wasm_tools::GeneralOpts {
-        self.io.general_opts()
-    }
-
     pub fn run(&self) -> Result<()> {
         let input = self.io.parse_input_wasm()?;
         let to_delete = regex::RegexSet::new(self.delete.iter())?;
diff --git a/src/bin/wasm-tools/validate.rs b/src/bin/wasm-tools/validate.rs
index 316834e0..ec561384 100644
--- a/src/bin/wasm-tools/validate.rs
+++ b/src/bin/wasm-tools/validate.rs
@@ -17,9 +17,6 @@ use wasmparser::{FuncValidatorAllocations, Parser, ValidPayload, Validator, Wasm
 /// # Validate `foo.wasm` with the default Wasm feature proposals.
 /// $ wasm-tools validate foo.wasm
 ///
-/// # Validate `foo.wasm` with more verbose output
-/// $ wasm-tools validate -vv foo.wasm
-///
 /// # Validate `fancy.wasm` with all Wasm feature proposals enabled.
 /// $ wasm-tools validate --features all fancy.wasm
 ///
@@ -33,9 +30,6 @@ pub struct Opts {
     /// The placeholder "all" can be used to enable all wasm features. If a "-"
     /// character is present in front of a feature it will disable that feature.
     /// For example "all,-simd" would enable everything but simd.
-    ///
-    /// Available feature options can be found in the wasmparser crate:
-    /// https://github.com/bytecodealliance/wasm-tools/blob/main/crates/wasmparser/src/validator.rs
     #[clap(long, short = 'f', value_parser = parse_features)]
     features: Option<WasmFeatures>,
 
@@ -44,10 +38,6 @@ pub struct Opts {
 }
 
 impl Opts {
-    pub fn general_opts(&self) -> &wasm_tools::GeneralOpts {
-        self.io.general_opts()
-    }
-
     pub fn run(&self) -> Result<()> {
         // Note that here we're copying the contents of
         // `Validator::validate_all`, but the end is followed up with a parallel
@@ -100,6 +90,7 @@ fn parse_features(arg: &str) -> Result<WasmFeatures> {
     const FEATURES: &[(&str, fn(&mut WasmFeatures) -> &mut bool)] = &[
         ("reference-types", |f| &mut f.reference_types),
         ("function-references", |f| &mut f.function_references),
+        ("typed-continuations", |f| &mut f.typed_continuations),
         ("simd", |f| &mut f.simd),
         ("threads", |f| &mut f.threads),
         ("bulk-memory", |f| &mut f.bulk_memory),
@@ -117,7 +108,6 @@ fn parse_features(arg: &str) -> Result<WasmFeatures> {
         ("sign-extension", |f| &mut f.sign_extension),
         ("mutable-global", |f| &mut f.mutable_global),
         ("relaxed-simd", |f| &mut f.relaxed_simd),
-        ("gc", |f| &mut f.gc),
     ];
 
     for part in arg.split(',').map(|s| s.trim()).filter(|s| !s.is_empty()) {
@@ -139,17 +129,10 @@ fn parse_features(arg: &str) -> Result<WasmFeatures> {
             }
 
             name => {
-                let (_, accessor) = FEATURES.iter().find(|(n, _)| *n == name).ok_or_else(|| {
-                    anyhow!(
-                        "unknown feature `{}`\nValid features: {}",
-                        name,
-                        FEATURES
-                            .iter()
-                            .map(|(name, _)| *name)
-                            .collect::<Vec<_>>()
-                            .join(", "),
-                    )
-                })?;
+                let (_, accessor) = FEATURES
+                    .iter()
+                    .find(|(n, _)| *n == name)
+                    .ok_or_else(|| anyhow!("unknown feature `{}`", name))?;
                 *accessor(&mut ret) = enable;
             }
         }
diff --git a/src/bin/wasm-tools/wit_smith.rs b/src/bin/wasm-tools/wit_smith.rs
deleted file mode 100644
index 19716e6c..00000000
--- a/src/bin/wasm-tools/wit_smith.rs
+++ /dev/null
@@ -1,81 +0,0 @@
-use anyhow::{Context, Result};
-use clap::Parser;
-use std::io::{stdin, Read};
-use std::path::PathBuf;
-use wit_smith::Config;
-
-/// A WIT test case generator.
-///
-/// Given an arbitrary input seed, `wit-smith` generates a valid WIT package set
-/// encoded as a WebAssembly component. The input seed is interpreted as a
-/// series of predetermined choices through a decision tree. Given the same
-/// input seed, `wit-smith` will always generate the same output WebAssembly
-/// component; it is deterministic. This tool is suitable for taking
-/// fuzz-generated input to generate a wide array of WIT documents.
-///
-/// ## Example
-///
-/// Generate a WIT document from 100 bytes of random data:
-///
-/// $ head -c 100 /dev/urandom | wasm-tools wit-smith -t
-#[derive(Parser)]
-pub struct Opts {
-    /// The arbitrary input seed.
-    ///
-    /// `stdin` is used if this argument is not supplied.
-    input: Option<PathBuf>,
-
-    #[clap(flatten)]
-    output: wasm_tools::OutputArg,
-
-    /// Output the text format of WebAssembly instead of the binary format.
-    #[clap(short = 't', long)]
-    wat: bool,
-
-    #[clap(flatten)]
-    config: Config,
-
-    /// Indicates that "arbitrary configuration" should be used meaning that the
-    /// input seed is first used to generate the configuration and then
-    /// afterwards the rest of the seed is used to generate the document.
-    #[clap(long)]
-    arbitrary_config: bool,
-
-    #[clap(flatten)]
-    general: wasm_tools::GeneralOpts,
-}
-
-impl Opts {
-    pub fn general_opts(&self) -> &wasm_tools::GeneralOpts {
-        &self.general
-    }
-
-    pub fn run(&self) -> Result<()> {
-        let seed = match &self.input {
-            Some(f) => {
-                std::fs::read(f).with_context(|| format!("failed to read '{}'", f.display()))?
-            }
-            None => {
-                let mut seed = Vec::new();
-                stdin()
-                    .read_to_end(&mut seed)
-                    .context("failed to read <stdin>")?;
-                seed
-            }
-        };
-
-        let mut u = arbitrary::Unstructured::new(&seed);
-        let config = if self.arbitrary_config {
-            u.arbitrary()?
-        } else {
-            self.config.clone()
-        };
-        let wasm_bytes = wit_smith::smith(&config, &mut u)?;
-
-        self.output.output(wasm_tools::Output::Wasm {
-            bytes: &wasm_bytes,
-            wat: self.wat,
-        })?;
-        Ok(())
-    }
-}
diff --git a/src/lib.rs b/src/lib.rs
index 3aa4dfd5..32a61f50 100644
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -4,27 +4,22 @@ use anyhow::{bail, Context, Result};
 use std::fs::File;
 use std::io::{BufWriter, Read, Write};
 use std::path::{Path, PathBuf};
-use termcolor::{Ansi, ColorChoice, NoColor, StandardStream, WriteColor};
 
+// Implements the verbosity flag for the CLI commands.
 #[derive(clap::Parser)]
-pub struct GeneralOpts {
-    /// Use verbose output (-v info, -vv debug, -vvv trace).
+pub struct Verbosity {
+    /// Use verbose output (-vv very verbose output).
     #[clap(long = "verbose", short = 'v', action = clap::ArgAction::Count)]
     verbose: u8,
-
-    /// Use colors in output.
-    #[clap(long = "color", default_value = "auto")]
-    pub color: ColorChoice,
 }
 
-impl GeneralOpts {
+impl Verbosity {
     /// Initializes the logger based on the verbosity level.
     pub fn init_logger(&self) {
         let default = match self.verbose {
             0 => "warn",
             1 => "info",
-            2 => "debug",
-            _ => "trace",
+            _ => "debug",
         };
 
         env_logger::Builder::from_env(env_logger::Env::default().default_filter_or(default))
@@ -41,28 +36,38 @@ impl GeneralOpts {
 // and then the methods are used to read the arguments,
 #[derive(clap::Parser)]
 pub struct InputOutput {
-    #[clap(flatten)]
-    input: InputArg,
+    /// Input file to process.
+    ///
+    /// If not provided or if this is `-` then stdin is read entirely and
+    /// processed. Note that for most subcommands this input can either be a
+    /// binary `*.wasm` file or a textual format `*.wat` file.
+    input: Option<PathBuf>,
 
     #[clap(flatten)]
     output: OutputArg,
 
     #[clap(flatten)]
-    general: GeneralOpts,
+    verbosity: Verbosity,
 }
 
 #[derive(clap::Parser)]
-pub struct InputArg {
-    /// Input file to process.
+pub struct OutputArg {
+    /// Where to place output.
     ///
-    /// If not provided or if this is `-` then stdin is read entirely and
-    /// processed. Note that for most subcommands this input can either be a
-    /// binary `*.wasm` file or a textual format `*.wat` file.
-    input: Option<PathBuf>,
+    /// If not provided then stdout is used.
+    #[clap(short, long)]
+    output: Option<PathBuf>,
+}
+
+pub enum Output<'a> {
+    Wat(&'a str),
+    Wasm { bytes: &'a [u8], wat: bool },
 }
 
-impl InputArg {
-    pub fn parse_wasm(&self) -> Result<Vec<u8>> {
+impl InputOutput {
+    pub fn parse_input_wasm(&self) -> Result<Vec<u8>> {
+        self.verbosity.init_logger();
+
         if let Some(path) = &self.input {
             if path != Path::new("-") {
                 let bytes = wat::parse_file(path)?;
@@ -79,33 +84,13 @@ impl InputArg {
         })?;
         Ok(bytes.into_owned())
     }
-}
-
-#[derive(clap::Parser)]
-pub struct OutputArg {
-    /// Where to place output.
-    ///
-    /// If not provided then stdout is used.
-    #[clap(short, long)]
-    output: Option<PathBuf>,
-}
-
-pub enum Output<'a> {
-    Wat(&'a str),
-    Wasm { bytes: &'a [u8], wat: bool },
-}
-
-impl InputOutput {
-    pub fn parse_input_wasm(&self) -> Result<Vec<u8>> {
-        self.input.parse_wasm()
-    }
 
     pub fn output(&self, bytes: Output<'_>) -> Result<()> {
         self.output.output(bytes)
     }
 
-    pub fn output_writer(&self) -> Result<Box<dyn WriteColor>> {
-        self.output.output_writer(self.general.color)
+    pub fn output_writer(&self) -> Result<Box<dyn Write>> {
+        self.output.output_writer()
     }
 
     pub fn output_path(&self) -> Option<&Path> {
@@ -113,11 +98,11 @@ impl InputOutput {
     }
 
     pub fn input_path(&self) -> Option<&Path> {
-        self.input.input.as_deref()
+        self.input.as_deref()
     }
 
-    pub fn general_opts(&self) -> &GeneralOpts {
-        &self.general
+    pub fn init_logger(&self) {
+        self.verbosity.init_logger();
     }
 }
 
@@ -165,23 +150,10 @@ impl OutputArg {
         self.output.as_deref()
     }
 
-    pub fn output_writer(&self, color: ColorChoice) -> Result<Box<dyn WriteColor>> {
+    pub fn output_writer(&self) -> Result<Box<dyn Write>> {
         match &self.output {
-            Some(output) => {
-                let writer = BufWriter::new(File::create(&output)?);
-                if color == ColorChoice::AlwaysAnsi {
-                    Ok(Box::new(Ansi::new(writer)))
-                } else {
-                    Ok(Box::new(NoColor::new(writer)))
-                }
-            }
-            None => {
-                if color == ColorChoice::Auto && !atty::is(atty::Stream::Stdout) {
-                    Ok(Box::new(StandardStream::stdout(ColorChoice::Never)))
-                } else {
-                    Ok(Box::new(StandardStream::stdout(color)))
-                }
-            }
+            Some(output) => Ok(Box::new(BufWriter::new(File::create(&output)?))),
+            None => Ok(Box::new(std::io::stdout())),
         }
     }
 }
diff --git a/tests/cli.rs b/tests/cli.rs
index b9bb53c0..1ec00047 100644
--- a/tests/cli.rs
+++ b/tests/cli.rs
@@ -34,12 +34,6 @@ use std::path::{Path, PathBuf};
 use std::process::{Command, Output, Stdio};
 
 fn main() {
-    // This test suite can't run on wasm since it involves spawning
-    // subprocesses.
-    if cfg!(target_family = "wasm") {
-        return;
-    }
-
     let mut tests = Vec::new();
     find_tests("tests/cli".as_ref(), &mut tests);
     let filter = std::env::args().nth(1);
@@ -89,7 +83,7 @@ fn run_test(test: &Path, bless: bool) -> Result<()> {
     let contents = std::fs::read_to_string(test)?;
     let line = contents
         .lines()
-        .filter_map(|l| l.strip_prefix(";; RUN: ").or(l.strip_prefix("// RUN: ")))
+        .filter_map(|l| l.strip_prefix(";; RUN: "))
         .next()
         .ok_or_else(|| anyhow!("no line found with `;; RUN: ` directive"))?;
 
@@ -108,19 +102,10 @@ fn run_test(test: &Path, bless: bool) -> Result<()> {
     }
 
     let output = execute(&mut cmd, stdin.as_deref())?;
-    let extension = test.extension().unwrap().to_str().unwrap();
-    assert_output(
-        bless,
-        &output.stdout,
-        &test.with_extension(&format!("{extension}.stdout")),
-    )
-    .context("failed to check stdout expectation (auto-update with BLESS=1)")?;
-    assert_output(
-        bless,
-        &output.stderr,
-        &test.with_extension(&format!("{extension}.stderr")),
-    )
-    .context("failed to check stderr expectation (auto-update with BLESS=1)")?;
+    assert_output(bless, &output.stdout, &test.with_extension("wat.stdout"))
+        .context("failed to check stdout expectation (auto-update with BLESS=1)")?;
+    assert_output(bless, &output.stderr, &test.with_extension("wat.stderr"))
+        .context("failed to check stderr expectation (auto-update with BLESS=1)")?;
     Ok(())
 }
 
@@ -193,7 +178,7 @@ fn find_tests(path: &Path, tests: &mut Vec<PathBuf>) {
             continue;
         }
         match f.path().extension().and_then(|s| s.to_str()) {
-            Some("wat") | Some("wit") => {}
+            Some("wat") => {}
             _ => continue,
         }
         tests.push(f.path());
diff --git a/tests/cli/dump-invalid-name-section.wat b/tests/cli/dump-invalid-name-section.wat
deleted file mode 100644
index 11c04e96..00000000
--- a/tests/cli/dump-invalid-name-section.wat
+++ /dev/null
@@ -1,22 +0,0 @@
-;; RUN: dump %
-
-(module binary
-  "\00asm"
-  "\01\00\00\00"
-
-  "\00" ;; custom section
-  "\10" ;; byte length of entire section
-  "\04" ;; byte length of "name"
-  "name"
-  "\02" ;; local name subsection
-  "\07" ;; 7 byte subsection
-  "\06" ;; six names
-  "\22" ;; names for function 0x22
-  "\00" ;; 0 count
-  "\00" ;; names for function 0
-  "\00" ;; 0 count
-  "\00" ;; names for function 0
-  "\40" ;; 0x40 count
-  "\00" ;; pad
-  "\00" ;; pad
-)
diff --git a/tests/cli/dump-invalid-name-section.wat.stdout b/tests/cli/dump-invalid-name-section.wat.stdout
deleted file mode 100644
index 202ff50d..00000000
--- a/tests/cli/dump-invalid-name-section.wat.stdout
+++ /dev/null
@@ -1,13 +0,0 @@
-  0x0 | 00 61 73 6d | version 1 (Module)
-      | 01 00 00 00
-  0x8 | 00 10       | custom section
-  0xa | 04 6e 61 6d | name: "name"
-      | 65         
-  0xf | 02 07       | local section
- 0x11 | 06          | 6 count
- 0x12 | 22          | function 34 local section
- 0x13 | 00          | 0 count
- 0x14 | 00          | function 0 local section
- 0x15 | 00          | 0 count
- 0x16 | 00 40       | ???
- 0x18 |-------------| ... failed to decode 2 more bytes: unexpected end-of-file (at offset 0x18)
diff --git a/tests/cli/dump-invalid-name-section2.wat b/tests/cli/dump-invalid-name-section2.wat
deleted file mode 100644
index c7b96674..00000000
--- a/tests/cli/dump-invalid-name-section2.wat
+++ /dev/null
@@ -1,22 +0,0 @@
-;; RUN: dump %
-
-(module binary
-  "\00asm"
-  "\01\00\00\00"
-
-  "\00" ;; custom section
-  "\10" ;; byte length of entire section
-  "\04" ;; byte length of "name"
-  "name"
-  "\02" ;; local name subsection
-  "\07" ;; 7 byte subsection
-  "\06" ;; six names
-  "\22" ;; names for function 0x22
-  "\00" ;; 0 count
-  "\00" ;; names for function 0
-  "\00" ;; 0 count
-  "\00" ;; names for function 0
-  "\00" ;; 0 count
-  "\00" ;; pad
-  "\00" ;; pad
-)
diff --git a/tests/cli/dump-invalid-name-section2.wat.stdout b/tests/cli/dump-invalid-name-section2.wat.stdout
deleted file mode 100644
index 43c8a265..00000000
--- a/tests/cli/dump-invalid-name-section2.wat.stdout
+++ /dev/null
@@ -1,14 +0,0 @@
-  0x0 | 00 61 73 6d | version 1 (Module)
-      | 01 00 00 00
-  0x8 | 00 10       | custom section
-  0xa | 04 6e 61 6d | name: "name"
-      | 65         
-  0xf | 02 07       | local section
- 0x11 | 06          | 6 count
- 0x12 | 22          | function 34 local section
- 0x13 | 00          | 0 count
- 0x14 | 00          | function 0 local section
- 0x15 | 00          | 0 count
- 0x16 | 00          | function 0 local section
- 0x17 | 00          | 0 count
- 0x18 |-------------| ... failed to decode 2 more bytes: unexpected end-of-file (at offset 0x18)
diff --git a/tests/cli/dump-invalid-name-section3.wat b/tests/cli/dump-invalid-name-section3.wat
deleted file mode 100644
index 53f8429f..00000000
--- a/tests/cli/dump-invalid-name-section3.wat
+++ /dev/null
@@ -1,14 +0,0 @@
-;; RUN: dump %
-
-(module binary
-  "\00asm"
-  "\01\00\00\00"
-
-  "\00" ;; custom section
-  "\08" ;; byte length of entire section
-  "\04" ;; byte length of "name"
-  "name"
-  "\02" ;; local name subsection
-  "\07" ;; 7 byte subsection
-  "\06" ;; six names
-)
diff --git a/tests/cli/dump-invalid-name-section3.wat.stdout b/tests/cli/dump-invalid-name-section3.wat.stdout
deleted file mode 100644
index 3c22468b..00000000
--- a/tests/cli/dump-invalid-name-section3.wat.stdout
+++ /dev/null
@@ -1,7 +0,0 @@
-  0x0 | 00 61 73 6d | version 1 (Module)
-      | 01 00 00 00
-  0x8 | 00 08       | custom section
-  0xa | 04 6e 61 6d | name: "name"
-      | 65         
-  0xf | 02 07       | ???
- 0x11 |-------------| ... failed to decode 1 more bytes: unexpected end of section (at offset 0x12)
diff --git a/tests/cli/dump/alias.wat b/tests/cli/dump/alias.wat
index 60bab1fa..25f1e0e7 100644
--- a/tests/cli/dump/alias.wat
+++ b/tests/cli/dump/alias.wat
@@ -16,6 +16,6 @@
   )
 
   (core instance $m (instantiate $m))
-  (core func (alias core export $m "f3"))
+  (core func (alias export $m "f3"))
   (alias core export $m "f3" (core func))
 )
diff --git a/tests/cli/dump/alias.wat.stdout b/tests/cli/dump/alias.wat.stdout
index 5e7fea47..80b9f120 100644
--- a/tests/cli/dump/alias.wat.stdout
+++ b/tests/cli/dump/alias.wat.stdout
@@ -1,18 +1,18 @@
-  0x0 | 00 61 73 6d | version 13 (Component)
-      | 0d 00 01 00
+  0x0 | 00 61 73 6d | version 12 (Component)
+      | 0c 00 01 00
   0x8 | 07 1f       | component type section
   0xa | 01          | 1 count
-  0xb | 42 04 01 40 | [type 0] Instance([Type(Func(ComponentFuncType { params: [], results: Named([]) })), Export { name: Kebab("f1"), ty: Func(0) }, Type(Func(ComponentFuncType { params: [("p1", Primitive(String))], results: Named([]) })), Export { name: Kebab("f2"), ty: Func(1) }])
+  0xb | 42 04 01 40 | [type 0] Instance([Type(Func(ComponentFuncType { params: [], results: Named([]) })), Export { name: "f1", url: "", ty: Func(0) }, Type(Func(ComponentFuncType { params: [("p1", Primitive(String))], results: Named([]) })), Export { name: "f2", url: "", ty: Func(1) }])
       | 00 01 00 04
-      | 00 02 66 31
+      | 02 66 31 00
       | 01 00 01 40
       | 01 02 70 31
       | 73 01 00 04
-      | 00 02 66 32
+      | 02 66 32 00
       | 01 01      
  0x29 | 0a 06       | component import section
  0x2b | 01          | 1 count
- 0x2c | 00 01 69 05 | [instance 0] ComponentImport { name: Kebab("i"), ty: Instance(0) }
+ 0x2c | 01 69 00 05 | [instance 0] ComponentImport { name: "i", url: "", ty: Instance(0) }
       | 00         
  0x31 | 06 13       | component alias section
  0x33 | 03          | 3 count
@@ -30,7 +30,7 @@
         | 01 00 00 00
    0x57 | 01 04       | type section
    0x59 | 01          | 1 count
-   0x5a | 60 00 00    | [type 0] SubType { is_final: false, supertype_idx: None, structural_type: Func(FuncType { params: [], returns: [] }) }
+   0x5a | 60 00 00    | [type 0] Func(FuncType { params: [], returns: [] })
    0x5d | 03 02       | func section
    0x5f | 01          | 1 count
    0x60 | 00          | [func 0] type 0
diff --git a/tests/cli/dump/alias2.wat.stdout b/tests/cli/dump/alias2.wat.stdout
index a3a1b64a..ae308f4c 100644
--- a/tests/cli/dump/alias2.wat.stdout
+++ b/tests/cli/dump/alias2.wat.stdout
@@ -1,55 +1,55 @@
-   0x0 | 00 61 73 6d | version 13 (Component)
-       | 0d 00 01 00
+   0x0 | 00 61 73 6d | version 12 (Component)
+       | 0c 00 01 00
    0x8 | 07 30       | component type section
    0xa | 01          | 1 count
-   0xb | 42 09 00 50 | [type 0] Instance([CoreType(Module([])), Export { name: Kebab("a"), ty: Module(0) }, Type(Func(ComponentFuncType { params: [], results: Named([]) })), Export { name: Kebab("b"), ty: Func(0) }, Export { name: Kebab("c"), ty: Value(Primitive(String)) }, Type(Instance([])), Export { name: Kebab("d"), ty: Instance(1) }, Type(Component([])), Export { name: Kebab("e"), ty: Component(2) }])
-       | 00 04 00 01
-       | 61 00 11 00
+   0xb | 42 09 00 50 | [type 0] Instance([CoreType(Module([])), Export { name: "a", url: "", ty: Module(0) }, Type(Func(ComponentFuncType { params: [], results: Named([]) })), Export { name: "b", url: "", ty: Func(0) }, Export { name: "c", url: "", ty: Value(Primitive(String)) }, Type(Instance([])), Export { name: "d", url: "", ty: Instance(1) }, Type(Component([])), Export { name: "e", url: "", ty: Component(2) }])
+       | 00 04 01 61
+       | 00 00 11 00
        | 01 40 00 01
-       | 00 04 00 01
-       | 62 01 00 04
-       | 00 01 63 02
+       | 00 04 01 62
+       | 00 01 00 04
+       | 01 63 00 02
        | 73 01 42 00
-       | 04 00 01 64
+       | 04 01 64 00
        | 05 01 01 41
-       | 00 04 00 01
-       | 65 04 02   
+       | 00 04 01 65
+       | 00 04 02   
   0x3a | 0a 06       | component import section
   0x3c | 01          | 1 count
-  0x3d | 00 01 61 05 | [instance 0] ComponentImport { name: Kebab("a"), ty: Instance(0) }
+  0x3d | 01 61 00 05 | [instance 0] ComponentImport { name: "a", url: "", ty: Instance(0) }
        | 00         
   0x42 | 04 59       | [component 0] inline size
-    0x44 | 00 61 73 6d | version 13 (Component)
-         | 0d 00 01 00
+    0x44 | 00 61 73 6d | version 12 (Component)
+         | 0c 00 01 00
     0x4c | 03 03       | core type section
     0x4e | 01          | 1 count
     0x4f | 50 00       | [core type 0] Module([])
     0x51 | 0a 07       | component import section
     0x53 | 01          | 1 count
-    0x54 | 00 01 61 00 | [module 0] ComponentImport { name: Kebab("a"), ty: Module(0) }
+    0x54 | 01 61 00 00 | [module 0] ComponentImport { name: "a", url: "", ty: Module(0) }
          | 11 00      
     0x5a | 07 05       | component type section
     0x5c | 01          | 1 count
     0x5d | 40 00 01 00 | [type 0] Func(ComponentFuncType { params: [], results: Named([]) })
     0x61 | 0a 0b       | component import section
     0x63 | 02          | 2 count
-    0x64 | 00 01 62 01 | [func 0] ComponentImport { name: Kebab("b"), ty: Func(0) }
+    0x64 | 01 62 00 01 | [func 0] ComponentImport { name: "b", url: "", ty: Func(0) }
          | 00         
-    0x69 | 00 01 63 02 | [value 0] ComponentImport { name: Kebab("c"), ty: Value(Primitive(String)) }
+    0x69 | 01 63 00 02 | [value 0] ComponentImport { name: "c", url: "", ty: Value(Primitive(String)) }
          | 73         
     0x6e | 07 03       | component type section
     0x70 | 01          | 1 count
     0x71 | 42 00       | [type 1] Instance([])
     0x73 | 0a 06       | component import section
     0x75 | 01          | 1 count
-    0x76 | 00 01 64 05 | [instance 0] ComponentImport { name: Kebab("d"), ty: Instance(1) }
+    0x76 | 01 64 00 05 | [instance 0] ComponentImport { name: "d", url: "", ty: Instance(1) }
          | 01         
     0x7b | 07 03       | component type section
     0x7d | 01          | 1 count
     0x7e | 41 00       | [type 2] Component([])
     0x80 | 0a 06       | component import section
     0x82 | 01          | 1 count
-    0x83 | 00 01 65 04 | [component 0] ComponentImport { name: Kebab("e"), ty: Component(2) }
+    0x83 | 01 65 00 04 | [component 0] ComponentImport { name: "e", url: "", ty: Component(2) }
          | 02         
     0x88 | 00 13       | custom section
     0x8a | 0e 63 6f 6d | name: "component-name"
@@ -79,14 +79,14 @@
        | 01 64 05 01
        | 01 65 04 01
   0xd5 | 04 34       | [component 2] inline size
-    0xd7 | 00 61 73 6d | version 13 (Component)
-         | 0d 00 01 00
+    0xd7 | 00 61 73 6d | version 12 (Component)
+         | 0c 00 01 00
     0xdf | 06 05       | component alias section
     0xe1 | 01          | 1 count
     0xe2 | 03 02 01 00 | alias [type 0] Outer { kind: Type, count: 1, index: 0 }
     0xe6 | 0a 06       | component import section
     0xe8 | 01          | 1 count
-    0xe9 | 00 01 61 05 | [instance 0] ComponentImport { name: Kebab("a"), ty: Instance(0) }
+    0xe9 | 01 61 00 05 | [instance 0] ComponentImport { name: "a", url: "", ty: Instance(0) }
          | 00         
     0xee | 00 1b       | custom section
     0xf0 | 0e 63 6f 6d | name: "component-name"
@@ -110,138 +110,137 @@
        | 64         
  0x123 | 04 00 00 01 | alias [component 3] InstanceExport { kind: Component, instance_index: 0, name: "e" }
        | 65         
- 0x128 | 05 24       | component instance section
+ 0x128 | 05 1f       | component instance section
  0x12a | 02          | 2 count
- 0x12b | 01 05 00 01 | [instance 4] FromExports([ComponentExport { name: Kebab("a"), kind: Module, index: 1, ty: None }, ComponentExport { name: Kebab("b"), kind: Func, index: 1, ty: None }, ComponentExport { name: Kebab("c"), kind: Value, index: 1, ty: None }, ComponentExport { name: Kebab("d"), kind: Instance, index: 3, ty: None }, ComponentExport { name: Kebab("e"), kind: Component, index: 3, ty: None }])
-       | 61 00 11 01
-       | 00 01 62 01
-       | 01 00 01 63
-       | 02 01 00 01
-       | 64 05 03 00
-       | 01 65 04 03
- 0x147 | 00 02 01 01 | [instance 5] Instantiate { component_index: 2, args: [ComponentInstantiationArg { name: "a", kind: Instance, index: 4 }] }
+ 0x12b | 01 05 01 61 | [instance 4] FromExports([ComponentExport { name: "a", url: "", kind: Module, index: 1, ty: None }, ComponentExport { name: "b", url: "", kind: Func, index: 1, ty: None }, ComponentExport { name: "c", url: "", kind: Value, index: 1, ty: None }, ComponentExport { name: "d", url: "", kind: Instance, index: 3, ty: None }, ComponentExport { name: "e", url: "", kind: Component, index: 3, ty: None }])
+       | 00 11 01 01
+       | 62 01 01 01
+       | 63 02 01 01
+       | 64 05 03 01
+       | 65 04 03   
+ 0x142 | 00 02 01 01 | [instance 5] Instantiate { component_index: 2, args: [ComponentInstantiationArg { name: "a", kind: Instance, index: 4 }] }
        | 61 05 04   
- 0x14e | 01 48       | [core module 2] inline size
-   0x150 | 00 61 73 6d | version 1 (Module)
+ 0x149 | 01 48       | [core module 2] inline size
+   0x14b | 00 61 73 6d | version 1 (Module)
          | 01 00 00 00
-   0x158 | 01 04       | type section
-   0x15a | 01          | 1 count
-   0x15b | 60 00 00    | [type 0] SubType { is_final: false, supertype_idx: None, structural_type: Func(FuncType { params: [], returns: [] }) }
-   0x15e | 03 02       | func section
-   0x160 | 01          | 1 count
-   0x161 | 00          | [func 0] type 0
-   0x162 | 04 04       | table section
-   0x164 | 01          | 1 count
-   0x165 | 70 00 01    | [table 0] Table { ty: TableType { element_type: funcref, initial: 1, maximum: None }, init: RefNull }
-   0x168 | 05 03       | memory section
+   0x153 | 01 04       | type section
+   0x155 | 01          | 1 count
+   0x156 | 60 00 00    | [type 0] Func(FuncType { params: [], returns: [] })
+   0x159 | 03 02       | func section
+   0x15b | 01          | 1 count
+   0x15c | 00          | [func 0] type 0
+   0x15d | 04 04       | table section
+   0x15f | 01          | 1 count
+   0x160 | 70 00 01    | [table 0] Table { ty: TableType { element_type: RefType { nullable: true, heap_type: Func }, initial: 1, maximum: None }, init: RefNull }
+   0x163 | 05 03       | memory section
+   0x165 | 01          | 1 count
+   0x166 | 00 01       | [memory 0] MemoryType { memory64: false, shared: false, initial: 1, maximum: None }
+   0x168 | 06 04       | global section
    0x16a | 01          | 1 count
-   0x16b | 00 01       | [memory 0] MemoryType { memory64: false, shared: false, initial: 1, maximum: None }
-   0x16d | 06 04       | global section
-   0x16f | 01          | 1 count
-   0x170 | 7f 00       | [global 0] GlobalType { content_type: I32, mutable: false }
-   0x172 | 0b          | end
-   0x173 | 07 11       | export section
-   0x175 | 04          | 4 count
-   0x176 | 01 31 00 00 | export Export { name: "1", kind: Func, index: 0 }
-   0x17a | 01 32 02 00 | export Export { name: "2", kind: Memory, index: 0 }
-   0x17e | 01 33 03 00 | export Export { name: "3", kind: Global, index: 0 }
-   0x182 | 01 34 01 00 | export Export { name: "4", kind: Table, index: 0 }
-   0x186 | 0a 04       | code section
-   0x188 | 01          | 1 count
+   0x16b | 7f 00       | [global 0] GlobalType { content_type: I32, mutable: false }
+   0x16d | 0b          | end
+   0x16e | 07 11       | export section
+   0x170 | 04          | 4 count
+   0x171 | 01 31 00 00 | export Export { name: "1", kind: Func, index: 0 }
+   0x175 | 01 32 02 00 | export Export { name: "2", kind: Memory, index: 0 }
+   0x179 | 01 33 03 00 | export Export { name: "3", kind: Global, index: 0 }
+   0x17d | 01 34 01 00 | export Export { name: "4", kind: Table, index: 0 }
+   0x181 | 0a 04       | code section
+   0x183 | 01          | 1 count
 ============== func 0 ====================
-   0x189 | 02          | size of function
-   0x18a | 00          | 0 local blocks
-   0x18b | 0b          | end
-   0x18c | 00 0a       | custom section
-   0x18e | 04 6e 61 6d | name: "name"
+   0x184 | 02          | size of function
+   0x185 | 00          | 0 local blocks
+   0x186 | 0b          | end
+   0x187 | 00 0a       | custom section
+   0x189 | 04 6e 61 6d | name: "name"
          | 65         
-   0x193 | 00 03       | module name
-   0x195 | 02 6d 31    | "m1"
- 0x198 | 01 35       | [core module 3] inline size
-   0x19a | 00 61 73 6d | version 1 (Module)
+   0x18e | 00 03       | module name
+   0x190 | 02 6d 31    | "m1"
+ 0x193 | 01 35       | [core module 3] inline size
+   0x195 | 00 61 73 6d | version 1 (Module)
          | 01 00 00 00
-   0x1a2 | 01 04       | type section
-   0x1a4 | 01          | 1 count
-   0x1a5 | 60 00 00    | [type 0] SubType { is_final: false, supertype_idx: None, structural_type: Func(FuncType { params: [], returns: [] }) }
-   0x1a8 | 02 19       | import section
-   0x1aa | 04          | 4 count
-   0x1ab | 00 01 31 00 | import [func 0] Import { module: "", name: "1", ty: Func(0) }
+   0x19d | 01 04       | type section
+   0x19f | 01          | 1 count
+   0x1a0 | 60 00 00    | [type 0] Func(FuncType { params: [], returns: [] })
+   0x1a3 | 02 19       | import section
+   0x1a5 | 04          | 4 count
+   0x1a6 | 00 01 31 00 | import [func 0] Import { module: "", name: "1", ty: Func(0) }
          | 00         
-   0x1b0 | 00 01 32 02 | import [memory 0] Import { module: "", name: "2", ty: Memory(MemoryType { memory64: false, shared: false, initial: 1, maximum: None }) }
+   0x1ab | 00 01 32 02 | import [memory 0] Import { module: "", name: "2", ty: Memory(MemoryType { memory64: false, shared: false, initial: 1, maximum: None }) }
          | 00 01      
-   0x1b6 | 00 01 33 03 | import [global 0] Import { module: "", name: "3", ty: Global(GlobalType { content_type: I32, mutable: false }) }
+   0x1b1 | 00 01 33 03 | import [global 0] Import { module: "", name: "3", ty: Global(GlobalType { content_type: I32, mutable: false }) }
          | 7f 00      
-   0x1bc | 00 01 34 01 | import [table 0] Import { module: "", name: "4", ty: Table(TableType { element_type: funcref, initial: 1, maximum: None }) }
+   0x1b7 | 00 01 34 01 | import [table 0] Import { module: "", name: "4", ty: Table(TableType { element_type: RefType { nullable: true, heap_type: Func }, initial: 1, maximum: None }) }
          | 70 00 01   
-   0x1c3 | 00 0a       | custom section
-   0x1c5 | 04 6e 61 6d | name: "name"
+   0x1be | 00 0a       | custom section
+   0x1c0 | 04 6e 61 6d | name: "name"
          | 65         
-   0x1ca | 00 03       | module name
-   0x1cc | 02 6d 32    | "m2"
- 0x1cf | 02 0a       | core instance section
- 0x1d1 | 02          | 2 count
- 0x1d2 | 00 02 00    | [core instance 0] Instantiate { module_index: 2, args: [] }
- 0x1d5 | 00 03 01 00 | [core instance 1] Instantiate { module_index: 3, args: [InstantiationArg { name: "", kind: Instance, index: 0 }] }
+   0x1c5 | 00 03       | module name
+   0x1c7 | 02 6d 32    | "m2"
+ 0x1ca | 02 0a       | core instance section
+ 0x1cc | 02          | 2 count
+ 0x1cd | 00 02 00    | [core instance 0] Instantiate { module_index: 2, args: [] }
+ 0x1d0 | 00 03 01 00 | [core instance 1] Instantiate { module_index: 3, args: [InstantiationArg { name: "", kind: Instance, index: 0 }] }
        | 12 00      
- 0x1db | 06 19       | component alias section
- 0x1dd | 04          | 4 count
- 0x1de | 00 00 01 00 | alias [core func 0] CoreInstanceExport { kind: Func, instance_index: 0, name: "1" }
+ 0x1d6 | 06 19       | component alias section
+ 0x1d8 | 04          | 4 count
+ 0x1d9 | 00 00 01 00 | alias [core func 0] CoreInstanceExport { kind: Func, instance_index: 0, name: "1" }
        | 01 31      
- 0x1e4 | 00 02 01 00 | alias [core memory 0] CoreInstanceExport { kind: Memory, instance_index: 0, name: "2" }
+ 0x1df | 00 02 01 00 | alias [core memory 0] CoreInstanceExport { kind: Memory, instance_index: 0, name: "2" }
        | 01 32      
- 0x1ea | 00 03 01 00 | alias [core global 0] CoreInstanceExport { kind: Global, instance_index: 0, name: "3" }
+ 0x1e5 | 00 03 01 00 | alias [core global 0] CoreInstanceExport { kind: Global, instance_index: 0, name: "3" }
        | 01 33      
- 0x1f0 | 00 01 01 00 | alias [core table 0] CoreInstanceExport { kind: Table, instance_index: 0, name: "4" }
+ 0x1eb | 00 01 01 00 | alias [core table 0] CoreInstanceExport { kind: Table, instance_index: 0, name: "4" }
        | 01 34      
- 0x1f6 | 02 19       | core instance section
- 0x1f8 | 02          | 2 count
- 0x1f9 | 01 04 01 31 | [core instance 2] FromExports([Export { name: "1", kind: Func, index: 0 }, Export { name: "2", kind: Memory, index: 0 }, Export { name: "3", kind: Global, index: 0 }, Export { name: "4", kind: Table, index: 0 }])
+ 0x1f1 | 02 19       | core instance section
+ 0x1f3 | 02          | 2 count
+ 0x1f4 | 01 04 01 31 | [core instance 2] FromExports([Export { name: "1", kind: Func, index: 0 }, Export { name: "2", kind: Memory, index: 0 }, Export { name: "3", kind: Global, index: 0 }, Export { name: "4", kind: Table, index: 0 }])
        | 00 00 01 32
        | 02 00 01 33
        | 03 00 01 34
        | 01 00      
- 0x20b | 00 03 01 00 | [core instance 3] Instantiate { module_index: 3, args: [InstantiationArg { name: "", kind: Instance, index: 2 }] }
+ 0x206 | 00 03 01 00 | [core instance 3] Instantiate { module_index: 3, args: [InstantiationArg { name: "", kind: Instance, index: 2 }] }
        | 12 02      
- 0x211 | 00 76       | custom section
- 0x213 | 0e 63 6f 6d | name: "component-name"
+ 0x20c | 00 76       | custom section
+ 0x20e | 0e 63 6f 6d | name: "component-name"
        | 70 6f 6e 65
        | 6e 74 2d 6e
        | 61 6d 65   
- 0x222 | 01 06 00 00 | core func section
- 0x226 | 01          | 1 count
- 0x227 | 00 01 66    | Naming { index: 0, name: "f" }
- 0x22a | 01 06 00 01 | core table section
- 0x22e | 01          | 1 count
- 0x22f | 00 01 74    | Naming { index: 0, name: "t" }
- 0x232 | 01 06 00 02 | core memory section
- 0x236 | 01          | 1 count
- 0x237 | 00 01 6d    | Naming { index: 0, name: "m" }
- 0x23a | 01 06 00 03 | core global section
- 0x23e | 01          | 1 count
- 0x23f | 00 01 67    | Naming { index: 0, name: "g" }
- 0x242 | 01 0e 00 11 | core module section
- 0x246 | 03          | 3 count
- 0x247 | 01 01 6d    | Naming { index: 1, name: "m" }
- 0x24a | 02 02 6d 31 | Naming { index: 2, name: "m1" }
- 0x24e | 03 02 6d 32 | Naming { index: 3, name: "m2" }
- 0x252 | 01 06 00 12 | core instance section
- 0x256 | 01          | 1 count
- 0x257 | 00 01 69    | Naming { index: 0, name: "i" }
- 0x25a | 01 05 01    | func section
- 0x25d | 01          | 1 count
- 0x25e | 01 01 66    | Naming { index: 1, name: "f" }
- 0x261 | 01 05 02    | value section
- 0x264 | 01          | 1 count
- 0x265 | 01 01 76    | Naming { index: 1, name: "v" }
- 0x268 | 01 05 03    | type section
- 0x26b | 01          | 1 count
- 0x26c | 00 01 74    | Naming { index: 0, name: "t" }
- 0x26f | 01 0d 04    | component section
- 0x272 | 03          | 3 count
- 0x273 | 00 01 63    | Naming { index: 0, name: "c" }
- 0x276 | 02 02 63 32 | Naming { index: 2, name: "c2" }
- 0x27a | 03 02 63 33 | Naming { index: 3, name: "c3" }
- 0x27e | 01 09 05    | instance section
- 0x281 | 02          | 2 count
- 0x282 | 00 01 69    | Naming { index: 0, name: "i" }
- 0x285 | 03 02 69 32 | Naming { index: 3, name: "i2" }
+ 0x21d | 01 06 00 00 | core func section
+ 0x221 | 01          | 1 count
+ 0x222 | 00 01 66    | Naming { index: 0, name: "f" }
+ 0x225 | 01 06 00 01 | core table section
+ 0x229 | 01          | 1 count
+ 0x22a | 00 01 74    | Naming { index: 0, name: "t" }
+ 0x22d | 01 06 00 02 | core memory section
+ 0x231 | 01          | 1 count
+ 0x232 | 00 01 6d    | Naming { index: 0, name: "m" }
+ 0x235 | 01 06 00 03 | core global section
+ 0x239 | 01          | 1 count
+ 0x23a | 00 01 67    | Naming { index: 0, name: "g" }
+ 0x23d | 01 0e 00 11 | core module section
+ 0x241 | 03          | 3 count
+ 0x242 | 01 01 6d    | Naming { index: 1, name: "m" }
+ 0x245 | 02 02 6d 31 | Naming { index: 2, name: "m1" }
+ 0x249 | 03 02 6d 32 | Naming { index: 3, name: "m2" }
+ 0x24d | 01 06 00 12 | core instance section
+ 0x251 | 01          | 1 count
+ 0x252 | 00 01 69    | Naming { index: 0, name: "i" }
+ 0x255 | 01 05 01    | func section
+ 0x258 | 01          | 1 count
+ 0x259 | 01 01 66    | Naming { index: 1, name: "f" }
+ 0x25c | 01 05 02    | value section
+ 0x25f | 01          | 1 count
+ 0x260 | 01 01 76    | Naming { index: 1, name: "v" }
+ 0x263 | 01 05 03    | type section
+ 0x266 | 01          | 1 count
+ 0x267 | 00 01 74    | Naming { index: 0, name: "t" }
+ 0x26a | 01 0d 04    | component section
+ 0x26d | 03          | 3 count
+ 0x26e | 00 01 63    | Naming { index: 0, name: "c" }
+ 0x271 | 02 02 63 32 | Naming { index: 2, name: "c2" }
+ 0x275 | 03 02 63 33 | Naming { index: 3, name: "c3" }
+ 0x279 | 01 09 05    | instance section
+ 0x27c | 02          | 2 count
+ 0x27d | 00 01 69    | Naming { index: 0, name: "i" }
+ 0x280 | 03 02 69 32 | Naming { index: 3, name: "i2" }
diff --git a/tests/cli/dump/blockty.wat.stdout b/tests/cli/dump/blockty.wat.stdout
index c622e0ec..6652088a 100644
--- a/tests/cli/dump/blockty.wat.stdout
+++ b/tests/cli/dump/blockty.wat.stdout
@@ -2,12 +2,12 @@
       | 01 00 00 00
   0x8 | 01 17       | type section
   0xa | 05          | 5 count
-  0xb | 60 00 00    | [type 0] SubType { is_final: false, supertype_idx: None, structural_type: Func(FuncType { params: [], returns: [] }) }
-  0xe | 60 00 01 7f | [type 1] SubType { is_final: false, supertype_idx: None, structural_type: Func(FuncType { params: [], returns: [I32] }) }
- 0x12 | 60 01 7f 00 | [type 2] SubType { is_final: false, supertype_idx: None, structural_type: Func(FuncType { params: [I32], returns: [] }) }
- 0x16 | 60 01 7f 01 | [type 3] SubType { is_final: false, supertype_idx: None, structural_type: Func(FuncType { params: [I32], returns: [I32] }) }
+  0xb | 60 00 00    | [type 0] Func(FuncType { params: [], returns: [] })
+  0xe | 60 00 01 7f | [type 1] Func(FuncType { params: [], returns: [I32] })
+ 0x12 | 60 01 7f 00 | [type 2] Func(FuncType { params: [I32], returns: [] })
+ 0x16 | 60 01 7f 01 | [type 3] Func(FuncType { params: [I32], returns: [I32] })
       | 7f         
- 0x1b | 60 01 7f 02 | [type 4] SubType { is_final: false, supertype_idx: None, structural_type: Func(FuncType { params: [I32], returns: [I32, I32] }) }
+ 0x1b | 60 01 7f 02 | [type 4] Func(FuncType { params: [I32], returns: [I32, I32] })
       | 7f 7f      
  0x21 | 03 02       | func section
  0x23 | 01          | 1 count
diff --git a/tests/cli/dump/bundled.wat.stdout b/tests/cli/dump/bundled.wat.stdout
index 13dbca18..26cee44a 100644
--- a/tests/cli/dump/bundled.wat.stdout
+++ b/tests/cli/dump/bundled.wat.stdout
@@ -1,31 +1,31 @@
-   0x0 | 00 61 73 6d | version 13 (Component)
-       | 0d 00 01 00
+   0x0 | 00 61 73 6d | version 12 (Component)
+       | 0c 00 01 00
    0x8 | 07 30       | component type section
    0xa | 01          | 1 count
-   0xb | 42 06 01 70 | [type 0] Instance([Type(Defined(List(Primitive(U8)))), Type(Func(ComponentFuncType { params: [("len", Primitive(U32))], results: Unnamed(Type(0)) })), Export { name: Kebab("read"), ty: Func(1) }, Type(Defined(List(Primitive(U8)))), Type(Func(ComponentFuncType { params: [("buf", Type(2))], results: Unnamed(Primitive(U32)) })), Export { name: Kebab("write"), ty: Func(3) }])
+   0xb | 42 06 01 70 | [type 0] Instance([Type(Defined(List(Primitive(U8)))), Type(Func(ComponentFuncType { params: [("len", Primitive(U32))], results: Unnamed(Type(0)) })), Export { name: "read", url: "", ty: Func(1) }, Type(Defined(List(Primitive(U8)))), Type(Func(ComponentFuncType { params: [("buf", Type(2))], results: Unnamed(Primitive(U32)) })), Export { name: "write", url: "", ty: Func(3) }])
        | 7d 01 40 01
        | 03 6c 65 6e
        | 79 00 00 04
-       | 00 04 72 65
-       | 61 64 01 01
+       | 04 72 65 61
+       | 64 00 01 01
        | 01 70 7d 01
        | 40 01 03 62
        | 75 66 02 00
-       | 79 04 00 05
-       | 77 72 69 74
-       | 65 01 03   
+       | 79 04 05 77
+       | 72 69 74 65
+       | 00 01 03   
   0x3a | 0a 0e       | component import section
   0x3c | 01          | 1 count
-  0x3d | 00 09 77 61 | [instance 0] ComponentImport { name: Kebab("wasi-file"), ty: Instance(0) }
-       | 73 69 2d 66
-       | 69 6c 65 05
+  0x3d | 09 77 61 73 | [instance 0] ComponentImport { name: "wasi-file", url: "", ty: Instance(0) }
+       | 69 2d 66 69
+       | 6c 65 00 05
        | 00         
   0x4a | 01 44       | [core module 0] inline size
     0x4c | 00 61 73 6d | version 1 (Module)
          | 01 00 00 00
     0x54 | 01 09       | type section
     0x56 | 01          | 1 count
-    0x57 | 60 04 7f 7f | [type 0] SubType { is_final: false, supertype_idx: None, structural_type: Func(FuncType { params: [I32, I32, I32, I32], returns: [I32] }) }
+    0x57 | 60 04 7f 7f | [type 0] Func(FuncType { params: [I32, I32, I32, I32], returns: [I32] })
          | 7f 7f 01 7f
     0x5f | 03 02       | func section
     0x61 | 01          | 1 count
@@ -61,9 +61,9 @@
          | 01 00 00 00
     0xa0 | 01 09       | type section
     0xa2 | 02          | 2 count
-    0xa3 | 60 02 7f 7f | [type 0] SubType { is_final: false, supertype_idx: None, structural_type: Func(FuncType { params: [I32, I32], returns: [] }) }
+    0xa3 | 60 02 7f 7f | [type 0] Func(FuncType { params: [I32, I32], returns: [] })
          | 00         
-    0xa8 | 60 00 00    | [type 1] SubType { is_final: false, supertype_idx: None, structural_type: Func(FuncType { params: [], returns: [] }) }
+    0xa8 | 60 00 00    | [type 1] Func(FuncType { params: [], returns: [] })
     0xab | 02 12       | import section
     0xad | 01          | 1 count
     0xae | 09 77 61 73 | import [func 0] Import { module: "wasi-file", name: "read", ty: Func(0) }
@@ -103,9 +103,9 @@
          | 01 00 00 00
    0x101 | 01 0c       | type section
    0x103 | 02          | 2 count
-   0x104 | 60 02 7f 7f | [type 0] SubType { is_final: false, supertype_idx: None, structural_type: Func(FuncType { params: [I32, I32], returns: [] }) }
+   0x104 | 60 02 7f 7f | [type 0] Func(FuncType { params: [I32, I32], returns: [] })
          | 00         
-   0x109 | 60 03 7f 7f | [type 1] SubType { is_final: false, supertype_idx: None, structural_type: Func(FuncType { params: [I32, I32, I32], returns: [] }) }
+   0x109 | 60 03 7f 7f | [type 1] Func(FuncType { params: [I32, I32, I32], returns: [] })
          | 7f 00      
    0x10f | 02 12       | import section
    0x111 | 01          | 1 count
@@ -189,8 +189,8 @@
        | 01         
  0x1e0 | 0b 0a       | component export section
  0x1e2 | 01          | 1 count
- 0x1e3 | 00 04 77 6f | export ComponentExport { name: Kebab("work"), kind: Func, index: 1, ty: None }
-       | 72 6b 01 01
+ 0x1e3 | 04 77 6f 72 | export ComponentExport { name: "work", url: "", kind: Func, index: 1, ty: None }
+       | 6b 00 01 01
        | 00         
  0x1ec | 00 7c       | custom section
  0x1ee | 0e 63 6f 6d | name: "component-name"
diff --git a/tests/cli/dump/component-expand-bundle.wat.stdout b/tests/cli/dump/component-expand-bundle.wat.stdout
index 12059371..652d028b 100644
--- a/tests/cli/dump/component-expand-bundle.wat.stdout
+++ b/tests/cli/dump/component-expand-bundle.wat.stdout
@@ -1,11 +1,11 @@
-  0x0 | 00 61 73 6d | version 13 (Component)
-      | 0d 00 01 00
+  0x0 | 00 61 73 6d | version 12 (Component)
+      | 0c 00 01 00
   0x8 | 01 29       | [core module 0] inline size
     0xa | 00 61 73 6d | version 1 (Module)
         | 01 00 00 00
    0x12 | 01 04       | type section
    0x14 | 01          | 1 count
-   0x15 | 60 00 00    | [type 0] SubType { is_final: false, supertype_idx: None, structural_type: Func(FuncType { params: [], returns: [] }) }
+   0x15 | 60 00 00    | [type 0] Func(FuncType { params: [], returns: [] })
    0x18 | 03 02       | func section
    0x1a | 01          | 1 count
    0x1b | 00          | [func 0] type 0
@@ -28,7 +28,7 @@
         | 01 00 00 00
    0x3d | 01 04       | type section
    0x3f | 01          | 1 count
-   0x40 | 60 00 00    | [type 0] SubType { is_final: false, supertype_idx: None, structural_type: Func(FuncType { params: [], returns: [] }) }
+   0x40 | 60 00 00    | [type 0] Func(FuncType { params: [], returns: [] })
    0x43 | 02 06       | import section
    0x45 | 01          | 1 count
    0x46 | 00 01 61 00 | import [func 0] Import { module: "", name: "a", ty: Func(0) }
diff --git a/tests/cli/dump/component-expand-bundle2.wat.stdout b/tests/cli/dump/component-expand-bundle2.wat.stdout
index 03470f02..d46e1822 100644
--- a/tests/cli/dump/component-expand-bundle2.wat.stdout
+++ b/tests/cli/dump/component-expand-bundle2.wat.stdout
@@ -1,14 +1,14 @@
-  0x0 | 00 61 73 6d | version 13 (Component)
-      | 0d 00 01 00
+  0x0 | 00 61 73 6d | version 12 (Component)
+      | 0c 00 01 00
   0x8 | 04 31       | [component 0] inline size
-    0xa | 00 61 73 6d | version 13 (Component)
-        | 0d 00 01 00
+    0xa | 00 61 73 6d | version 12 (Component)
+        | 0c 00 01 00
    0x12 | 01 08       | [core module 0] inline size
      0x14 | 00 61 73 6d | version 1 (Module)
           | 01 00 00 00
    0x1c | 0b 08       | component export section
    0x1e | 01          | 1 count
-   0x1f | 00 01 65 00 | export ComponentExport { name: Kebab("e"), kind: Module, index: 0, ty: None }
+   0x1f | 01 65 00 00 | export ComponentExport { name: "e", url: "", kind: Module, index: 0, ty: None }
         | 11 00 00   
    0x26 | 00 13       | custom section
    0x28 | 0e 63 6f 6d | name: "component-name"
@@ -18,16 +18,16 @@
    0x37 | 00 02       | component name
    0x39 | 01 63       | "c"
  0x3b | 04 35       | [component 1] inline size
-   0x3d | 00 61 73 6d | version 13 (Component)
-        | 0d 00 01 00
+   0x3d | 00 61 73 6d | version 12 (Component)
+        | 0c 00 01 00
    0x45 | 07 0d       | component type section
    0x47 | 01          | 1 count
-   0x48 | 41 02 00 50 | [type 0] Component([CoreType(Module([])), Import(ComponentImport { name: Kebab("i"), ty: Module(0) })])
-        | 00 03 00 01
-        | 69 00 11 00
+   0x48 | 41 02 00 50 | [type 0] Component([CoreType(Module([])), Import(ComponentImport { name: "i", url: "", ty: Module(0) })])
+        | 00 03 01 69
+        | 00 00 11 00
    0x54 | 0a 06       | component import section
    0x56 | 01          | 1 count
-   0x57 | 00 01 69 04 | [component 0] ComponentImport { name: Kebab("i"), ty: Component(0) }
+   0x57 | 01 69 00 04 | [component 0] ComponentImport { name: "i", url: "", ty: Component(0) }
         | 00         
    0x5c | 00 14       | custom section
    0x5e | 0e 63 6f 6d | name: "component-name"
@@ -43,24 +43,24 @@
  0x7a | 01          | 1 count
  0x7b | 00 11 00 00 | alias [module 0] InstanceExport { kind: Module, instance_index: 0, name: "e" }
       | 01 65      
- 0x81 | 05 10       | component instance section
+ 0x81 | 05 0f       | component instance section
  0x83 | 02          | 2 count
- 0x84 | 01 01 00 01 | [instance 1] FromExports([ComponentExport { name: Kebab("e"), kind: Module, index: 0, ty: None }])
-      | 65 00 11 00
- 0x8c | 00 01 01 01 | [instance 2] Instantiate { component_index: 1, args: [ComponentInstantiationArg { name: "i", kind: Instance, index: 1 }] }
+ 0x84 | 01 01 01 65 | [instance 1] FromExports([ComponentExport { name: "e", url: "", kind: Module, index: 0, ty: None }])
+      | 00 11 00   
+ 0x8b | 00 01 01 01 | [instance 2] Instantiate { component_index: 1, args: [ComponentInstantiationArg { name: "i", kind: Instance, index: 1 }] }
       | 69 05 01   
- 0x93 | 00 29       | custom section
- 0x95 | 0e 63 6f 6d | name: "component-name"
+ 0x92 | 00 29       | custom section
+ 0x94 | 0e 63 6f 6d | name: "component-name"
       | 70 6f 6e 65
       | 6e 74 2d 6e
       | 61 6d 65   
- 0xa4 | 01 06 00 11 | core module section
- 0xa8 | 01          | 1 count
- 0xa9 | 00 01 6d    | Naming { index: 0, name: "m" }
- 0xac | 01 09 04    | component section
- 0xaf | 02          | 2 count
- 0xb0 | 00 01 63    | Naming { index: 0, name: "c" }
- 0xb3 | 01 02 63 32 | Naming { index: 1, name: "c2" }
- 0xb7 | 01 05 05    | instance section
- 0xba | 01          | 1 count
- 0xbb | 00 01 43    | Naming { index: 0, name: "C" }
+ 0xa3 | 01 06 00 11 | core module section
+ 0xa7 | 01          | 1 count
+ 0xa8 | 00 01 6d    | Naming { index: 0, name: "m" }
+ 0xab | 01 09 04    | component section
+ 0xae | 02          | 2 count
+ 0xaf | 00 01 63    | Naming { index: 0, name: "c" }
+ 0xb2 | 01 02 63 32 | Naming { index: 1, name: "c2" }
+ 0xb6 | 01 05 05    | instance section
+ 0xb9 | 01          | 1 count
+ 0xba | 00 01 43    | Naming { index: 0, name: "C" }
diff --git a/tests/cli/dump/component-inline-export-import.wat.stdout b/tests/cli/dump/component-inline-export-import.wat.stdout
index 8ac44f5c..83983bd0 100644
--- a/tests/cli/dump/component-inline-export-import.wat.stdout
+++ b/tests/cli/dump/component-inline-export-import.wat.stdout
@@ -1,21 +1,21 @@
-  0x0 | 00 61 73 6d | version 13 (Component)
-      | 0d 00 01 00
+  0x0 | 00 61 73 6d | version 12 (Component)
+      | 0c 00 01 00
   0x8 | 07 03       | component type section
   0xa | 01          | 1 count
   0xb | 41 00       | [type 0] Component([])
   0xd | 0a 05       | component import section
   0xf | 01          | 1 count
- 0x10 | 00 00 04 00 | [component 0] ComponentImport { name: Kebab(""), ty: Component(0) }
+ 0x10 | 00 00 04 00 | [component 0] ComponentImport { name: "", url: "", ty: Component(0) }
  0x14 | 03 03       | core type section
  0x16 | 01          | 1 count
  0x17 | 50 00       | [core type 0] Module([])
  0x19 | 0a 07       | component import section
  0x1b | 01          | 1 count
- 0x1c | 00 01 61 00 | [module 0] ComponentImport { name: Kebab("a"), ty: Module(0) }
+ 0x1c | 01 61 00 00 | [module 0] ComponentImport { name: "a", url: "", ty: Module(0) }
       | 11 00      
  0x22 | 0b 0d       | component export section
  0x24 | 02          | 2 count
- 0x25 | 00 00 04 00 | export ComponentExport { name: Kebab(""), kind: Component, index: 0, ty: None }
+ 0x25 | 00 00 04 00 | export ComponentExport { name: "", url: "", kind: Component, index: 0, ty: None }
       | 00         
- 0x2a | 00 01 61 00 | export ComponentExport { name: Kebab("a"), kind: Module, index: 0, ty: None }
+ 0x2a | 01 61 00 00 | export ComponentExport { name: "a", url: "", kind: Module, index: 0, ty: None }
       | 11 00 00   
diff --git a/tests/cli/dump/component-inline-type.wat.stdout b/tests/cli/dump/component-inline-type.wat.stdout
index d6d55e5d..6ed828b8 100644
--- a/tests/cli/dump/component-inline-type.wat.stdout
+++ b/tests/cli/dump/component-inline-type.wat.stdout
@@ -1,30 +1,30 @@
-  0x0 | 00 61 73 6d | version 13 (Component)
-      | 0d 00 01 00
+  0x0 | 00 61 73 6d | version 12 (Component)
+      | 0c 00 01 00
   0x8 | 07 03       | component type section
   0xa | 01          | 1 count
   0xb | 41 00       | [type 0] Component([])
   0xd | 0a 06       | component import section
   0xf | 01          | 1 count
- 0x10 | 00 01 61 04 | [component 0] ComponentImport { name: Kebab("a"), ty: Component(0) }
+ 0x10 | 01 61 00 04 | [component 0] ComponentImport { name: "a", url: "", ty: Component(0) }
       | 00         
  0x15 | 03 03       | core type section
  0x17 | 01          | 1 count
  0x18 | 50 00       | [core type 0] Module([])
  0x1a | 0a 07       | component import section
  0x1c | 01          | 1 count
- 0x1d | 00 01 62 00 | [module 0] ComponentImport { name: Kebab("b"), ty: Module(0) }
+ 0x1d | 01 62 00 00 | [module 0] ComponentImport { name: "b", url: "", ty: Module(0) }
       | 11 00      
  0x23 | 07 03       | component type section
  0x25 | 01          | 1 count
  0x26 | 42 00       | [type 1] Instance([])
  0x28 | 0a 06       | component import section
  0x2a | 01          | 1 count
- 0x2b | 00 01 63 05 | [instance 0] ComponentImport { name: Kebab("c"), ty: Instance(1) }
+ 0x2b | 01 63 00 05 | [instance 0] ComponentImport { name: "c", url: "", ty: Instance(1) }
       | 01         
  0x30 | 07 05       | component type section
  0x32 | 01          | 1 count
  0x33 | 40 00 01 00 | [type 2] Func(ComponentFuncType { params: [], results: Named([]) })
  0x37 | 0a 06       | component import section
  0x39 | 01          | 1 count
- 0x3a | 00 01 64 01 | [func 0] ComponentImport { name: Kebab("d"), ty: Func(2) }
+ 0x3a | 01 64 00 01 | [func 0] ComponentImport { name: "d", url: "", ty: Func(2) }
       | 02         
diff --git a/tests/cli/dump/component-instance-type.wat.stdout b/tests/cli/dump/component-instance-type.wat.stdout
index 00233fd9..26a143f3 100644
--- a/tests/cli/dump/component-instance-type.wat.stdout
+++ b/tests/cli/dump/component-instance-type.wat.stdout
@@ -1,17 +1,17 @@
-  0x0 | 00 61 73 6d | version 13 (Component)
-      | 0d 00 01 00
+  0x0 | 00 61 73 6d | version 12 (Component)
+      | 0c 00 01 00
   0x8 | 07 28       | component type section
   0xa | 01          | 1 count
-  0xb | 42 03 01 40 | [type 0] Instance([Type(Func(ComponentFuncType { params: [], results: Named([]) })), Type(Component([Type(Func(ComponentFuncType { params: [], results: Named([]) })), Alias(Outer { kind: Type, count: 1, index: 0 }), Import(ComponentImport { name: Kebab("1"), ty: Func(0) }), Export { name: Kebab("1"), ty: Func(1) }])), Export { name: Kebab("c5"), ty: Component(1) }])
+  0xb | 42 03 01 40 | [type 0] Instance([Type(Func(ComponentFuncType { params: [], results: Named([]) })), Type(Component([Type(Func(ComponentFuncType { params: [], results: Named([]) })), Alias(Outer { kind: Type, count: 1, index: 0 }), Import(ComponentImport { name: "1", url: "", ty: Func(0) }), Export { name: "1", url: "", ty: Func(1) }])), Export { name: "c5", url: "", ty: Component(1) }])
       | 00 01 00 01
       | 41 04 01 40
       | 00 01 00 02
       | 03 02 01 00
-      | 03 00 01 31
-      | 01 00 04 00
-      | 01 31 01 01
-      | 04 00 02 63
-      | 35 04 01   
+      | 03 01 31 00
+      | 01 00 04 01
+      | 31 00 01 01
+      | 04 02 63 35
+      | 00 04 01   
  0x32 | 00 1a       | custom section
  0x34 | 0e 63 6f 6d | name: "component-name"
       | 70 6f 6e 65
diff --git a/tests/cli/dump/component-linking.wat.stdout b/tests/cli/dump/component-linking.wat.stdout
index 98b16dc7..80fb557f 100644
--- a/tests/cli/dump/component-linking.wat.stdout
+++ b/tests/cli/dump/component-linking.wat.stdout
@@ -1,55 +1,55 @@
-  0x0 | 00 61 73 6d | version 13 (Component)
-      | 0d 00 01 00
+  0x0 | 00 61 73 6d | version 12 (Component)
+      | 0c 00 01 00
   0x8 | 07 30       | component type section
   0xa | 01          | 1 count
-  0xb | 42 09 00 50 | [type 0] Instance([CoreType(Module([])), Export { name: Kebab("a"), ty: Module(0) }, Type(Func(ComponentFuncType { params: [], results: Named([]) })), Export { name: Kebab("b"), ty: Func(0) }, Export { name: Kebab("c"), ty: Value(Primitive(String)) }, Type(Instance([])), Export { name: Kebab("d"), ty: Instance(1) }, Type(Component([])), Export { name: Kebab("e"), ty: Component(2) }])
-      | 00 04 00 01
-      | 61 00 11 00
+  0xb | 42 09 00 50 | [type 0] Instance([CoreType(Module([])), Export { name: "a", url: "", ty: Module(0) }, Type(Func(ComponentFuncType { params: [], results: Named([]) })), Export { name: "b", url: "", ty: Func(0) }, Export { name: "c", url: "", ty: Value(Primitive(String)) }, Type(Instance([])), Export { name: "d", url: "", ty: Instance(1) }, Type(Component([])), Export { name: "e", url: "", ty: Component(2) }])
+      | 00 04 01 61
+      | 00 00 11 00
       | 01 40 00 01
-      | 00 04 00 01
-      | 62 01 00 04
-      | 00 01 63 02
+      | 00 04 01 62
+      | 00 01 00 04
+      | 01 63 00 02
       | 73 01 42 00
-      | 04 00 01 64
+      | 04 01 64 00
       | 05 01 01 41
-      | 00 04 00 01
-      | 65 04 02   
+      | 00 04 01 65
+      | 00 04 02   
  0x3a | 0a 06       | component import section
  0x3c | 01          | 1 count
- 0x3d | 00 01 61 05 | [instance 0] ComponentImport { name: Kebab("a"), ty: Instance(0) }
+ 0x3d | 01 61 00 05 | [instance 0] ComponentImport { name: "a", url: "", ty: Instance(0) }
       | 00         
  0x42 | 04 59       | [component 0] inline size
-   0x44 | 00 61 73 6d | version 13 (Component)
-        | 0d 00 01 00
+   0x44 | 00 61 73 6d | version 12 (Component)
+        | 0c 00 01 00
    0x4c | 03 03       | core type section
    0x4e | 01          | 1 count
    0x4f | 50 00       | [core type 0] Module([])
    0x51 | 0a 07       | component import section
    0x53 | 01          | 1 count
-   0x54 | 00 01 61 00 | [module 0] ComponentImport { name: Kebab("a"), ty: Module(0) }
+   0x54 | 01 61 00 00 | [module 0] ComponentImport { name: "a", url: "", ty: Module(0) }
         | 11 00      
    0x5a | 07 05       | component type section
    0x5c | 01          | 1 count
    0x5d | 40 00 01 00 | [type 0] Func(ComponentFuncType { params: [], results: Named([]) })
    0x61 | 0a 0b       | component import section
    0x63 | 02          | 2 count
-   0x64 | 00 01 62 01 | [func 0] ComponentImport { name: Kebab("b"), ty: Func(0) }
+   0x64 | 01 62 00 01 | [func 0] ComponentImport { name: "b", url: "", ty: Func(0) }
         | 00         
-   0x69 | 00 01 63 02 | [value 0] ComponentImport { name: Kebab("c"), ty: Value(Primitive(String)) }
+   0x69 | 01 63 00 02 | [value 0] ComponentImport { name: "c", url: "", ty: Value(Primitive(String)) }
         | 73         
    0x6e | 07 03       | component type section
    0x70 | 01          | 1 count
    0x71 | 42 00       | [type 1] Instance([])
    0x73 | 0a 06       | component import section
    0x75 | 01          | 1 count
-   0x76 | 00 01 64 05 | [instance 0] ComponentImport { name: Kebab("d"), ty: Instance(1) }
+   0x76 | 01 64 00 05 | [instance 0] ComponentImport { name: "d", url: "", ty: Instance(1) }
         | 01         
    0x7b | 07 03       | component type section
    0x7d | 01          | 1 count
    0x7e | 41 00       | [type 2] Component([])
    0x80 | 0a 06       | component import section
    0x82 | 01          | 1 count
-   0x83 | 00 01 65 04 | [component 0] ComponentImport { name: Kebab("e"), ty: Component(2) }
+   0x83 | 01 65 00 04 | [component 0] ComponentImport { name: "e", url: "", ty: Component(2) }
         | 02         
    0x88 | 00 13       | custom section
    0x8a | 0e 63 6f 6d | name: "component-name"
diff --git a/tests/cli/dump/component-outer-alias.wat.stdout b/tests/cli/dump/component-outer-alias.wat.stdout
index 54124dd7..187fe2ea 100644
--- a/tests/cli/dump/component-outer-alias.wat.stdout
+++ b/tests/cli/dump/component-outer-alias.wat.stdout
@@ -1,5 +1,5 @@
-  0x0 | 00 61 73 6d | version 13 (Component)
-      | 0d 00 01 00
+  0x0 | 00 61 73 6d | version 12 (Component)
+      | 0c 00 01 00
   0x8 | 07 0e       | component type section
   0xa | 02          | 2 count
   0xb | 73          | [type 0] Defined(Primitive(String))
@@ -7,8 +7,8 @@
       | 02 01 00 01
       | 40 00 00 00
  0x18 | 04 2e       | [component 0] inline size
-   0x1a | 00 61 73 6d | version 13 (Component)
-        | 0d 00 01 00
+   0x1a | 00 61 73 6d | version 12 (Component)
+        | 0c 00 01 00
    0x22 | 06 05       | component alias section
    0x24 | 01          | 1 count
    0x25 | 03 02 01 00 | alias [type 0] Outer { kind: Type, count: 1, index: 0 }
@@ -24,8 +24,8 @@
    0x44 | 01          | 1 count
    0x45 | 00 01 74    | Naming { index: 0, name: "t" }
  0x48 | 04 32       | [component 1] inline size
-   0x4a | 00 61 73 6d | version 13 (Component)
-        | 0d 00 01 00
+   0x4a | 00 61 73 6d | version 12 (Component)
+        | 0c 00 01 00
    0x52 | 06 05       | component alias section
    0x54 | 01          | 1 count
    0x55 | 03 02 01 00 | alias [type 0] Outer { kind: Type, count: 1, index: 0 }
@@ -45,8 +45,8 @@
  0x7e | 01          | 1 count
  0x7f | 7d          | [type 2] Defined(Primitive(U8))
  0x80 | 04 33       | [component 2] inline size
-   0x82 | 00 61 73 6d | version 13 (Component)
-        | 0d 00 01 00
+   0x82 | 00 61 73 6d | version 12 (Component)
+        | 0c 00 01 00
    0x8a | 06 05       | component alias section
    0x8c | 01          | 1 count
    0x8d | 03 02 01 02 | alias [type 0] Outer { kind: Type, count: 1, index: 2 }
diff --git a/tests/cli/dump/import-modules.wat.stdout b/tests/cli/dump/import-modules.wat.stdout
index acdfd862..3cc12aef 100644
--- a/tests/cli/dump/import-modules.wat.stdout
+++ b/tests/cli/dump/import-modules.wat.stdout
@@ -1,20 +1,20 @@
-  0x0 | 00 61 73 6d | version 13 (Component)
-      | 0d 00 01 00
+  0x0 | 00 61 73 6d | version 12 (Component)
+      | 0c 00 01 00
   0x8 | 03 0d       | core type section
   0xa | 01          | 1 count
-  0xb | 50 02 01 60 | [core type 0] Module([Type(SubType { is_final: false, supertype_idx: None, structural_type: Func(FuncType { params: [], returns: [] }) }), Import(Import { module: "", name: "f", ty: Func(0) })])
+  0xb | 50 02 01 60 | [core type 0] Module([Type(Func(FuncType { params: [], returns: [] })), Import(Import { module: "", name: "f", ty: Func(0) })])
       | 00 00 00 00
       | 01 66 00 00
  0x17 | 0a 07       | component import section
  0x19 | 01          | 1 count
- 0x1a | 00 01 61 00 | [module 0] ComponentImport { name: Kebab("a"), ty: Module(0) }
+ 0x1a | 01 61 00 00 | [module 0] ComponentImport { name: "a", url: "", ty: Module(0) }
       | 11 00      
  0x20 | 01 2b       | [core module 1] inline size
    0x22 | 00 61 73 6d | version 1 (Module)
         | 01 00 00 00
    0x2a | 01 04       | type section
    0x2c | 01          | 1 count
-   0x2d | 60 00 00    | [type 0] SubType { is_final: false, supertype_idx: None, structural_type: Func(FuncType { params: [], returns: [] }) }
+   0x2d | 60 00 00    | [type 0] Func(FuncType { params: [], returns: [] })
    0x30 | 03 02       | func section
    0x32 | 01          | 1 count
    0x33 | 00          | [func 0] type 0
diff --git a/tests/cli/dump/instance-expand.wat.stdout b/tests/cli/dump/instance-expand.wat.stdout
index 1efe59db..89c67f8c 100644
--- a/tests/cli/dump/instance-expand.wat.stdout
+++ b/tests/cli/dump/instance-expand.wat.stdout
@@ -1,13 +1,13 @@
-  0x0 | 00 61 73 6d | version 13 (Component)
-      | 0d 00 01 00
+  0x0 | 00 61 73 6d | version 12 (Component)
+      | 0c 00 01 00
   0x8 | 07 0d       | component type section
   0xa | 01          | 1 count
-  0xb | 42 02 01 40 | [type 0] Instance([Type(Func(ComponentFuncType { params: [], results: Named([]) })), Export { name: Kebab(""), ty: Func(0) }])
+  0xb | 42 02 01 40 | [type 0] Instance([Type(Func(ComponentFuncType { params: [], results: Named([]) })), Export { name: "", url: "", ty: Func(0) }])
       | 00 01 00 04
       | 00 00 01 00
  0x17 | 0a 06       | component import section
  0x19 | 01          | 1 count
- 0x1a | 00 01 61 05 | [instance 0] ComponentImport { name: Kebab("a"), ty: Instance(0) }
+ 0x1a | 01 61 00 05 | [instance 0] ComponentImport { name: "a", url: "", ty: Instance(0) }
       | 00         
  0x1f | 00 16       | custom section
  0x21 | 0e 63 6f 6d | name: "component-name"
diff --git a/tests/cli/dump/instance-type.wat.stdout b/tests/cli/dump/instance-type.wat.stdout
index 98c33d3f..5451e560 100644
--- a/tests/cli/dump/instance-type.wat.stdout
+++ b/tests/cli/dump/instance-type.wat.stdout
@@ -1,10 +1,10 @@
-  0x0 | 00 61 73 6d | version 13 (Component)
-      | 0d 00 01 00
+  0x0 | 00 61 73 6d | version 12 (Component)
+      | 0c 00 01 00
   0x8 | 07 17       | component type section
   0xa | 02          | 2 count
-  0xb | 42 02 01 40 | [type 0] Instance([Type(Func(ComponentFuncType { params: [], results: Named([]) })), Export { name: Kebab(""), ty: Func(0) }])
+  0xb | 42 02 01 40 | [type 0] Instance([Type(Func(ComponentFuncType { params: [], results: Named([]) })), Export { name: "", url: "", ty: Func(0) }])
       | 00 01 00 04
       | 00 00 01 00
- 0x17 | 42 02 01 42 | [type 1] Instance([Type(Instance([])), Export { name: Kebab(""), ty: Instance(0) }])
+ 0x17 | 42 02 01 42 | [type 1] Instance([Type(Instance([])), Export { name: "", url: "", ty: Instance(0) }])
       | 00 04 00 00
       | 05 00      
diff --git a/tests/cli/dump/instance-type2.wat.stdout b/tests/cli/dump/instance-type2.wat.stdout
index 7d77ef7e..84828cd3 100644
--- a/tests/cli/dump/instance-type2.wat.stdout
+++ b/tests/cli/dump/instance-type2.wat.stdout
@@ -1,12 +1,12 @@
-  0x0 | 00 61 73 6d | version 13 (Component)
-      | 0d 00 01 00
+  0x0 | 00 61 73 6d | version 12 (Component)
+      | 0c 00 01 00
   0x8 | 07 18       | component type section
   0xa | 04          | 4 count
   0xb | 42 00       | [type 0] Instance([])
-  0xd | 42 01 04 00 | [type 1] Instance([Export { name: Kebab(""), ty: Instance(0) }])
+  0xd | 42 01 04 00 | [type 1] Instance([Export { name: "", url: "", ty: Instance(0) }])
       | 00 05 00   
  0x14 | 42 00       | [type 2] Instance([])
- 0x16 | 42 02 02 03 | [type 3] Instance([Alias(Outer { kind: Type, count: 1, index: 2 }), Export { name: Kebab(""), ty: Instance(0) }])
+ 0x16 | 42 02 02 03 | [type 3] Instance([Alias(Outer { kind: Type, count: 1, index: 2 }), Export { name: "", url: "", ty: Instance(0) }])
       | 02 01 02 04
       | 00 00 05 00
  0x22 | 00 16       | custom section
diff --git a/tests/cli/dump/instantiate.wat.stdout b/tests/cli/dump/instantiate.wat.stdout
index aa26fcdc..b203d6f9 100644
--- a/tests/cli/dump/instantiate.wat.stdout
+++ b/tests/cli/dump/instantiate.wat.stdout
@@ -1,18 +1,18 @@
-  0x0 | 00 61 73 6d | version 13 (Component)
-      | 0d 00 01 00
+  0x0 | 00 61 73 6d | version 12 (Component)
+      | 0c 00 01 00
   0x8 | 07 03       | component type section
   0xa | 01          | 1 count
   0xb | 41 00       | [type 0] Component([])
   0xd | 0a 06       | component import section
   0xf | 01          | 1 count
- 0x10 | 00 01 61 04 | [component 0] ComponentImport { name: Kebab("a"), ty: Component(0) }
+ 0x10 | 01 61 00 04 | [component 0] ComponentImport { name: "a", url: "", ty: Component(0) }
       | 00         
  0x15 | 07 05       | component type section
  0x17 | 01          | 1 count
  0x18 | 40 00 01 00 | [type 1] Func(ComponentFuncType { params: [], results: Named([]) })
  0x1c | 0a 06       | component import section
  0x1e | 01          | 1 count
- 0x1f | 00 01 66 01 | [func 0] ComponentImport { name: Kebab("f"), ty: Func(1) }
+ 0x1f | 01 66 00 01 | [func 0] ComponentImport { name: "f", url: "", ty: Func(1) }
       | 01         
  0x24 | 05 08       | component instance section
  0x26 | 01          | 1 count
diff --git a/tests/cli/dump/instantiate2.wat.stdout b/tests/cli/dump/instantiate2.wat.stdout
index e6ef6544..8d557e3e 100644
--- a/tests/cli/dump/instantiate2.wat.stdout
+++ b/tests/cli/dump/instantiate2.wat.stdout
@@ -1,14 +1,14 @@
-  0x0 | 00 61 73 6d | version 13 (Component)
-      | 0d 00 01 00
+  0x0 | 00 61 73 6d | version 12 (Component)
+      | 0c 00 01 00
   0x8 | 07 0e       | component type section
   0xa | 01          | 1 count
-  0xb | 41 02 01 40 | [type 0] Component([Type(Func(ComponentFuncType { params: [], results: Named([]) })), Import(ComponentImport { name: Kebab("a"), ty: Func(0) })])
+  0xb | 41 02 01 40 | [type 0] Component([Type(Func(ComponentFuncType { params: [], results: Named([]) })), Import(ComponentImport { name: "a", url: "", ty: Func(0) })])
       | 00 01 00 03
-      | 00 01 61 01
+      | 01 61 00 01
       | 00         
  0x18 | 0a 06       | component import section
  0x1a | 01          | 1 count
- 0x1b | 00 01 61 04 | [component 0] ComponentImport { name: Kebab("a"), ty: Component(0) }
+ 0x1b | 01 61 00 04 | [component 0] ComponentImport { name: "a", url: "", ty: Component(0) }
       | 00         
  0x20 | 05 04       | component instance section
  0x22 | 01          | 1 count
diff --git a/tests/cli/dump/module-types.wat.stdout b/tests/cli/dump/module-types.wat.stdout
index 89abe322..014c2b07 100644
--- a/tests/cli/dump/module-types.wat.stdout
+++ b/tests/cli/dump/module-types.wat.stdout
@@ -1,8 +1,8 @@
-  0x0 | 00 61 73 6d | version 13 (Component)
-      | 0d 00 01 00
+  0x0 | 00 61 73 6d | version 12 (Component)
+      | 0c 00 01 00
   0x8 | 03 23       | core type section
   0xa | 01          | 1 count
-  0xb | 50 05 01 60 | [core type 0] Module([Type(SubType { is_final: false, supertype_idx: None, structural_type: Func(FuncType { params: [], returns: [] }) }), Import(Import { module: "", name: "f", ty: Func(0) }), Import(Import { module: "", name: "g", ty: Global(GlobalType { content_type: I32, mutable: false }) }), Import(Import { module: "", name: "t", ty: Table(TableType { element_type: funcref, initial: 1, maximum: None }) }), Import(Import { module: "", name: "m", ty: Memory(MemoryType { memory64: false, shared: false, initial: 1, maximum: None }) })])
+  0xb | 50 05 01 60 | [core type 0] Module([Type(Func(FuncType { params: [], returns: [] })), Import(Import { module: "", name: "f", ty: Func(0) }), Import(Import { module: "", name: "g", ty: Global(GlobalType { content_type: I32, mutable: false }) }), Import(Import { module: "", name: "t", ty: Table(TableType { element_type: RefType { nullable: true, heap_type: Func }, initial: 1, maximum: None }) }), Import(Import { module: "", name: "m", ty: Memory(MemoryType { memory64: false, shared: false, initial: 1, maximum: None }) })])
       | 00 00 00 00
       | 01 66 00 00
       | 00 00 01 67
@@ -13,7 +13,7 @@
       | 00 01      
  0x2d | 0a 07       | component import section
  0x2f | 01          | 1 count
- 0x30 | 00 01 61 00 | [module 0] ComponentImport { name: Kebab("a"), ty: Module(0) }
+ 0x30 | 01 61 00 00 | [module 0] ComponentImport { name: "a", url: "", ty: Module(0) }
       | 11 00      
  0x36 | 07 03       | component type section
  0x38 | 01          | 1 count
diff --git a/tests/cli/dump/names.wat.stdout b/tests/cli/dump/names.wat.stdout
index 830dca9d..9982eebc 100644
--- a/tests/cli/dump/names.wat.stdout
+++ b/tests/cli/dump/names.wat.stdout
@@ -2,7 +2,7 @@
       | 01 00 00 00
   0x8 | 01 05       | type section
   0xa | 01          | 1 count
-  0xb | 60 01 7f 00 | [type 0] SubType { is_final: false, supertype_idx: None, structural_type: Func(FuncType { params: [I32], returns: [] }) }
+  0xb | 60 01 7f 00 | [type 0] Func(FuncType { params: [I32], returns: [] })
   0xf | 03 02       | func section
  0x11 | 01          | 1 count
  0x12 | 00          | [func 0] type 0
diff --git a/tests/cli/dump/nested-component.wat.stdout b/tests/cli/dump/nested-component.wat.stdout
index 2607c058..1a944d64 100644
--- a/tests/cli/dump/nested-component.wat.stdout
+++ b/tests/cli/dump/nested-component.wat.stdout
@@ -1,30 +1,30 @@
-  0x0 | 00 61 73 6d | version 13 (Component)
-      | 0d 00 01 00
+  0x0 | 00 61 73 6d | version 12 (Component)
+      | 0c 00 01 00
   0x8 | 07 03       | component type section
   0xa | 01          | 1 count
   0xb | 41 00       | [type 0] Component([])
   0xd | 0a 06       | component import section
   0xf | 01          | 1 count
- 0x10 | 00 01 61 04 | [component 0] ComponentImport { name: Kebab("a"), ty: Component(0) }
+ 0x10 | 01 61 00 04 | [component 0] ComponentImport { name: "a", url: "", ty: Component(0) }
       | 00         
  0x15 | 04 08       | [component 1] inline size
-   0x17 | 00 61 73 6d | version 13 (Component)
-        | 0d 00 01 00
+   0x17 | 00 61 73 6d | version 12 (Component)
+        | 0c 00 01 00
  0x1f | 04 08       | [component 2] inline size
-   0x21 | 00 61 73 6d | version 13 (Component)
-        | 0d 00 01 00
+   0x21 | 00 61 73 6d | version 12 (Component)
+        | 0c 00 01 00
  0x29 | 04 08       | [component 3] inline size
-   0x2b | 00 61 73 6d | version 13 (Component)
-        | 0d 00 01 00
+   0x2b | 00 61 73 6d | version 12 (Component)
+        | 0c 00 01 00
  0x33 | 04 12       | [component 4] inline size
-   0x35 | 00 61 73 6d | version 13 (Component)
-        | 0d 00 01 00
+   0x35 | 00 61 73 6d | version 12 (Component)
+        | 0c 00 01 00
    0x3d | 04 08       | [component 0] inline size
-     0x3f | 00 61 73 6d | version 13 (Component)
-          | 0d 00 01 00
+     0x3f | 00 61 73 6d | version 12 (Component)
+          | 0c 00 01 00
  0x47 | 04 73       | [component 5] inline size
-   0x49 | 00 61 73 6d | version 13 (Component)
-        | 0d 00 01 00
+   0x49 | 00 61 73 6d | version 12 (Component)
+        | 0c 00 01 00
    0x51 | 01 13       | [core module 0] inline size
      0x53 | 00 61 73 6d | version 1 (Module)
           | 01 00 00 00
@@ -39,25 +39,25 @@
         | 73 01 00   
    0x70 | 0a 06       | component import section
    0x72 | 01          | 1 count
-   0x73 | 00 01 61 01 | [func 0] ComponentImport { name: Kebab("a"), ty: Func(0) }
+   0x73 | 01 61 00 01 | [func 0] ComponentImport { name: "a", url: "", ty: Func(0) }
         | 00         
    0x78 | 0b 08       | component export section
    0x7a | 01          | 1 count
-   0x7b | 00 01 61 00 | export ComponentExport { name: Kebab("a"), kind: Module, index: 0, ty: None }
+   0x7b | 01 61 00 00 | export ComponentExport { name: "a", url: "", kind: Module, index: 0, ty: None }
         | 11 00 00   
    0x82 | 07 0e       | component type section
    0x84 | 01          | 1 count
-   0x85 | 42 02 01 40 | [type 1] Instance([Type(Func(ComponentFuncType { params: [], results: Named([]) })), Export { name: Kebab("a"), ty: Func(0) }])
+   0x85 | 42 02 01 40 | [type 1] Instance([Type(Func(ComponentFuncType { params: [], results: Named([]) })), Export { name: "a", url: "", ty: Func(0) }])
         | 00 01 00 04
-        | 00 01 61 01
+        | 01 61 00 01
         | 00         
    0x92 | 0a 06       | component import section
    0x94 | 01          | 1 count
-   0x95 | 00 01 62 05 | [instance 0] ComponentImport { name: Kebab("b"), ty: Instance(1) }
+   0x95 | 01 62 00 05 | [instance 0] ComponentImport { name: "b", url: "", ty: Instance(1) }
         | 01         
    0x9a | 0b 07       | component export section
    0x9c | 01          | 1 count
-   0x9d | 00 01 62 05 | export ComponentExport { name: Kebab("b"), kind: Instance, index: 0, ty: None }
+   0x9d | 01 62 00 05 | export ComponentExport { name: "b", url: "", kind: Instance, index: 0, ty: None }
         | 00 00      
    0xa3 | 00 17       | custom section
    0xa5 | 0e 63 6f 6d | name: "component-name"
@@ -69,5 +69,5 @@
    0xb9 | 00 01 6d    | Naming { index: 0, name: "m" }
  0xbc | 0b 07       | component export section
  0xbe | 01          | 1 count
- 0xbf | 00 01 61 04 | export ComponentExport { name: Kebab("a"), kind: Component, index: 3, ty: None }
+ 0xbf | 01 61 00 04 | export ComponentExport { name: "a", url: "", kind: Component, index: 3, ty: None }
       | 03 00      
diff --git a/tests/cli/dump/select.wat.stdout b/tests/cli/dump/select.wat.stdout
index fd63bd00..7b650d26 100644
--- a/tests/cli/dump/select.wat.stdout
+++ b/tests/cli/dump/select.wat.stdout
@@ -2,7 +2,7 @@
       | 01 00 00 00
   0x8 | 01 04       | type section
   0xa | 01          | 1 count
-  0xb | 60 00 00    | [type 0] SubType { is_final: false, supertype_idx: None, structural_type: Func(FuncType { params: [], returns: [] }) }
+  0xb | 60 00 00    | [type 0] Func(FuncType { params: [], returns: [] })
   0xe | 03 02       | func section
  0x10 | 01          | 1 count
  0x11 | 00          | [func 0] type 0
diff --git a/tests/cli/dump/simple.wat.stdout b/tests/cli/dump/simple.wat.stdout
index 61ea2222..bbed1143 100644
--- a/tests/cli/dump/simple.wat.stdout
+++ b/tests/cli/dump/simple.wat.stdout
@@ -2,8 +2,8 @@
       | 01 00 00 00
   0x8 | 01 08       | type section
   0xa | 02          | 2 count
-  0xb | 60 01 7f 00 | [type 0] SubType { is_final: false, supertype_idx: None, structural_type: Func(FuncType { params: [I32], returns: [] }) }
-  0xf | 60 00 00    | [type 1] SubType { is_final: false, supertype_idx: None, structural_type: Func(FuncType { params: [], returns: [] }) }
+  0xb | 60 01 7f 00 | [type 0] Func(FuncType { params: [I32], returns: [] })
+  0xf | 60 00 00    | [type 1] Func(FuncType { params: [], returns: [] })
  0x12 | 02 07       | import section
  0x14 | 01          | 1 count
  0x15 | 01 6d 01 6e | import [func 0] Import { module: "m", name: "n", ty: Func(0) }
@@ -15,7 +15,7 @@
  0x20 | 01          | [func 3] type 1
  0x21 | 04 04       | table section
  0x23 | 01          | 1 count
- 0x24 | 70 00 01    | [table 0] Table { ty: TableType { element_type: funcref, initial: 1, maximum: None }, init: RefNull }
+ 0x24 | 70 00 01    | [table 0] Table { ty: TableType { element_type: RefType { nullable: true, heap_type: Func }, initial: 1, maximum: None }, init: RefNull }
  0x27 | 05 03       | memory section
  0x29 | 01          | 1 count
  0x2a | 00 01       | [memory 0] MemoryType { memory64: false, shared: false, initial: 1, maximum: None }
@@ -31,14 +31,14 @@
  0x3d | 00          | start function 0
  0x3e | 09 0f       | element section
  0x40 | 03          | 3 count
- 0x41 | 00          | element funcref table[None]
+ 0x41 | 00          | element RefType { nullable: true, heap_type: Func } table[0]
  0x42 | 41 03       | i32_const value:3
  0x44 | 0b          | end
  0x45 | 01          | 1 items
  0x46 | 00          | item 0
- 0x47 | 01 00 01    | element funcref passive, 1 items
+ 0x47 | 01 00 01    | element RefType { nullable: true, heap_type: Func } passive, 1 items
  0x4a | 00          | item 0
- 0x4b | 03 00 01    | element funcref declared 1 items
+ 0x4b | 03 00 01    | element RefType { nullable: true, heap_type: Func } declared 1 items
  0x4e | 00          | item 0
  0x4f | 0a 10       | code section
  0x51 | 03          | 3 count
diff --git a/tests/cli/dump/try-delegate.wat.stdout b/tests/cli/dump/try-delegate.wat.stdout
index ad1e93f6..ed6d3cd4 100644
--- a/tests/cli/dump/try-delegate.wat.stdout
+++ b/tests/cli/dump/try-delegate.wat.stdout
@@ -2,7 +2,7 @@
       | 01 00 00 00
   0x8 | 01 04       | type section
   0xa | 01          | 1 count
-  0xb | 60 00 00    | [type 0] SubType { is_final: false, supertype_idx: None, structural_type: Func(FuncType { params: [], returns: [] }) }
+  0xb | 60 00 00    | [type 0] Func(FuncType { params: [], returns: [] })
   0xe | 03 02       | func section
  0x10 | 01          | 1 count
  0x11 | 00          | [func 0] type 0
diff --git a/tests/cli/print-core-wasm-wit.wit b/tests/cli/print-core-wasm-wit.wit
deleted file mode 100644
index bad24b4b..00000000
--- a/tests/cli/print-core-wasm-wit.wit
+++ /dev/null
@@ -1,11 +0,0 @@
-// RUN: component embed --dummy % | component wit
-
-package foo:foo
-
-interface my-interface {
-  foo: func()
-}
-
-world my-world {
-  import my-interface
-}
diff --git a/tests/cli/print-core-wasm-wit.wit.stdout b/tests/cli/print-core-wasm-wit.wit.stdout
deleted file mode 100644
index e5a97071..00000000
--- a/tests/cli/print-core-wasm-wit.wit.stdout
+++ /dev/null
@@ -1,5 +0,0 @@
-package root:root
-
-world root {
-  import foo:foo/my-interface
-}
diff --git a/tests/cli/print-skeleton.wat b/tests/cli/print-skeleton.wat
deleted file mode 100644
index 809615cf..00000000
--- a/tests/cli/print-skeleton.wat
+++ /dev/null
@@ -1,9 +0,0 @@
-;; RUN: print --skeleton %
-
-(module
-  (memory 0)
-  (func $f unreachable)
-  (data (i32.const 0) "1234")
-  (table 1 funcref)
-  (elem (i32.const 0) func $f)
-)
diff --git a/tests/cli/print-skeleton.wat.stdout b/tests/cli/print-skeleton.wat.stdout
deleted file mode 100644
index 2f1da14a..00000000
--- a/tests/cli/print-skeleton.wat.stdout
+++ /dev/null
@@ -1,8 +0,0 @@
-(module
-  (type (;0;) (func))
-  (func $f (;0;) (type 0) ...)
-  (table (;0;) 1 funcref)
-  (memory (;0;) 0)
-  (elem (;0;) (i32.const 0) ...)
-  (data (;0;) (i32.const 0) ...)
-)
\ No newline at end of file
diff --git a/tests/local/component-model/export-ascription.wast b/tests/local/component-model/export-ascription.wast
index f44d9d24..b6e566a9 100644
--- a/tests/local/component-model/export-ascription.wast
+++ b/tests/local/component-model/export-ascription.wast
@@ -35,4 +35,4 @@
 
     (instance (instantiate $consume (with "arg" (instance $c "f2"))))
   )
-  "missing expected export `f`")
+  "type mismatch for component instantiation argument `arg`")
diff --git a/tests/local/component-model/export.wast b/tests/local/component-model/export.wast
index e9d6146b..9e9d5056 100644
--- a/tests/local/component-model/export.wast
+++ b/tests/local/component-model/export.wast
@@ -43,11 +43,25 @@
 
 (component
   (import "a" (func))
-  (export (interface "wasi:http/types@2.0.0") (func 0))
+  (export "b" "https://example.com" (func 0))
 )
 
-;; import/exports can overlap on ids
+;; Empty URLs are treated as no URL
 (component
-  (import (interface "wasi:http/types@2.0.0") (func))
-  (export (interface "wasi:http/types@2.0.0") (func 0))
+  (import "a" (func))
+  (export "b" "" (func 0))
 )
+
+(assert_invalid
+  (component
+    (import "a" (func))
+    (export "b" "foo" (func 0))
+  )
+  "relative URL without a base")
+
+(assert_invalid
+  (component
+    (import "a" "https://example.com" (func))
+    (import "b" "https://example.com" (func))
+  )
+  "duplicate import URL `https://example.com/`")
diff --git a/tests/local/component-model/import.wast b/tests/local/component-model/import.wast
index f5509298..069d4bcb 100644
--- a/tests/local/component-model/import.wast
+++ b/tests/local/component-model/import.wast
@@ -72,7 +72,7 @@
     "(import \"a\" (func))"
     "(import \"a\" (func))"
   )
-  "import name `a` conflicts with previous name `a`")
+  "import name `a` conflicts with previous import name `a`")
 
 (assert_malformed
   (component quote
@@ -81,7 +81,7 @@
       "(import \"a\" (func))"
     "))"
   )
-  "import name `a` conflicts with previous name `a`")
+  "import name `a` conflicts with previous import name `a`")
 
 (assert_invalid
   (component
@@ -109,80 +109,30 @@
 )
 
 (component
-  (import (interface "wasi:http/types") (func))
-  (import (interface "wasi:http/types@1.0.0") (func))
-  (import (interface "wasi:http/types@2.0.0") (func))
-  (import (interface "a-b:c-d/e-f@123456.7890.488") (func))
-  (import (interface "a:b/c@1.2.3") (func))
-  (import (interface "a:b/c@0.0.0") (func))
-  (import (interface "a:b/c@0.0.0+abcd") (func))
-  (import (interface "a:b/c@0.0.0+abcd-efg") (func))
-  (import (interface "a:b/c@0.0.0-abcd+efg") (func))
-  (import (interface "a:b/c@0.0.0-abcd.1.2+efg.4.ee.5") (func))
+  (import "a" "https://example.com" (func))
+)
+
+;; Empty URLs are treated as no URL
+(component
+  (import "a" "" (func))
 )
 
 (assert_invalid
   (component
-    (import (interface "wasi:http/types") (func))
-    (import (interface "wasi:http/types") (func))
+    (import "a" "foo" (func))
   )
-  "conflicts with previous name")
+  "relative URL without a base")
 
 (assert_invalid
-  (component (import (interface "") (func)))
-  "failed to find `:` character")
-(assert_invalid
-  (component (import (interface "wasi") (func)))
-  "failed to find `:` character")
-(assert_invalid
-  (component (import (interface "wasi:") (func)))
-  "failed to find `/` character")
-(assert_invalid
-  (component (import (interface "wasi:/") (func)))
-  "not in kebab case")
-(assert_invalid
-  (component (import (interface ":/") (func)))
-  "not in kebab case")
-(assert_invalid
-  (component (import (interface "wasi/http") (func)))
-  "failed to find `:` character")
-(assert_invalid
-  (component (import (interface "wasi:http/TyPeS") (func)))
-  "`TyPeS` is not in kebab case")
-(assert_invalid
-  (component (import (interface "WaSi:http/types") (func)))
-  "`WaSi` is not in kebab case")
-(assert_invalid
-  (component (import (interface "wasi:HtTp/types") (func)))
-  "`HtTp` is not in kebab case")
-(assert_invalid
-  (component (import (interface "wasi:http/types@") (func)))
-  "empty string")
-(assert_invalid
-  (component (import (interface "wasi:http/types@.") (func)))
-  "unexpected character '.'")
-(assert_invalid
-  (component (import (interface "wasi:http/types@1.") (func)))
-  "unexpected end of input")
-(assert_invalid
-  (component (import (interface "wasi:http/types@a.2") (func)))
-  "unexpected character 'a'")
-(assert_invalid
-  (component (import (interface "wasi:http/types@2.b") (func)))
-  "unexpected character 'b'")
-(assert_invalid
-  (component (import (interface "wasi:http/types@2.0x0") (func)))
-  "unexpected character 'x'")
-(assert_invalid
-  (component (import (interface "wasi:http/types@2.0.0+") (func)))
-  "empty identifier segment")
-(assert_invalid
-  (component (import (interface "wasi:http/types@2.0.0-") (func)))
-  "empty identifier segment")
+  (component
+    (import "a" "https://example.com" (func))
+    (import "b" "https://example.com" (func))
+  )
+  "duplicate import URL `https://example.com/`")
 
 (assert_invalid
   (component
     (import "a" (func $a))
     (export "a" (func $a))
   )
-  "export name `a` conflicts with previous name `a`")
+  "export name `a` conflicts with previous import name `a`")
diff --git a/tests/local/component-model/inline-exports.wast b/tests/local/component-model/inline-exports.wast
index 649c30c9..3cefeb79 100644
--- a/tests/local/component-model/inline-exports.wast
+++ b/tests/local/component-model/inline-exports.wast
@@ -1,7 +1,3 @@
 (component
   (type (export "foo") u8)
 )
-
-(assert_malformed
-  (component quote "(type (component (type (export \"\") (func))))")
-  "unexpected token")
diff --git a/tests/local/component-model/instance-type.wast b/tests/local/component-model/instance-type.wast
index 4446e5ee..86fc310e 100644
--- a/tests/local/component-model/instance-type.wast
+++ b/tests/local/component-model/instance-type.wast
@@ -180,7 +180,7 @@
     (type (instance
       (export "a" (func))
       (export "a" (func)))))
-  "export name `a` conflicts with previous name `a`")
+  "export name `a` conflicts with previous export name `a`")
 
 (assert_invalid
   (component
diff --git a/tests/local/component-model/instantiate.wast b/tests/local/component-model/instantiate.wast
index 562cda77..228dd11d 100644
--- a/tests/local/component-model/instantiate.wast
+++ b/tests/local/component-model/instantiate.wast
@@ -165,7 +165,7 @@
     (import "a" (component $m (import "a" (func))))
     (instance (instantiate $m))
   )
-  "missing import named `a`")
+  "missing component instantiation argument")
 
 (assert_invalid
   (component
@@ -175,7 +175,7 @@
     (import "b" (component $c))
     (instance $i (instantiate $m (with "a" (component $c))))
   )
-  "expected func, found component")
+  "to be a function")
 
 (assert_invalid
   (component
@@ -185,7 +185,7 @@
     (import "b" (func $f (result string)))
     (instance $i (instantiate $m (with "a" (func $f))))
   )
-  "expected 0 results, found 1")
+  "type mismatch for component instantiation argument `a`")
 
 (assert_invalid
   (component
@@ -195,7 +195,7 @@
     (import "b" (func (param "i" string)))
     (instance $i (instantiate $m (with "a" (func 0))))
   )
-  "expected 0 parameters, found 1")
+  "type mismatch for component instantiation argument `a`")
 
 (assert_invalid
   (component
@@ -209,7 +209,7 @@
     ))
     (instance $i (instantiate $m (with "a" (core module $i))))
   )
-  "type mismatch in import `::`")
+  "type mismatch for component instantiation argument `a`")
 
 (assert_invalid
   (component
@@ -221,16 +221,7 @@
     ))
     (instance $i (instantiate $m (with "a" (core module $i))))
   )
-  "missing expected import `::foobar`")
-(assert_invalid
-  (component
-    (import "a" (component $m
-      (import "a" (core module (export "x" (func))))
-    ))
-    (import "b" (core module $i))
-    (instance $i (instantiate $m (with "a" (core module $i))))
-  )
-  "missing expected export `x`")
+  "type mismatch for component instantiation argument `a`")
 
 ;; it's ok to give a module with fewer imports
 (component
@@ -283,7 +274,7 @@
     (core instance $i (instantiate $m2))
     (core instance (instantiate $m1 (with "" (instance $i))))
   )
-  "expected: [] -> []")
+  "function type mismatch")
 (assert_invalid
   (component
     (import "m1" (core module $m1 (import "" "" (func))))
@@ -291,7 +282,7 @@
     (core instance $i (instantiate $m2))
     (core instance (instantiate $m1 (with "" (instance $i))))
   )
-  "expected: [] -> []")
+  "function type mismatch")
 (assert_invalid
   (component
     (import "m1" (core module $m1 (import "" "" (global i32))))
@@ -299,7 +290,7 @@
     (core instance $i (instantiate $m2))
     (core instance (instantiate $m1 (with "" (instance $i))))
   )
-  "expected global type i32, found i64")
+  "global type mismatch")
 (assert_invalid
   (component
     (import "m1" (core module $m1 (import "" "" (table 1 funcref))))
@@ -307,7 +298,7 @@
     (core instance $i (instantiate $m2))
     (core instance (instantiate $m1 (with "" (instance $i))))
   )
-  "expected table element type funcref, found externref")
+  "table type mismatch")
 (assert_invalid
   (component
     (import "m1" (core module $m1 (import "" "" (table 1 2 funcref))))
@@ -315,7 +306,7 @@
     (core instance $i (instantiate $m2))
     (core instance (instantiate $m1 (with "" (instance $i))))
   )
-  "mismatch in table limits")
+  "table type mismatch")
 (assert_invalid
   (component
     (import "m1" (core module $m1 (import "" "" (table 2 2 funcref))))
@@ -323,7 +314,7 @@
     (core instance $i (instantiate $m2))
     (core instance (instantiate $m1 (with "" (instance $i))))
   )
-  "mismatch in table limits")
+  "table type mismatch")
 (assert_invalid
   (component
     (import "m1" (core module $m1 (import "" "" (table 2 2 funcref))))
@@ -331,7 +322,7 @@
     (core instance $i (instantiate $m2))
     (core instance (instantiate $m1 (with "" (instance $i))))
   )
-  "mismatch in table limits")
+  "table type mismatch")
 (assert_invalid
   (component
     (import "m1" (core module $m1 (import "" "" (memory 1 2 shared))))
@@ -339,7 +330,7 @@
     (core instance $i (instantiate $m2))
     (core instance (instantiate $m1 (with "" (instance $i))))
   )
-  "mismatch in the shared flag for memories")
+  "memory type mismatch")
 (assert_invalid
   (component
     (import "m1" (core module $m1 (import "" "" (memory 1))))
@@ -347,16 +338,7 @@
     (core instance $i (instantiate $m2))
     (core instance (instantiate $m1 (with "" (instance $i))))
   )
-  "mismatch in memory limits")
-(assert_invalid
-  (component
-    (import "m1" (core module $m1 (export "g" (func))))
-    (component $c
-      (import "m" (core module (export "g" (global i32))))
-    )
-    (instance (instantiate $c (with "m" (core module $m1))))
-  )
-  "type mismatch in export `g`")
+  "memory type mismatch")
 
 (assert_invalid
   (component
@@ -454,7 +436,7 @@
       (with "" (instance $i))
     ))
   )
-  "expected global, found func")
+  "module instantiation argument `` exports an item named `` but it is not a global")
 
 (assert_invalid
   (component
@@ -474,7 +456,7 @@
       (with "a" (component $c))
     ))
   )
-  "expected func, found component")
+  "expected component instantiation argument `a` to be a function")
 
 (assert_invalid
   (component
@@ -529,7 +511,7 @@
       (export "a" (component $c))
     )
   )
-  "instance export name `a` conflicts with previous name `a`")
+  "instance export name `a` conflicts with previous export name `a`")
 
 (component
   (import "a" (instance $i))
@@ -635,359 +617,15 @@
 
 (assert_invalid
   (component
-    (type $t (tuple string string))
-    (import "a" (type $a (eq $t)))
-    (component $c
-      (type $t (tuple u32 u32))
-      (import "a" (type (eq $t)))
+    (type (tuple string string))
+    (import "a" (type (eq 0)))
+    (component
+      (type (tuple u32 u32))
+      (import "a" (type (eq 0)))
     )
-    (instance (instantiate $c
-        (with "a" (type $a))
+    (instance (instantiate 0
+        (with "a" (type 1))
       )
     )
   )
-  "expected primitive `u32` found primitive `string`")
-
-
-;; subtyping for module imports reverses order of imports/exports for the
-;; subtyping check
-;;
-;; Here `C` imports a module, and the module itself imports a table of min size
-;; 1. A module import which imports a min-size table of 0, however, is valid to
-;; supply for this since it'll already be given at least 1 anyway.
-;;
-;; Similarly for exports `C` imports a module that exports a table of at least
-;; size 1. If it's given a module that exports a larger table that's ok too.
-(component
-  (core module $a
-    (import "" "" (table 0 funcref))
-    (table (export "x") 2 funcref)
-  )
-  (component $C
-    (import "a" (core module
-      (import "" "" (table 1 funcref))
-      (export "x" (table 1 funcref))
-    ))
-  )
-  (instance (instantiate $C (with "a" (core module $a))))
-)
-
-;; same as above but for memories
-(component
-  (core module $a1 (import "" "" (memory 0)))
-  (core module $a2 (memory (export "x") 2))
-  (component $C
-    (import "a1" (core module (import "" "" (memory 1))))
-    (import "a2" (core module (export "x" (memory 1))))
-  )
-  (instance (instantiate $C
-    (with "a1" (core module $a1))
-    (with "a2" (core module $a2))
-  ))
-)
-
-(assert_invalid
-  (component
-    (import "x" (func $x (param "x" u32)))
-    (import "y" (component $c
-      (import "x" (func (param "y" u32)))
-    ))
-
-    (instance (instantiate $c (with "x" (func $x))))
-  )
-  "expected parameter named `y`, found `x`")
-(assert_invalid
-  (component
-    (import "x" (func $x (param "x" u32)))
-    (import "y" (component $c
-      (import "x" (func (param "x" s32)))
-    ))
-
-    (instance (instantiate $c (with "x" (func $x))))
-  )
-  "type mismatch in function parameter `x`")
-(assert_invalid
-  (component
-    (import "x" (func $x (result "x" u32)))
-    (import "y" (component $c
-      (import "x" (func (result "y" u32)))
-    ))
-
-    (instance (instantiate $c (with "x" (func $x))))
-  )
-  "mismatched result names")
-(assert_invalid
-  (component
-    (import "x" (func $x (result "x" u32)))
-    (import "y" (component $c
-      (import "x" (func (result "x" s32)))
-    ))
-
-    (instance (instantiate $c (with "x" (func $x))))
-  )
-  "type mismatch with result type")
-
-(assert_invalid
-  (component
-    (import "x" (instance $x (export "a" (func))))
-    (import "y" (component $c
-      (import "x" (instance $x (export "a" (component))))
-    ))
-
-    (instance (instantiate $c (with "x" (instance $x))))
-  )
-  "type mismatch in instance export `a`")
-
-(assert_invalid
-  (component
-    (import "y" (component $c
-      (type $t u32)
-      (import "x" (type (eq $t)))
-    ))
-
-    (type $x (record))
-    (instance (instantiate $c (with "x" (type $x))))
-  )
-  "expected primitive, found record")
-
-(assert_invalid
-  (component
-    (import "y" (component $c
-      (type $t (record))
-      (import "x" (type (eq $t)))
-    ))
-
-    (type $x u32)
-    (instance (instantiate $c (with "x" (type $x))))
-  )
-  "expected record, found u32")
-
-(assert_invalid
-  (component
-    (import "y" (component $c
-      (type $t (record (field "x" u32)))
-      (import "x" (type (eq $t)))
-    ))
-
-    (type $f (record))
-    (type $x (record (field "x" $f)))
-    (instance (instantiate $c (with "x" (type $x))))
-  )
-  "expected u32, found record")
-
-(assert_invalid
-  (component
-    (import "y" (component $c
-      (type $f (option s32))
-      (type $t (record (field "x" $f)))
-      (import "x" (type (eq $t)))
-    ))
-
-    (type $x (record (field "x" u32)))
-    (instance (instantiate $c (with "x" (type $x))))
-  )
-  "type mismatch in record field `x`")
-
-(assert_invalid
-  (component
-    (import "y" (component $c
-      (type $t (record (field "x" u32)))
-      (import "x" (type (eq $t)))
-    ))
-
-    (type $x (record))
-    (instance (instantiate $c (with "x" (type $x))))
-  )
-  "expected 1 fields, found 0")
-
-(assert_invalid
-  (component
-    (import "y" (component $c
-      (type $t (record (field "a" u32)))
-      (import "x" (type (eq $t)))
-    ))
-
-    (type $x (record (field "b" u32)))
-    (instance (instantiate $c (with "x" (type $x))))
-  )
-  "expected field name `a`, found `b`")
-
-(assert_invalid
-  (component
-    (import "y" (component $c
-      (type $t (variant (case "x" u32)))
-      (import "x" (type (eq $t)))
-    ))
-
-    (type $x (variant (case "x" u32) (case "y" u32)))
-    (instance (instantiate $c (with "x" (type $x))))
-  )
-  "expected 1 cases, found 2")
-
-(assert_invalid
-  (component
-    (import "y" (component $c
-      (type $t (variant (case "x" u32)))
-      (import "x" (type (eq $t)))
-    ))
-
-    (type $x (variant (case "y" u32)))
-    (instance (instantiate $c (with "x" (type $x))))
-  )
-  "expected case named `x`, found `y`")
-
-(assert_invalid
-  (component
-    (import "y" (component $c
-      (type $t (variant (case "x" u32)))
-      (import "x" (type (eq $t)))
-    ))
-
-    (type $x (variant (case "x")))
-    (instance (instantiate $c (with "x" (type $x))))
-  )
-  "expected case `x` to have a type, found none")
-
-(assert_invalid
-  (component
-    (import "y" (component $c
-      (type $t (variant (case "x")))
-      (import "x" (type (eq $t)))
-    ))
-
-    (type $x (variant (case "x" u32)))
-    (instance (instantiate $c (with "x" (type $x))))
-  )
-  "expected case `x` to have no type")
-
-(assert_invalid
-  (component
-    (import "y" (component $c
-      (type $t (variant (case "x" u32)))
-      (import "x" (type (eq $t)))
-    ))
-
-    (type $x (variant (case "x" s32)))
-    (instance (instantiate $c (with "x" (type $x))))
-  )
-  "type mismatch in variant case `x`")
-
-(assert_invalid
-  (component
-    (import "y" (component $c
-      (type $t (tuple u8))
-      (import "x" (type (eq $t)))
-    ))
-
-    (type $x (tuple))
-    (instance (instantiate $c (with "x" (type $x))))
-  )
-  "expected 1 types, found 0")
-
-(assert_invalid
-  (component
-    (import "y" (component $c
-      (type $t (tuple u8))
-      (import "x" (type (eq $t)))
-    ))
-
-    (type $x (tuple u16))
-    (instance (instantiate $c (with "x" (type $x))))
-  )
-  "type mismatch in tuple field 0")
-
-(assert_invalid
-  (component
-    (import "y" (component $c
-      (type $t (flags))
-      (import "x" (type (eq $t)))
-    ))
-
-    (type $x (flags "x"))
-    (instance (instantiate $c (with "x" (type $x))))
-  )
-  "mismatch in flags elements")
-
-(assert_invalid
-  (component
-    (import "y" (component $c
-      (type $t (enum))
-      (import "x" (type (eq $t)))
-    ))
-
-    (type $x (enum "x"))
-    (instance (instantiate $c (with "x" (type $x))))
-  )
-  "mismatch in enum elements")
-
-(assert_invalid
-  (component
-    (import "y" (component $c
-      (type $t (result s32))
-      (import "x" (type (eq $t)))
-    ))
-
-    (type $x (result u32))
-    (instance (instantiate $c (with "x" (type $x))))
-  )
-  "type mismatch in ok variant")
-
-(assert_invalid
-  (component
-    (import "y" (component $c
-      (type $t (result (error s32)))
-      (import "x" (type (eq $t)))
-    ))
-
-    (type $x (result (error u32)))
-    (instance (instantiate $c (with "x" (type $x))))
-  )
-  "type mismatch in err variant")
-
-(assert_invalid
-  (component
-    (import "y" (component $c
-      (type $t (result))
-      (import "x" (type (eq $t)))
-    ))
-
-    (type $x (result u32))
-    (instance (instantiate $c (with "x" (type $x))))
-  )
-  "expected ok type to not be present")
-
-(assert_invalid
-  (component
-    (import "y" (component $c
-      (type $t (result u32))
-      (import "x" (type (eq $t)))
-    ))
-
-    (type $x (result))
-    (instance (instantiate $c (with "x" (type $x))))
-  )
-  "expected ok type, but found none")
-
-(assert_invalid
-  (component
-    (import "y" (component $c
-      (type $t (result))
-      (import "x" (type (eq $t)))
-    ))
-
-    (type $x (result (error u32)))
-    (instance (instantiate $c (with "x" (type $x))))
-  )
-  "expected err type to not be present")
-
-(assert_invalid
-  (component
-    (import "y" (component $c
-      (type $t (result (error u32)))
-      (import "x" (type (eq $t)))
-    ))
-
-    (type $x (result))
-    (instance (instantiate $c (with "x" (type $x))))
-  )
-  "expected err type, but found none")
+  "type mismatch for component instantiation argument `a`")
diff --git a/tests/local/component-model/memory64.wast b/tests/local/component-model/memory64.wast
index 612e4b72..6edc0da6 100644
--- a/tests/local/component-model/memory64.wast
+++ b/tests/local/component-model/memory64.wast
@@ -7,7 +7,7 @@
     (core instance $b (instantiate $B))
     (core instance $a (instantiate $A (with "" (instance $b))))
   )
-  "mismatch in index type used for memories")
+  "memory type mismatch")
 
 (assert_invalid
   (component
@@ -18,4 +18,4 @@
     (core instance $b (instantiate $B))
     (core instance $a (instantiate $A (with "" (instance $b))))
   )
-  "mismatch in index type used for memories")
+  "memory type mismatch")
diff --git a/tests/local/component-model/naming.wast b/tests/local/component-model/naming.wast
index c3a6c7ea..42228f74 100644
--- a/tests/local/component-model/naming.wast
+++ b/tests/local/component-model/naming.wast
@@ -1,7 +1,10 @@
-(component
-  (func (import "a"))
-  (component)
-  (instance (instantiate 0 (with "NotKebab-Case" (func 0))))
+(assert_invalid
+  (component
+    (func (import "a"))
+    (component)
+    (instance (instantiate 0 (with "NotKebab-Case" (func 0))))
+  )
+  "instantiation argument name `NotKebab-Case` is not in kebab case"
 )
 
 (assert_invalid
@@ -9,7 +12,7 @@
     (import "f" (func))
     (instance (export "1" (func 0)))
   )
-  "`1` is not in kebab case"
+  "instance export name `1` is not in kebab case"
 )
 
 (assert_invalid
@@ -17,7 +20,7 @@
     (instance)
     (alias export 0 "Xml" (func))
   )
-  "instance 0 has no export named `Xml`"
+  "alias export name `Xml` is not in kebab case"
 )
 
 (assert_invalid
@@ -60,40 +63,40 @@
   (component
     (type (func (result "uP" string)))
   )
-  "name `uP` is not in kebab case"
+  "function result name `uP` is not in kebab case"
 )
 
 (assert_invalid
   (component
     (type (component (export "NevEr" (func))))
   )
-  "`NevEr` is not in kebab case"
+  "export name `NevEr` is not in kebab case"
 )
 
 (assert_invalid
   (component
     (type (component (import "GonnA" (func))))
   )
-  "`GonnA` is not in kebab case"
+  "import name `GonnA` is not in kebab case"
 )
 
 (assert_invalid
   (component
     (type (instance (export "lET" (func))))
   )
-  "`lET` is not in kebab case"
+  "export name `lET` is not in kebab case"
 )
 
 (assert_invalid
   (component
     (instance (export "YoU"))
   )
-  "`YoU` is not in kebab case"
+  "export name `YoU` is not in kebab case"
 )
 
 (assert_invalid
   (component
     (instance (import "DOWn"))
   )
-  "`DOWn` is not in kebab case"
+  "import name `DOWn` is not in kebab case"
 )
diff --git a/tests/local/component-model/resources.wast b/tests/local/component-model/resources.wast
deleted file mode 100644
index 7957a87c..00000000
--- a/tests/local/component-model/resources.wast
+++ /dev/null
@@ -1,1127 +0,0 @@
-(component
-  (type $x (resource (rep i32)))
-)
-
-(component
-  (type $x (resource (rep i32)))
-
-  (core func (canon resource.new $x))
-  (core func (canon resource.rep $x))
-  (core func (canon resource.drop $x))
-)
-
-(component
-  (import "x" (type $x (sub resource)))
-
-  (core func (canon resource.drop $x))
-)
-
-(component
-  (core module $m
-    (func (export "dtor") (param i32))
-  )
-  (core instance $m (instantiate $m))
-  (type $x (resource (rep i32) (dtor (func $m "dtor"))))
-  (core func (canon resource.new $x))
-)
-
-(component
-  (type $x (resource (rep i32)))
-  (core func $f1 (canon resource.new $x))
-  (core func $f2 (canon resource.rep $x))
-  (core func $f3 (canon resource.drop $x))
-
-  (core module $m
-    (import "" "f1" (func (param i32) (result i32)))
-    (import "" "f2" (func (param i32) (result i32)))
-    (import "" "f3" (func (param i32)))
-  )
-
-  (core instance (instantiate $m
-    (with "" (instance
-      (export "f1" (func $f1))
-      (export "f2" (func $f2))
-      (export "f3" (func $f3))
-    ))
-  ))
-)
-
-(assert_invalid
-  (component
-    (type $x (resource (rep i64)))
-  )
-  "resources can only be represented by `i32`")
-
-(assert_invalid
-  (component
-    (type $x (own 100))
-  )
-  "type index out of bounds")
-
-(assert_invalid
-  (component
-    (type $x (borrow 100))
-  )
-  "type index out of bounds")
-
-(assert_invalid
-  (component
-    (type $t u8)
-    (type $x (borrow $t))
-  )
-  "not a resource type")
-
-(assert_invalid
-  (component
-    (type $t u8)
-    (type $x (own $t))
-  )
-  "not a resource type")
-
-(assert_invalid
-  (component
-    (import "x" (type $x (sub resource)))
-    (core func (canon resource.new $x))
-  )
-  "not a local resource")
-
-(assert_invalid
-  (component
-    (import "x" (type $x (sub resource)))
-    (core func (canon resource.rep $x))
-  )
-  "not a local resource")
-
-(assert_invalid
-  (component
-    (type $t (record))
-    (core func (canon resource.drop $t))
-  )
-  "not a resource type")
-
-(assert_invalid
-  (component
-    (core func (canon resource.drop 100))
-  )
-  "type index out of bounds")
-
-(assert_invalid
-  (component
-    (type (component))
-    (core func (canon resource.drop 0))
-  )
-  "not a resource type")
-
-(assert_invalid
-  (component
-    (type (component))
-    (core func (canon resource.new 0))
-  )
-  "not a resource type")
-
-(assert_invalid
-  (component
-    (core module $m
-      (func (export "dtor"))
-    )
-    (core instance $m (instantiate $m))
-    (type $x (resource (rep i32) (dtor (func $m "dtor"))))
-    (core func (canon resource.new $x))
-  )
-  "wrong signature for a destructor")
-
-(assert_invalid
-  (component
-    (type (resource (rep i32) (dtor (func 100))))
-  )
-  "function index out of bounds")
-
-(assert_invalid
-  (component
-    (import "x" (type $x (sub resource)))
-    (import "y" (type $y (sub resource)))
-    (import "z" (func $z (param "x" (own $x)) (param "y" (own $y))))
-
-    (component $c
-      (import "x" (type $x (sub resource)))
-      (import "z" (func (param "x" (own $x)) (param "y" (own $x))))
-    )
-
-    (instance (instantiate $c (with "x" (type $x)) (with "z" (func $z))))
-  )
-  "resource types are not the same")
-
-(component
-  (type (component
-    (import "x" (type $x (sub resource)))
-    (export "y" (type (eq $x)))
-    (export "z" (type (sub resource)))
-  ))
-)
-
-(assert_invalid
-  (component
-    (type (component
-      (type $x (resource (rep i32)))
-    ))
-  )
-  "resources can only be defined within a concrete component")
-
-(assert_invalid
-  (component
-    (type (instance
-      (type $x (resource (rep i32)))
-    ))
-  )
-  "resources can only be defined within a concrete component")
-
-(component
-  (type (component
-    (import "x" (instance $i
-      (export $t "t" (type (sub resource)))
-      (export "f" (func (result "x" (own $t))))
-    ))
-    (alias export $i "t" (type $t))
-    (export "f" (func (result "x" (own $t))))
-  ))
-)
-
-(component
-  (import "fancy-fs" (instance $fancy-fs
-    (export $fs "fs" (instance
-      (export "file" (type (sub resource)))
-    ))
-    (alias export $fs "file" (type $file))
-    (export "fancy-op" (func (param "f" (borrow $file))))
-  ))
-)
-
-(component $C
-  (type $T (list (tuple string bool)))
-  (type $U (option $T))
-  (type $G (func (param "x" (list $T)) (result $U)))
-  (type $D (component
-    (alias outer $C $T (type $C_T))
-    (type $L (list $C_T))
-    (import "f" (func (param "x" $L) (result (list u8))))
-    (import "g" (func (type $G)))
-    (export "g2" (func (type $G)))
-    (export "h" (func (result $U)))
-    (import "T" (type $T (sub resource)))
-    (import "i" (func (param "x" (list (own $T)))))
-    (export $T' "T2" (type (eq $T)))
-    (export $U' "U" (type (sub resource)))
-    (export "j" (func (param "x" (borrow $T')) (result (own $U'))))
-  ))
-)
-
-(component
-  (import "T1" (type $T1 (sub resource)))
-  (import "T2" (type $T2 (sub resource)))
-)
-
-(component $C
-  (import "T1" (type $T1 (sub resource)))
-  (import "T2" (type $T2 (sub resource)))
-  (import "T3" (type $T3 (eq $T2)))
-  (type $ListT1 (list (own $T1)))
-  (type $ListT2 (list (own $T2)))
-  (type $ListT3 (list (own $T3)))
-)
-
-(component
-  (import "T" (type $T (sub resource)))
-  (import "U" (type $U (sub resource)))
-  (type $Own1 (own $T))
-  (type $Own2 (own $T))
-  (type $Own3 (own $U))
-  (type $ListOwn1 (list $Own1))
-  (type $ListOwn2 (list $Own2))
-  (type $ListOwn3 (list $Own3))
-  (type $Borrow1 (borrow $T))
-  (type $Borrow2 (borrow $T))
-  (type $Borrow3 (borrow $U))
-  (type $ListBorrow1 (list $Borrow1))
-  (type $ListBorrow2 (list $Borrow2))
-  (type $ListBorrow3 (list $Borrow3))
-)
-
-(component
-  (import "C" (component $C
-    (export "T1" (type (sub resource)))
-    (export $T2 "T2" (type (sub resource)))
-    (export "T3" (type (eq $T2)))
-  ))
-  (instance $c (instantiate $C))
-  (alias export $c "T1" (type $T1))
-  (alias export $c "T2" (type $T2))
-  (alias export $c "T3" (type $T3))
-)
-
-(component
-  (component $C
-    (type $r1 (export "r1") (resource (rep i32)))
-    (type $r2 (export "r2") (resource (rep i32)))
-  )
-  (instance $c1 (instantiate $C))
-  (instance $c2 (instantiate $C))
-  (alias export $c1 "r1" (type $c1r1))
-  (alias export $c1 "r2" (type $c1r2))
-  (alias export $c2 "r1" (type $c2r1))
-  (alias export $c2 "r2" (type $c2r2))
-)
-
-(component
-  (type $r (resource (rep i32)))
-  (export "r1" (type $r))
-  (export "r2" (type $r))
-)
-
-(component
-  (type (component
-    (export "r1" (type (sub resource)))
-    (export "r2" (type (sub resource)))
-  ))
-)
-
-(component
-  (type $r (resource (rep i32)))
-  (export $r1 "r1" (type $r))
-  (export "r2" (type $r1))
-)
-
-(component
-  (type (component
-    (export $r1 "r1" (type (sub resource)))
-    (export "r2" (type (eq $r1)))
-  ))
-)
-
-(component $P
-  (import "C1" (component $C1
-    (import "T" (type $T (sub resource)))
-    (export "foo" (func (param "t" (own $T))))
-  ))
-  (import "C2" (component $C2
-    (import "T" (type $T (sub resource)))
-    (import "foo" (func (param "t" (own $T))))
-  ))
-  (type $R (resource (rep i32)))
-  (instance $c1 (instantiate $C1 (with "T" (type $R))))
-  (instance $c2 (instantiate $C2
-    (with "T" (type $R))
-    (with "foo" (func $c1 "foo"))
-  ))
-)
-
-(component
-  (import "C1" (component $C1
-    (import "T1" (type $T1 (sub resource)))
-    (import "T2" (type $T2 (sub resource)))
-    (export "foo" (func (param "t" (tuple (own $T1) (own $T2)))))
-  ))
-  (import "C2" (component $C2
-    (import "T" (type $T (sub resource)))
-    (export "foo" (func (param "t" (tuple (own $T) (own $T)))))
-  ))
-  (type $R (resource (rep i32)))
-  (instance $c1 (instantiate $C1
-    (with "T1" (type $R))
-    (with "T2" (type $R))
-  ))
-  (instance $c2 (instantiate $C2
-    (with "T" (type $R))
-    (with "foo" (func $c1 "foo"))
-  ))
-)
-
-(assert_invalid
-  (component
-    (component $C
-      (type $R (resource (rep i32)))
-      (export "R" (type $R))
-    )
-    (instance $c (instantiate $C))
-    (alias export $c "R" (type $R))
-    (core func (canon resource.rep $R))
-  )
-  "not a local resource")
-
-(component
-  (component $C
-    (type $R (resource (rep i32)))
-    (export "R" (type $R))
-  )
-  (instance $c (instantiate $C))
-  (alias export $c "R" (type $R))
-  (core func (canon resource.drop $R))
-)
-
-(component
-  (component $C1
-    (import "X" (type (sub resource)))
-  )
-  (component $C2
-    (import "C1" (component
-      (import "X" (type (sub resource)))
-    ))
-  )
-  (instance $c (instantiate $C2 (with "C1" (component $C1))))
-)
-
-(component
-  (component $C1
-    (import "X" (type $X (sub resource)))
-    (import "f" (func $f (result (own $X))))
-    (export "g" (func $f))
-  )
-  (component $C2
-    (import "C1" (component
-      (import "X" (type $X (sub resource)))
-      (import "f" (func (result (own $X))))
-      (export "g" (func (result (own $X))))
-    ))
-  )
-  (instance $c (instantiate $C2 (with "C1" (component $C1))))
-)
-
-(component
-  (component $C1
-    (type $X' (resource (rep i32)))
-    (export $X "X" (type $X'))
-
-    (core func $f (canon resource.drop $X))
-    (func (export "f") (param "X" (own $X)) (canon lift (core func $f)))
-  )
-  (instance $c1 (instantiate $C1))
-
-  (component $C2
-    (import "X" (type $X (sub resource)))
-    (import "f" (func (param "X" (own $X))))
-  )
-  (instance $c2 (instantiate $C2
-    (with "X" (type $c1 "X"))
-    (with "f" (func $c1 "f"))
-  ))
-)
-
-(assert_invalid
-  (component
-    (component $C1
-      (type $X' (resource (rep i32)))
-      (export $X "X" (type $X'))
-
-      (core func $f (canon resource.drop $X))
-      (func (export "f") (param "X" (own $X)) (canon lift (core func $f)))
-    )
-    (instance $c1 (instantiate $C1))
-    (instance $c2 (instantiate $C1))
-
-    (component $C2
-      (import "X" (type $X (sub resource)))
-      (import "f" (func (param "X" (own $X))))
-    )
-    (instance $c3 (instantiate $C2
-      (with "X" (type $c1 "X"))
-      (with "f" (func $c2 "f"))
-    ))
-  )
-  "resource types are not the same")
-
-(component
-  (component $C1
-    (type $X (resource (rep i32)))
-    (export $X1 "X1" (type $X))
-    (export $X2 "X2" (type $X))
-
-    (core func $f (canon resource.drop $X))
-    (func (export "f1") (param "X" (own $X1)) (canon lift (core func $f)))
-    (func (export "f2") (param "X" (own $X2)) (canon lift (core func $f)))
-  )
-  (instance $c1 (instantiate $C1))
-
-  (component $C2
-    (import "X" (type $X (sub resource)))
-    (import "f" (func (param "X" (own $X))))
-  )
-  (instance $c2 (instantiate $C2
-    (with "X" (type $c1 "X1"))
-    (with "f" (func $c1 "f1"))
-  ))
-  (instance $c3 (instantiate $C2
-    (with "X" (type $c1 "X2"))
-    (with "f" (func $c1 "f2"))
-  ))
-)
-
-(component
-  (component $C1
-    (type $X (resource (rep i32)))
-    (export $X1 "X1" (type $X))
-    (export $X2 "X2" (type $X))
-
-    (core func $f (canon resource.drop $X))
-    (func (export "f1") (param "X" (own $X1)) (canon lift (core func $f)))
-    (func (export "f2") (param "X" (own $X2)) (canon lift (core func $f)))
-  )
-  (instance $c1 (instantiate $C1))
-
-  (component $C2
-    (import "X" (type $X (sub resource)))
-    (import "f" (func (param "X" (own $X))))
-  )
-  (instance $c2 (instantiate $C2
-    (with "X" (type $c1 "X1"))
-    (with "f" (func $c1 "f2"))
-  ))
-  (instance $c3 (instantiate $C2
-    (with "X" (type $c1 "X2"))
-    (with "f" (func $c1 "f1"))
-  ))
-)
-
-(assert_invalid
-  (component
-    (component $c
-      (import "x" (type (sub resource)))
-    )
-    (type $x u32)
-    (instance (instantiate $c (with "x" (type $x))))
-  )
-  "expected resource, found type")
-
-(assert_invalid
-  (component
-    (component $c
-      (type $t u32)
-      (import "x" (type (eq $t)))
-    )
-    (type $x (resource (rep i32)))
-    (instance (instantiate $c (with "x" (type $x))))
-  )
-  "expected type, found resource")
-
-(assert_invalid
-  (component
-    (component $c
-      (import "x1" (type $x1 (sub resource)))
-      (import "x2" (type $x2 (eq $x1)))
-    )
-    (type $x1 (resource (rep i32)))
-    (type $x2 (resource (rep i32)))
-    (instance (instantiate $c
-      (with "x1" (type $x1))
-      (with "x2" (type $x2))
-    ))
-  )
-  "resource types are not the same")
-
-(component
-  (type $x (resource (rep i32)))
-  (component $c
-    (import "x" (type $t (sub resource)))
-    (export "y" (type $t))
-  )
-  (instance $c (instantiate $c (with "x" (type $x))))
-
-  (alias export $c "y" (type $x2))
-  (core func (canon resource.rep $x2))
-
-)
-
-(assert_invalid
-  (component
-    (type $r (resource (rep i32)))
-    (import "x" (func (result (own $r))))
-  )
-  "func not valid to be used as import")
-
-(assert_invalid
-  (component
-    (type (component
-      (export $x "x" (type (sub resource)))
-      (import "f" (func (result (own $x))))
-    ))
-  )
-  "func not valid to be used as import")
-
-(assert_invalid
-  (component
-    (type $r (resource (rep i32)))
-
-    (core func $f (canon resource.drop $r))
-    (func (export "f") (param "x" (own $r))
-      (canon lift (core func $f)))
-  )
-  "func not valid to be used as export")
-
-;; direct exports count as "explicit in" for resources
-(component
-  (type $r' (resource (rep i32)))
-  (export $r "r" (type $r'))
-
-  (core func $f (canon resource.drop $r))
-  (func (export "f") (param "x" (own $r))
-    (canon lift (core func $f)))
-)
-
-;; instances-as-a-bundle count as "explicit in" for resources
-(component
-  (type $r' (resource (rep i32)))
-  (instance $i'
-    (export "r" (type $r'))
-  )
-  (export $i "i" (instance $i'))
-  (alias export $i "r" (type $r))
-
-  (core func $f (canon resource.drop $r))
-  (func (export "f") (param "x" (own $r))
-    (canon lift (core func $f)))
-)
-
-;; Transitive bundles count for "explicit in"
-(component
-  (type $r' (resource (rep i32)))
-  (instance $i'
-    (export "r" (type $r'))
-  )
-  (instance $i2'
-    (export "i" (instance $i'))
-  )
-  (export $i2 "i2" (instance $i2'))
-  (alias export $i2 "i" (instance $i))
-  (alias export $i "r" (type $r))
-
-  (core func $f (canon resource.drop $r))
-  (func (export "f") (param "x" (own $r))
-    (canon lift (core func $f)))
-)
-
-;; Component instantiations count for "explicit in"
-(component
-  (type $r' (resource (rep i32)))
-  (component $C
-    (import "x" (type $x (sub resource)))
-    (export "y" (type $x))
-  )
-  (instance $c' (instantiate $C (with "x" (type $r'))))
-  (export $c "c" (instance $c'))
-  (alias export $c "y" (type $r))
-
-  (core func $f (canon resource.drop $r))
-  (func (export "f") (param "x" (own $r))
-    (canon lift (core func $f)))
-)
-
-;; Make sure threading things around is valid for "explicit in"
-(component
-  (type $r' (resource (rep i32)))
-  (component $C
-    (import "x" (type $x (sub resource)))
-    (export "y" (type $x))
-  )
-  (instance $c (instantiate $C (with "x" (type $r'))))
-  (instance $i (export "x" (type $c "y")))
-
-  (component $C2
-    (import "x" (instance $i
-      (export "i1" (instance
-        (export "i2" (type (sub resource)))
-      ))
-    ))
-    (export "y" (type $i "i1" "i2"))
-  )
-
-  (instance $i2 (export "i2" (type $i "x")))
-  (instance $i1 (export "i1" (instance $i2)))
-  (instance $c2 (instantiate $C2
-    (with "x" (instance $i1))
-  ))
-  (export $r "x" (type $c2 "y"))
-
-  (core func $f (canon resource.drop $r))
-  (func (export "f") (param "x" (own $r))
-    (canon lift (core func $f)))
-)
-
-;; Importing-and-exporting instances through instantiation counts for "explicit
-;; in"
-(component
-  (type $r' (resource (rep i32)))
-  (component $C
-    (import "x" (instance $x (export "t" (type (sub resource)))))
-    (export "y" (instance $x))
-  )
-  (instance $c' (instantiate $C
-    (with "x" (instance
-      (export "t" (type $r'))
-    ))
-  ))
-  (export $c "c" (instance $c'))
-  (alias export $c "y" (instance $y))
-  (alias export $y "t" (type $r))
-
-  (core func $f (canon resource.drop $r))
-  (func (export "f") (param "x" (own $r))
-    (canon lift (core func $f)))
-)
-
-(component
-  (type $i (instance
-    (export $r "r" (type (sub resource)))
-    (export "f" (func (result (own $r))))
-  ))
-  (import "i1" (instance $i1 (type $i)))
-  (import "i2" (instance $i2 (type $i)))
-
-  (component $c
-    (import "r" (type $t (sub resource)))
-    (import "f" (func (result (own $t))))
-  )
-  (instance (instantiate $c
-    (with "r" (type $i1 "r"))
-    (with "f" (func $i1 "f"))
-  ))
-  (instance (instantiate $c
-    (with "r" (type $i2 "r"))
-    (with "f" (func $i2 "f"))
-  ))
-)
-
-
-(assert_invalid
-  (component
-    (type $i (instance
-      (export $r "r" (type (sub resource)))
-      (export "f" (func (result (own $r))))
-    ))
-    (import "i1" (instance $i1 (type $i)))
-    (import "i2" (instance $i2 (type $i)))
-
-    (component $c
-      (import "r" (type $t (sub resource)))
-      (import "f" (func (result (own $t))))
-    )
-    (instance (instantiate $c
-      (with "r" (type $i1 "r"))
-      (with "f" (func $i2 "f"))
-    ))
-  )
-  "resource types are not the same")
-
-;; substitution works
-(component
-  (type $t (resource (rep i32)))
-  (component $c
-    (import "x" (type $t (sub resource)))
-    (export "y" (type $t))
-  )
-  (instance $c1 (instantiate $c (with "x" (type $t))))
-  (instance $c2 (instantiate $c (with "x" (type $t))))
-
-  (component $c2
-    (import "x1" (type $t (sub resource)))
-    (import "x2" (type (eq $t)))
-    (import "x3" (type (eq $t)))
-  )
-  (instance (instantiate $c2
-    (with "x1" (type $t))
-    (with "x2" (type $c1 "y"))
-    (with "x3" (type $c2 "y"))
-  ))
-)
-
-;; must supply a resource to instantiation
-(assert_invalid
-  (component
-    (component $c
-      (import "x" (type (sub resource)))
-    )
-    (instance (instantiate $c))
-  )
-  "missing import named `x`")
-(assert_invalid
-  (component
-    (type $x (resource (rep i32)))
-    (component $c
-      (import "x" (type (sub resource)))
-      (import "y" (type (sub resource)))
-    )
-    (instance (instantiate $c (with "x" (type $x))))
-  )
-  "missing import named `y`")
-
-;; supply the wrong resource
-(assert_invalid
-  (component
-    (type $x (resource (rep i32)))
-    (type $y (resource (rep i32)))
-    (component $c
-      (import "x" (type $t (sub resource)))
-      (import "y" (type (eq $t)))
-    )
-    (instance (instantiate $c
-      (with "x" (type $x))
-      (with "y" (type $y))
-    ))
-  )
-  "resource types are not the same")
-
-;; aliasing outer resources is ok
-(component $A
-  (type $C (component
-    (import "x" (type $x (sub resource)))
-
-    (type $y (component
-      (alias outer $C $x (type $my-x))
-      (import "x" (type (eq $my-x)))
-    ))
-
-    (import "y" (component (type $y)))
-    (export "z" (component (type $y)))
-  ))
-
-  (type $t (resource (rep i32)))
-
-  (alias outer $A $t (type $other-t))
-
-  (type (instance (export "t" (type (eq $t)))))
-  (type (component (export "t" (type (eq $t)))))
-  (type (component (import "t" (type (eq $t)))))
-)
-
-;; aliasing beyond components, however, is not ok
-(assert_invalid
-  (component $A
-    (type $t (resource (rep i32)))
-    (component (alias outer $A $t (type $foo)))
-  )
-  "refers to resources not defined in the current component")
-(assert_invalid
-  (component $A
-    (type $t (resource (rep i32)))
-    (type $u (record (field "x" (own $t))))
-    (component (alias outer $A $u (type $foo)))
-  )
-  "refers to resources not defined in the current component")
-(assert_invalid
-  (component $A
-    (type $t (resource (rep i32)))
-    (type $u (borrow $t))
-    (component (alias outer $A $u (type $foo)))
-  )
-  "refers to resources not defined in the current component")
-(assert_invalid
-  (component $A
-    (type $t (resource (rep i32)))
-    (type $u (component (export "a" (type (eq $t)))))
-    (component (alias outer $A $u (type $foo)))
-  )
-  "refers to resources not defined in the current component")
-(assert_invalid
-  (component $A
-    (type $t (resource (rep i32)))
-    (type $u (component (import "a" (type (eq $t)))))
-    (component (alias outer $A $u (type $foo)))
-  )
-  "refers to resources not defined in the current component")
-
-(assert_invalid
-  (component
-    (component $X
-      (type $t (resource (rep i32)))
-      (export "t" (type $t))
-    )
-    (component $F
-      (import "x" (component (export $t "t" (type (sub resource)))))
-    )
-    (instance $x1 (instantiate $X))
-    (instance $f1 (instantiate $F (with "x" (instance $x1))))
-  )
-  "expected component, found instance")
-
-;; Show that two instantiations of the same component produce unique exported
-;; resource types.
-(assert_invalid
-  (component
-    (component $F
-      (type $t1 (resource (rep i32)))
-      (export "t1" (type $t1))
-    )
-    (instance $f1 (instantiate $F))
-    (instance $f2 (instantiate $F))
-    (alias export $f1 "t1" (type $t1))
-    (alias export $f2 "t1" (type $t2))
-    (component $T
-      (import "x" (type $x (sub resource)))
-      (import "y" (type (eq $x)))
-    )
-    (instance $test
-      (instantiate $T (with "x" (type $t1)) (with "y" (type $t2))))
-  )
-  "type mismatch for import `y`")
-
-;; Show that re-exporting imported resources from an imported component doesn't
-;; change the identity of that resource.
-(component
-  (component $X
-    (type $t (resource (rep i32)))
-    (export "t" (type $t))
-  )
-  (component $F
-    (import "x" (instance $i (export $t "t" (type (sub resource)))))
-    (alias export $i "t" (type $t))
-    (export "t" (type $t))
-  )
-  (instance $x1 (instantiate $X))
-  (instance $f1 (instantiate $F (with "x" (instance $x1))))
-  (instance $f2 (instantiate $F (with "x" (instance $x1))))
-  (alias export $f1 "t" (type $t1))
-  (alias export $f2 "t" (type $t2))
-  (component $T
-    (import "x" (type $x (sub resource)))
-    (import "y" (type (eq $x)))
-  )
-  (instance $test
-    (instantiate $T (with "x" (type $t1)) (with "y" (type $t2))))
-)
-
-(assert_invalid
-  (component (import "[static]" (func)))
-  "failed to find `.` character")
-
-;; validation of `[constructor]foo`
-(assert_invalid
-  (component (import "[constructor]" (func)))
-  "not in kebab case")
-(assert_invalid
-  (component (import "[constructor]a" (func)))
-  "should return one value")
-(assert_invalid
-  (component (import "[constructor]a" (func (result u32))))
-  "should return `(own $T)`")
-(assert_invalid
-  (component
-    (import "b" (type $a (sub resource)))
-    (import "[constructor]a" (func (result (own $a)))))
-  "import name `[constructor]a` is not valid")
-(assert_invalid
-  (component
-    (import "b" (type $a (sub resource)))
-    (import "[constructor]a" (func (result (own $a)))))
-  "function does not match expected resource name `b`")
-(component
-  (import "a" (type $a (sub resource)))
-  (import "[constructor]a" (func (result (own $a)))))
-(component
-  (import "a" (type $a (sub resource)))
-  (import "[constructor]a" (func (param "x" u32) (result (own $a)))))
-
-;; validation of `[method]a.b`
-(assert_invalid
-  (component (import "[method]" (func)))
-  "failed to find `.` character")
-(assert_invalid
-  (component (import "[method]a" (func)))
-  "failed to find `.` character")
-(assert_invalid
-  (component (import "[method]a." (func)))
-  "not in kebab case")
-(assert_invalid
-  (component (import "[method].a" (func)))
-  "not in kebab case")
-(assert_invalid
-  (component (import "[method]a.b.c" (func)))
-  "not in kebab case")
-(assert_invalid
-  (component (import "[method]a.b" (instance)))
-  "is not a func")
-(assert_invalid
-  (component (import "[method]a.b" (func)))
-  "should have at least one argument")
-(assert_invalid
-  (component (import "[method]a.b" (func (param "x" u32))))
-  "should have a first argument called `self`")
-(assert_invalid
-  (component (import "[method]a.b" (func (param "self" u32))))
-  "should take a first argument of `(borrow $T)`")
-(assert_invalid
-  (component
-    (import "b" (type $T (sub resource)))
-    (import "[method]a.b" (func (param "self" (borrow $T)))))
-  "does not match expected resource name")
-(component
-  (import "a" (type $T (sub resource)))
-  (import "[method]a.b" (func (param "self" (borrow $T)))))
-
-;; validation of `[static]a.b`
-(assert_invalid
-  (component (import "[static]" (func)))
-  "failed to find `.` character")
-(assert_invalid
-  (component (import "[static]a" (func)))
-  "failed to find `.` character")
-(assert_invalid
-  (component (import "[static]a." (func)))
-  "not in kebab case")
-(assert_invalid
-  (component (import "[static].a" (func)))
-  "not in kebab case")
-(assert_invalid
-  (component (import "[static]a.b.c" (func)))
-  "not in kebab case")
-(assert_invalid
-  (component (import "[static]a.b" (instance)))
-  "is not a func")
-(assert_invalid
-  (component (import "[static]a.b" (func)))
-  "static resource name is not known in this context")
-
-(component
-  (import "a" (type (sub resource)))
-  (import "[static]a.b" (func)))
-
-;; exports/imports are disjoint
-(assert_invalid
-  (component
-    (import "b" (type $T (sub resource)))
-    (import "f" (func $f (param "self" (borrow $T))))
-    (export "[method]b.foo" (func $f))
-  )
-  "resource used in function does not have a name in this context")
-
-(component
-  (import "b" (type $T (sub resource)))
-  (import "f" (func $f (param "self" (borrow $T))))
-  (export $c "c" (type $T))
-  (export "[method]c.foo" (func $f) (func (param "self" (borrow $c))))
-)
-
-;; imports aren't transitive
-(assert_invalid
-  (component
-    (import "i" (instance $i
-      (export "t" (type (sub resource)))
-    ))
-    (alias export $i "t" (type $t))
-    (import "[method]t.foo" (func (param "self" (borrow $t))))
-  )
-  "resource used in function does not have a name in this context")
-
-;; validation happens in a type context
-(assert_invalid
-  (component
-    (type (component
-      (import "b" (type $T (sub resource)))
-      (import "[constructor]a" (func (result (own $T))))
-    ))
-  )
-  "function does not match expected resource name `b`")
-
-;; bag-of-exports validation
-(assert_invalid
-  (component
-    (type $T (resource (rep i32)))
-    (core module $m (func (export "a") (result i32) unreachable))
-    (core instance $i (instantiate $m))
-    (func $f (result (own $T)) (canon lift (core func $i "a")))
-    (instance
-      (export "a" (type $T))
-      (export "[constructor]a" (func $f))
-    )
-  )
-  "resource used in function does not have a name in this context")
-
-(component
-  (component $C)
-  (instance (instantiate $C (with "this is not kebab case" (component $C))))
-)
-
-;; Test that unused arguments to instantiation are not validated to have
-;; appropriate types with respect to kebab naming conventions which require
-;; functions/interfaces/etc.
-(component
-  (component $C)
-  (instance (instantiate $C (with "[method]foo.bar" (component $C))))
-)
-
-;; thread a resource through a few layers
-(component
-  (component $C
-    (import "in" (type $r (sub resource)))
-    (export "out" (type $r))
-  )
-
-  (type $r (resource (rep i32)))
-
-  (instance $c1 (instantiate $C (with "in" (type $r))))
-  (instance $c2 (instantiate $C (with "in" (type $c1 "out"))))
-  (instance $c3 (instantiate $C (with "in" (type $c2 "out"))))
-  (instance $c4 (instantiate $C (with "in" (type $c3 "out"))))
-  (instance $c5 (instantiate $C (with "in" (type $c4 "out"))))
-
-  (component $C2
-    (import "in1" (type $r (sub resource)))
-    (import "in2" (type (eq $r)))
-    (import "in3" (type (eq $r)))
-    (import "in4" (type (eq $r)))
-    (import "in5" (type (eq $r)))
-    (import "in6" (type (eq $r)))
-  )
-
-  (instance (instantiate $C2
-    (with "in1" (type $r))
-    (with "in2" (type $c1 "out"))
-    (with "in3" (type $c2 "out"))
-    (with "in4" (type $c3 "out"))
-    (with "in5" (type $c4 "out"))
-    (with "in6" (type $c5 "out"))
-  ))
-)
-
-;; exporting an instance type "freshens" resources
-(assert_invalid
-  (component
-    (import "x" (instance $i
-      (type $i (instance
-        (export "r" (type (sub resource)))
-      ))
-      (export "a" (instance (type $i)))
-      (export "b" (instance (type $i)))
-    ))
-
-    (component $C
-      (import "x" (type $x (sub resource)))
-      (import "y" (type (eq $x)))
-    )
-    (instance (instantiate $C
-      (with "x" (type $i "a" "r"))
-      (with "y" (type $i "b" "r"))
-    ))
-  )
-  "resource types are not the same")
-
-(component
-  (type (export "x") (component
-    (type $t' (instance
-      (export "r" (type (sub resource)))
-    ))
-    (export $t "t" (instance (type $t')))
-    (alias export $t "r" (type $r))
-    (type $t2' (instance
-      (export "r2" (type (eq $r)))
-      (export "r" (type (sub resource)))
-    ))
-    (export "t2" (instance (type $t2')))
-  ))
-)
-
-(component
-  (type (component
-    (type (instance
-      (export "bar" (type (sub resource)))
-      (export "[static]bar.a" (func))
-    ))
-    (export "x" (instance (type 0)))
-  ))
-)
diff --git a/tests/local/component-model/start.wast b/tests/local/component-model/start.wast
index 31a86e1c..7e596fa4 100644
--- a/tests/local/component-model/start.wast
+++ b/tests/local/component-model/start.wast
@@ -74,7 +74,7 @@
 
 (assert_invalid
   (component binary
-    "\00asm" "\0d\00\01\00"   ;; component header
+    "\00asm" "\0c\00\01\00"   ;; component header
 
     "\07\05"          ;; type section, 5 bytes large
     "\01"             ;; 1 count
@@ -82,9 +82,10 @@
     "\00"             ;; parameters, 0 count
     "\01\00"          ;; results, named, 0 count
 
-    "\0a\06"          ;; import section, 6 bytes large
+    "\0a\06"          ;; import section, 5 bytes large
     "\01"             ;; 1 count
-    "\00\01a"         ;; name = "a"
+    "\01a"            ;; name = "a"
+    "\00"             ;; url = ""
     "\01\00"          ;; type = func ($type 0)
 
     "\09\06"          ;; start section, 6 bytes large
@@ -96,7 +97,7 @@
 
 (assert_invalid
   (component binary
-    "\00asm" "\0d\00\01\00"   ;; component header
+    "\00asm" "\0c\00\01\00"   ;; component header
 
     "\07\05"          ;; type section, 5 bytes large
     "\01"             ;; 1 count
@@ -104,9 +105,10 @@
     "\00"             ;; parameters, 0 count
     "\01\00"          ;; results, named, 0 count
 
-    "\0a\06"          ;; import section, 6 bytes large
+    "\0a\06"          ;; import section, 5 bytes large
     "\01"             ;; 1 count
-    "\00\01a"         ;; name = "a"
+    "\01a"            ;; name = "a"
+    "\00"             ;; url = ""
     "\01\00"          ;; type = func ($type 0)
 
     "\09\04"          ;; start section, 4 bytes large
diff --git a/tests/local/component-model/type-export-restrictions.wast b/tests/local/component-model/type-export-restrictions.wast
deleted file mode 100644
index 7df590ce..00000000
--- a/tests/local/component-model/type-export-restrictions.wast
+++ /dev/null
@@ -1,514 +0,0 @@
-;; Test that unnamed types in various types are all detected
-
-(assert_invalid
-  (component
-    (type $t (record))
-    (type $f (record (field "f" $t)))
-    (export "f" (type $f))
-  )
-  "type not valid to be used as export")
-
-(assert_invalid
-  (component
-    (type $t (record))
-    (type $f (list $t))
-    (export "f" (type $f))
-  )
-  "type not valid to be used as export")
-
-(assert_invalid
-  (component
-    (type $t (record))
-    (type $f (union $t))
-    (export "f" (type $f))
-  )
-  "type not valid to be used as export")
-
-(assert_invalid
-  (component
-    (type $t (record))
-    (type $f (tuple $t))
-    (export "f" (type $f))
-  )
-  "type not valid to be used as export")
-
-(assert_invalid
-  (component
-    (type $t (record))
-    (type $f (variant (case "c" $t)))
-    (export "f" (type $f))
-  )
-  "type not valid to be used as export")
-
-(assert_invalid
-  (component
-    (type $t (record))
-    (type $f (option $t))
-    (export "f" (type $f))
-  )
-  "type not valid to be used as export")
-
-(assert_invalid
-  (component
-    (type $t (record))
-    (type $f (result $t))
-    (export "f" (type $f))
-  )
-  "type not valid to be used as export")
-
-;; Test that various types are all flagged as "requires a name"
-
-(assert_invalid
-  (component
-    (type $t (record))
-    (type $f (list $t))
-    (export "f" (type $f))
-  )
-  "type not valid to be used as export")
-
-(assert_invalid
-  (component
-    (type $t (union u32))
-    (type $f (list $t))
-    (export "f" (type $f))
-  )
-  "type not valid to be used as export")
-
-(assert_invalid
-  (component
-    (type $t (enum "a"))
-    (type $f (list $t))
-    (export "f" (type $f))
-  )
-  "type not valid to be used as export")
-
-(assert_invalid
-  (component
-    (type $t (flags "a"))
-    (type $f (list $t))
-    (export "f" (type $f))
-  )
-  "type not valid to be used as export")
-
-(assert_invalid
-  (component
-    (type $t (variant (case "a")))
-    (type $f (list $t))
-    (export "f" (type $f))
-  )
-  "type not valid to be used as export")
-
-(assert_invalid
-  (component
-    (type $t (resource (rep i32)))
-    (type $f (list (own $t)))
-    (export "f" (type $f))
-  )
-  "type not valid to be used as export")
-
-;; Some types don't need names
-(component
-  (type $t1 (tuple (tuple)))
-  (export "t1" (type $t1))
-
-  (type $t2 (option (tuple (list u8) (result (list u32) (error (option string))))))
-  (export "t2" (type $t2))
-
-  (type $t3 u32)
-  (export "t3" (type $t3))
-)
-
-(component
-  (type $t' (record))
-  (export $t "t" (type $t'))
-  (type $t2 (record (field "x" $t)))
-  (export "t2" (type $t2))
-)
-
-;; imports are validated as well
-(assert_invalid
-  (component
-    (type $t (record))
-    (type $t2 (record (field "f" $t)))
-    (import "x" (type (eq $t2)))
-  )
-  "type not valid to be used as import")
-(component
-  (type $t (record))
-  (import "t" (type $t' (eq $t)))
-  (type $t2 (record (field "f" $t')))
-  (import "x" (type (eq $t2)))
-)
-(assert_invalid
-  (component
-    (type $t (record))
-    (type $t2 (record (field "f" $t)))
-    (import "x" (func (param "x" $t2)))
-  )
-  "func not valid to be used as import")
-
-(assert_invalid
-  (component
-    (type $t (resource (rep i32)))
-    (export "t" (type $t))
-    (type $f (list (own $t)))
-    (export "f" (type $f))
-  )
-  "type not valid to be used as export")
-
-;; validate within the type context
-(assert_invalid
-  (component
-    (type (component
-      (type $t (record))
-      (export "f" (func (param "x" $t)))
-    ))
-  )
-  "func not valid to be used as export")
-(assert_invalid
-  (component
-    (type (component
-      (type $t (record))
-      (type $f (record (field "t" $t)))
-      (export "f" (type (eq $f)))
-    ))
-  )
-  "type not valid to be used as export")
-
-;; instances of unexported types is ok
-(component
-  (type $t (record))
-  (type $f (record (field "t" $t)))
-  (instance
-    (export "f" (type $f))
-  )
-)
-;; .. but exporting them is not
-(assert_invalid
-  (component
-    (type $t (record))
-    (type $f (record (field "t" $t)))
-    (instance $i
-      (export "f" (type $f))
-    )
-    (export "i" (instance $i))
-  )
-  "instance not valid to be used as export")
-
-;; Can't export a lifted function with unexported types
-(assert_invalid
-  (component
-    (type $t (record))
-    (type $f (record (field "t" $t)))
-
-    (core module $m (func $f (export "f")))
-    (core instance $i (instantiate $m))
-    (func $f (param "f" $f) (canon lift (core func $i "f")))
-    (export "f" (func $f))
-  )
-  "func not valid to be used as export")
-
-;; Unexported instances don't work
-(assert_invalid
-  (component
-    (type $t' (record))
-    (instance $i
-      (export "t" (type $t'))
-    )
-    (alias export $i "t" (type $t))
-
-    (core module $m (func $f (export "f")))
-    (core instance $i (instantiate $m))
-    (func $f (param "f" $t) (canon lift (core func $i "f")))
-    (export "f" (func $f))
-  )
-  "func not valid to be used as export")
-
-;; Even through a component it doesn't work
-(assert_invalid
-  (component
-    (component $C
-      (type $t (record))
-      (export "t" (type $t))
-    )
-    (instance $i (instantiate $C))
-    (alias export $i "t" (type $t))
-
-    (core module $m (func $f (export "f")))
-    (core instance $i (instantiate $m))
-    (func $f (param "f" $t) (canon lift (core func $i "f")))
-    (export "f" (func $f))
-  )
-  "func not valid to be used as export")
-
-;; through exported instances is ok though
-(component
-  (type $t' (record))
-  (instance $i'
-    (export "t" (type $t'))
-  )
-  (export $i "i" (instance $i'))
-  (alias export $i "t" (type $t))
-
-  (core module $m (func $f (export "f")))
-  (core instance $i (instantiate $m))
-  (func $f (param "f" $t) (canon lift (core func $i "f")))
-  (export "f" (func $f))
-)
-(component
-  (component $C
-    (type $t (record))
-    (export "t" (type $t))
-  )
-  (instance $i' (instantiate $C))
-  (export $i "i" (instance $i'))
-  (alias export $i "t" (type $t))
-
-  (core module $m (func $f (export "f")))
-  (core instance $i (instantiate $m))
-  (func $f (param "f" $t) (canon lift (core func $i "f")))
-  (export "f" (func $f))
-)
-
-;; a type-ascribed export which is otherwise invalid can become valid
-(component
-  (type $t (record))
-
-  (core module $m (func (export "f")))
-  (core instance $i (instantiate $m))
-  (func $f (param "x" $t) (canon lift (core func $i "f")))
-
-  (export $t' "t" (type $t))
-  (export "f" (func $f) (func (param "x" $t')))
-)
-
-;; imports can't reference exports
-(assert_invalid
-  (component
-    (type $t1 (record))
-    (export $t2 "t1" (type $t1))
-    (import "i" (func (result $t2)))
-  )
-  "func not valid to be used as import")
-
-;; exports can reference imports
-(component
-  (type $t1 (record))
-  (import "t1" (type $t2 (eq $t1)))
-  (export "e-t1" (type $t2))
-)
-(component
-  (type $t1 (record))
-  (import "t1" (type $t2 (eq $t1)))
-  (import "i" (func $f (result $t2)))
-
-  (export "e-i" (func $f))
-)
-
-;; outer aliases don't work for imports/exports
-(assert_invalid
-  (component
-    (type $t1 (record))
-    (import "t1" (type $t2 (eq $t1)))
-    (component
-      (import "i" (func $f (result $t2)))
-    )
-  )
-  "func not valid to be used as import")
-(assert_invalid
-  (component
-    (type $t1 (record))
-    (export $t2 "t1" (type $t1))
-    (component
-      (core module $m (func (export "f")))
-      (core instance $i (instantiate $m))
-      (func $f (export "i") (result $t2) (canon lift (core func $i "f")))
-    )
-  )
-  "func not valid to be used as export")
-
-;; outer aliases work for components, modules, and resources
-(component
-  (type $c (component))
-  (type (component
-    (import "c" (component (type $c)))
-  ))
-  (component
-    (import "c" (component (type $c)))
-  )
-  (type $i (instance))
-  (type (component
-    (import "c" (instance (type $i)))
-  ))
-
-  (type $r (resource (rep i32)))
-  (type (component
-    (import "r" (type (eq $r)))
-  ))
-)
-
-;; reexport of an import is fine
-(component
-  (import "r" (func $r))
-  (export "r2" (func $r))
-)
-(component
-  (type $t (record))
-  (import "r" (type $r (eq $t)))
-  (export "r2" (type $r))
-)
-(component
-  (import "r" (instance $r))
-  (export "r2" (instance $r))
-)
-(component
-  (import "r" (type $r (sub resource)))
-  (export "r2" (type $r))
-)
-
-;; bag of exports cannot be exported by carrying through context that's not
-;; otherwise exported
-(assert_invalid
-  (component
-    (component $A
-      (type $t (record))
-      (export $t2 "t" (type $t))
-      (core module $m (func (export "f")))
-      (core instance $i (instantiate $m))
-      (func $f (result $t2) (canon lift (core func $i "f")))
-
-      (instance (export "i")
-        (export "f" (func $f))
-      )
-    )
-
-    (instance $a (instantiate $A))
-    ;; this component only exports `f`, not the record type that is the result
-    ;; of `f`, so it should be invalid.
-    (export "a" (instance $a "i"))
-  )
-  "instance not valid to be used as export")
-
-;; instance types can be "temporarily invalid", but not if they're attached
-;; to a concrete component
-(component
-  (type (instance
-    (type $t (record))
-    (export "f" (func (param "x" $t)))
-  ))
-)
-(assert_invalid
-  (component
-    (type $i (instance
-      (type $t (record))
-      (type $f (record (field "t" $t)))
-      (export "f" (type (eq $f)))
-    ))
-    (import "f" (instance (type $i)))
-  )
-  "instance not valid to be used as import")
-
-;; allow for one import to refer to another
-(component $C
-  (import "foo" (instance $i
-    (type $baz' (record))
-    (export $baz "baz" (type (eq $baz')))
-    (type $bar' (record (field "baz" $baz)))
-    (export $bar "bar" (type (eq $bar')))
-  ))
-  (alias export $i "bar" (type $bar))
-  (import "bar" (instance
-    (alias outer $C $bar (type $bar'))
-    (export $bar "bar" (type (eq $bar')))
-    (export $f "a" (func (result $bar)))
-  ))
-)
-
-;; allow for one import to refer to another
-(component
-  (type $r' (record))
-  (import "r" (type $r (eq $r')))
-  (component $C
-    (type $r' (record))
-    (import "r" (type $r (eq $r')))
-    (type $r2' (record (field "r" $r)))
-    (export "r2" (type $r2'))
-  )
-  (instance $c (instantiate $C (with "r" (type $r))))
-  (export "r2" (type $c "r2"))
-)
-
-;; types are validated when they are exported
-(assert_invalid
-  (component
-    (type $i (instance
-      (type $t (record))
-      (type $f (record (field "t" $t)))
-      (export "f" (type (eq $f)))
-    ))
-    (import "f" (type (eq $i)))
-  )
-  "type not valid to be used as import")
-(assert_invalid
-  (component
-    (type $i (instance
-      (type $t (record))
-      (type $f (record (field "t" $t)))
-      (export "f" (type (eq $f)))
-    ))
-    (export "f" (type $i))
-  )
-  "type not valid to be used as export")
-
-(assert_invalid
-  (component
-    (type $t (record))
-    (type $f (func (result $t)))
-    (import "f" (type (eq $f)))
-  )
-  "type not valid to be used as import")
-(assert_invalid
-  (component
-    (type $t (record))
-    (type $f (func (result $t)))
-    (export "f" (type $f))
-  )
-  "type not valid to be used as export")
-
-(component
-  (type (;0;)
-    (instance
-      (type (;0;) (enum "qux"))
-      (export (;1;) "baz" (type (eq 0)))
-      (type (;2;) (record (field "bar" 1) ))
-      (export (;3;) "foo" (type (eq 2)))
-    )
-  )
-  (import (interface "demo:component/types") (instance (;0;) (type 0)))
-  (component 
-    (type (;0;)
-      (instance
-        (type (;0;) (enum "qux"))
-        (export (;1;) "baz" (type (eq 0)))
-        (type (;2;) (record (field "bar" 1) ))
-        (export (;3;) "foo" (type (eq 2)))
-      )
-    )
-    (import (interface "demo:component/types") (instance (;0;) (type 0)))
-    (component (;0;)
-      (type (;0;) (enum "qux"))
-      (import "import-type-baz" (type (;1;) (eq 0)))
-      (type (;2;) (record (field "bar" 1) ))
-      (import "import-type-bar" (type (;3;) (eq 2)))
-      (export (;4;) "foo" (type 3))
-    )
-    (instance (;1;) (instantiate 0
-        (with "import-type-baz" (type 0 "baz"))
-        (with "import-type-bar" (type 0 "foo"))
-      )
-    )
-    (export (;0;) (interface "demo:component/types") (instance 1))
-  )
-  (instance (instantiate 0 (with "demo:component/types" (instance 0))))
-  (export   (interface "demo:component/types") (instance 1 "demo:component/types"))
-)
\ No newline at end of file
diff --git a/tests/local/component-model/types.wast b/tests/local/component-model/types.wast
index 742f257b..76096d0c 100644
--- a/tests/local/component-model/types.wast
+++ b/tests/local/component-model/types.wast
@@ -107,7 +107,7 @@
       (export "A" (func))
     ))
   )
-  "export name `A` conflicts with previous name `a`")
+  "export name `A` conflicts with previous export name `a`")
 
 (assert_invalid
   (component
@@ -116,7 +116,7 @@
       (import "a" (func))
     ))
   )
-  "import name `a` conflicts with previous name `A`")
+  "import name `a` conflicts with previous import name `A`")
 
 (assert_invalid
   (component $c
@@ -195,7 +195,7 @@
       (export "FOO-bar-BAZ" (func))
     ))
   )
-  "export name `FOO-bar-BAZ` conflicts with previous name `foo-BAR-baz`")
+  "export name `FOO-bar-BAZ` conflicts with previous export name `foo-BAR-baz`")
 
 (assert_invalid
   (component $c
diff --git a/tests/local/component-model/very-nested.wast b/tests/local/component-model/very-nested.wast
index 8e82efe3..6705cf36 100644
--- a/tests/local/component-model/very-nested.wast
+++ b/tests/local/component-model/very-nested.wast
@@ -1562,7 +1562,7 @@
       (component)
     )
   )
-  "conflicts with previous name")
+  "conflicts with previous export name")
 
 (assert_invalid
   (component
diff --git a/tests/local/gc/gc-array-types-invalid.wast b/tests/local/gc/gc-array-types-invalid.wast
deleted file mode 100644
index a3073bff..00000000
--- a/tests/local/gc/gc-array-types-invalid.wast
+++ /dev/null
@@ -1,8 +0,0 @@
-;; --enable-gc
-
-(assert_invalid
-  (module
-    (type $a (array (mut (ref null 1000))))
-  )
-  "unknown type"
-)
diff --git a/tests/local/gc/gc-array-types.wat b/tests/local/gc/gc-array-types.wat
deleted file mode 100644
index fd5b0eae..00000000
--- a/tests/local/gc/gc-array-types.wat
+++ /dev/null
@@ -1,9 +0,0 @@
-;; --enable-gc
-
-(module
-  (type $a (array i32))
-  (type $b (array (mut i32)))
-  (type $c (array (mut (ref null $b))))
-  (type $d (array i8))
-  (type $e (array (mut i16)))
-)
diff --git a/tests/local/gc/gc-heaptypes.wat b/tests/local/gc/gc-heaptypes.wat
index 3eed1156..b2401a03 100644
--- a/tests/local/gc/gc-heaptypes.wat
+++ b/tests/local/gc/gc-heaptypes.wat
@@ -6,9 +6,6 @@
   (func (param anyref (ref any) (ref null any)))
   (func (param eqref (ref eq) (ref null eq)))
   (func (param i31ref (ref i31) (ref null i31)))
-  (func (param structref (ref struct) (ref null struct)))
+  (func (param dataref (ref data) (ref null data)))
   (func (param arrayref (ref array) (ref null array)))
-  (func (param nullfuncref (ref nofunc) (ref null nofunc)))
-  (func (param nullexternref (ref noextern) (ref null noextern)))
-  (func (param nullref (ref none) (ref null none)))
 )
diff --git a/tests/local/gc/gc-i31.wat b/tests/local/gc/gc-i31.wat
deleted file mode 100644
index 90352174..00000000
--- a/tests/local/gc/gc-i31.wat
+++ /dev/null
@@ -1,14 +0,0 @@
-;; --enable-gc
-
-(module
-  (func $f (result i32 i32)
-    (local $a (ref i31))
-    (local $b (ref null i31))
-    (local $c i31ref)
-
-    (local.set $a (i31.new (i32.const 42)))
-    (local.set $b (i31.new (i32.const 0)))
-    (i31.get_u (local.get $a))
-    (i31.get_s (local.get $b))
-  )
-)
diff --git a/tests/local/gc/gc-rec-sub.wat b/tests/local/gc/gc-rec-sub.wat
index cfea4f73..9ee43c9d 100644
--- a/tests/local/gc/gc-rec-sub.wat
+++ b/tests/local/gc/gc-rec-sub.wat
@@ -30,13 +30,10 @@
 
   (rec
     (type $a (func))
-    (type (sub $a (func)))
+    (sub $a (type (func)))
   )
   (rec
-    (type (sub $a (func)))
+    (sub $a (type (func)))
   )
-  (rec
-    (type (sub final $a (func)))
-  )
-  (type (sub $a (func)))
+  (sub $a (type (func)))
 )
diff --git a/tests/local/gc/gc-struct-types.wat b/tests/local/gc/gc-struct-types.wat
deleted file mode 100644
index 1b3eb4d5..00000000
--- a/tests/local/gc/gc-struct-types.wat
+++ /dev/null
@@ -1,16 +0,0 @@
-;; --enable-gc
-
-(module
-  (type (struct))
-  (type (struct (field i32)))
-  (type (struct (field (mut i32))))
-  (type (struct (field i32) (field i32)))
-  (type (struct (field i32) (field (mut i32))))
-  (type (struct (field (mut i32)) (field (mut i32))))
-
-  (type $a (struct (field f32)))
-  (type $b (struct (field f32)))
-
-  (type (struct (field $field_a externref)))
-  (type (struct (field $field_b externref) (field $field_c funcref)))
-)
diff --git a/tests/local/gc/gc-subtypes-invalid.wast b/tests/local/gc/gc-subtypes-invalid.wast
deleted file mode 100644
index c143d45b..00000000
--- a/tests/local/gc/gc-subtypes-invalid.wast
+++ /dev/null
@@ -1,131 +0,0 @@
-;; --enable-gc
-
-(assert_invalid
-  (module
-    (type $a (func))
-    (type $b (sub final $a (func)))
-    (type $c (sub $b (func))) ;; invalid
-  )
-  "subtype must match supertype"
-)
-(assert_invalid
-  (module
-    (type $a (func))
-    (type $b (sub $a (struct))) ;; invalid
-  )
-  "subtype must match supertype"
-)
-(assert_invalid
-  (module
-    (type $a (func))
-    (type $b (sub $a (func (param i32)))) ;; invalid
-  )
-  "subtype must match supertype"
-)
-(assert_invalid
-  (module
-    (type $a (struct i32))
-    (type $b (sub $a (struct i64))) ;; invalid
-  )
-  "subtype must match supertype"
-)
-(assert_invalid
-  (module
-    (type $d (struct))
-    (type $e (sub $d (struct (field (ref null $d)))))
-    (type $f (sub $e (struct (field (ref $e)))))
-
-    (type $g (func (param (ref $e)) (result (ref $e))))
-    (type $i (sub $g (func (param (ref $f)) (result (ref $d))))) ;; invalid
-  )
-  "subtype must match supertype"
-)
-(assert_invalid
-  (module
-    (type $o (array i32))
-    (type (sub $o (array (mut i32)))) ;; invalid
-  )
-  "subtype must match supertype"
-)
-(assert_invalid
-  (module
-    (type $o (array i32))
-    (type (sub $o (array i64))) ;; invalid
-  )
-  "subtype must match supertype"
-)
-(assert_invalid
-  (module
-    (type $q (array (mut anyref)))
-    (type $r (sub $q (array i31ref)))
-    (type $s (sub $r (array (ref i31))))
-    (type (sub $s (array (ref null i31)))) ;; invalid
-  )
-  "subtype must match supertype"
-)
-(assert_invalid
-  (module
-    (type $q (array (mut anyref)))
-    (type $rr (sub $q (array arrayref)))
-    (type $ss (sub $rr (array (ref array))))
-    (type (sub $ss (array (ref null array)))) ;; invalid
-  )
-  "subtype must match supertype"
-)
-(assert_invalid
-  (module
-    (type $q (array (mut anyref)))
-    (type $rrr (sub $q (array structref)))
-    (type $sss (sub $rrr (array (ref struct))))
-    (type (sub $sss (array (ref null struct)))) ;; invalid
-  )
-  "subtype must match supertype"
-)
-(assert_invalid
-  (module
-    (type $t (array (mut funcref)))
-    (type $u (sub $t (array (ref null func))))
-    (type (sub $u (array (mut (ref func))))) ;; invalid
-  )
-  "subtype must match supertype"
-)
-(assert_invalid
-  (module
-    (type $t (array (mut funcref)))
-    (type $u (sub $t (array (ref null func))))
-    (type (sub $u (array (ref null extern)))) ;; invalid
-  )
-  "subtype must match supertype"
-)
-(assert_invalid
-  (module
-    (type $t0 (array (mut externref)))
-    (type $u0 (sub $t0 (array (ref null extern))))
-    (type (sub $u0 (array (mut (ref extern))))) ;; invalid
-  )
-  "subtype must match supertype"
-)
-(assert_invalid
-  (module
-    (type $t0 (array (mut externref)))
-    (type $u0 (sub $t0 (array (ref null extern))))
-    (type $v0 (sub $u0 (array (ref extern))))
-    (type (sub $v0 (array nullexternref))) ;; invalid
-  )
-  "subtype must match supertype"
-)
-(assert_invalid
-  (module
-    (type $t (array (mut funcref)))
-    (type (sub $t (array nullexternref))) ;; invalid
-  )
-  "subtype must match supertype"
-)
-(assert_invalid
-  (module
-    (type $d (struct))
-    (type $e (sub $d (struct (field (ref null $d)))))
-    (type (sub $e (struct (field (ref 1000)))))
-  )
-  "type index out of bounds"
-)
diff --git a/tests/local/gc/gc-subtypes.wat b/tests/local/gc/gc-subtypes.wat
deleted file mode 100644
index 86057600..00000000
--- a/tests/local/gc/gc-subtypes.wat
+++ /dev/null
@@ -1,100 +0,0 @@
-;; --enable-gc
-
-(module
-  (type $a (func))
-  (type $b (sub $a (func)))
-  (type $c (sub $b (func)))
-  (type $b1 (sub final $a (func)))
-
-  ;; struct, ref types, mutability, nullability
-  (type $d (struct))
-  (type $e (sub $d (struct (field (mut (ref null $d)))))) ;; width
-  (type $f (sub final $e (struct (field (ref $e))))) ;; depth
-
-  ;; func
-  (type $g (func (param (ref $e)) (result (ref $e))))
-  (type $h (sub $g (func (param (ref $d)) (result (ref $f)))))
-
-  (type $j (func (param (ref $b)) (result (ref $b))))
-  (type $k (sub $j (func (param (ref $a)) (result (ref $c)))))
-
-  ;; valid: expanded param/result types are equal to those of the parent
-  (type $l (sub $j (func (param (ref $c)) (result (ref $a)))))
-
-  ;; array, val types, ref types, mutability, nullability
-  (type $m (array (mut i32)))
-  (type $n (sub $m (array i32)))
-
-  (type $o (array i32))
-  (type $p (sub $o (array i32)))
-
-  (type $o1 (array i64))
-  (type $p1 (sub $o1 (array i64)))
-
-  ;; any refs
-  (type $q (array (mut anyref)))
-  (type $q0 (sub $q (array (ref any))))
-
-  ;; eq refs
-  (type $q1 (sub $q (array (mut eqref))))
-  (type $q2 (sub $q1 (array (mut (ref eq)))))
-  (type $q3 (sub $q2 (array (ref eq))))
-
-  ;; i31 refs
-  (type $r (sub $q (array i31ref)))
-  (type $r1 (sub $q1 (array i31ref)))
-  (type $s (sub $r (array (ref i31))))
-  (type $s1 (sub $q1 (array (ref i31))))
-  (type $s2 (sub $q2 (array (ref i31))))
-
-  ;; array refs
-  (type $rr (sub $q (array arrayref)))
-  (type $rr1 (sub $q1 (array arrayref)))
-  (type $ss (sub $rr (array (ref array))))
-  (type $ss0 (sub $ss (array (ref $rr))))
-  (type $ss1 (sub $q1 (array (ref array))))
-  (type (sub $q1 (array (ref $rr))))
-  (type $ss2 (sub $q2 (array (ref array))))
-  (type (sub $q2 (array (ref $rr))))
-
-  ;; struct refs
-  (type $rrr (sub $q (array structref)))
-  (type $rrr1 (sub $q1 (array structref)))
-  (type $sss (sub $rrr (array (ref struct))))
-  (type $sss0 (sub $rrr (array (ref null $d))))
-  (type $sss1 (sub $q1 (array (ref struct))))
-  (type (sub $q1 (array (ref $d))))
-  (type $sss2 (sub $q2 (array (ref struct))))
-  (type (sub $q2 (array (ref $d))))
-
-  ;; none refs
-  (type $z1 (sub $q (array (mut nullref))))
-  (type $z2 (sub $q0 (array (ref none))))
-  (type $z3 (sub $z1 (array (mut (ref none)))))
-  (type $z4 (sub $z1 (array nullref)))
-  (type (sub $q1 (array nullref)))
-  (type (sub $r (array nullref)))
-  (type (sub $rr (array nullref)))
-  (type (sub $rrr (array nullref)))
-  (type (sub $q1 (array (ref none))))
-  (type (sub $r (array (ref none))))
-  (type (sub $rr (array (ref none))))
-  (type (sub $rrr (array (ref none))))
-
-  ;; func refs
-  (type $t (array (mut funcref)))
-  (type $u (sub $t (array (ref null func))))
-  (type $v (sub $u (array (ref func))))
-  (type $w (sub $v (array (ref $a))))
-  (type $x (sub $t (array (ref null $a))))
-  (type $y (sub $w (array (ref nofunc))))
-  (type $z (sub $x (array nullfuncref)))
-
-  ;; extern refs
-  (type $t0 (array (mut externref)))
-  (type $u0 (sub $t0 (array (ref null extern))))
-  (type $v0 (sub $u0 (array (ref extern))))
-  (type $y0 (sub $v0 (array (ref noextern))))
-  (type $y01 (sub $u0 (array (ref noextern))))
-  (type $z0 (sub $u0 (array nullexternref)))
-)
diff --git a/tests/local/missing-features/reference-types/function-references.wast b/tests/local/missing-features/reference-types/function-references.wast
deleted file mode 100644
index 1e3dd513..00000000
--- a/tests/local/missing-features/reference-types/function-references.wast
+++ /dev/null
@@ -1,12 +0,0 @@
-(assert_invalid
-  (module (type (func (param (ref func)))))
-  "function references required")
-(assert_invalid
-  (module (type (func (param (ref extern)))))
-  "function references required")
-(assert_invalid
-  (module
-    (type $f (func))
-    (type (func (param (ref $f))))
-  )
-  "function references required")
diff --git a/tests/local/missing-features/reference-types/gc-indexed-types.wast b/tests/local/missing-features/reference-types/gc-indexed-types.wast
deleted file mode 100644
index ff44b094..00000000
--- a/tests/local/missing-features/reference-types/gc-indexed-types.wast
+++ /dev/null
@@ -1,9 +0,0 @@
-(assert_invalid
-  (module (type (array i32)))
-  "array indexed types not supported without the gc feature")
-(assert_invalid
-  (module (type (array i8)))
-  "array indexed types not supported without the gc feature")
-(assert_invalid
-  (module (type (struct)))
-  "struct indexed types not supported without the gc feature")
diff --git a/tests/local/missing-features/reference-types/gc.wast b/tests/local/missing-features/reference-types/gc.wast
deleted file mode 100644
index dd1e45ba..00000000
--- a/tests/local/missing-features/reference-types/gc.wast
+++ /dev/null
@@ -1,30 +0,0 @@
-(assert_invalid
-  (module (type (func (param i31ref))))
-  "heap types not supported without the gc feature")
-(assert_invalid
-  (module (type (func (param anyref))))
-  "heap types not supported without the gc feature")
-(assert_invalid
-  (module (type (func (param (ref none)))))
-  "heap types not supported without the gc feature")
-(assert_invalid
-  (module (type (func (param (ref array)))))
-  "heap types not supported without the gc feature")
-(assert_invalid
-  (module (type (func (param (ref struct)))))
-  "heap types not supported without the gc feature")
-(assert_invalid
-  (module (type (func (param (ref eq)))))
-  "heap types not supported without the gc feature")
-(assert_invalid
-  (module (type (func (param (ref noextern)))))
-  "heap types not supported without the gc feature")
-(assert_invalid
-  (module (type (func (param (ref nofunc)))))
-  "heap types not supported without the gc feature")
-(assert_invalid
-  (module (func (local i31ref)))
-  "heap types not supported without the gc feature")
-(assert_invalid
-  (module (func (block (result i31ref) unreachable)))
-  "heap types not supported without the gc feature")
diff --git a/tests/local/producers.wast b/tests/local/producers.wast
deleted file mode 100644
index 9e29885e..00000000
--- a/tests/local/producers.wast
+++ /dev/null
@@ -1,51 +0,0 @@
-(module
-  (@producers)
-)
-
-(module
-  (@producers
-    (language "foo" "bar")
-  )
-)
-
-(module
-  (@producers
-    (language "foo" "bar")
-    (language "foo" "bar")
-    (sdk "foo" "bar")
-    (processed-by "foo" "bar")
-  )
-)
-
-(module
-  (@producers)
-  (@producers (sdk "foo" "bar"))
-)
-
-(assert_invalid
-  (module quote "(@producers (foo))")
-  "unexpected token")
-
-
-;; invalid is ok
-(module binary
-  "\00asm" "\01\00\00\00"
-
-  "\00"          ;; custom
-  "\0b"          ;; length
-  "\09producers" ;; custom section name
-  "\01"          ;; 1 entry
-)
-
-;; weird name
-(module binary
-  "\00asm" "\01\00\00\00"
-
-  "\00"          ;; custom
-  "\14"          ;; length
-  "\09producers" ;; custom section name
-  "\01"          ;; 1 entry
-  "\03a\na"      ;; name = "a\na"
-  "\01"          ;; 1 field
-  "\01a\01a"     ;; value = "a" version = "a"
-)
diff --git a/tests/local/typed-continuations/cont.wast b/tests/local/typed-continuations/cont.wast
new file mode 100644
index 00000000..8928e7d9
--- /dev/null
+++ b/tests/local/typed-continuations/cont.wast
@@ -0,0 +1,549 @@
+;; Unhandled tags & guards
+
+(module
+  (tag $exn)
+  (tag $e1)
+  (tag $e2)
+
+  (type $f1 (func))
+  (type $k1 (cont $f1))
+
+  (func $f1 (export "unhandled-1")
+    (suspend $e1)
+  )
+
+  (func (export "unhandled-2")
+    (resume (cont.new (type $k1) (ref.func $f1)))
+  )
+
+  (func (export "unhandled-3")
+    (block $h (result (ref $k1))
+      (resume (tag $e2 $h) (cont.new (type $k1) (ref.func $f1)))
+      (unreachable)
+    )
+    (drop)
+  )
+
+  (func (export "handled")
+    (block $h (result (ref $k1))
+      (resume (tag $e1 $h) (cont.new (type $k1) (ref.func $f1)))
+      (unreachable)
+    )
+    (drop)
+  )
+
+  (elem declare func $f2)
+  (func $f2
+    (throw $exn)
+  )
+
+  (func (export "uncaught-1")
+    (block $h (result (ref $k1))
+      (resume (tag $e1 $h) (cont.new (type $k1) (ref.func $f2)))
+      (unreachable)
+    )
+    (drop)
+  )
+
+  (func (export "uncaught-2")
+    (block $h (result (ref $k1))
+      (resume (tag $e1 $h) (cont.new (type $k1) (ref.func $f1)))
+      (unreachable)
+    )
+    (resume_throw $exn)
+  )
+
+  (elem declare func $f3)
+  (func $f3
+    (barrier (call $f4))
+  )
+  (func $f4
+    (suspend $e1)
+  )
+
+  (func (export "barrier")
+    (block $h (result (ref $k1))
+      (resume (tag $e1 $h) (cont.new (type $k1) (ref.func $f3)))
+      (unreachable)
+    )
+    (resume_throw $exn)
+  )
+
+  (elem declare func $r0 $r1)
+  (func $r0)
+  (func $r1 (suspend $e1) (suspend $e1))
+
+  (func $nl1 (param $k (ref $k1))
+    (resume (local.get $k))
+    (resume (local.get $k))
+  )
+  (func $nl2 (param $k (ref $k1))
+    (block $h (result (ref $k1))
+      (resume (tag $e1 $h) (local.get $k))
+      (unreachable)
+    )
+    (resume (local.get $k))
+    (unreachable)
+  )
+  (func $nl3 (param $k (ref $k1))
+    (local $k' (ref null $k1))
+    (block $h1 (result (ref $k1))
+      (resume (tag $e1 $h1) (local.get $k))
+      (unreachable)
+    )
+    (local.set $k')
+    (block $h2 (result (ref $k1))
+      (resume (tag $e1 $h2) (local.get $k'))
+      (unreachable)
+    )
+    (resume (local.get $k'))
+    (unreachable)
+  )
+  (func $nl4 (param $k (ref $k1))
+    (drop (cont.bind (type $k1) (local.get $k)))
+    (resume (local.get $k))
+  )
+
+  (func (export "non-linear-1")
+    (call $nl1 (cont.new (type $k1) (ref.func $r0)))
+  )
+  (func (export "non-linear-2")
+    (call $nl2 (cont.new (type $k1) (ref.func $r1)))
+  )
+  (func (export "non-linear-3")
+    (call $nl3 (cont.new (type $k1) (ref.func $r1)))
+  )
+  (func (export "non-linear-4")
+    (call $nl4 (cont.new (type $k1) (ref.func $r1)))
+  )
+)
+
+(assert_suspension (invoke "unhandled-1") "unhandled")
+(assert_suspension (invoke "unhandled-2") "unhandled")
+(assert_suspension (invoke "unhandled-3") "unhandled")
+(assert_return (invoke "handled"))
+
+;; (assert_exception (invoke "uncaught-1") "unhandled")
+;; (assert_exception (invoke "uncaught-2") "unhandled")
+(assert_exception (invoke "uncaught-1"))
+(assert_exception (invoke "uncaught-2"))
+
+
+(assert_trap (invoke "barrier") "barrier")
+
+(assert_trap (invoke "non-linear-1") "continuation already consumed")
+(assert_trap (invoke "non-linear-2") "continuation already consumed")
+(assert_trap (invoke "non-linear-3") "continuation already consumed")
+(assert_trap (invoke "non-linear-4") "continuation already consumed")
+
+
+;; Simple state example
+
+(module $state
+  (tag $get (result i32))
+  (tag $set (param i32) (result i32))
+
+  (type $f (func (param i32) (result i32)))
+  (type $k (cont $f))
+
+  (func $runner (param $s i32) (param $k (ref $k)) (result i32)
+    (loop $loop
+      (block $on_get (result (ref $k))
+        (block $on_set (result i32 (ref $k))
+          (resume (tag $get $on_get) (tag $set $on_set)
+            (local.get $s) (local.get $k)
+          )
+          (return)
+        )
+        ;; on set
+        (local.set $k)
+        (local.set $s)
+        (br $loop)
+      )
+      ;; on get
+      (local.set $k)
+      (br $loop)
+    )
+    (unreachable)
+  )
+
+  (func $f (param i32) (result i32)
+    (drop (suspend $set (i32.const 7)))
+    (i32.add
+      (suspend $get)
+      (i32.mul
+        (i32.const 2)
+        (i32.add
+          (suspend $set (i32.const 3))
+          (suspend $get)
+        )
+      )
+    )
+  )
+
+  (elem declare func $f)
+  (func (export "run") (result i32)
+    (call $runner (i32.const 0) (cont.new (type $k) (ref.func $f)))
+  )
+)
+
+(assert_return (invoke "run") (i32.const 19))
+
+
+;; Simple generator example
+
+(module $generator
+  (type $gen (func (param i64)))
+  (type $geny (func (param i32)))
+  (type $cont0 (cont $gen))
+  (type $cont (cont $geny))
+
+  (tag $yield (param i64) (result i32))
+
+  ;; Hook for logging purposes
+  (global $hook (export "hook") (mut (ref $gen)) (ref.func $dummy))
+  (func $dummy (param i64))
+
+  (func $gen (export "start") (param $i i64)
+    (loop $l
+      (br_if 1 (suspend $yield (local.get $i)))
+      (call_ref $gen (local.get $i) (global.get $hook))
+      (local.set $i (i64.add (local.get $i) (i64.const 1)))
+      (br $l)
+    )
+  )
+
+  (elem declare func $gen)
+
+  (func (export "sum") (param $i i64) (param $j i64) (result i64)
+    (local $sum i64)
+    (local $n i64)
+    (local $k (ref null $cont))
+    (local.get $i)
+    (cont.new (type $cont0) (ref.func $gen))
+    (block $on_first_yield (param i64 (ref $cont0)) (result i64 (ref $cont))
+      (resume (tag $yield $on_first_yield))
+      (unreachable)
+    )
+    (loop $on_yield (param i64) (param (ref $cont))
+      (local.set $k)
+      (local.set $n)
+      (local.set $sum (i64.add (local.get $sum) (local.get $n)))
+      (i64.eq (local.get $n) (local.get $j))
+      (local.get $k)
+      (resume (tag $yield $on_yield))
+    )
+    (return (local.get $sum))
+  )
+)
+
+(register "generator")
+
+(assert_return (invoke "sum" (i64.const 0) (i64.const 0)) (i64.const 0))
+(assert_return (invoke "sum" (i64.const 2) (i64.const 2)) (i64.const 2))
+(assert_return (invoke "sum" (i64.const 0) (i64.const 3)) (i64.const 6))
+(assert_return (invoke "sum" (i64.const 1) (i64.const 10)) (i64.const 55))
+(assert_return (invoke "sum" (i64.const 100) (i64.const 2000)) (i64.const 1_996_050))
+
+
+;; Simple scheduler example
+
+(module $scheduler
+  (type $proc (func))
+  (type $cont (cont $proc))
+
+  (tag $yield (export "yield"))
+  (tag $spawn (export "spawn") (param (ref $cont)))
+
+  ;; Table as simple queue (keeping it simple, no ring buffer)
+  (table $queue 0 (ref null $cont))
+  (global $qdelta i32 (i32.const 10))
+  (global $qback (mut i32) (i32.const 0))
+  (global $qfront (mut i32) (i32.const 0))
+
+  (func $queue-empty (result i32)
+    (i32.eq (global.get $qfront) (global.get $qback))
+  )
+
+  (func $dequeue (result (ref null $cont))
+    (local $i i32)
+    (if (call $queue-empty)
+      (then (return (ref.null $cont)))
+    )
+    (local.set $i (global.get $qfront))
+    (global.set $qfront (i32.add (local.get $i) (i32.const 1)))
+    (table.get $queue (local.get $i))
+  )
+
+  (func $enqueue (param $k (ref $cont))
+    ;; Check if queue is full
+    (if (i32.eq (global.get $qback) (table.size $queue))
+      (then
+        ;; Check if there is enough space in the front to compact
+        (if (i32.lt_u (global.get $qfront) (global.get $qdelta))
+          (then
+            ;; Space is below threshold, grow table instead
+            (drop (table.grow $queue (ref.null $cont) (global.get $qdelta)))
+          )
+          (else
+            ;; Enough space, move entries up to head of table
+            (global.set $qback (i32.sub (global.get $qback) (global.get $qfront)))
+            (table.copy $queue $queue
+              (i32.const 0)         ;; dest = new front = 0
+              (global.get $qfront)  ;; src = old front
+              (global.get $qback)   ;; len = new back = old back - old front
+            )
+            (table.fill $queue      ;; null out old entries to avoid leaks
+              (global.get $qback)   ;; start = new back
+              (ref.null $cont)      ;; init value
+              (global.get $qfront)  ;; len = old front = old front - new front
+            )
+            (global.set $qfront (i32.const 0))
+          )
+        )
+      )
+    )
+    (table.set $queue (global.get $qback) (local.get $k))
+    (global.set $qback (i32.add (global.get $qback) (i32.const 1)))
+  )
+
+  (func $scheduler (export "scheduler") (param $main (ref $cont))
+    (call $enqueue (local.get $main))
+    (loop $l
+      (if (call $queue-empty) (then (return)))
+      (block $on_yield (result (ref $cont))
+        (block $on_spawn (result (ref $cont) (ref $cont))
+          (resume (tag $yield $on_yield) (tag $spawn $on_spawn)
+            (call $dequeue)
+          )
+          (br $l)  ;; thread terminated
+        )
+        ;; on $spawn, proc and cont on stack
+        (call $enqueue)             ;; continuation of old thread
+        (call $enqueue)             ;; new thread
+        (br $l)
+      )
+      ;; on $yield, cont on stack
+      (call $enqueue)
+      (br $l)
+    )
+  )
+)
+
+(register "scheduler")
+
+(module
+  (type $proc (func))
+  (type $pproc (func (param i32))) ;; parameterised proc
+  (type $cont (cont $proc))
+  (type $pcont (cont $pproc)) ;; parameterised continuation proc
+  (tag $yield (import "scheduler" "yield"))
+  (tag $spawn (import "scheduler" "spawn") (param (ref $cont)))
+  (func $scheduler (import "scheduler" "scheduler") (param $main (ref $cont)))
+
+  (func $log (import "spectest" "print_i32") (param i32))
+
+  (global $width (mut i32) (i32.const 0))
+  (global $depth (mut i32) (i32.const 0))
+
+  (elem declare func $main $thread1 $thread2 $thread3)
+
+  (func $main
+    (call $log (i32.const 0))
+    (suspend $spawn (cont.new (type $cont) (ref.func $thread1)))
+    (call $log (i32.const 1))
+    (suspend $spawn (cont.bind (type $cont) (global.get $depth) (cont.new (type $pcont) (ref.func $thread2))))
+    (call $log (i32.const 2))
+    (suspend $spawn (cont.new (type $cont) (ref.func $thread3)))
+    (call $log (i32.const 3))
+  )
+
+  (func $thread1
+    (call $log (i32.const 10))
+    (suspend $yield)
+    (call $log (i32.const 11))
+    (suspend $yield)
+    (call $log (i32.const 12))
+    (suspend $yield)
+    (call $log (i32.const 13))
+  )
+
+  (func $thread2 (param $d i32)
+    (local $w i32)
+    (local.set $w (global.get $width))
+    (call $log (i32.const 20))
+    (br_if 0 (i32.eqz (local.get $d)))
+    (call $log (i32.const 21))
+    (loop $l
+      (if (local.get $w)
+        (then
+          (call $log (i32.const 22))
+          (suspend $yield)
+          (call $log (i32.const 23))
+          (suspend $spawn
+            (cont.bind (type $cont)
+              (i32.sub (local.get $d) (i32.const 1))
+              (cont.new (type $pcont) (ref.func $thread2))
+            )
+          )
+          (call $log (i32.const 24))
+          (local.set $w (i32.sub (local.get $w) (i32.const 1)))
+          (br $l)
+        )
+      )
+    )
+    (call $log (i32.const 25))
+  )
+
+  (func $thread3
+    (call $log (i32.const 30))
+    (suspend $yield)
+    (call $log (i32.const 31))
+    (suspend $yield)
+    (call $log (i32.const 32))
+  )
+
+  (func (export "run") (param $width i32) (param $depth i32)
+    (global.set $depth (local.get $depth))
+    (global.set $width (local.get $width))
+    (call $log (i32.const -1))
+    (call $scheduler (cont.new (type $cont) (ref.func $main)))
+    (call $log (i32.const -2))
+  )
+)
+
+(assert_return (invoke "run" (i32.const 0) (i32.const 0)))
+(assert_return (invoke "run" (i32.const 0) (i32.const 1)))
+(assert_return (invoke "run" (i32.const 1) (i32.const 0)))
+(assert_return (invoke "run" (i32.const 1) (i32.const 1)))
+(assert_return (invoke "run" (i32.const 3) (i32.const 4)))
+
+
+;; Nested example: generator in a thread
+
+(module $concurrent-generator
+  (func $log (import "spectest" "print_i64") (param i64))
+
+  (tag $syield (import "scheduler" "yield"))
+  (tag $spawn (import "scheduler" "spawn") (param (ref $cont)))
+  (func $scheduler (import "scheduler" "scheduler") (param $main (ref $cont)))
+
+  (type $ghook (func (param i64)))
+  (func $gsum (import "generator" "sum") (param i64 i64) (result i64))
+  (global $ghook (import "generator" "hook") (mut (ref $ghook)))
+
+  (global $result (mut i64) (i64.const 0))
+  (global $done (mut i32) (i32.const 0))
+
+  (elem declare func $main $bg-thread $syield)
+
+  (func $syield (param $i i64)
+    (call $log (local.get $i))
+    (suspend $syield)
+  )
+
+  (func $bg-thread
+    (call $log (i64.const -10))
+    (loop $l
+      (call $log (i64.const -11))
+      (suspend $syield)
+      (br_if $l (i32.eqz (global.get $done)))
+    )
+    (call $log (i64.const -12))
+  )
+
+  (func $main (param $i i64) (param $j i64)
+    (suspend $spawn (cont.new (type $cont) (ref.func $bg-thread)))
+    (global.set $ghook (ref.func $syield))
+    (global.set $result (call $gsum (local.get $i) (local.get $j)))
+    (global.set $done (i32.const 1))
+  )
+
+  (type $proc (func))
+  (type $pproc (func (param i64 i64)))
+  (type $cont (cont $proc))
+  (type $pcont (cont $pproc))
+  (func (export "sum") (param $i i64) (param $j i64) (result i64)
+    (call $log (i64.const -1))
+    (call $scheduler
+      (cont.bind (type $cont) (local.get $i) (local.get $j) (cont.new (type $pcont) (ref.func $main)))
+    )
+    (call $log (i64.const -2))
+    (global.get $result)
+  )
+)
+
+(assert_return (invoke "sum" (i64.const 10) (i64.const 20)) (i64.const 165))
+
+
+;; cont.bind
+
+(module
+  (type $f2 (func (param i32 i32) (result i32 i32 i32 i32 i32 i32)))
+  (type $f4 (func (param i32 i32 i32 i32) (result i32 i32 i32 i32 i32 i32)))
+  (type $f6 (func (param i32 i32 i32 i32 i32 i32) (result i32 i32 i32 i32 i32 i32)))
+
+  (type $k2 (cont $f2))
+  (type $k4 (cont $f4))
+  (type $k6 (cont $f6))
+
+  (elem declare func $f)
+  (func $f (param i32 i32 i32 i32 i32 i32) (result i32 i32 i32 i32 i32 i32)
+    (local.get 0) (local.get 1) (local.get 2)
+    (local.get 3) (local.get 4) (local.get 5)
+  )
+
+  (func (export "run") (result i32 i32 i32 i32 i32 i32)
+    (local $k6 (ref null $k6))
+    (local $k4 (ref null $k4))
+    (local $k2 (ref null $k2))
+    (local.set $k6 (cont.new (type $k6) (ref.func $f)))
+    (local.set $k4 (cont.bind (type $k4) (i32.const 1) (i32.const 2) (local.get $k6)))
+    (local.set $k2 (cont.bind (type $k2) (i32.const 3) (i32.const 4) (local.get $k4)))
+    (resume (i32.const 5) (i32.const 6) (local.get $k2))
+  )
+)
+
+(assert_return (invoke "run")
+  (i32.const 1) (i32.const 2) (i32.const 3)
+  (i32.const 4) (i32.const 5) (i32.const 6)
+)
+
+
+(module
+  (tag $e (result i32 i32 i32 i32 i32 i32))
+
+  (type $f0 (func (result i32 i32 i32 i32 i32 i32 i32)))
+  (type $f2 (func (param i32 i32) (result i32 i32 i32 i32 i32 i32 i32)))
+  (type $f4 (func (param i32 i32 i32 i32) (result i32 i32 i32 i32 i32 i32 i32)))
+  (type $f6 (func (param i32 i32 i32 i32 i32 i32) (result i32 i32 i32 i32 i32 i32 i32)))
+
+  (type $k0 (cont $f0))
+  (type $k2 (cont $f2))
+  (type $k4 (cont $f4))
+  (type $k6 (cont $f6))
+
+  (elem declare func $f)
+  (func $f (result i32 i32 i32 i32 i32 i32 i32)
+    (i32.const 0) (suspend $e)
+  )
+
+  (func (export "run") (result i32 i32 i32 i32 i32 i32 i32)
+    (local $k6 (ref null $k6))
+    (local $k4 (ref null $k4))
+    (local $k2 (ref null $k2))
+    (block $l (result (ref $k6))
+      (resume (tag $e $l) (cont.new (type $k0) (ref.func $f)))
+      (unreachable)
+    )
+    (local.set $k6)
+    (local.set $k4 (cont.bind (type $k4) (i32.const 1) (i32.const 2) (local.get $k6)))
+    (local.set $k2 (cont.bind (type $k2) (i32.const 3) (i32.const 4) (local.get $k4)))
+    (resume (i32.const 5) (i32.const 6) (local.get $k2))
+  )
+)
+
+(assert_return (invoke "run")
+  (i32.const 0) (i32.const 1) (i32.const 2) (i32.const 3)
+  (i32.const 4) (i32.const 5) (i32.const 6)
+)
diff --git a/tests/roundtrip.rs b/tests/roundtrip.rs
index 40f33424..55f4b9e3 100644
--- a/tests/roundtrip.rs
+++ b/tests/roundtrip.rs
@@ -39,7 +39,7 @@ fn main() {
     let filter = std::env::args().nth(1);
     let bless = std::env::var_os("BLESS").is_some();
     if bless {
-        drop(std::fs::remove_dir_all("tests/snapshots"));
+        std::fs::remove_dir_all("tests/snapshots").expect("clear the snapshots directory");
     }
 
     let tests = tests
@@ -66,19 +66,12 @@ fn main() {
     let state = TestState::default();
     let errors = tests
         .par_iter()
-        .filter_map(|(test, contents)| {
-            let start = std::time::Instant::now();
-            let result = state.run_test(test, contents).err();
-            if start.elapsed().as_secs() > 2 {
-                println!("{test:?} SLOW");
-            }
-            result
-        })
+        .filter_map(|(test, contents)| state.run_test(test, contents).err())
         .collect::<Vec<_>>();
 
     if !errors.is_empty() {
         for msg in errors.iter() {
-            eprintln!("{:?}", msg);
+            eprintln!("{:?}\n", msg);
         }
 
         panic!("{} tests failed", errors.len())
@@ -144,17 +137,13 @@ fn skip_test(test: &Path, contents: &[u8]) -> bool {
         "exception-handling/throw.wast",
         // This is an empty file which currently doesn't parse
         "multi-memory/memory_copy1.wast",
-        // the GC proposal isn't implemented yet
-        "gc/gc-array.wat",
-        "gc/gc-rec-sub.wat",
-        "gc/gc-ref.wat",
-        "gc/gc-ref-global-import.wat",
-        "gc/gc-struct.wat",
-        "gc/let.wat",
-        "/proposals/gc/",
     ];
-    let test_path = test.to_str().unwrap().replace("\\", "/"); // for windows paths
-    if broken.iter().any(|x| test_path.contains(x)) {
+    if broken.iter().any(|x| test.ends_with(x)) {
+        return true;
+    }
+
+    // TODO: the gc proposal isn't implemented yet
+    if test.iter().any(|p| p == "gc") {
         return true;
     }
 
@@ -213,11 +202,13 @@ impl TestState {
         // If we can, convert the string back to bytes and assert it has the
         // same binary representation.
         if test_roundtrip {
-            let binary2 =
-                wat::parse_str(&string).context("failed to parse `wat` from `wasmprinter`")?;
+            let binary2 = wat::parse_str(&string)
+                .context("failed to parse `wat` from `wasmprinter`")
+                .context(format!("text:\n{}", string))?;
             self.bump_ntests();
             self.binary_compare(&binary2, contents)
-                .context("failed to compare original `wat` with roundtrip `wat`")?;
+                .context("failed to compare original `wat` with roundtrip `wat`")
+                .context(format!("as parsed:\n{}", string))?;
         }
 
         // Test that the `wasmprinter`-printed bytes have "pretty" whitespace
@@ -231,9 +222,8 @@ impl TestState {
         // which while they don't actually affect the meaning they do "affect"
         // humans reading the output.
         for token in wast::lexer::Lexer::new(&string).allow_confusing_unicode(true) {
-            let token = token?;
-            let ws = match token.kind {
-                wast::lexer::TokenKind::Whitespace => token.src(&string),
+            let ws = match token? {
+                wast::lexer::Token::Whitespace(ws) => ws,
                 _ => continue,
             };
             if ws.starts_with("\n") || ws == " " {
@@ -303,7 +293,7 @@ impl TestState {
     fn test_wast_directive(&self, test: &Path, directive: WastDirective, idx: usize) -> Result<()> {
         // Only test parsing and encoding of modules which wasmparser doesn't
         // support test (basically just test `wast`, nothing else)
-        let skip_verify =
+        let skip_verify = test.iter().any(|t| t == "gc")
             // This specific test contains a module along the lines of:
             //
             //  (module
@@ -316,7 +306,7 @@ impl TestState {
             // segment has a type of `funcref` which isn't compatible with the
             // table's type. The spec interpreter thinks this should validate,
             // however, and I'm not entirely sure why.
-            test.ends_with("function-references/br_table.wast");
+            || test.ends_with("function-references/br_table.wast");
 
         match directive {
             WastDirective::Wat(mut module) => {
@@ -401,7 +391,8 @@ impl TestState {
             | WastDirective::AssertReturn { .. }
             | WastDirective::AssertExhaustion { .. }
             | WastDirective::AssertUnlinkable { .. }
-            | WastDirective::AssertException { .. } => {}
+            | WastDirective::AssertException { .. }
+            | WastDirective::AssertSuspension { .. } => {}
         }
         Ok(())
     }
@@ -573,8 +564,8 @@ impl TestState {
             sign_extension: true,
             mutable_global: true,
             function_references: true,
+            typed_continuations: true,
             memory_control: true,
-            gc: true,
         };
         for part in test.iter().filter_map(|t| t.to_str()) {
             match part {
@@ -589,7 +580,6 @@ impl TestState {
                     features.mutable_global = false;
                     features.bulk_memory = false;
                     features.function_references = false;
-                    features.gc = false;
                 }
                 "floats-disabled.wast" => features.floats = false,
                 "threads" => {
@@ -610,7 +600,6 @@ impl TestState {
                 "function-references" => features.function_references = true,
                 "relaxed-simd" => features.relaxed_simd = true,
                 "reference-types" => features.reference_types = true,
-                "gc" => features.gc = true,
                 _ => {}
             }
         }
diff --git a/tests/snapshots/local/component-model/alias.wast/13.print b/tests/snapshots/local/component-model/alias.wast/13.print
index 93081466..32544d12 100644
--- a/tests/snapshots/local/component-model/alias.wast/13.print
+++ b/tests/snapshots/local/component-model/alias.wast/13.print
@@ -14,11 +14,11 @@
         (type (;3;)
           (component
             (type (;0;) (func (result string)))
-            (import "a" (func (;0;) (type 0)))
+            (import "a" (func (type 0)))
             (type (;1;) (func (result u32)))
-            (import "b" (func (;1;) (type 1)))
+            (import "b" (func (type 1)))
             (type (;2;) (func (result s32)))
-            (import "c" (func (;2;) (type 2)))
+            (import "c" (func (type 2)))
           )
         )
         (import "d" (component $C (;0;) (type 3)))
diff --git a/tests/snapshots/local/component-model/alias.wast/14.print b/tests/snapshots/local/component-model/alias.wast/14.print
index bad29a25..22cc4e5c 100644
--- a/tests/snapshots/local/component-model/alias.wast/14.print
+++ b/tests/snapshots/local/component-model/alias.wast/14.print
@@ -24,7 +24,7 @@
   (type (;1;)
     (component
       (type (;0;) (func))
-      (import "a" (func (;0;) (type 0)))
+      (import "a" (func (type 0)))
     )
   )
   (import "b" (component $b (;0;) (type 1)))
diff --git a/tests/snapshots/local/component-model/export-introduces-alias.wast/1.print b/tests/snapshots/local/component-model/export-introduces-alias.wast/1.print
index 092f9473..2cc5b900 100644
--- a/tests/snapshots/local/component-model/export-introduces-alias.wast/1.print
+++ b/tests/snapshots/local/component-model/export-introduces-alias.wast/1.print
@@ -8,7 +8,7 @@
           (export (;1;) "t" (type (eq 0)))
         )
       )
-      (import "x" (instance (;0;) (type 1)))
+      (import "x" (instance (type 1)))
       (alias export 0 "t" (type (;2;)))
     )
   )
diff --git a/tests/snapshots/local/component-model/export-introduces-alias.wast/2.print b/tests/snapshots/local/component-model/export-introduces-alias.wast/2.print
index 46f213d9..33a6a6c7 100644
--- a/tests/snapshots/local/component-model/export-introduces-alias.wast/2.print
+++ b/tests/snapshots/local/component-model/export-introduces-alias.wast/2.print
@@ -13,8 +13,8 @@
           (export (;0;) "i" (instance (type 0)))
         )
       )
-      (import "x" (instance (;0;) (type 1)))
-      (alias export 0 "i" (instance (;1;)))
+      (import "x" (instance (type 1)))
+      (alias export 0 "i" (instance (;0;)))
       (alias export 1 "t" (type (;2;)))
     )
   )
diff --git a/tests/snapshots/local/component-model/export.wast/7.print b/tests/snapshots/local/component-model/export.wast/7.print
index 19402892..e2870b4c 100644
--- a/tests/snapshots/local/component-model/export.wast/7.print
+++ b/tests/snapshots/local/component-model/export.wast/7.print
@@ -1,5 +1,5 @@
 (component
   (type (;0;) (func))
   (import "a" (func (;0;) (type 0)))
-  (export (;1;) (interface "wasi:http/types@2.0.0") (func 0))
+  (export (;1;) "b" "https://example.com" (func 0))
 )
\ No newline at end of file
diff --git a/tests/snapshots/local/component-model/export.wast/8.print b/tests/snapshots/local/component-model/export.wast/8.print
index ce88c858..3a488087 100644
--- a/tests/snapshots/local/component-model/export.wast/8.print
+++ b/tests/snapshots/local/component-model/export.wast/8.print
@@ -1,5 +1,5 @@
 (component
   (type (;0;) (func))
-  (import (interface "wasi:http/types@2.0.0") (func (;0;) (type 0)))
-  (export (;1;) (interface "wasi:http/types@2.0.0") (func 0))
+  (import "a" (func (;0;) (type 0)))
+  (export (;1;) "b" (func 0))
 )
\ No newline at end of file
diff --git a/tests/snapshots/local/component-model/import.wast/0.print b/tests/snapshots/local/component-model/import.wast/0.print
index c78744c0..6a70b93c 100644
--- a/tests/snapshots/local/component-model/import.wast/0.print
+++ b/tests/snapshots/local/component-model/import.wast/0.print
@@ -17,12 +17,12 @@
       (core type (;0;)
         (module)
       )
-      (import "a" (core module (;0;) (type 0)))
+      (import "a" (core module (type 0)))
       (type (;0;) (func))
       (export (;0;) "b" (func (type 0)))
     )
   )
   (import "d" (component (;0;) (type 3)))
   (type $t (;4;) (func))
-  (import "e" (type (;5;) (eq $t)))
+  (import "e" (type (eq $t)))
 )
\ No newline at end of file
diff --git a/tests/snapshots/local/component-model/import.wast/14.print b/tests/snapshots/local/component-model/import.wast/14.print
index 95fa2297..4846c17d 100644
--- a/tests/snapshots/local/component-model/import.wast/14.print
+++ b/tests/snapshots/local/component-model/import.wast/14.print
@@ -1,22 +1,4 @@
 (component
   (type (;0;) (func))
-  (import (interface "wasi:http/types") (func (;0;) (type 0)))
-  (type (;1;) (func))
-  (import (interface "wasi:http/types@1.0.0") (func (;1;) (type 1)))
-  (type (;2;) (func))
-  (import (interface "wasi:http/types@2.0.0") (func (;2;) (type 2)))
-  (type (;3;) (func))
-  (import (interface "a-b:c-d/e-f@123456.7890.488") (func (;3;) (type 3)))
-  (type (;4;) (func))
-  (import (interface "a:b/c@1.2.3") (func (;4;) (type 4)))
-  (type (;5;) (func))
-  (import (interface "a:b/c@0.0.0") (func (;5;) (type 5)))
-  (type (;6;) (func))
-  (import (interface "a:b/c@0.0.0+abcd") (func (;6;) (type 6)))
-  (type (;7;) (func))
-  (import (interface "a:b/c@0.0.0+abcd-efg") (func (;7;) (type 7)))
-  (type (;8;) (func))
-  (import (interface "a:b/c@0.0.0-abcd+efg") (func (;8;) (type 8)))
-  (type (;9;) (func))
-  (import (interface "a:b/c@0.0.0-abcd.1.2+efg.4.ee.5") (func (;9;) (type 9)))
+  (import "a" "https://example.com" (func (;0;) (type 0)))
 )
\ No newline at end of file
diff --git a/tests/snapshots/local/component-model/import.wast/15.print b/tests/snapshots/local/component-model/import.wast/15.print
new file mode 100644
index 00000000..29a69beb
--- /dev/null
+++ b/tests/snapshots/local/component-model/import.wast/15.print
@@ -0,0 +1,4 @@
+(component
+  (type (;0;) (func))
+  (import "a" (func (;0;) (type 0)))
+)
\ No newline at end of file
diff --git a/tests/snapshots/local/component-model/imports-exports.wast/0.print b/tests/snapshots/local/component-model/imports-exports.wast/0.print
index 82bba876..21f39cd7 100644
--- a/tests/snapshots/local/component-model/imports-exports.wast/0.print
+++ b/tests/snapshots/local/component-model/imports-exports.wast/0.print
@@ -14,7 +14,7 @@
           (export (;0;) "f" (func (type 0)))
         )
       )
-      (import "c" (instance (;0;) (type 0)))
+      (import "c" (instance (type 0)))
       (type (;1;) (func (result string)))
       (export (;0;) "g" (func (type 1)))
     )
diff --git a/tests/snapshots/local/component-model/instance-type.wast/0.print b/tests/snapshots/local/component-model/instance-type.wast/0.print
index 1ce047a1..9f3407f8 100644
--- a/tests/snapshots/local/component-model/instance-type.wast/0.print
+++ b/tests/snapshots/local/component-model/instance-type.wast/0.print
@@ -57,7 +57,7 @@
       (type (;10;)
         (component
           (type (;0;) (func))
-          (import "i1" (func (;0;) (type 0)))
+          (import "i1" (func (type 0)))
         )
       )
       (export (;1;) "c2" (component (type 10)))
@@ -73,16 +73,16 @@
         (component
           (type (;0;) (func))
           (alias outer 1 0 (type (;1;)))
-          (import "i1" (func (;0;) (type 0)))
+          (import "i1" (func (type 0)))
           (type (;2;)
             (component)
           )
-          (import "i2" (component (;0;) (type 2)))
-          (export (;1;) "e1" (func (type 1)))
+          (import "i2" (component (type 2)))
+          (export (;0;) "e1" (func (type 1)))
           (type (;3;)
             (component)
           )
-          (export (;1;) "e2" (component (type 3)))
+          (export (;0;) "e2" (component (type 3)))
         )
       )
       (export (;4;) "c5" (component (type 12)))
diff --git a/tests/snapshots/local/component-model/instance-type.wast/4.print b/tests/snapshots/local/component-model/instance-type.wast/4.print
index 0682ec7b..2bfb5300 100644
--- a/tests/snapshots/local/component-model/instance-type.wast/4.print
+++ b/tests/snapshots/local/component-model/instance-type.wast/4.print
@@ -33,19 +33,19 @@
   (type (;2;)
     (component
       (type (;0;) (func))
-      (import "a" (func (;0;) (type 0)))
+      (import "a" (func (type 0)))
       (alias outer 1 $empty (type (;1;)))
-      (import "b" (func (;1;) (type 1)))
+      (import "b" (func (type 1)))
       (type (;2;) (func (param "c" s32)))
-      (import "c" (func (;2;) (type 2)))
+      (import "c" (func (type 2)))
       (type (;3;) (func (param "d" s32) (result s32)))
-      (import "d" (func (;3;) (type 3)))
+      (import "d" (func (type 3)))
       (type (;4;)
         (instance)
       )
-      (import "h" (instance (;0;) (type 4)))
+      (import "h" (instance (type 4)))
       (alias outer 1 $i (type (;5;)))
-      (import "i" (instance (;1;) (type 5)))
+      (import "i" (instance (type 5)))
       (type (;6;)
         (instance
           (type (;0;) (func))
@@ -56,11 +56,11 @@
           (export (;2;) "c" (func (type 2)))
         )
       )
-      (import "j" (instance (;2;) (type 6)))
+      (import "j" (instance (type 6)))
       (core type (;0;)
         (module)
       )
-      (import "k" (core module (;0;) (type 0)))
+      (import "k" (core module (type 0)))
       (core type (;1;)
         (module
           (type (;0;) (func))
@@ -72,12 +72,12 @@
           (export "b" (func (type 2)))
         )
       )
-      (import "l" (core module (;1;) (type 1)))
+      (import "l" (core module (type 1)))
       (type (;7;) (func))
-      (export (;4;) "m" (func (type 7)))
-      (export (;5;) "n" (func (type 1)))
+      (export (;0;) "m" (func (type 7)))
+      (export (;1;) "n" (func (type 1)))
       (type (;8;) (func (param "f" s32)))
-      (export (;6;) "o" (func (type 8)))
+      (export (;2;) "o" (func (type 8)))
       (type (;9;)
         (instance
           (type (;0;) (func))
@@ -88,7 +88,7 @@
           (export (;2;) "c" (func (type 2)))
         )
       )
-      (export (;3;) "p" (instance (type 9)))
+      (export (;0;) "p" (instance (type 9)))
       (core type (;2;)
         (module
           (type (;0;) (func))
@@ -100,7 +100,7 @@
           (export "b" (func (type 2)))
         )
       )
-      (export (;2;) "q" (core module (type 2)))
+      (export (;0;) "q" (core module (type 2)))
     )
   )
 )
\ No newline at end of file
diff --git a/tests/snapshots/local/component-model/instantiate.wast/1.print b/tests/snapshots/local/component-model/instantiate.wast/1.print
index fb5a0e8d..b55b44d2 100644
--- a/tests/snapshots/local/component-model/instantiate.wast/1.print
+++ b/tests/snapshots/local/component-model/instantiate.wast/1.print
@@ -4,7 +4,7 @@
   (type (;1;)
     (component
       (type (;0;) (func))
-      (import "a" (func (;0;) (type 0)))
+      (import "a" (func (type 0)))
     )
   )
   (import "b" (component $c (;0;) (type 1)))
diff --git a/tests/snapshots/local/component-model/instantiate.wast/10.print b/tests/snapshots/local/component-model/instantiate.wast/10.print
index f65bf73f..a4a27109 100644
--- a/tests/snapshots/local/component-model/instantiate.wast/10.print
+++ b/tests/snapshots/local/component-model/instantiate.wast/10.print
@@ -4,18 +4,18 @@
       (core type (;0;)
         (module)
       )
-      (import "a" (core module (;0;) (type 0)))
+      (import "a" (core module (type 0)))
       (type (;0;) (func))
-      (import "b" (func (;0;) (type 0)))
+      (import "b" (func (type 0)))
       (type (;1;)
         (component)
       )
-      (import "c" (component (;0;) (type 1)))
+      (import "c" (component (type 1)))
       (type (;2;)
         (instance)
       )
-      (import "d" (instance (;0;) (type 2)))
-      (import "e" (value (;0;) string))
+      (import "d" (instance (type 2)))
+      (import "e" (value string))
     )
   )
   (import "a" (component $c (;0;) (type 0)))
diff --git a/tests/snapshots/local/component-model/instantiate.wast/2.print b/tests/snapshots/local/component-model/instantiate.wast/2.print
index af1c57f2..5d89fdd1 100644
--- a/tests/snapshots/local/component-model/instantiate.wast/2.print
+++ b/tests/snapshots/local/component-model/instantiate.wast/2.print
@@ -2,7 +2,7 @@
   (import "a" (value $i (;0;) string))
   (type (;0;)
     (component
-      (import "a" (value (;0;) string))
+      (import "a" (value string))
     )
   )
   (import "b" (component $c (;0;) (type 0)))
diff --git a/tests/snapshots/local/component-model/instantiate.wast/22.print b/tests/snapshots/local/component-model/instantiate.wast/22.print
new file mode 100644
index 00000000..b0af8866
--- /dev/null
+++ b/tests/snapshots/local/component-model/instantiate.wast/22.print
@@ -0,0 +1,25 @@
+(component
+  (type (;0;)
+    (component
+      (core type (;0;)
+        (module
+          (import "" "" (global i32))
+          (type (;0;) (func))
+          (import "" "f" (func (type 0)))
+        )
+      )
+      (import "a" (core module (type 0)))
+    )
+  )
+  (import "a" (component $m (;0;) (type 0)))
+  (core type (;0;)
+    (module
+      (import "" "" (global i32))
+    )
+  )
+  (import "b" (core module $i (;0;) (type 0)))
+  (instance $i (;0;) (instantiate $m
+      (with "a" (core module $i))
+    )
+  )
+)
\ No newline at end of file
diff --git a/tests/snapshots/local/component-model/instantiate.wast/23.print b/tests/snapshots/local/component-model/instantiate.wast/23.print
index b49dad22..ff79aa4b 100644
--- a/tests/snapshots/local/component-model/instantiate.wast/23.print
+++ b/tests/snapshots/local/component-model/instantiate.wast/23.print
@@ -3,18 +3,20 @@
     (component
       (core type (;0;)
         (module
-          (import "" "" (global i32))
           (type (;0;) (func))
-          (import "" "f" (func (type 0)))
+          (export "" (func (type 0)))
         )
       )
-      (import "a" (core module (;0;) (type 0)))
+      (import "a" (core module (type 0)))
     )
   )
   (import "a" (component $m (;0;) (type 0)))
   (core type (;0;)
     (module
-      (import "" "" (global i32))
+      (type (;0;) (func))
+      (export "" (func (type 0)))
+      (type (;1;) (func))
+      (export "a" (func (type 1)))
     )
   )
   (import "b" (core module $i (;0;) (type 0)))
diff --git a/tests/snapshots/local/component-model/instantiate.wast/24.print b/tests/snapshots/local/component-model/instantiate.wast/24.print
index 5d0a5ead..cb1b4ad7 100644
--- a/tests/snapshots/local/component-model/instantiate.wast/24.print
+++ b/tests/snapshots/local/component-model/instantiate.wast/24.print
@@ -1,27 +1,27 @@
 (component
   (type (;0;)
     (component
-      (core type (;0;)
-        (module
+      (type (;0;)
+        (instance
           (type (;0;) (func))
-          (export "" (func (type 0)))
+          (export (;0;) "a" (func (type 0)))
         )
       )
-      (import "a" (core module (;0;) (type 0)))
+      (import "a" (instance (type 0)))
     )
   )
   (import "a" (component $m (;0;) (type 0)))
-  (core type (;0;)
-    (module
+  (type (;1;)
+    (instance
       (type (;0;) (func))
-      (export "" (func (type 0)))
+      (export (;0;) "a" (func (type 0)))
       (type (;1;) (func))
-      (export "a" (func (type 1)))
+      (export (;1;) "b" (func (type 1)))
     )
   )
-  (import "b" (core module $i (;0;) (type 0)))
-  (instance $i (;0;) (instantiate $m
-      (with "a" (core module $i))
+  (import "b" (instance $i (;0;) (type 1)))
+  (instance (;1;) (instantiate $m
+      (with "a" (instance $i))
     )
   )
 )
\ No newline at end of file
diff --git a/tests/snapshots/local/component-model/instantiate.wast/25.print b/tests/snapshots/local/component-model/instantiate.wast/25.print
deleted file mode 100644
index 763ef616..00000000
--- a/tests/snapshots/local/component-model/instantiate.wast/25.print
+++ /dev/null
@@ -1,27 +0,0 @@
-(component
-  (type (;0;)
-    (component
-      (type (;0;)
-        (instance
-          (type (;0;) (func))
-          (export (;0;) "a" (func (type 0)))
-        )
-      )
-      (import "a" (instance (;0;) (type 0)))
-    )
-  )
-  (import "a" (component $m (;0;) (type 0)))
-  (type (;1;)
-    (instance
-      (type (;0;) (func))
-      (export (;0;) "a" (func (type 0)))
-      (type (;1;) (func))
-      (export (;1;) "b" (func (type 1)))
-    )
-  )
-  (import "b" (instance $i (;0;) (type 1)))
-  (instance (;1;) (instantiate $m
-      (with "a" (instance $i))
-    )
-  )
-)
\ No newline at end of file
diff --git a/tests/snapshots/local/component-model/instantiate.wast/3.print b/tests/snapshots/local/component-model/instantiate.wast/3.print
index 27da9d7e..a1822fb7 100644
--- a/tests/snapshots/local/component-model/instantiate.wast/3.print
+++ b/tests/snapshots/local/component-model/instantiate.wast/3.print
@@ -8,7 +8,7 @@
       (type (;0;)
         (component)
       )
-      (import "a" (component (;0;) (type 0)))
+      (import "a" (component (type 0)))
     )
   )
   (import "b" (component $c (;1;) (type 1)))
diff --git a/tests/snapshots/local/component-model/instantiate.wast/37.print b/tests/snapshots/local/component-model/instantiate.wast/35.print
similarity index 100%
rename from tests/snapshots/local/component-model/instantiate.wast/37.print
rename to tests/snapshots/local/component-model/instantiate.wast/35.print
diff --git a/tests/snapshots/local/component-model/instantiate.wast/4.print b/tests/snapshots/local/component-model/instantiate.wast/4.print
index 3f25b3c9..a3596b80 100644
--- a/tests/snapshots/local/component-model/instantiate.wast/4.print
+++ b/tests/snapshots/local/component-model/instantiate.wast/4.print
@@ -8,7 +8,7 @@
       (core type (;0;)
         (module)
       )
-      (import "a" (core module (;0;) (type 0)))
+      (import "a" (core module (type 0)))
     )
   )
   (import "b" (component $c (;0;) (type 0)))
diff --git a/tests/snapshots/local/component-model/instantiate.wast/5.print b/tests/snapshots/local/component-model/instantiate.wast/5.print
index b149c932..2ac9209a 100644
--- a/tests/snapshots/local/component-model/instantiate.wast/5.print
+++ b/tests/snapshots/local/component-model/instantiate.wast/5.print
@@ -8,7 +8,7 @@
       (type (;0;)
         (instance)
       )
-      (import "a" (instance (;0;) (type 0)))
+      (import "a" (instance (type 0)))
     )
   )
   (import "b" (component $c (;0;) (type 1)))
diff --git a/tests/snapshots/local/component-model/instantiate.wast/59.print b/tests/snapshots/local/component-model/instantiate.wast/57.print
similarity index 100%
rename from tests/snapshots/local/component-model/instantiate.wast/59.print
rename to tests/snapshots/local/component-model/instantiate.wast/57.print
diff --git a/tests/snapshots/local/component-model/instantiate.wast/60.print b/tests/snapshots/local/component-model/instantiate.wast/58.print
similarity index 100%
rename from tests/snapshots/local/component-model/instantiate.wast/60.print
rename to tests/snapshots/local/component-model/instantiate.wast/58.print
diff --git a/tests/snapshots/local/component-model/instantiate.wast/65.print b/tests/snapshots/local/component-model/instantiate.wast/63.print
similarity index 69%
rename from tests/snapshots/local/component-model/instantiate.wast/65.print
rename to tests/snapshots/local/component-model/instantiate.wast/63.print
index aeab4b3b..027ae55c 100644
--- a/tests/snapshots/local/component-model/instantiate.wast/65.print
+++ b/tests/snapshots/local/component-model/instantiate.wast/63.print
@@ -1,9 +1,9 @@
 (component
   (type (;0;) (tuple u32 u32))
-  (import "a" (type (;1;) (eq 0)))
+  (import "a" (type (eq 0)))
   (component (;0;)
     (type (;0;) (tuple u32 u32))
-    (import "a" (type (;1;) (eq 0)))
+    (import "a" (type (eq 0)))
   )
   (instance (;0;) (instantiate 0
       (with "a" (type 1))
diff --git a/tests/snapshots/local/component-model/instantiate.wast/67.print b/tests/snapshots/local/component-model/instantiate.wast/67.print
deleted file mode 100644
index 6d3344a9..00000000
--- a/tests/snapshots/local/component-model/instantiate.wast/67.print
+++ /dev/null
@@ -1,20 +0,0 @@
-(component
-  (core module $a (;0;)
-    (import "" "" (table (;0;) 0 funcref))
-    (table (;1;) 2 funcref)
-    (export "x" (table 1))
-  )
-  (component $C (;0;)
-    (core type (;0;)
-      (module
-        (import "" "" (table 1 funcref))
-        (export "x" (table 1 funcref))
-      )
-    )
-    (import "a" (core module (;0;) (type 0)))
-  )
-  (instance (;0;) (instantiate $C
-      (with "a" (core module $a))
-    )
-  )
-)
\ No newline at end of file
diff --git a/tests/snapshots/local/component-model/instantiate.wast/68.print b/tests/snapshots/local/component-model/instantiate.wast/68.print
deleted file mode 100644
index 3971ee43..00000000
--- a/tests/snapshots/local/component-model/instantiate.wast/68.print
+++ /dev/null
@@ -1,28 +0,0 @@
-(component
-  (core module $a1 (;0;)
-    (import "" "" (memory (;0;) 0))
-  )
-  (core module $a2 (;1;)
-    (memory (;0;) 2)
-    (export "x" (memory 0))
-  )
-  (component $C (;0;)
-    (core type (;0;)
-      (module
-        (import "" "" (memory 1))
-      )
-    )
-    (import "a1" (core module (;0;) (type 0)))
-    (core type (;1;)
-      (module
-        (export "x" (memory 1))
-      )
-    )
-    (import "a2" (core module (;1;) (type 1)))
-  )
-  (instance (;0;) (instantiate $C
-      (with "a1" (core module $a1))
-      (with "a2" (core module $a2))
-    )
-  )
-)
\ No newline at end of file
diff --git a/tests/snapshots/local/component-model/instantiate.wast/9.print b/tests/snapshots/local/component-model/instantiate.wast/9.print
index 9646eb3a..3446f838 100644
--- a/tests/snapshots/local/component-model/instantiate.wast/9.print
+++ b/tests/snapshots/local/component-model/instantiate.wast/9.print
@@ -9,7 +9,7 @@
           (export (;0;) "a" (core module (type 0)))
         )
       )
-      (import "a" (instance (;0;) (type 0)))
+      (import "a" (instance (type 0)))
     )
   )
   (import "a" (component $m (;0;) (type 0)))
diff --git a/tests/snapshots/local/component-model/module-link.wast/1.print b/tests/snapshots/local/component-model/module-link.wast/1.print
index 54a5911b..decdb632 100644
--- a/tests/snapshots/local/component-model/module-link.wast/1.print
+++ b/tests/snapshots/local/component-model/module-link.wast/1.print
@@ -27,7 +27,7 @@
     (type (;1;)
       (component
         (alias outer $B $Wasi (type (;0;)))
-        (import "wasi" (instance (;0;) (type 0)))
+        (import "wasi" (instance (type 0)))
         (type (;1;) (func))
         (export (;0;) "a" (func (type 1)))
       )
@@ -80,7 +80,7 @@
     (type (;1;)
       (component
         (alias outer $C $Wasi (type (;0;)))
-        (import "wasi" (instance (;0;) (type 0)))
+        (import "wasi" (instance (type 0)))
         (type (;1;) (func))
         (export (;0;) "b" (func (type 1)))
       )
@@ -116,7 +116,7 @@
     (type (;1;)
       (component
         (alias outer $D $Wasi (type (;0;)))
-        (import "wasi" (instance (;0;) (type 0)))
+        (import "wasi" (instance (type 0)))
         (type (;1;) (func))
         (export (;0;) "c" (func (type 1)))
       )
diff --git a/tests/snapshots/local/component-model/naming.wast/0.print b/tests/snapshots/local/component-model/naming.wast/0.print
deleted file mode 100644
index 29425ffb..00000000
--- a/tests/snapshots/local/component-model/naming.wast/0.print
+++ /dev/null
@@ -1,9 +0,0 @@
-(component
-  (type (;0;) (func))
-  (import "a" (func (;0;) (type 0)))
-  (component (;0;))
-  (instance (;0;) (instantiate 0
-      (with "NotKebab-Case" (func 0))
-    )
-  )
-)
\ No newline at end of file
diff --git a/tests/snapshots/local/component-model/resources.wast/0.print b/tests/snapshots/local/component-model/resources.wast/0.print
deleted file mode 100644
index bd774ff1..00000000
--- a/tests/snapshots/local/component-model/resources.wast/0.print
+++ /dev/null
@@ -1,3 +0,0 @@
-(component
-  (type $x (;0;) (resource (rep i32)))
-)
\ No newline at end of file
diff --git a/tests/snapshots/local/component-model/resources.wast/1.print b/tests/snapshots/local/component-model/resources.wast/1.print
deleted file mode 100644
index a0846300..00000000
--- a/tests/snapshots/local/component-model/resources.wast/1.print
+++ /dev/null
@@ -1,6 +0,0 @@
-(component
-  (type $x (;0;) (resource (rep i32)))
-  (core func (;0;) (canon resource.new $x))
-  (core func (;1;) (canon resource.rep $x))
-  (core func (;2;) (canon resource.drop $x))
-)
\ No newline at end of file
diff --git a/tests/snapshots/local/component-model/resources.wast/100.print b/tests/snapshots/local/component-model/resources.wast/100.print
deleted file mode 100644
index 60e719b8..00000000
--- a/tests/snapshots/local/component-model/resources.wast/100.print
+++ /dev/null
@@ -1,10 +0,0 @@
-(component
-  (import "b" (type $T (;0;) (sub resource)))
-  (type (;1;) (borrow $T))
-  (type (;2;) (func (param "self" 1)))
-  (import "f" (func $f (;0;) (type 2)))
-  (export $c (;3;) "c" (type $T))
-  (type (;4;) (borrow $c))
-  (type (;5;) (func (param "self" 4)))
-  (export (;1;) "[method]c.foo" (func $f) (func (type 5)))
-)
\ No newline at end of file
diff --git a/tests/snapshots/local/component-model/resources.wast/104.print b/tests/snapshots/local/component-model/resources.wast/104.print
deleted file mode 100644
index 3277a8a2..00000000
--- a/tests/snapshots/local/component-model/resources.wast/104.print
+++ /dev/null
@@ -1,7 +0,0 @@
-(component
-  (component $C (;0;))
-  (instance (;0;) (instantiate $C
-      (with "this is not kebab case" (component $C))
-    )
-  )
-)
\ No newline at end of file
diff --git a/tests/snapshots/local/component-model/resources.wast/105.print b/tests/snapshots/local/component-model/resources.wast/105.print
deleted file mode 100644
index 4af1dd0f..00000000
--- a/tests/snapshots/local/component-model/resources.wast/105.print
+++ /dev/null
@@ -1,7 +0,0 @@
-(component
-  (component $C (;0;))
-  (instance (;0;) (instantiate $C
-      (with "[method]foo.bar" (component $C))
-    )
-  )
-)
\ No newline at end of file
diff --git a/tests/snapshots/local/component-model/resources.wast/106.print b/tests/snapshots/local/component-model/resources.wast/106.print
deleted file mode 100644
index 86b57d1b..00000000
--- a/tests/snapshots/local/component-model/resources.wast/106.print
+++ /dev/null
@@ -1,53 +0,0 @@
-(component
-  (component $C (;0;)
-    (import "in" (type $r (;0;) (sub resource)))
-    (export (;1;) "out" (type $r))
-  )
-  (type $r (;0;) (resource (rep i32)))
-  (instance $c1 (;0;) (instantiate $C
-      (with "in" (type $r))
-    )
-  )
-  (alias export $c1 "out" (type (;1;)))
-  (instance $c2 (;1;) (instantiate $C
-      (with "in" (type 1))
-    )
-  )
-  (alias export $c2 "out" (type (;2;)))
-  (instance $c3 (;2;) (instantiate $C
-      (with "in" (type 2))
-    )
-  )
-  (alias export $c3 "out" (type (;3;)))
-  (instance $c4 (;3;) (instantiate $C
-      (with "in" (type 3))
-    )
-  )
-  (alias export $c4 "out" (type (;4;)))
-  (instance $c5 (;4;) (instantiate $C
-      (with "in" (type 4))
-    )
-  )
-  (component $C2 (;1;)
-    (import "in1" (type $r (;0;) (sub resource)))
-    (import "in2" (type (;1;) (eq $r)))
-    (import "in3" (type (;2;) (eq $r)))
-    (import "in4" (type (;3;) (eq $r)))
-    (import "in5" (type (;4;) (eq $r)))
-    (import "in6" (type (;5;) (eq $r)))
-  )
-  (alias export $c1 "out" (type (;5;)))
-  (alias export $c2 "out" (type (;6;)))
-  (alias export $c3 "out" (type (;7;)))
-  (alias export $c4 "out" (type (;8;)))
-  (alias export $c5 "out" (type (;9;)))
-  (instance (;5;) (instantiate $C2
-      (with "in1" (type $r))
-      (with "in2" (type 5))
-      (with "in3" (type 6))
-      (with "in4" (type 7))
-      (with "in5" (type 8))
-      (with "in6" (type 9))
-    )
-  )
-)
\ No newline at end of file
diff --git a/tests/snapshots/local/component-model/resources.wast/108.print b/tests/snapshots/local/component-model/resources.wast/108.print
deleted file mode 100644
index fa0a26ec..00000000
--- a/tests/snapshots/local/component-model/resources.wast/108.print
+++ /dev/null
@@ -1,22 +0,0 @@
-(component
-  (type (;0;)
-    (component
-      (type (;0;)
-        (instance
-          (export (;0;) "r" (type (sub resource)))
-        )
-      )
-      (export (;0;) "t" (instance (type 0)))
-      (alias export 0 "r" (type (;1;)))
-      (type (;2;)
-        (instance
-          (alias outer 1 1 (type (;0;)))
-          (export (;1;) "r2" (type (eq 0)))
-          (export (;2;) "r" (type (sub resource)))
-        )
-      )
-      (export (;1;) "t2" (instance (type 2)))
-    )
-  )
-  (export (;1;) "x" (type 0))
-)
\ No newline at end of file
diff --git a/tests/snapshots/local/component-model/resources.wast/109.print b/tests/snapshots/local/component-model/resources.wast/109.print
deleted file mode 100644
index 6662df03..00000000
--- a/tests/snapshots/local/component-model/resources.wast/109.print
+++ /dev/null
@@ -1,14 +0,0 @@
-(component
-  (type (;0;)
-    (component
-      (type (;0;)
-        (instance
-          (export (;0;) "bar" (type (sub resource)))
-          (type (;1;) (func))
-          (export (;0;) "[static]bar.a" (func (type 1)))
-        )
-      )
-      (export (;0;) "x" (instance (type 0)))
-    )
-  )
-)
\ No newline at end of file
diff --git a/tests/snapshots/local/component-model/resources.wast/19.print b/tests/snapshots/local/component-model/resources.wast/19.print
deleted file mode 100644
index 08a62d41..00000000
--- a/tests/snapshots/local/component-model/resources.wast/19.print
+++ /dev/null
@@ -1,9 +0,0 @@
-(component
-  (type (;0;)
-    (component
-      (import "x" (type (;0;) (sub resource)))
-      (export (;1;) "y" (type (eq 0)))
-      (export (;2;) "z" (type (sub resource)))
-    )
-  )
-)
\ No newline at end of file
diff --git a/tests/snapshots/local/component-model/resources.wast/2.print b/tests/snapshots/local/component-model/resources.wast/2.print
deleted file mode 100644
index e5a6cb1e..00000000
--- a/tests/snapshots/local/component-model/resources.wast/2.print
+++ /dev/null
@@ -1,4 +0,0 @@
-(component
-  (import "x" (type $x (;0;) (sub resource)))
-  (core func (;0;) (canon resource.drop $x))
-)
\ No newline at end of file
diff --git a/tests/snapshots/local/component-model/resources.wast/22.print b/tests/snapshots/local/component-model/resources.wast/22.print
deleted file mode 100644
index bc99af6f..00000000
--- a/tests/snapshots/local/component-model/resources.wast/22.print
+++ /dev/null
@@ -1,19 +0,0 @@
-(component
-  (type (;0;)
-    (component
-      (type (;0;)
-        (instance
-          (export (;0;) "t" (type (sub resource)))
-          (type (;1;) (own 0))
-          (type (;2;) (func (result "x" 1)))
-          (export (;0;) "f" (func (type 2)))
-        )
-      )
-      (import "x" (instance (;0;) (type 0)))
-      (alias export 0 "t" (type (;1;)))
-      (type (;2;) (own 1))
-      (type (;3;) (func (result "x" 2)))
-      (export (;0;) "f" (func (type 3)))
-    )
-  )
-)
\ No newline at end of file
diff --git a/tests/snapshots/local/component-model/resources.wast/23.print b/tests/snapshots/local/component-model/resources.wast/23.print
deleted file mode 100644
index 13418057..00000000
--- a/tests/snapshots/local/component-model/resources.wast/23.print
+++ /dev/null
@@ -1,17 +0,0 @@
-(component
-  (type (;0;)
-    (instance
-      (type (;0;)
-        (instance
-          (export (;0;) "file" (type (sub resource)))
-        )
-      )
-      (export (;0;) "fs" (instance (type 0)))
-      (alias export 0 "file" (type (;1;)))
-      (type (;2;) (borrow 1))
-      (type (;3;) (func (param "f" 2)))
-      (export (;0;) "fancy-op" (func (type 3)))
-    )
-  )
-  (import "fancy-fs" (instance $fancy-fs (;0;) (type 0)))
-)
\ No newline at end of file
diff --git a/tests/snapshots/local/component-model/resources.wast/24.print b/tests/snapshots/local/component-model/resources.wast/24.print
deleted file mode 100644
index abae41f6..00000000
--- a/tests/snapshots/local/component-model/resources.wast/24.print
+++ /dev/null
@@ -1,33 +0,0 @@
-(component $C
-  (type (;0;) (tuple string bool))
-  (type $T (;1;) (list 0))
-  (type $U (;2;) (option $T))
-  (type (;3;) (list $T))
-  (type $G (;4;) (func (param "x" 3) (result $U)))
-  (type $D (;5;)
-    (component
-      (alias outer $C $T (type (;0;)))
-      (type (;1;) (list 0))
-      (type (;2;) (list u8))
-      (type (;3;) (func (param "x" 1) (result 2)))
-      (import "f" (func (;0;) (type 3)))
-      (alias outer $C $G (type (;4;)))
-      (import "g" (func (;1;) (type 4)))
-      (export (;2;) "g2" (func (type 4)))
-      (alias outer $C $U (type (;5;)))
-      (type (;6;) (func (result 5)))
-      (export (;3;) "h" (func (type 6)))
-      (import "T" (type (;7;) (sub resource)))
-      (type (;8;) (own 7))
-      (type (;9;) (list 8))
-      (type (;10;) (func (param "x" 9)))
-      (import "i" (func (;4;) (type 10)))
-      (export (;11;) "T2" (type (eq 7)))
-      (export (;12;) "U" (type (sub resource)))
-      (type (;13;) (borrow 11))
-      (type (;14;) (own 12))
-      (type (;15;) (func (param "x" 13) (result 14)))
-      (export (;5;) "j" (func (type 15)))
-    )
-  )
-)
\ No newline at end of file
diff --git a/tests/snapshots/local/component-model/resources.wast/25.print b/tests/snapshots/local/component-model/resources.wast/25.print
deleted file mode 100644
index 4f05df73..00000000
--- a/tests/snapshots/local/component-model/resources.wast/25.print
+++ /dev/null
@@ -1,4 +0,0 @@
-(component
-  (import "T1" (type $T1 (;0;) (sub resource)))
-  (import "T2" (type $T2 (;1;) (sub resource)))
-)
\ No newline at end of file
diff --git a/tests/snapshots/local/component-model/resources.wast/26.print b/tests/snapshots/local/component-model/resources.wast/26.print
deleted file mode 100644
index b8ad78ec..00000000
--- a/tests/snapshots/local/component-model/resources.wast/26.print
+++ /dev/null
@@ -1,11 +0,0 @@
-(component $C
-  (import "T1" (type $T1 (;0;) (sub resource)))
-  (import "T2" (type $T2 (;1;) (sub resource)))
-  (import "T3" (type $T3 (;2;) (eq $T2)))
-  (type (;3;) (own $T1))
-  (type $ListT1 (;4;) (list 3))
-  (type (;5;) (own $T2))
-  (type $ListT2 (;6;) (list 5))
-  (type (;7;) (own $T3))
-  (type $ListT3 (;8;) (list 7))
-)
\ No newline at end of file
diff --git a/tests/snapshots/local/component-model/resources.wast/27.print b/tests/snapshots/local/component-model/resources.wast/27.print
deleted file mode 100644
index f3a96193..00000000
--- a/tests/snapshots/local/component-model/resources.wast/27.print
+++ /dev/null
@@ -1,16 +0,0 @@
-(component
-  (import "T" (type $T (;0;) (sub resource)))
-  (import "U" (type $U (;1;) (sub resource)))
-  (type $Own1 (;2;) (own $T))
-  (type $Own2 (;3;) (own $T))
-  (type $Own3 (;4;) (own $U))
-  (type $ListOwn1 (;5;) (list $Own1))
-  (type $ListOwn2 (;6;) (list $Own2))
-  (type $ListOwn3 (;7;) (list $Own3))
-  (type $Borrow1 (;8;) (borrow $T))
-  (type $Borrow2 (;9;) (borrow $T))
-  (type $Borrow3 (;10;) (borrow $U))
-  (type $ListBorrow1 (;11;) (list $Borrow1))
-  (type $ListBorrow2 (;12;) (list $Borrow2))
-  (type $ListBorrow3 (;13;) (list $Borrow3))
-)
\ No newline at end of file
diff --git a/tests/snapshots/local/component-model/resources.wast/28.print b/tests/snapshots/local/component-model/resources.wast/28.print
deleted file mode 100644
index 907c9244..00000000
--- a/tests/snapshots/local/component-model/resources.wast/28.print
+++ /dev/null
@@ -1,14 +0,0 @@
-(component
-  (type (;0;)
-    (component
-      (export (;0;) "T1" (type (sub resource)))
-      (export (;1;) "T2" (type (sub resource)))
-      (export (;2;) "T3" (type (eq 1)))
-    )
-  )
-  (import "C" (component $C (;0;) (type 0)))
-  (instance $c (;0;) (instantiate $C))
-  (alias export $c "T1" (type $T1 (;1;)))
-  (alias export $c "T2" (type $T2 (;2;)))
-  (alias export $c "T3" (type $T3 (;3;)))
-)
\ No newline at end of file
diff --git a/tests/snapshots/local/component-model/resources.wast/29.print b/tests/snapshots/local/component-model/resources.wast/29.print
deleted file mode 100644
index 855c66d8..00000000
--- a/tests/snapshots/local/component-model/resources.wast/29.print
+++ /dev/null
@@ -1,14 +0,0 @@
-(component
-  (component $C (;0;)
-    (type $r1 (;0;) (resource (rep i32)))
-    (type $r2 (;1;) (resource (rep i32)))
-    (export (;2;) "r1" (type $r1))
-    (export (;3;) "r2" (type $r2))
-  )
-  (instance $c1 (;0;) (instantiate $C))
-  (instance $c2 (;1;) (instantiate $C))
-  (alias export $c1 "r1" (type $c1r1 (;0;)))
-  (alias export $c1 "r2" (type $c1r2 (;1;)))
-  (alias export $c2 "r1" (type $c2r1 (;2;)))
-  (alias export $c2 "r2" (type $c2r2 (;3;)))
-)
\ No newline at end of file
diff --git a/tests/snapshots/local/component-model/resources.wast/3.print b/tests/snapshots/local/component-model/resources.wast/3.print
deleted file mode 100644
index b1aaacf5..00000000
--- a/tests/snapshots/local/component-model/resources.wast/3.print
+++ /dev/null
@@ -1,11 +0,0 @@
-(component
-  (core module $m (;0;)
-    (type (;0;) (func (param i32)))
-    (func (;0;) (type 0) (param i32))
-    (export "dtor" (func 0))
-  )
-  (core instance $m (;0;) (instantiate $m))
-  (alias core export $m "dtor" (core func (;0;)))
-  (type $x (;0;) (resource (rep i32) (dtor (func 0))))
-  (core func (;1;) (canon resource.new $x))
-)
\ No newline at end of file
diff --git a/tests/snapshots/local/component-model/resources.wast/30.print b/tests/snapshots/local/component-model/resources.wast/30.print
deleted file mode 100644
index b3057267..00000000
--- a/tests/snapshots/local/component-model/resources.wast/30.print
+++ /dev/null
@@ -1,5 +0,0 @@
-(component
-  (type $r (;0;) (resource (rep i32)))
-  (export (;1;) "r1" (type $r))
-  (export (;2;) "r2" (type $r))
-)
\ No newline at end of file
diff --git a/tests/snapshots/local/component-model/resources.wast/31.print b/tests/snapshots/local/component-model/resources.wast/31.print
deleted file mode 100644
index 4609e789..00000000
--- a/tests/snapshots/local/component-model/resources.wast/31.print
+++ /dev/null
@@ -1,8 +0,0 @@
-(component
-  (type (;0;)
-    (component
-      (export (;0;) "r1" (type (sub resource)))
-      (export (;1;) "r2" (type (sub resource)))
-    )
-  )
-)
\ No newline at end of file
diff --git a/tests/snapshots/local/component-model/resources.wast/32.print b/tests/snapshots/local/component-model/resources.wast/32.print
deleted file mode 100644
index b42a70b5..00000000
--- a/tests/snapshots/local/component-model/resources.wast/32.print
+++ /dev/null
@@ -1,5 +0,0 @@
-(component
-  (type $r (;0;) (resource (rep i32)))
-  (export $r1 (;1;) "r1" (type $r))
-  (export (;2;) "r2" (type $r1))
-)
\ No newline at end of file
diff --git a/tests/snapshots/local/component-model/resources.wast/33.print b/tests/snapshots/local/component-model/resources.wast/33.print
deleted file mode 100644
index d92b7292..00000000
--- a/tests/snapshots/local/component-model/resources.wast/33.print
+++ /dev/null
@@ -1,8 +0,0 @@
-(component
-  (type (;0;)
-    (component
-      (export (;0;) "r1" (type (sub resource)))
-      (export (;1;) "r2" (type (eq 0)))
-    )
-  )
-)
\ No newline at end of file
diff --git a/tests/snapshots/local/component-model/resources.wast/34.print b/tests/snapshots/local/component-model/resources.wast/34.print
deleted file mode 100644
index aeb37ae2..00000000
--- a/tests/snapshots/local/component-model/resources.wast/34.print
+++ /dev/null
@@ -1,31 +0,0 @@
-(component $P
-  (type (;0;)
-    (component
-      (import "T" (type (;0;) (sub resource)))
-      (type (;1;) (own 0))
-      (type (;2;) (func (param "t" 1)))
-      (export (;0;) "foo" (func (type 2)))
-    )
-  )
-  (import "C1" (component $C1 (;0;) (type 0)))
-  (type (;1;)
-    (component
-      (import "T" (type (;0;) (sub resource)))
-      (type (;1;) (own 0))
-      (type (;2;) (func (param "t" 1)))
-      (import "foo" (func (;0;) (type 2)))
-    )
-  )
-  (import "C2" (component $C2 (;1;) (type 1)))
-  (type $R (;2;) (resource (rep i32)))
-  (instance $c1 (;0;) (instantiate $C1
-      (with "T" (type $R))
-    )
-  )
-  (alias export $c1 "foo" (func (;0;)))
-  (instance $c2 (;1;) (instantiate $C2
-      (with "T" (type $R))
-      (with "foo" (func 0))
-    )
-  )
-)
\ No newline at end of file
diff --git a/tests/snapshots/local/component-model/resources.wast/35.print b/tests/snapshots/local/component-model/resources.wast/35.print
deleted file mode 100644
index ad6e67db..00000000
--- a/tests/snapshots/local/component-model/resources.wast/35.print
+++ /dev/null
@@ -1,37 +0,0 @@
-(component
-  (type (;0;)
-    (component
-      (import "T1" (type (;0;) (sub resource)))
-      (import "T2" (type (;1;) (sub resource)))
-      (type (;2;) (own 0))
-      (type (;3;) (own 1))
-      (type (;4;) (tuple 2 3))
-      (type (;5;) (func (param "t" 4)))
-      (export (;0;) "foo" (func (type 5)))
-    )
-  )
-  (import "C1" (component $C1 (;0;) (type 0)))
-  (type (;1;)
-    (component
-      (import "T" (type (;0;) (sub resource)))
-      (type (;1;) (own 0))
-      (type (;2;) (own 0))
-      (type (;3;) (tuple 1 2))
-      (type (;4;) (func (param "t" 3)))
-      (export (;0;) "foo" (func (type 4)))
-    )
-  )
-  (import "C2" (component $C2 (;1;) (type 1)))
-  (type $R (;2;) (resource (rep i32)))
-  (instance $c1 (;0;) (instantiate $C1
-      (with "T1" (type $R))
-      (with "T2" (type $R))
-    )
-  )
-  (alias export $c1 "foo" (func (;0;)))
-  (instance $c2 (;1;) (instantiate $C2
-      (with "T" (type $R))
-      (with "foo" (func 0))
-    )
-  )
-)
\ No newline at end of file
diff --git a/tests/snapshots/local/component-model/resources.wast/37.print b/tests/snapshots/local/component-model/resources.wast/37.print
deleted file mode 100644
index 10a8fd09..00000000
--- a/tests/snapshots/local/component-model/resources.wast/37.print
+++ /dev/null
@@ -1,9 +0,0 @@
-(component
-  (component $C (;0;)
-    (type $R (;0;) (resource (rep i32)))
-    (export (;1;) "R" (type $R))
-  )
-  (instance $c (;0;) (instantiate $C))
-  (alias export $c "R" (type $R (;0;)))
-  (core func (;0;) (canon resource.drop $R))
-)
\ No newline at end of file
diff --git a/tests/snapshots/local/component-model/resources.wast/38.print b/tests/snapshots/local/component-model/resources.wast/38.print
deleted file mode 100644
index bdb2e282..00000000
--- a/tests/snapshots/local/component-model/resources.wast/38.print
+++ /dev/null
@@ -1,17 +0,0 @@
-(component
-  (component $C1 (;0;)
-    (import "X" (type (;0;) (sub resource)))
-  )
-  (component $C2 (;1;)
-    (type (;0;)
-      (component
-        (import "X" (type (;0;) (sub resource)))
-      )
-    )
-    (import "C1" (component (;0;) (type 0)))
-  )
-  (instance $c (;0;) (instantiate $C2
-      (with "C1" (component $C1))
-    )
-  )
-)
\ No newline at end of file
diff --git a/tests/snapshots/local/component-model/resources.wast/39.print b/tests/snapshots/local/component-model/resources.wast/39.print
deleted file mode 100644
index bf2b9723..00000000
--- a/tests/snapshots/local/component-model/resources.wast/39.print
+++ /dev/null
@@ -1,27 +0,0 @@
-(component
-  (component $C1 (;0;)
-    (import "X" (type $X (;0;) (sub resource)))
-    (type (;1;) (own $X))
-    (type (;2;) (func (result 1)))
-    (import "f" (func $f (;0;) (type 2)))
-    (export (;1;) "g" (func $f))
-  )
-  (component $C2 (;1;)
-    (type (;0;)
-      (component
-        (import "X" (type (;0;) (sub resource)))
-        (type (;1;) (own 0))
-        (type (;2;) (func (result 1)))
-        (import "f" (func (;0;) (type 2)))
-        (type (;3;) (own 0))
-        (type (;4;) (func (result 3)))
-        (export (;1;) "g" (func (type 4)))
-      )
-    )
-    (import "C1" (component (;0;) (type 0)))
-  )
-  (instance $c (;0;) (instantiate $C2
-      (with "C1" (component $C1))
-    )
-  )
-)
\ No newline at end of file
diff --git a/tests/snapshots/local/component-model/resources.wast/4.print b/tests/snapshots/local/component-model/resources.wast/4.print
deleted file mode 100644
index f96121c2..00000000
--- a/tests/snapshots/local/component-model/resources.wast/4.print
+++ /dev/null
@@ -1,22 +0,0 @@
-(component
-  (type $x (;0;) (resource (rep i32)))
-  (core func $f1 (;0;) (canon resource.new $x))
-  (core func $f2 (;1;) (canon resource.rep $x))
-  (core func $f3 (;2;) (canon resource.drop $x))
-  (core module $m (;0;)
-    (type (;0;) (func (param i32) (result i32)))
-    (type (;1;) (func (param i32)))
-    (import "" "f1" (func (;0;) (type 0)))
-    (import "" "f2" (func (;1;) (type 0)))
-    (import "" "f3" (func (;2;) (type 1)))
-  )
-  (core instance (;0;)
-    (export "f1" (func $f1))
-    (export "f2" (func $f2))
-    (export "f3" (func $f3))
-  )
-  (core instance (;1;) (instantiate $m
-      (with "" (instance 0))
-    )
-  )
-)
\ No newline at end of file
diff --git a/tests/snapshots/local/component-model/resources.wast/40.print b/tests/snapshots/local/component-model/resources.wast/40.print
deleted file mode 100644
index 6d9a7009..00000000
--- a/tests/snapshots/local/component-model/resources.wast/40.print
+++ /dev/null
@@ -1,25 +0,0 @@
-(component
-  (component $C1 (;0;)
-    (type $X' (;0;) (resource (rep i32)))
-    (export $X (;1;) "X" (type $X'))
-    (core func $f (;0;) (canon resource.drop $X))
-    (type (;2;) (own $X))
-    (type (;3;) (func (param "X" 2)))
-    (func (;0;) (type 3) (canon lift (core func $f)))
-    (export (;1;) "f" (func 0))
-  )
-  (instance $c1 (;0;) (instantiate $C1))
-  (component $C2 (;1;)
-    (import "X" (type $X (;0;) (sub resource)))
-    (type (;1;) (own $X))
-    (type (;2;) (func (param "X" 1)))
-    (import "f" (func (;0;) (type 2)))
-  )
-  (alias export $c1 "X" (type (;0;)))
-  (alias export $c1 "f" (func (;0;)))
-  (instance $c2 (;1;) (instantiate $C2
-      (with "X" (type 0))
-      (with "f" (func 0))
-    )
-  )
-)
\ No newline at end of file
diff --git a/tests/snapshots/local/component-model/resources.wast/42.print b/tests/snapshots/local/component-model/resources.wast/42.print
deleted file mode 100644
index 01b51a4a..00000000
--- a/tests/snapshots/local/component-model/resources.wast/42.print
+++ /dev/null
@@ -1,37 +0,0 @@
-(component
-  (component $C1 (;0;)
-    (type $X (;0;) (resource (rep i32)))
-    (export $X1 (;1;) "X1" (type $X))
-    (export $X2 (;2;) "X2" (type $X))
-    (core func $f (;0;) (canon resource.drop $X))
-    (type (;3;) (own $X1))
-    (type (;4;) (func (param "X" 3)))
-    (func (;0;) (type 4) (canon lift (core func $f)))
-    (type (;5;) (own $X2))
-    (type (;6;) (func (param "X" 5)))
-    (func (;1;) (type 6) (canon lift (core func $f)))
-    (export (;2;) "f1" (func 0))
-    (export (;3;) "f2" (func 1))
-  )
-  (instance $c1 (;0;) (instantiate $C1))
-  (component $C2 (;1;)
-    (import "X" (type $X (;0;) (sub resource)))
-    (type (;1;) (own $X))
-    (type (;2;) (func (param "X" 1)))
-    (import "f" (func (;0;) (type 2)))
-  )
-  (alias export $c1 "X1" (type (;0;)))
-  (alias export $c1 "f1" (func (;0;)))
-  (instance $c2 (;1;) (instantiate $C2
-      (with "X" (type 0))
-      (with "f" (func 0))
-    )
-  )
-  (alias export $c1 "X2" (type (;1;)))
-  (alias export $c1 "f2" (func (;1;)))
-  (instance $c3 (;2;) (instantiate $C2
-      (with "X" (type 1))
-      (with "f" (func 1))
-    )
-  )
-)
\ No newline at end of file
diff --git a/tests/snapshots/local/component-model/resources.wast/43.print b/tests/snapshots/local/component-model/resources.wast/43.print
deleted file mode 100644
index 2ff17b5c..00000000
--- a/tests/snapshots/local/component-model/resources.wast/43.print
+++ /dev/null
@@ -1,37 +0,0 @@
-(component
-  (component $C1 (;0;)
-    (type $X (;0;) (resource (rep i32)))
-    (export $X1 (;1;) "X1" (type $X))
-    (export $X2 (;2;) "X2" (type $X))
-    (core func $f (;0;) (canon resource.drop $X))
-    (type (;3;) (own $X1))
-    (type (;4;) (func (param "X" 3)))
-    (func (;0;) (type 4) (canon lift (core func $f)))
-    (type (;5;) (own $X2))
-    (type (;6;) (func (param "X" 5)))
-    (func (;1;) (type 6) (canon lift (core func $f)))
-    (export (;2;) "f1" (func 0))
-    (export (;3;) "f2" (func 1))
-  )
-  (instance $c1 (;0;) (instantiate $C1))
-  (component $C2 (;1;)
-    (import "X" (type $X (;0;) (sub resource)))
-    (type (;1;) (own $X))
-    (type (;2;) (func (param "X" 1)))
-    (import "f" (func (;0;) (type 2)))
-  )
-  (alias export $c1 "X1" (type (;0;)))
-  (alias export $c1 "f2" (func (;0;)))
-  (instance $c2 (;1;) (instantiate $C2
-      (with "X" (type 0))
-      (with "f" (func 0))
-    )
-  )
-  (alias export $c1 "X2" (type (;1;)))
-  (alias export $c1 "f1" (func (;1;)))
-  (instance $c3 (;2;) (instantiate $C2
-      (with "X" (type 1))
-      (with "f" (func 1))
-    )
-  )
-)
\ No newline at end of file
diff --git a/tests/snapshots/local/component-model/resources.wast/47.print b/tests/snapshots/local/component-model/resources.wast/47.print
deleted file mode 100644
index 61827789..00000000
--- a/tests/snapshots/local/component-model/resources.wast/47.print
+++ /dev/null
@@ -1,13 +0,0 @@
-(component
-  (type $x (;0;) (resource (rep i32)))
-  (component $c (;0;)
-    (import "x" (type $t (;0;) (sub resource)))
-    (export (;1;) "y" (type $t))
-  )
-  (instance $c (;0;) (instantiate $c
-      (with "x" (type $x))
-    )
-  )
-  (alias export $c "y" (type $x2 (;1;)))
-  (core func (;0;) (canon resource.rep $x2))
-)
\ No newline at end of file
diff --git a/tests/snapshots/local/component-model/resources.wast/51.print b/tests/snapshots/local/component-model/resources.wast/51.print
deleted file mode 100644
index e4d76256..00000000
--- a/tests/snapshots/local/component-model/resources.wast/51.print
+++ /dev/null
@@ -1,9 +0,0 @@
-(component
-  (type $r' (;0;) (resource (rep i32)))
-  (export $r (;1;) "r" (type $r'))
-  (core func $f (;0;) (canon resource.drop $r))
-  (type (;2;) (own $r))
-  (type (;3;) (func (param "x" 2)))
-  (func (;0;) (type 3) (canon lift (core func $f)))
-  (export (;1;) "f" (func 0))
-)
\ No newline at end of file
diff --git a/tests/snapshots/local/component-model/resources.wast/52.print b/tests/snapshots/local/component-model/resources.wast/52.print
deleted file mode 100644
index 4b11fca3..00000000
--- a/tests/snapshots/local/component-model/resources.wast/52.print
+++ /dev/null
@@ -1,13 +0,0 @@
-(component
-  (type $r' (;0;) (resource (rep i32)))
-  (instance $i' (;0;)
-    (export "r" (type $r'))
-  )
-  (export $i (;1;) "i" (instance $i'))
-  (alias export $i "r" (type $r (;1;)))
-  (core func $f (;0;) (canon resource.drop $r))
-  (type (;2;) (own $r))
-  (type (;3;) (func (param "x" 2)))
-  (func (;0;) (type 3) (canon lift (core func $f)))
-  (export (;1;) "f" (func 0))
-)
\ No newline at end of file
diff --git a/tests/snapshots/local/component-model/resources.wast/53.print b/tests/snapshots/local/component-model/resources.wast/53.print
deleted file mode 100644
index 102fba04..00000000
--- a/tests/snapshots/local/component-model/resources.wast/53.print
+++ /dev/null
@@ -1,17 +0,0 @@
-(component
-  (type $r' (;0;) (resource (rep i32)))
-  (instance $i' (;0;)
-    (export "r" (type $r'))
-  )
-  (instance $i2' (;1;)
-    (export "i" (instance $i'))
-  )
-  (export $i2 (;2;) "i2" (instance $i2'))
-  (alias export $i2 "i" (instance $i (;3;)))
-  (alias export $i "r" (type $r (;1;)))
-  (core func $f (;0;) (canon resource.drop $r))
-  (type (;2;) (own $r))
-  (type (;3;) (func (param "x" 2)))
-  (func (;0;) (type 3) (canon lift (core func $f)))
-  (export (;1;) "f" (func 0))
-)
\ No newline at end of file
diff --git a/tests/snapshots/local/component-model/resources.wast/54.print b/tests/snapshots/local/component-model/resources.wast/54.print
deleted file mode 100644
index 5028a696..00000000
--- a/tests/snapshots/local/component-model/resources.wast/54.print
+++ /dev/null
@@ -1,18 +0,0 @@
-(component
-  (type $r' (;0;) (resource (rep i32)))
-  (component $C (;0;)
-    (import "x" (type $x (;0;) (sub resource)))
-    (export (;1;) "y" (type $x))
-  )
-  (instance $c' (;0;) (instantiate $C
-      (with "x" (type $r'))
-    )
-  )
-  (export $c (;1;) "c" (instance $c'))
-  (alias export $c "y" (type $r (;1;)))
-  (core func $f (;0;) (canon resource.drop $r))
-  (type (;2;) (own $r))
-  (type (;3;) (func (param "x" 2)))
-  (func (;0;) (type 3) (canon lift (core func $f)))
-  (export (;1;) "f" (func 0))
-)
\ No newline at end of file
diff --git a/tests/snapshots/local/component-model/resources.wast/55.print b/tests/snapshots/local/component-model/resources.wast/55.print
deleted file mode 100644
index ff95441c..00000000
--- a/tests/snapshots/local/component-model/resources.wast/55.print
+++ /dev/null
@@ -1,49 +0,0 @@
-(component
-  (type $r' (;0;) (resource (rep i32)))
-  (component $C (;0;)
-    (import "x" (type $x (;0;) (sub resource)))
-    (export (;1;) "y" (type $x))
-  )
-  (instance $c (;0;) (instantiate $C
-      (with "x" (type $r'))
-    )
-  )
-  (alias export $c "y" (type (;1;)))
-  (instance $i (;1;)
-    (export "x" (type 1))
-  )
-  (component $C2 (;1;)
-    (type (;0;)
-      (instance
-        (type (;0;)
-          (instance
-            (export (;0;) "i2" (type (sub resource)))
-          )
-        )
-        (export (;0;) "i1" (instance (type 0)))
-      )
-    )
-    (import "x" (instance $i (;0;) (type 0)))
-    (alias export $i "i1" (instance (;1;)))
-    (alias export 1 "i2" (type (;1;)))
-    (export (;2;) "y" (type 1))
-  )
-  (alias export $i "x" (type (;2;)))
-  (instance $i2 (;2;)
-    (export "i2" (type 2))
-  )
-  (instance $i1 (;3;)
-    (export "i1" (instance $i2))
-  )
-  (instance $c2 (;4;) (instantiate $C2
-      (with "x" (instance $i1))
-    )
-  )
-  (alias export $c2 "y" (type (;3;)))
-  (export $r (;4;) "x" (type 3))
-  (core func $f (;0;) (canon resource.drop $r))
-  (type (;5;) (own $r))
-  (type (;6;) (func (param "x" 5)))
-  (func (;0;) (type 6) (canon lift (core func $f)))
-  (export (;1;) "f" (func 0))
-)
\ No newline at end of file
diff --git a/tests/snapshots/local/component-model/resources.wast/56.print b/tests/snapshots/local/component-model/resources.wast/56.print
deleted file mode 100644
index 2bc66c3e..00000000
--- a/tests/snapshots/local/component-model/resources.wast/56.print
+++ /dev/null
@@ -1,27 +0,0 @@
-(component
-  (type $r' (;0;) (resource (rep i32)))
-  (component $C (;0;)
-    (type (;0;)
-      (instance
-        (export (;0;) "t" (type (sub resource)))
-      )
-    )
-    (import "x" (instance $x (;0;) (type 0)))
-    (export (;1;) "y" (instance $x))
-  )
-  (instance (;0;)
-    (export "t" (type $r'))
-  )
-  (instance $c' (;1;) (instantiate $C
-      (with "x" (instance 0))
-    )
-  )
-  (export $c (;2;) "c" (instance $c'))
-  (alias export $c "y" (instance $y (;3;)))
-  (alias export $y "t" (type $r (;1;)))
-  (core func $f (;0;) (canon resource.drop $r))
-  (type (;2;) (own $r))
-  (type (;3;) (func (param "x" 2)))
-  (func (;0;) (type 3) (canon lift (core func $f)))
-  (export (;1;) "f" (func 0))
-)
\ No newline at end of file
diff --git a/tests/snapshots/local/component-model/resources.wast/57.print b/tests/snapshots/local/component-model/resources.wast/57.print
deleted file mode 100644
index 04e5d0f9..00000000
--- a/tests/snapshots/local/component-model/resources.wast/57.print
+++ /dev/null
@@ -1,32 +0,0 @@
-(component
-  (type $i (;0;)
-    (instance
-      (export (;0;) "r" (type (sub resource)))
-      (type (;1;) (own 0))
-      (type (;2;) (func (result 1)))
-      (export (;0;) "f" (func (type 2)))
-    )
-  )
-  (import "i1" (instance $i1 (;0;) (type $i)))
-  (import "i2" (instance $i2 (;1;) (type $i)))
-  (component $c (;0;)
-    (import "r" (type $t (;0;) (sub resource)))
-    (type (;1;) (own $t))
-    (type (;2;) (func (result 1)))
-    (import "f" (func (;0;) (type 2)))
-  )
-  (alias export $i1 "r" (type (;1;)))
-  (alias export $i1 "f" (func (;0;)))
-  (instance (;2;) (instantiate $c
-      (with "r" (type 1))
-      (with "f" (func 0))
-    )
-  )
-  (alias export $i2 "r" (type (;2;)))
-  (alias export $i2 "f" (func (;1;)))
-  (instance (;3;) (instantiate $c
-      (with "r" (type 2))
-      (with "f" (func 1))
-    )
-  )
-)
\ No newline at end of file
diff --git a/tests/snapshots/local/component-model/resources.wast/59.print b/tests/snapshots/local/component-model/resources.wast/59.print
deleted file mode 100644
index e4dbe705..00000000
--- a/tests/snapshots/local/component-model/resources.wast/59.print
+++ /dev/null
@@ -1,28 +0,0 @@
-(component
-  (type $t (;0;) (resource (rep i32)))
-  (component $c (;0;)
-    (import "x" (type $t (;0;) (sub resource)))
-    (export (;1;) "y" (type $t))
-  )
-  (instance $c1 (;0;) (instantiate $c
-      (with "x" (type $t))
-    )
-  )
-  (instance $c2 (;1;) (instantiate $c
-      (with "x" (type $t))
-    )
-  )
-  (component $c2 (;1;)
-    (import "x1" (type $t (;0;) (sub resource)))
-    (import "x2" (type (;1;) (eq $t)))
-    (import "x3" (type (;2;) (eq $t)))
-  )
-  (alias export $c1 "y" (type (;1;)))
-  (alias export $c2 "y" (type (;2;)))
-  (instance (;2;) (instantiate $c2
-      (with "x1" (type $t))
-      (with "x2" (type 1))
-      (with "x3" (type 2))
-    )
-  )
-)
\ No newline at end of file
diff --git a/tests/snapshots/local/component-model/resources.wast/63.print b/tests/snapshots/local/component-model/resources.wast/63.print
deleted file mode 100644
index a0e0b93e..00000000
--- a/tests/snapshots/local/component-model/resources.wast/63.print
+++ /dev/null
@@ -1,35 +0,0 @@
-(component $A
-  (type $C (;0;)
-    (component
-      (import "x" (type (;0;) (sub resource)))
-      (type (;1;)
-        (component
-          (alias outer 1 0 (type (;0;)))
-          (import "x" (type (;1;) (eq 0)))
-        )
-      )
-      (import "y" (component (;0;) (type 1)))
-      (export (;1;) "z" (component (type 1)))
-    )
-  )
-  (type $t (;1;) (resource (rep i32)))
-  (alias outer $A $t (type $other-t (;2;)))
-  (type (;3;)
-    (instance
-      (alias outer $A $t (type (;0;)))
-      (export (;1;) "t" (type (eq 0)))
-    )
-  )
-  (type (;4;)
-    (component
-      (alias outer $A $t (type (;0;)))
-      (export (;1;) "t" (type (eq 0)))
-    )
-  )
-  (type (;5;)
-    (component
-      (alias outer $A $t (type (;0;)))
-      (import "t" (type (;1;) (eq 0)))
-    )
-  )
-)
\ No newline at end of file
diff --git a/tests/snapshots/local/component-model/resources.wast/71.print b/tests/snapshots/local/component-model/resources.wast/71.print
deleted file mode 100644
index 8dd02bbc..00000000
--- a/tests/snapshots/local/component-model/resources.wast/71.print
+++ /dev/null
@@ -1,36 +0,0 @@
-(component
-  (component $X (;0;)
-    (type $t (;0;) (resource (rep i32)))
-    (export (;1;) "t" (type $t))
-  )
-  (component $F (;1;)
-    (type (;0;)
-      (instance
-        (export (;0;) "t" (type (sub resource)))
-      )
-    )
-    (import "x" (instance $i (;0;) (type 0)))
-    (alias export $i "t" (type $t (;1;)))
-    (export (;2;) "t" (type $t))
-  )
-  (instance $x1 (;0;) (instantiate $X))
-  (instance $f1 (;1;) (instantiate $F
-      (with "x" (instance $x1))
-    )
-  )
-  (instance $f2 (;2;) (instantiate $F
-      (with "x" (instance $x1))
-    )
-  )
-  (alias export $f1 "t" (type $t1 (;0;)))
-  (alias export $f2 "t" (type $t2 (;1;)))
-  (component $T (;2;)
-    (import "x" (type $x (;0;) (sub resource)))
-    (import "y" (type (;1;) (eq $x)))
-  )
-  (instance $test (;3;) (instantiate $T
-      (with "x" (type $t1))
-      (with "y" (type $t2))
-    )
-  )
-)
\ No newline at end of file
diff --git a/tests/snapshots/local/component-model/resources.wast/78.print b/tests/snapshots/local/component-model/resources.wast/78.print
deleted file mode 100644
index c011b878..00000000
--- a/tests/snapshots/local/component-model/resources.wast/78.print
+++ /dev/null
@@ -1,6 +0,0 @@
-(component
-  (import "a" (type $a (;0;) (sub resource)))
-  (type (;1;) (own $a))
-  (type (;2;) (func (result 1)))
-  (import "[constructor]a" (func (;0;) (type 2)))
-)
\ No newline at end of file
diff --git a/tests/snapshots/local/component-model/resources.wast/79.print b/tests/snapshots/local/component-model/resources.wast/79.print
deleted file mode 100644
index 8609a2e3..00000000
--- a/tests/snapshots/local/component-model/resources.wast/79.print
+++ /dev/null
@@ -1,6 +0,0 @@
-(component
-  (import "a" (type $a (;0;) (sub resource)))
-  (type (;1;) (own $a))
-  (type (;2;) (func (param "x" u32) (result 1)))
-  (import "[constructor]a" (func (;0;) (type 2)))
-)
\ No newline at end of file
diff --git a/tests/snapshots/local/component-model/resources.wast/90.print b/tests/snapshots/local/component-model/resources.wast/90.print
deleted file mode 100644
index 6df38e45..00000000
--- a/tests/snapshots/local/component-model/resources.wast/90.print
+++ /dev/null
@@ -1,6 +0,0 @@
-(component
-  (import "a" (type $T (;0;) (sub resource)))
-  (type (;1;) (borrow $T))
-  (type (;2;) (func (param "self" 1)))
-  (import "[method]a.b" (func (;0;) (type 2)))
-)
\ No newline at end of file
diff --git a/tests/snapshots/local/component-model/resources.wast/98.print b/tests/snapshots/local/component-model/resources.wast/98.print
deleted file mode 100644
index 1ecbe067..00000000
--- a/tests/snapshots/local/component-model/resources.wast/98.print
+++ /dev/null
@@ -1,5 +0,0 @@
-(component
-  (import "a" (type (;0;) (sub resource)))
-  (type (;1;) (func))
-  (import "[static]a.b" (func (;0;) (type 1)))
-)
\ No newline at end of file
diff --git a/tests/snapshots/local/component-model/type-export-restrictions.wast/13.print b/tests/snapshots/local/component-model/type-export-restrictions.wast/13.print
deleted file mode 100644
index 4f519486..00000000
--- a/tests/snapshots/local/component-model/type-export-restrictions.wast/13.print
+++ /dev/null
@@ -1,14 +0,0 @@
-(component
-  (type (;0;) (tuple))
-  (type $t1 (;1;) (tuple 0))
-  (export (;2;) "t1" (type $t1))
-  (type (;3;) (list u8))
-  (type (;4;) (list u32))
-  (type (;5;) (option string))
-  (type (;6;) (result 4 (error 5)))
-  (type (;7;) (tuple 3 6))
-  (type $t2 (;8;) (option 7))
-  (export (;9;) "t2" (type $t2))
-  (type $t3 (;10;) u32)
-  (export (;11;) "t3" (type $t3))
-)
\ No newline at end of file
diff --git a/tests/snapshots/local/component-model/type-export-restrictions.wast/14.print b/tests/snapshots/local/component-model/type-export-restrictions.wast/14.print
deleted file mode 100644
index 4e9c421d..00000000
--- a/tests/snapshots/local/component-model/type-export-restrictions.wast/14.print
+++ /dev/null
@@ -1,6 +0,0 @@
-(component
-  (type $t' (;0;) (record))
-  (export $t (;1;) "t" (type $t'))
-  (type $t2 (;2;) (record (field "x" $t)))
-  (export (;3;) "t2" (type $t2))
-)
\ No newline at end of file
diff --git a/tests/snapshots/local/component-model/type-export-restrictions.wast/16.print b/tests/snapshots/local/component-model/type-export-restrictions.wast/16.print
deleted file mode 100644
index 21052d0e..00000000
--- a/tests/snapshots/local/component-model/type-export-restrictions.wast/16.print
+++ /dev/null
@@ -1,6 +0,0 @@
-(component
-  (type $t (;0;) (record))
-  (import "t" (type $t' (;1;) (eq $t)))
-  (type $t2 (;2;) (record (field "f" $t')))
-  (import "x" (type (;3;) (eq $t2)))
-)
\ No newline at end of file
diff --git a/tests/snapshots/local/component-model/type-export-restrictions.wast/21.print b/tests/snapshots/local/component-model/type-export-restrictions.wast/21.print
deleted file mode 100644
index a20c96c7..00000000
--- a/tests/snapshots/local/component-model/type-export-restrictions.wast/21.print
+++ /dev/null
@@ -1,7 +0,0 @@
-(component
-  (type $t (;0;) (record))
-  (type $f (;1;) (record (field "t" $t)))
-  (instance (;0;)
-    (export "f" (type $f))
-  )
-)
\ No newline at end of file
diff --git a/tests/snapshots/local/component-model/type-export-restrictions.wast/26.print b/tests/snapshots/local/component-model/type-export-restrictions.wast/26.print
deleted file mode 100644
index 8f38d9c0..00000000
--- a/tests/snapshots/local/component-model/type-export-restrictions.wast/26.print
+++ /dev/null
@@ -1,18 +0,0 @@
-(component
-  (type $t' (;0;) (record))
-  (instance $i' (;0;)
-    (export "t" (type $t'))
-  )
-  (export $i (;1;) "i" (instance $i'))
-  (alias export $i "t" (type $t (;1;)))
-  (core module $m (;0;)
-    (type (;0;) (func))
-    (func $f (;0;) (type 0))
-    (export "f" (func $f))
-  )
-  (core instance $i (;0;) (instantiate $m))
-  (type (;2;) (func (param "f" $t)))
-  (alias core export $i "f" (core func (;0;)))
-  (func $f (;0;) (type 2) (canon lift (core func 0)))
-  (export (;1;) "f" (func $f))
-)
\ No newline at end of file
diff --git a/tests/snapshots/local/component-model/type-export-restrictions.wast/27.print b/tests/snapshots/local/component-model/type-export-restrictions.wast/27.print
deleted file mode 100644
index 70dac596..00000000
--- a/tests/snapshots/local/component-model/type-export-restrictions.wast/27.print
+++ /dev/null
@@ -1,19 +0,0 @@
-(component
-  (component $C (;0;)
-    (type $t (;0;) (record))
-    (export (;1;) "t" (type $t))
-  )
-  (instance $i' (;0;) (instantiate $C))
-  (export $i (;1;) "i" (instance $i'))
-  (alias export $i "t" (type $t (;0;)))
-  (core module $m (;0;)
-    (type (;0;) (func))
-    (func $f (;0;) (type 0))
-    (export "f" (func $f))
-  )
-  (core instance $i (;0;) (instantiate $m))
-  (type (;1;) (func (param "f" $t)))
-  (alias core export $i "f" (core func (;0;)))
-  (func $f (;0;) (type 1) (canon lift (core func 0)))
-  (export (;1;) "f" (func $f))
-)
\ No newline at end of file
diff --git a/tests/snapshots/local/component-model/type-export-restrictions.wast/28.print b/tests/snapshots/local/component-model/type-export-restrictions.wast/28.print
deleted file mode 100644
index b6bdeaa5..00000000
--- a/tests/snapshots/local/component-model/type-export-restrictions.wast/28.print
+++ /dev/null
@@ -1,15 +0,0 @@
-(component
-  (type $t (;0;) (record))
-  (core module $m (;0;)
-    (type (;0;) (func))
-    (func (;0;) (type 0))
-    (export "f" (func 0))
-  )
-  (core instance $i (;0;) (instantiate $m))
-  (type (;1;) (func (param "x" $t)))
-  (alias core export $i "f" (core func (;0;)))
-  (func $f (;0;) (type 1) (canon lift (core func 0)))
-  (export $t' (;2;) "t" (type $t))
-  (type (;3;) (func (param "x" $t')))
-  (export (;1;) "f" (func $f) (func (type 3)))
-)
\ No newline at end of file
diff --git a/tests/snapshots/local/component-model/type-export-restrictions.wast/30.print b/tests/snapshots/local/component-model/type-export-restrictions.wast/30.print
deleted file mode 100644
index 0b30fba7..00000000
--- a/tests/snapshots/local/component-model/type-export-restrictions.wast/30.print
+++ /dev/null
@@ -1,5 +0,0 @@
-(component
-  (type $t1 (;0;) (record))
-  (import "t1" (type $t2 (;1;) (eq $t1)))
-  (export (;2;) "e-t1" (type $t2))
-)
\ No newline at end of file
diff --git a/tests/snapshots/local/component-model/type-export-restrictions.wast/31.print b/tests/snapshots/local/component-model/type-export-restrictions.wast/31.print
deleted file mode 100644
index a9d41e52..00000000
--- a/tests/snapshots/local/component-model/type-export-restrictions.wast/31.print
+++ /dev/null
@@ -1,7 +0,0 @@
-(component
-  (type $t1 (;0;) (record))
-  (import "t1" (type $t2 (;1;) (eq $t1)))
-  (type (;2;) (func (result $t2)))
-  (import "i" (func $f (;0;) (type 2)))
-  (export (;1;) "e-i" (func $f))
-)
\ No newline at end of file
diff --git a/tests/snapshots/local/component-model/type-export-restrictions.wast/34.print b/tests/snapshots/local/component-model/type-export-restrictions.wast/34.print
deleted file mode 100644
index efd6175d..00000000
--- a/tests/snapshots/local/component-model/type-export-restrictions.wast/34.print
+++ /dev/null
@@ -1,31 +0,0 @@
-(component
-  (type $c (;0;)
-    (component)
-  )
-  (type (;1;)
-    (component
-      (alias outer 1 $c (type (;0;)))
-      (import "c" (component (;0;) (type 0)))
-    )
-  )
-  (component (;0;)
-    (alias outer 1 $c (type $c (;0;)))
-    (import "c" (component (;0;) (type $c)))
-  )
-  (type $i (;2;)
-    (instance)
-  )
-  (type (;3;)
-    (component
-      (alias outer 1 $i (type (;0;)))
-      (import "c" (instance (;0;) (type 0)))
-    )
-  )
-  (type $r (;4;) (resource (rep i32)))
-  (type (;5;)
-    (component
-      (alias outer 1 $r (type (;0;)))
-      (import "r" (type (;1;) (eq 0)))
-    )
-  )
-)
\ No newline at end of file
diff --git a/tests/snapshots/local/component-model/type-export-restrictions.wast/35.print b/tests/snapshots/local/component-model/type-export-restrictions.wast/35.print
deleted file mode 100644
index 28a28baa..00000000
--- a/tests/snapshots/local/component-model/type-export-restrictions.wast/35.print
+++ /dev/null
@@ -1,5 +0,0 @@
-(component
-  (type (;0;) (func))
-  (import "r" (func $r (;0;) (type 0)))
-  (export (;1;) "r2" (func $r))
-)
\ No newline at end of file
diff --git a/tests/snapshots/local/component-model/type-export-restrictions.wast/36.print b/tests/snapshots/local/component-model/type-export-restrictions.wast/36.print
deleted file mode 100644
index eab00289..00000000
--- a/tests/snapshots/local/component-model/type-export-restrictions.wast/36.print
+++ /dev/null
@@ -1,5 +0,0 @@
-(component
-  (type $t (;0;) (record))
-  (import "r" (type $r (;1;) (eq $t)))
-  (export (;2;) "r2" (type $r))
-)
\ No newline at end of file
diff --git a/tests/snapshots/local/component-model/type-export-restrictions.wast/37.print b/tests/snapshots/local/component-model/type-export-restrictions.wast/37.print
deleted file mode 100644
index e5c7bf1c..00000000
--- a/tests/snapshots/local/component-model/type-export-restrictions.wast/37.print
+++ /dev/null
@@ -1,7 +0,0 @@
-(component
-  (type (;0;)
-    (instance)
-  )
-  (import "r" (instance $r (;0;) (type 0)))
-  (export (;1;) "r2" (instance $r))
-)
\ No newline at end of file
diff --git a/tests/snapshots/local/component-model/type-export-restrictions.wast/38.print b/tests/snapshots/local/component-model/type-export-restrictions.wast/38.print
deleted file mode 100644
index 7682001d..00000000
--- a/tests/snapshots/local/component-model/type-export-restrictions.wast/38.print
+++ /dev/null
@@ -1,4 +0,0 @@
-(component
-  (import "r" (type $r (;0;) (sub resource)))
-  (export (;1;) "r2" (type $r))
-)
\ No newline at end of file
diff --git a/tests/snapshots/local/component-model/type-export-restrictions.wast/40.print b/tests/snapshots/local/component-model/type-export-restrictions.wast/40.print
deleted file mode 100644
index 1215cfd7..00000000
--- a/tests/snapshots/local/component-model/type-export-restrictions.wast/40.print
+++ /dev/null
@@ -1,9 +0,0 @@
-(component
-  (type (;0;)
-    (instance
-      (type (;0;) (record))
-      (type (;1;) (func (param "x" 0)))
-      (export (;0;) "f" (func (type 1)))
-    )
-  )
-)
\ No newline at end of file
diff --git a/tests/snapshots/local/component-model/type-export-restrictions.wast/42.print b/tests/snapshots/local/component-model/type-export-restrictions.wast/42.print
deleted file mode 100644
index 52f90926..00000000
--- a/tests/snapshots/local/component-model/type-export-restrictions.wast/42.print
+++ /dev/null
@@ -1,21 +0,0 @@
-(component $C
-  (type (;0;)
-    (instance
-      (type (;0;) (record))
-      (export (;1;) "baz" (type (eq 0)))
-      (type (;2;) (record (field "baz" 1)))
-      (export (;3;) "bar" (type (eq 2)))
-    )
-  )
-  (import "foo" (instance $i (;0;) (type 0)))
-  (alias export $i "bar" (type $bar (;1;)))
-  (type (;2;)
-    (instance
-      (alias outer $C $bar (type (;0;)))
-      (export (;1;) "bar" (type (eq 0)))
-      (type (;2;) (func (result 1)))
-      (export (;0;) "a" (func (type 2)))
-    )
-  )
-  (import "bar" (instance (;1;) (type 2)))
-)
\ No newline at end of file
diff --git a/tests/snapshots/local/component-model/type-export-restrictions.wast/43.print b/tests/snapshots/local/component-model/type-export-restrictions.wast/43.print
deleted file mode 100644
index 803cc2c9..00000000
--- a/tests/snapshots/local/component-model/type-export-restrictions.wast/43.print
+++ /dev/null
@@ -1,16 +0,0 @@
-(component
-  (type $r' (;0;) (record))
-  (import "r" (type $r (;1;) (eq $r')))
-  (component $C (;0;)
-    (type $r' (;0;) (record))
-    (import "r" (type $r (;1;) (eq $r')))
-    (type $r2' (;2;) (record (field "r" $r)))
-    (export (;3;) "r2" (type $r2'))
-  )
-  (instance $c (;0;) (instantiate $C
-      (with "r" (type $r))
-    )
-  )
-  (alias export $c "r2" (type (;2;)))
-  (export (;3;) "r2" (type 2))
-)
\ No newline at end of file
diff --git a/tests/snapshots/local/component-model/type-export-restrictions.wast/48.print b/tests/snapshots/local/component-model/type-export-restrictions.wast/48.print
deleted file mode 100644
index da10c90b..00000000
--- a/tests/snapshots/local/component-model/type-export-restrictions.wast/48.print
+++ /dev/null
@@ -1,43 +0,0 @@
-(component
-  (type (;0;)
-    (instance
-      (type (;0;) (enum "qux"))
-      (export (;1;) "baz" (type (eq 0)))
-      (type (;2;) (record (field "bar" 1)))
-      (export (;3;) "foo" (type (eq 2)))
-    )
-  )
-  (import (interface "demo:component/types") (instance (;0;) (type 0)))
-  (component (;0;)
-    (type (;0;)
-      (instance
-        (type (;0;) (enum "qux"))
-        (export (;1;) "baz" (type (eq 0)))
-        (type (;2;) (record (field "bar" 1)))
-        (export (;3;) "foo" (type (eq 2)))
-      )
-    )
-    (import (interface "demo:component/types") (instance (;0;) (type 0)))
-    (component (;0;)
-      (type (;0;) (enum "qux"))
-      (import "import-type-baz" (type (;1;) (eq 0)))
-      (type (;2;) (record (field "bar" 1)))
-      (import "import-type-bar" (type (;3;) (eq 2)))
-      (export (;4;) "foo" (type 3))
-    )
-    (alias export 0 "baz" (type (;1;)))
-    (alias export 0 "foo" (type (;2;)))
-    (instance (;1;) (instantiate 0
-        (with "import-type-baz" (type 1))
-        (with "import-type-bar" (type 2))
-      )
-    )
-    (export (;2;) (interface "demo:component/types") (instance 1))
-  )
-  (instance (;1;) (instantiate 0
-      (with "demo:component/types" (instance 0))
-    )
-  )
-  (alias export 1 "demo:component/types" (instance (;2;)))
-  (export (;3;) (interface "demo:component/types") (instance 2))
-)
\ No newline at end of file
diff --git a/tests/snapshots/local/component-model/types.wast/34.print b/tests/snapshots/local/component-model/types.wast/34.print
index 27e740b6..c1a61f4b 100644
--- a/tests/snapshots/local/component-model/types.wast/34.print
+++ b/tests/snapshots/local/component-model/types.wast/34.print
@@ -2,8 +2,8 @@
   (type (;0;)
     (component
       (type (;0;) string)
-      (import "a" (type (;1;) (eq 0)))
-      (export (;2;) "b" (type (eq 0)))
+      (import "a" (type (eq 0)))
+      (export (;1;) "b" (type (eq 0)))
     )
   )
 )
\ No newline at end of file
diff --git a/tests/snapshots/local/component-model/virtualize.wast/0.print b/tests/snapshots/local/component-model/virtualize.wast/0.print
index 9da97c9c..d7d94e7b 100644
--- a/tests/snapshots/local/component-model/virtualize.wast/0.print
+++ b/tests/snapshots/local/component-model/virtualize.wast/0.print
@@ -80,7 +80,7 @@
     (type (;1;)
       (component
         (alias outer 1 $WasiFile (type (;0;)))
-        (import "wasi-file" (instance (;0;) (type 0)))
+        (import "wasi-file" (instance (type 0)))
         (type (;1;) (list u8))
         (type (;2;) (func (param "len" u32) (result 1)))
         (export (;0;) "read" (func (type 2)))
@@ -93,7 +93,7 @@
     (type (;2;)
       (component
         (alias outer 1 $WasiFile (type (;0;)))
-        (import "wasi-file" (instance (;0;) (type 0)))
+        (import "wasi-file" (instance (type 0)))
         (type (;1;) (func))
         (export (;0;) "play" (func (type 1)))
       )
diff --git a/tests/snapshots/local/function-references/call_ref/br_on_non_null.wast/0.print b/tests/snapshots/local/function-references/call_ref/br_on_non_null.wast/0.print
index 534e7f5d..04331c8c 100644
--- a/tests/snapshots/local/function-references/call_ref/br_on_non_null.wast/0.print
+++ b/tests/snapshots/local/function-references/call_ref/br_on_non_null.wast/0.print
@@ -9,7 +9,7 @@
       i32.const -1
       return
     end
-    call_ref $t
+    call_ref 0
   )
   (func $n (;1;) (type 2) (param $r (ref null 0)) (result i32)
     block $l (result (ref 0)) ;; label = @1
@@ -18,7 +18,7 @@
       i32.const -1
       return
     end
-    call_ref $t
+    call_ref 0
   )
   (func $f (;2;) (type $t) (result i32)
     i32.const 7
@@ -39,7 +39,7 @@
     block $l ;; label = @1
       unreachable
       br_on_null 0 (;@1;)
-      call_ref $t
+      call_ref 0
       return
     end
     i32.const -1
diff --git a/tests/snapshots/local/function-references/call_ref/br_on_non_null.wast/6.print b/tests/snapshots/local/function-references/call_ref/br_on_non_null.wast/6.print
index e3707064..78f56a76 100644
--- a/tests/snapshots/local/function-references/call_ref/br_on_non_null.wast/6.print
+++ b/tests/snapshots/local/function-references/call_ref/br_on_non_null.wast/6.print
@@ -14,7 +14,7 @@
       br_on_non_null 0 (;@1;)
       return
     end
-    call_ref $t
+    call_ref 0
   )
   (func (;2;) (type $t) (param $n i32) (result i32)
     local.get $n
diff --git a/tests/snapshots/local/function-references/call_ref/br_on_null.wast/0.print b/tests/snapshots/local/function-references/call_ref/br_on_null.wast/0.print
index fdfd989b..37ea5986 100644
--- a/tests/snapshots/local/function-references/call_ref/br_on_null.wast/0.print
+++ b/tests/snapshots/local/function-references/call_ref/br_on_null.wast/0.print
@@ -6,7 +6,7 @@
     block $l ;; label = @1
       local.get $r
       br_on_null 0 (;@1;)
-      call_ref $t
+      call_ref 0
       return
     end
     i32.const -1
@@ -15,7 +15,7 @@
     block $l ;; label = @1
       local.get $r
       br_on_null 0 (;@1;)
-      call_ref $t
+      call_ref 0
       return
     end
     i32.const -1
@@ -39,7 +39,7 @@
     block $l ;; label = @1
       unreachable
       br_on_null 0 (;@1;)
-      call_ref $t
+      call_ref 0
       return
     end
     i32.const -1
diff --git a/tests/snapshots/local/function-references/call_ref/br_on_null.wast/6.print b/tests/snapshots/local/function-references/call_ref/br_on_null.wast/6.print
index 8be1657f..b0093ff5 100644
--- a/tests/snapshots/local/function-references/call_ref/br_on_null.wast/6.print
+++ b/tests/snapshots/local/function-references/call_ref/br_on_null.wast/6.print
@@ -11,7 +11,7 @@
       local.get $n
       local.get $r
       br_on_null 0 (;@1;)
-      call_ref $t
+      call_ref 0
       return
     end
   )
diff --git a/tests/snapshots/local/function-references/call_ref/call_ref.wast/0.print b/tests/snapshots/local/function-references/call_ref/call_ref.wast/0.print
index b5339eab..ba93d972 100644
--- a/tests/snapshots/local/function-references/call_ref/call_ref.wast/0.print
+++ b/tests/snapshots/local/function-references/call_ref/call_ref.wast/0.print
@@ -7,7 +7,7 @@
   (func $apply (;0;) (type 3) (param $f (ref 0)) (param $x i32) (result i32)
     local.get $x
     local.get $f
-    call_ref $ii
+    call_ref 0
   )
   (func $f (;1;) (type $ii) (param i32) (result i32)
     local.get 0
@@ -27,14 +27,14 @@
     local.set $rg
     local.get $x
     local.get $rf
-    call_ref $ii
+    call_ref 0
     local.get $rg
-    call_ref $ii
+    call_ref 0
   )
   (func (;4;) (type 4) (result i32)
     i32.const 1
     ref.null 0
-    call_ref $ii
+    call_ref 0
   )
   (func $fac (;5;) (type $ll) (param i64) (result i64)
     local.get 0
@@ -47,7 +47,7 @@
       i64.const 1
       i64.sub
       global.get $fac
-      call_ref $ll
+      call_ref 1
       i64.mul
     end
   )
@@ -64,7 +64,7 @@
       local.get 1
       i64.mul
       global.get $fac-acc
-      call_ref $lll
+      call_ref 2
     end
   )
   (func $fib (;7;) (type $ll) (param i64) (result i64)
@@ -78,12 +78,12 @@
       i64.const 2
       i64.sub
       global.get $fib
-      call_ref $ll
+      call_ref 1
       local.get 0
       i64.const 1
       i64.sub
       global.get $fib
-      call_ref $ll
+      call_ref 1
       i64.add
     end
   )
@@ -97,7 +97,7 @@
       i64.const 1
       i64.sub
       global.get $odd
-      call_ref $ll
+      call_ref 1
     end
   )
   (func $odd (;9;) (type $ll) (param i64) (result i64)
@@ -110,7 +110,7 @@
       i64.const 1
       i64.sub
       global.get $even
-      call_ref $ll
+      call_ref 1
     end
   )
   (global $fac (;0;) (ref 1) ref.func $fac)
diff --git a/tests/snapshots/local/function-references/call_ref/call_ref.wast/25.print b/tests/snapshots/local/function-references/call_ref/call_ref.wast/25.print
index 9b733d46..0a27b320 100644
--- a/tests/snapshots/local/function-references/call_ref/call_ref.wast/25.print
+++ b/tests/snapshots/local/function-references/call_ref/call_ref.wast/25.print
@@ -3,7 +3,7 @@
   (type (;1;) (func (result i32)))
   (func (;0;) (type 1) (result i32)
     unreachable
-    call_ref $t
+    call_ref 0
   )
   (export "unreachable" (func 0))
 )
\ No newline at end of file
diff --git a/tests/snapshots/local/function-references/call_ref/call_ref.wast/27.print b/tests/snapshots/local/function-references/call_ref/call_ref.wast/27.print
index 3f690c6f..9a52596e 100644
--- a/tests/snapshots/local/function-references/call_ref/call_ref.wast/27.print
+++ b/tests/snapshots/local/function-references/call_ref/call_ref.wast/27.print
@@ -7,7 +7,7 @@
   (func (;1;) (type 1) (result i32)
     unreachable
     ref.func $f
-    call_ref $t
+    call_ref 0
   )
   (export "unreachable" (func 1))
   (elem (;0;) declare func $f)
diff --git a/tests/snapshots/local/function-references/call_ref/call_ref.wast/29.print b/tests/snapshots/local/function-references/call_ref/call_ref.wast/29.print
index 89b7ecc2..7b0119bb 100644
--- a/tests/snapshots/local/function-references/call_ref/call_ref.wast/29.print
+++ b/tests/snapshots/local/function-references/call_ref/call_ref.wast/29.print
@@ -8,7 +8,7 @@
     unreachable
     i32.const 0
     ref.func $f
-    call_ref $t
+    call_ref 0
     drop
     i32.const 0
   )
diff --git a/tests/snapshots/local/function-references/call_ref/ref_as_non_null.wast/0.print b/tests/snapshots/local/function-references/call_ref/ref_as_non_null.wast/0.print
index d1387d3f..9926998d 100644
--- a/tests/snapshots/local/function-references/call_ref/ref_as_non_null.wast/0.print
+++ b/tests/snapshots/local/function-references/call_ref/ref_as_non_null.wast/0.print
@@ -5,12 +5,12 @@
   (func $nn (;0;) (type 1) (param $r (ref 0)) (result i32)
     local.get $r
     ref.as_non_null
-    call_ref $t
+    call_ref 0
   )
   (func $n (;1;) (type 2) (param $r (ref null 0)) (result i32)
     local.get $r
     ref.as_non_null
-    call_ref $t
+    call_ref 0
   )
   (func $f (;2;) (type $t) (result i32)
     i32.const 7
diff --git a/tests/snapshots/local/function-references/call_ref/return_call_ref.wast/0.print b/tests/snapshots/local/function-references/call_ref/return_call_ref.wast/0.print
index fb2a39b0..e74ad09f 100644
--- a/tests/snapshots/local/function-references/call_ref/return_call_ref.wast/0.print
+++ b/tests/snapshots/local/function-references/call_ref/return_call_ref.wast/0.print
@@ -51,67 +51,67 @@
   )
   (func (;12;) (type $-i32) (result i32)
     global.get $const-i32
-    return_call_ref $-i32
+    return_call_ref 1
   )
   (func (;13;) (type $-i64) (result i64)
     global.get $const-i64
-    return_call_ref $-i64
+    return_call_ref 2
   )
   (func (;14;) (type $-f32) (result f32)
     global.get $const-f32
-    return_call_ref $-f32
+    return_call_ref 3
   )
   (func (;15;) (type $-f64) (result f64)
     global.get $const-f64
-    return_call_ref $-f64
+    return_call_ref 4
   )
   (func (;16;) (type $-i32) (result i32)
     i32.const 32
     global.get $id-i32
-    return_call_ref $i32-i32
+    return_call_ref 5
   )
   (func (;17;) (type $-i64) (result i64)
     i64.const 64
     global.get $id-i64
-    return_call_ref $i64-i64
+    return_call_ref 6
   )
   (func (;18;) (type $-f32) (result f32)
     f32.const 0x1.51eb86p+0 (;=1.32;)
     global.get $id-f32
-    return_call_ref $f32-f32
+    return_call_ref 7
   )
   (func (;19;) (type $-f64) (result f64)
     f64.const 0x1.a3d70a3d70a3dp+0 (;=1.64;)
     global.get $id-f64
-    return_call_ref $f64-f64
+    return_call_ref 8
   )
   (func (;20;) (type $-i32) (result i32)
     f32.const 0x1.00ccccp+5 (;=32.1;)
     i32.const 32
     global.get $f32-i32
-    return_call_ref $f32-i32
+    return_call_ref 9
   )
   (func (;21;) (type $-i64) (result i64)
     i32.const 32
     i64.const 64
     global.get $i32-i64
-    return_call_ref $i32-i64
+    return_call_ref 10
   )
   (func (;22;) (type $-f32) (result f32)
     f64.const 0x1p+6 (;=64;)
     f32.const 0x1p+5 (;=32;)
     global.get $f64-f32
-    return_call_ref $f64-f32
+    return_call_ref 11
   )
   (func (;23;) (type $-f64) (result f64)
     i64.const 64
     f64.const 0x1.0066666666666p+6 (;=64.1;)
     global.get $i64-f64
-    return_call_ref $i64-f64
+    return_call_ref 12
   )
   (func (;24;) (type $proc)
     ref.null 0
-    return_call_ref $proc
+    return_call_ref 0
   )
   (func $fac-acc (;25;) (type $i64i64-i64) (param i64 i64) (result i64)
     local.get 0
@@ -126,7 +126,7 @@
       local.get 1
       i64.mul
       global.get $fac-acc
-      return_call_ref $i64i64-i64
+      return_call_ref 13
     end
   )
   (func $count (;26;) (type $i64-i64) (param i64) (result i64)
@@ -139,7 +139,7 @@
       i64.const 1
       i64.sub
       global.get $count
-      return_call_ref $i64-i64
+      return_call_ref 6
     end
   )
   (func $even (;27;) (type $i64-i64) (param i64) (result i64)
@@ -152,7 +152,7 @@
       i64.const 1
       i64.sub
       global.get $odd
-      return_call_ref $i64-i64
+      return_call_ref 6
     end
   )
   (func $odd (;28;) (type $i64-i64) (param i64) (result i64)
@@ -165,7 +165,7 @@
       i64.const 1
       i64.sub
       global.get $even
-      return_call_ref $i64-i64
+      return_call_ref 6
     end
   )
   (global $const-i32 (;0;) (ref 1) ref.func $const-i32)
diff --git a/tests/snapshots/local/function-references/call_ref/return_call_ref.wast/33.print b/tests/snapshots/local/function-references/call_ref/return_call_ref.wast/33.print
index db9c9d65..e22e5e4b 100644
--- a/tests/snapshots/local/function-references/call_ref/return_call_ref.wast/33.print
+++ b/tests/snapshots/local/function-references/call_ref/return_call_ref.wast/33.print
@@ -6,39 +6,39 @@
   (type $t4 (;4;) (func (result funcref)))
   (func $f11 (;0;) (type $t1) (result (ref 0))
     ref.func $f11
-    return_call_ref $t1
+    return_call_ref 1
   )
   (func $f21 (;1;) (type $t2) (result (ref null 0))
     ref.func $f11
-    return_call_ref $t1
+    return_call_ref 1
   )
   (func $f22 (;2;) (type $t2) (result (ref null 0))
     ref.func $f22
-    return_call_ref $t2
+    return_call_ref 2
   )
   (func $f31 (;3;) (type $t3) (result (ref func))
     ref.func $f11
-    return_call_ref $t1
+    return_call_ref 1
   )
   (func $f33 (;4;) (type $t3) (result (ref func))
     ref.func $f33
-    return_call_ref $t3
+    return_call_ref 3
   )
   (func $f41 (;5;) (type $t4) (result funcref)
     ref.func $f11
-    return_call_ref $t1
+    return_call_ref 1
   )
   (func $f42 (;6;) (type $t4) (result funcref)
     ref.func $f22
-    return_call_ref $t2
+    return_call_ref 2
   )
   (func $f43 (;7;) (type $t4) (result funcref)
     ref.func $f33
-    return_call_ref $t3
+    return_call_ref 3
   )
   (func $f44 (;8;) (type $t4) (result funcref)
     ref.func $f44
-    return_call_ref $t4
+    return_call_ref 4
   )
   (elem (;0;) declare func $f11 $f22 $f33 $f44)
 )
\ No newline at end of file
diff --git a/tests/snapshots/local/function-references/call_ref/return_call_ref.wast/40.print b/tests/snapshots/local/function-references/call_ref/return_call_ref.wast/40.print
index 70ed02cc..f725354e 100644
--- a/tests/snapshots/local/function-references/call_ref/return_call_ref.wast/40.print
+++ b/tests/snapshots/local/function-references/call_ref/return_call_ref.wast/40.print
@@ -2,7 +2,7 @@
   (type $t (;0;) (func (result i32)))
   (func (;0;) (type $t) (result i32)
     unreachable
-    return_call_ref $t
+    return_call_ref 0
   )
   (export "unreachable" (func 0))
 )
\ No newline at end of file
diff --git a/tests/snapshots/local/function-references/call_ref/return_call_ref.wast/42.print b/tests/snapshots/local/function-references/call_ref/return_call_ref.wast/42.print
index 09c8e10b..f439be69 100644
--- a/tests/snapshots/local/function-references/call_ref/return_call_ref.wast/42.print
+++ b/tests/snapshots/local/function-references/call_ref/return_call_ref.wast/42.print
@@ -7,7 +7,7 @@
   (func (;1;) (type 1) (result i32)
     unreachable
     ref.func $f
-    return_call_ref $t
+    return_call_ref 0
   )
   (export "unreachable" (func 1))
   (elem (;0;) declare func $f)
diff --git a/tests/snapshots/local/function-references/call_ref/return_call_ref.wast/44.print b/tests/snapshots/local/function-references/call_ref/return_call_ref.wast/44.print
index 97eaf8fe..1e11c9cc 100644
--- a/tests/snapshots/local/function-references/call_ref/return_call_ref.wast/44.print
+++ b/tests/snapshots/local/function-references/call_ref/return_call_ref.wast/44.print
@@ -8,7 +8,7 @@
     unreachable
     i32.const 0
     ref.func $f
-    return_call_ref $t
+    return_call_ref 0
     i32.const 0
   )
   (export "unreachable" (func 1))
diff --git a/tests/snapshots/local/gc/gc-array-types.wat.print b/tests/snapshots/local/gc/gc-array-types.wat.print
deleted file mode 100644
index d3fa5f75..00000000
--- a/tests/snapshots/local/gc/gc-array-types.wat.print
+++ /dev/null
@@ -1,7 +0,0 @@
-(module
-  (type $a (;0;) (array i32))
-  (type $b (;1;) (array (mut i32)))
-  (type $c (;2;) (array (mut (ref null 1))))
-  (type $d (;3;) (array i8))
-  (type $e (;4;) (array (mut i16)))
-)
\ No newline at end of file
diff --git a/tests/snapshots/local/gc/gc-heaptypes.wat.print b/tests/snapshots/local/gc/gc-heaptypes.wat.print
deleted file mode 100644
index 1fc5f440..00000000
--- a/tests/snapshots/local/gc/gc-heaptypes.wat.print
+++ /dev/null
@@ -1,22 +0,0 @@
-(module
-  (type (;0;) (func (param funcref (ref func) funcref)))
-  (type (;1;) (func (param externref (ref extern) externref)))
-  (type (;2;) (func (param anyref (ref any) anyref)))
-  (type (;3;) (func (param eqref (ref eq) eqref)))
-  (type (;4;) (func (param i31ref (ref i31) i31ref)))
-  (type (;5;) (func (param structref (ref struct) structref)))
-  (type (;6;) (func (param arrayref (ref array) arrayref)))
-  (type (;7;) (func (param nullfuncref (ref nofunc) nullfuncref)))
-  (type (;8;) (func (param nullexternref (ref noextern) nullexternref)))
-  (type (;9;) (func (param nullref (ref none) nullref)))
-  (func (;0;) (type 0) (param funcref (ref func) funcref))
-  (func (;1;) (type 1) (param externref (ref extern) externref))
-  (func (;2;) (type 2) (param anyref (ref any) anyref))
-  (func (;3;) (type 3) (param eqref (ref eq) eqref))
-  (func (;4;) (type 4) (param i31ref (ref i31) i31ref))
-  (func (;5;) (type 5) (param structref (ref struct) structref))
-  (func (;6;) (type 6) (param arrayref (ref array) arrayref))
-  (func (;7;) (type 7) (param nullfuncref (ref nofunc) nullfuncref))
-  (func (;8;) (type 8) (param nullexternref (ref noextern) nullexternref))
-  (func (;9;) (type 9) (param nullref (ref none) nullref))
-)
\ No newline at end of file
diff --git a/tests/snapshots/local/gc/gc-i31.wat.print b/tests/snapshots/local/gc/gc-i31.wat.print
deleted file mode 100644
index 983d103f..00000000
--- a/tests/snapshots/local/gc/gc-i31.wat.print
+++ /dev/null
@@ -1,16 +0,0 @@
-(module
-  (type (;0;) (func (result i32 i32)))
-  (func $f (;0;) (type 0) (result i32 i32)
-    (local $a (ref i31)) (local $b i31ref) (local $c i31ref)
-    i32.const 42
-    i31.new
-    local.set $a
-    i32.const 0
-    i31.new
-    local.set $b
-    local.get $a
-    i31.get_u
-    local.get $b
-    i31.get_s
-  )
-)
\ No newline at end of file
diff --git a/tests/snapshots/local/gc/gc-struct-types.wat.print b/tests/snapshots/local/gc/gc-struct-types.wat.print
deleted file mode 100644
index 8ad4690d..00000000
--- a/tests/snapshots/local/gc/gc-struct-types.wat.print
+++ /dev/null
@@ -1,12 +0,0 @@
-(module
-  (type (;0;) (struct))
-  (type (;1;) (struct (field i32)))
-  (type (;2;) (struct (field (mut i32))))
-  (type (;3;) (struct (field i32) (field i32)))
-  (type (;4;) (struct (field i32) (field (mut i32))))
-  (type (;5;) (struct (field (mut i32)) (field (mut i32))))
-  (type $a (;6;) (struct (field f32)))
-  (type $b (;7;) (struct (field f32)))
-  (type (;8;) (struct (field externref)))
-  (type (;9;) (struct (field externref) (field funcref)))
-)
\ No newline at end of file
diff --git a/tests/snapshots/local/gc/gc-subtypes.wat.print b/tests/snapshots/local/gc/gc-subtypes.wat.print
deleted file mode 100644
index 2e102903..00000000
--- a/tests/snapshots/local/gc/gc-subtypes.wat.print
+++ /dev/null
@@ -1,71 +0,0 @@
-(module
-  (type $a (;0;) (func))
-  (type $b (;1;) (sub $a (;0;) (func)))
-  (type $c (;2;) (sub $b (;1;) (func)))
-  (type $b1 (;3;) (sub final $a (;0;) (func)))
-  (type $d (;4;) (struct))
-  (type $e (;5;) (sub $d (;4;) (struct (field (mut (ref null 4))))))
-  (type $f (;6;) (sub final $e (;5;) (struct (field (ref 5)))))
-  (type $g (;7;) (func (param (ref 5)) (result (ref 5))))
-  (type $h (;8;) (sub $g (;7;) (func (param (ref 4)) (result (ref 6)))))
-  (type $j (;9;) (func (param (ref 1)) (result (ref 1))))
-  (type $k (;10;) (sub $j (;9;) (func (param (ref 0)) (result (ref 2)))))
-  (type $l (;11;) (sub $j (;9;) (func (param (ref 2)) (result (ref 0)))))
-  (type $m (;12;) (array (mut i32)))
-  (type $n (;13;) (sub $m (;12;) (array i32)))
-  (type $o (;14;) (array i32))
-  (type $p (;15;) (sub $o (;14;) (array i32)))
-  (type $o1 (;16;) (array i64))
-  (type $p1 (;17;) (sub $o1 (;16;) (array i64)))
-  (type $q (;18;) (array (mut anyref)))
-  (type $q0 (;19;) (sub $q (;18;) (array (ref any))))
-  (type $q1 (;20;) (sub $q (;18;) (array (mut eqref))))
-  (type $q2 (;21;) (sub $q1 (;20;) (array (mut (ref eq)))))
-  (type $q3 (;22;) (sub $q2 (;21;) (array (ref eq))))
-  (type $r (;23;) (sub $q (;18;) (array i31ref)))
-  (type $r1 (;24;) (sub $q1 (;20;) (array i31ref)))
-  (type $s (;25;) (sub $r (;23;) (array (ref i31))))
-  (type $s1 (;26;) (sub $q1 (;20;) (array (ref i31))))
-  (type $s2 (;27;) (sub $q2 (;21;) (array (ref i31))))
-  (type $rr (;28;) (sub $q (;18;) (array arrayref)))
-  (type $rr1 (;29;) (sub $q1 (;20;) (array arrayref)))
-  (type $ss (;30;) (sub $rr (;28;) (array (ref array))))
-  (type $ss0 (;31;) (sub $ss (;30;) (array (ref 28))))
-  (type $ss1 (;32;) (sub $q1 (;20;) (array (ref array))))
-  (type (;33;) (sub $q1 (;20;) (array (ref 28))))
-  (type $ss2 (;34;) (sub $q2 (;21;) (array (ref array))))
-  (type (;35;) (sub $q2 (;21;) (array (ref 28))))
-  (type $rrr (;36;) (sub $q (;18;) (array structref)))
-  (type $rrr1 (;37;) (sub $q1 (;20;) (array structref)))
-  (type $sss (;38;) (sub $rrr (;36;) (array (ref struct))))
-  (type $sss0 (;39;) (sub $rrr (;36;) (array (ref null 4))))
-  (type $sss1 (;40;) (sub $q1 (;20;) (array (ref struct))))
-  (type (;41;) (sub $q1 (;20;) (array (ref 4))))
-  (type $sss2 (;42;) (sub $q2 (;21;) (array (ref struct))))
-  (type (;43;) (sub $q2 (;21;) (array (ref 4))))
-  (type $z1 (;44;) (sub $q (;18;) (array (mut nullref))))
-  (type $z2 (;45;) (sub $q0 (;19;) (array (ref none))))
-  (type $z3 (;46;) (sub $z1 (;44;) (array (mut (ref none)))))
-  (type $z4 (;47;) (sub $z1 (;44;) (array nullref)))
-  (type (;48;) (sub $q1 (;20;) (array nullref)))
-  (type (;49;) (sub $r (;23;) (array nullref)))
-  (type (;50;) (sub $rr (;28;) (array nullref)))
-  (type (;51;) (sub $rrr (;36;) (array nullref)))
-  (type (;52;) (sub $q1 (;20;) (array (ref none))))
-  (type (;53;) (sub $r (;23;) (array (ref none))))
-  (type (;54;) (sub $rr (;28;) (array (ref none))))
-  (type (;55;) (sub $rrr (;36;) (array (ref none))))
-  (type $t (;56;) (array (mut funcref)))
-  (type $u (;57;) (sub $t (;56;) (array funcref)))
-  (type $v (;58;) (sub $u (;57;) (array (ref func))))
-  (type $w (;59;) (sub $v (;58;) (array (ref 0))))
-  (type $x (;60;) (sub $t (;56;) (array (ref null 0))))
-  (type $y (;61;) (sub $w (;59;) (array (ref nofunc))))
-  (type $z (;62;) (sub $x (;60;) (array nullfuncref)))
-  (type $t0 (;63;) (array (mut externref)))
-  (type $u0 (;64;) (sub $t0 (;63;) (array externref)))
-  (type $v0 (;65;) (sub $u0 (;64;) (array (ref extern))))
-  (type $y0 (;66;) (sub $v0 (;65;) (array (ref noextern))))
-  (type $y01 (;67;) (sub $u0 (;64;) (array (ref noextern))))
-  (type $z0 (;68;) (sub $u0 (;64;) (array nullexternref)))
-)
\ No newline at end of file
diff --git a/tests/snapshots/local/producers.wast/0.print b/tests/snapshots/local/producers.wast/0.print
deleted file mode 100644
index 88ad199b..00000000
--- a/tests/snapshots/local/producers.wast/0.print
+++ /dev/null
@@ -1,3 +0,0 @@
-(module
-  (@producers)
-)
\ No newline at end of file
diff --git a/tests/snapshots/local/producers.wast/1.print b/tests/snapshots/local/producers.wast/1.print
deleted file mode 100644
index 2f14e514..00000000
--- a/tests/snapshots/local/producers.wast/1.print
+++ /dev/null
@@ -1,5 +0,0 @@
-(module
-  (@producers
-    (language "foo" "bar")
-  )
-)
\ No newline at end of file
diff --git a/tests/snapshots/local/producers.wast/2.print b/tests/snapshots/local/producers.wast/2.print
deleted file mode 100644
index d8f701c2..00000000
--- a/tests/snapshots/local/producers.wast/2.print
+++ /dev/null
@@ -1,8 +0,0 @@
-(module
-  (@producers
-    (language "foo" "bar")
-    (language "foo" "bar")
-    (sdk "foo" "bar")
-    (processed-by "foo" "bar")
-  )
-)
\ No newline at end of file
diff --git a/tests/snapshots/local/producers.wast/3.print b/tests/snapshots/local/producers.wast/3.print
deleted file mode 100644
index ba77a054..00000000
--- a/tests/snapshots/local/producers.wast/3.print
+++ /dev/null
@@ -1,6 +0,0 @@
-(module
-  (@producers)
-  (@producers
-    (sdk "foo" "bar")
-  )
-)
\ No newline at end of file
diff --git a/tests/snapshots/local/producers.wast/5.print b/tests/snapshots/local/producers.wast/5.print
deleted file mode 100644
index f26da787..00000000
--- a/tests/snapshots/local/producers.wast/5.print
+++ /dev/null
@@ -1,4 +0,0 @@
-(module
-    ;; failed to parse custom section `producers`: unexpected end-of-file (at offset 0x15)
-    
-  )
\ No newline at end of file
diff --git a/tests/snapshots/local/producers.wast/6.print b/tests/snapshots/local/producers.wast/6.print
deleted file mode 100644
index d61f51e0..00000000
--- a/tests/snapshots/local/producers.wast/6.print
+++ /dev/null
@@ -1,5 +0,0 @@
-(module
-    ;; failed to parse custom section `producers`: invalid producers field name: `a
-    ;; a` (at offset 0x15)
-    
-  )
\ No newline at end of file
diff --git a/tests/snapshots/local/typed-continuations/cont.wast/0.print b/tests/snapshots/local/typed-continuations/cont.wast/0.print
new file mode 100644
index 00000000..af35e43c
--- /dev/null
+++ b/tests/snapshots/local/typed-continuations/cont.wast/0.print
@@ -0,0 +1,151 @@
+(module
+  (type $f1 (;0;) (func))
+  (type $k1 (;1;) (cont $f1))
+  (type (;2;) (func (param (ref 1))))
+  (func $f1 (;0;) (type $f1)
+    suspend 1
+  )
+  (func (;1;) (type $f1)
+    ref.func $f1
+    cont.new (type $k1)
+    resume
+  )
+  (func (;2;) (type $f1)
+    block $h (result (ref 1)) ;; label = @1
+      ref.func $f1
+      cont.new (type $k1)
+      resume (tag 2 0 (;@1;))
+      unreachable
+    end
+    drop
+  )
+  (func (;3;) (type $f1)
+    block $h (result (ref 1)) ;; label = @1
+      ref.func $f1
+      cont.new (type $k1)
+      resume (tag 1 0 (;@1;))
+      unreachable
+    end
+    drop
+  )
+  (func $f2 (;4;) (type $f1)
+    throw 0
+  )
+  (func (;5;) (type $f1)
+    block $h (result (ref 1)) ;; label = @1
+      ref.func $f2
+      cont.new (type $k1)
+      resume (tag 1 0 (;@1;))
+      unreachable
+    end
+    drop
+  )
+  (func (;6;) (type $f1)
+    block $h (result (ref 1)) ;; label = @1
+      ref.func $f1
+      cont.new (type $k1)
+      resume (tag 1 0 (;@1;))
+      unreachable
+    end
+    resume_throw 0
+  )
+  (func $f3 (;7;) (type $f1)
+    barrier ;; label = @1
+    call $f4
+    end
+  )
+  (func $f4 (;8;) (type $f1)
+    suspend 1
+  )
+  (func (;9;) (type $f1)
+    block $h (result (ref 1)) ;; label = @1
+      ref.func $f3
+      cont.new (type $k1)
+      resume (tag 1 0 (;@1;))
+      unreachable
+    end
+    resume_throw 0
+  )
+  (func $r0 (;10;) (type $f1))
+  (func $r1 (;11;) (type $f1)
+    suspend 1
+    suspend 1
+  )
+  (func $nl1 (;12;) (type 2) (param $k (ref 1))
+    local.get $k
+    resume
+    local.get $k
+    resume
+  )
+  (func $nl2 (;13;) (type 2) (param $k (ref 1))
+    block $h (result (ref 1)) ;; label = @1
+      local.get $k
+      resume (tag 1 0 (;@1;))
+      unreachable
+    end
+    local.get $k
+    resume
+    unreachable
+  )
+  (func $nl3 (;14;) (type 2) (param $k (ref 1))
+    (local $k' (ref null 1))
+    block $h1 (result (ref 1)) ;; label = @1
+      local.get $k
+      resume (tag 1 0 (;@1;))
+      unreachable
+    end
+    local.set $k'
+    block $h2 (result (ref 1)) ;; label = @1
+      local.get $k'
+      resume (tag 1 0 (;@1;))
+      unreachable
+    end
+    local.get $k'
+    resume
+    unreachable
+  )
+  (func $nl4 (;15;) (type 2) (param $k (ref 1))
+    local.get $k
+    cont.bind (type $k1)
+    drop
+    local.get $k
+    resume
+  )
+  (func (;16;) (type $f1)
+    ref.func $r0
+    cont.new (type $k1)
+    call $nl1
+  )
+  (func (;17;) (type $f1)
+    ref.func $r1
+    cont.new (type $k1)
+    call $nl2
+  )
+  (func (;18;) (type $f1)
+    ref.func $r1
+    cont.new (type $k1)
+    call $nl3
+  )
+  (func (;19;) (type $f1)
+    ref.func $r1
+    cont.new (type $k1)
+    call $nl4
+  )
+  (tag (;0;) (type $f1))
+  (tag (;1;) (type $f1))
+  (tag (;2;) (type $f1))
+  (export "unhandled-1" (func $f1))
+  (export "unhandled-2" (func 1))
+  (export "unhandled-3" (func 2))
+  (export "handled" (func 3))
+  (export "uncaught-1" (func 5))
+  (export "uncaught-2" (func 6))
+  (export "barrier" (func 9))
+  (export "non-linear-1" (func 16))
+  (export "non-linear-2" (func 17))
+  (export "non-linear-3" (func 18))
+  (export "non-linear-4" (func 19))
+  (elem (;0;) declare func $f2)
+  (elem (;1;) declare func $f3)
+  (elem (;2;) declare func $r0 $r1)
+)
\ No newline at end of file
diff --git a/tests/snapshots/local/typed-continuations/cont.wast/12.print b/tests/snapshots/local/typed-continuations/cont.wast/12.print
new file mode 100644
index 00000000..7c14aa05
--- /dev/null
+++ b/tests/snapshots/local/typed-continuations/cont.wast/12.print
@@ -0,0 +1,48 @@
+(module $state
+  (type $f (;0;) (func (param i32) (result i32)))
+  (type $k (;1;) (cont $f))
+  (type (;2;) (func (result i32)))
+  (type (;3;) (func (param i32 (ref 1)) (result i32)))
+  (type (;4;) (func (result i32 (ref 1))))
+  (func $runner (;0;) (type 3) (param $s i32) (param $k (ref 1)) (result i32)
+    loop $loop ;; label = @1
+      block $on_get (result (ref 1)) ;; label = @2
+        block $on_set (type 4) (result i32 (ref 1)) ;; label = @3
+          local.get $s
+          local.get $k
+          resume (tag 0 1 (;@2;))(tag 1 0 (;@3;))
+          return
+        end
+        local.set $k
+        local.set $s
+        br 1 (;@1;)
+      end
+      local.set $k
+      br 0 (;@1;)
+    end
+    unreachable
+  )
+  (func $f (;1;) (type $f) (param i32) (result i32)
+    i32.const 7
+    suspend 1
+    drop
+    suspend 0
+    i32.const 2
+    i32.const 3
+    suspend 1
+    suspend 0
+    i32.add
+    i32.mul
+    i32.add
+  )
+  (func (;2;) (type 2) (result i32)
+    i32.const 0
+    ref.func $f
+    cont.new (type $k)
+    call $runner
+  )
+  (tag (;0;) (type 2) (result i32))
+  (tag (;1;) (type $f) (param i32) (result i32))
+  (export "run" (func 2))
+  (elem (;0;) declare func $f)
+)
\ No newline at end of file
diff --git a/tests/snapshots/local/typed-continuations/cont.wast/14.print b/tests/snapshots/local/typed-continuations/cont.wast/14.print
new file mode 100644
index 00000000..6662587a
--- /dev/null
+++ b/tests/snapshots/local/typed-continuations/cont.wast/14.print
@@ -0,0 +1,57 @@
+(module $generator
+  (type $gen (;0;) (func (param i64)))
+  (type $geny (;1;) (func (param i32)))
+  (type $cont0 (;2;) (cont $gen))
+  (type $cont (;3;) (cont $geny))
+  (type (;4;) (func (param i64) (result i32)))
+  (type (;5;) (func (param i64 i64) (result i64)))
+  (type (;6;) (func (param i64 (ref 2)) (result i64 (ref 3))))
+  (type (;7;) (func (param i64 (ref 3))))
+  (func $dummy (;0;) (type $gen) (param i64))
+  (func $gen (;1;) (type $gen) (param $i i64)
+    loop $l ;; label = @1
+      local.get $i
+      suspend 0
+      br_if 1 (;@0;)
+      local.get $i
+      global.get $hook
+      call_ref 0
+      local.get $i
+      i64.const 1
+      i64.add
+      local.set $i
+      br 0 (;@1;)
+    end
+  )
+  (func (;2;) (type 5) (param $i i64) (param $j i64) (result i64)
+    (local $sum i64) (local $n i64) (local $k (ref null 3))
+    local.get $i
+    ref.func $gen
+    cont.new (type $cont0)
+    block $on_first_yield (type 6) (param i64 (ref 2)) (result i64 (ref 3)) ;; label = @1
+      resume (tag 0 0 (;@1;))
+      unreachable
+    end
+    loop $on_yield (type 7) (param i64 (ref 3)) ;; label = @1
+      local.set $k
+      local.set $n
+      local.get $sum
+      local.get $n
+      i64.add
+      local.set $sum
+      local.get $n
+      local.get $j
+      i64.eq
+      local.get $k
+      resume (tag 0 0 (;@1;))
+    end
+    local.get $sum
+    return
+  )
+  (tag (;0;) (type 4) (param i64) (result i32))
+  (global $hook (;0;) (mut (ref 0)) ref.func $dummy)
+  (export "hook" (global $hook))
+  (export "start" (func $gen))
+  (export "sum" (func 2))
+  (elem (;0;) declare func $gen)
+)
\ No newline at end of file
diff --git a/tests/snapshots/local/typed-continuations/cont.wast/21.print b/tests/snapshots/local/typed-continuations/cont.wast/21.print
new file mode 100644
index 00000000..3050c9e4
--- /dev/null
+++ b/tests/snapshots/local/typed-continuations/cont.wast/21.print
@@ -0,0 +1,98 @@
+(module $scheduler
+  (type $proc (;0;) (func))
+  (type $cont (;1;) (cont $proc))
+  (type (;2;) (func (param (ref 1))))
+  (type (;3;) (func (result i32)))
+  (type (;4;) (func (result (ref null 1))))
+  (type (;5;) (func (result (ref 1) (ref 1))))
+  (func $queue-empty (;0;) (type 3) (result i32)
+    global.get $qfront
+    global.get $qback
+    i32.eq
+  )
+  (func $dequeue (;1;) (type 4) (result (ref null 1))
+    (local $i i32)
+    call $queue-empty
+    if ;; label = @1
+      ref.null 1
+      return
+    end
+    global.get $qfront
+    local.set $i
+    local.get $i
+    i32.const 1
+    i32.add
+    global.set $qfront
+    local.get $i
+    table.get $queue
+  )
+  (func $enqueue (;2;) (type 2) (param $k (ref 1))
+    global.get $qback
+    table.size $queue
+    i32.eq
+    if ;; label = @1
+      global.get $qfront
+      global.get $qdelta
+      i32.lt_u
+      if ;; label = @2
+        ref.null 1
+        global.get $qdelta
+        table.grow $queue
+        drop
+      else
+        global.get $qback
+        global.get $qfront
+        i32.sub
+        global.set $qback
+        i32.const 0
+        global.get $qfront
+        global.get $qback
+        table.copy
+        global.get $qback
+        ref.null 1
+        global.get $qfront
+        table.fill $queue
+        i32.const 0
+        global.set $qfront
+      end
+    end
+    global.get $qback
+    local.get $k
+    table.set $queue
+    global.get $qback
+    i32.const 1
+    i32.add
+    global.set $qback
+  )
+  (func $scheduler (;3;) (type 2) (param $main (ref 1))
+    local.get $main
+    call $enqueue
+    loop $l ;; label = @1
+      call $queue-empty
+      if ;; label = @2
+        return
+      end
+      block $on_yield (result (ref 1)) ;; label = @2
+        block $on_spawn (type 5) (result (ref 1) (ref 1)) ;; label = @3
+          call $dequeue
+          resume (tag 0 1 (;@2;))(tag 1 0 (;@3;))
+          br 2 (;@1;)
+        end
+        call $enqueue
+        call $enqueue
+        br 1 (;@1;)
+      end
+      call $enqueue
+      br 0 (;@1;)
+    end
+  )
+  (table $queue (;0;) 0 (ref null 1))
+  (tag (;0;) (type $proc))
+  (tag (;1;) (type 2) (param (ref 1)))
+  (global $qdelta (;0;) i32 i32.const 10)
+  (global $qback (;1;) (mut i32) i32.const 0)
+  (global $qfront (;2;) (mut i32) i32.const 0)
+  (export "yield" (tag 0))
+  (export "spawn" (tag 1))
+  (export "scheduler" (func $scheduler))
+)
\ No newline at end of file
diff --git a/tests/snapshots/local/typed-continuations/cont.wast/23.print b/tests/snapshots/local/typed-continuations/cont.wast/23.print
new file mode 100644
index 00000000..c19f5f48
--- /dev/null
+++ b/tests/snapshots/local/typed-continuations/cont.wast/23.print
@@ -0,0 +1,111 @@
+(module
+  (type $proc (;0;) (func))
+  (type $pproc (;1;) (func (param i32)))
+  (type $cont (;2;) (cont $proc))
+  (type $pcont (;3;) (cont $pproc))
+  (type (;4;) (func (param (ref 2))))
+  (type (;5;) (func (param i32 i32)))
+  (import "scheduler" "yield" (tag (;0;) (type $proc)))
+  (import "scheduler" "spawn" (tag (;1;) (type 4) (param (ref 2))))
+  (import "scheduler" "scheduler" (func $scheduler (;0;) (type 4)))
+  (import "spectest" "print_i32" (func $log (;1;) (type $pproc)))
+  (func $main (;2;) (type $proc)
+    i32.const 0
+    call $log
+    ref.func $thread1
+    cont.new (type $cont)
+    suspend 1
+    i32.const 1
+    call $log
+    global.get $depth
+    ref.func $thread2
+    cont.new (type $pcont)
+    cont.bind (type $cont)
+    suspend 1
+    i32.const 2
+    call $log
+    ref.func $thread3
+    cont.new (type $cont)
+    suspend 1
+    i32.const 3
+    call $log
+  )
+  (func $thread1 (;3;) (type $proc)
+    i32.const 10
+    call $log
+    suspend 0
+    i32.const 11
+    call $log
+    suspend 0
+    i32.const 12
+    call $log
+    suspend 0
+    i32.const 13
+    call $log
+  )
+  (func $thread2 (;4;) (type $pproc) (param $d i32)
+    (local $w i32)
+    global.get $width
+    local.set $w
+    i32.const 20
+    call $log
+    local.get $d
+    i32.eqz
+    br_if 0 (;@0;)
+    i32.const 21
+    call $log
+    loop $l ;; label = @1
+      local.get $w
+      if ;; label = @2
+        i32.const 22
+        call $log
+        suspend 0
+        i32.const 23
+        call $log
+        local.get $d
+        i32.const 1
+        i32.sub
+        ref.func $thread2
+        cont.new (type $pcont)
+        cont.bind (type $cont)
+        suspend 1
+        i32.const 24
+        call $log
+        local.get $w
+        i32.const 1
+        i32.sub
+        local.set $w
+        br 1 (;@1;)
+      end
+    end
+    i32.const 25
+    call $log
+  )
+  (func $thread3 (;5;) (type $proc)
+    i32.const 30
+    call $log
+    suspend 0
+    i32.const 31
+    call $log
+    suspend 0
+    i32.const 32
+    call $log
+  )
+  (func (;6;) (type 5) (param $width i32) (param $depth i32)
+    local.get $depth
+    global.set $depth
+    local.get $width
+    global.set $width
+    i32.const -1
+    call $log
+    ref.func $main
+    cont.new (type $cont)
+    call $scheduler
+    i32.const -2
+    call $log
+  )
+  (global $width (;0;) (mut i32) i32.const 0)
+  (global $depth (;1;) (mut i32) i32.const 0)
+  (export "run" (func 6))
+  (elem (;0;) declare func $main $thread1 $thread2 $thread3)
+)
\ No newline at end of file
diff --git a/tests/snapshots/local/typed-continuations/cont.wast/29.print b/tests/snapshots/local/typed-continuations/cont.wast/29.print
new file mode 100644
index 00000000..41161428
--- /dev/null
+++ b/tests/snapshots/local/typed-continuations/cont.wast/29.print
@@ -0,0 +1,64 @@
+(module $concurrent-generator
+  (type $ghook (;0;) (func (param i64)))
+  (type $proc (;1;) (func))
+  (type $pproc (;2;) (func (param i64 i64)))
+  (type $cont (;3;) (cont $proc))
+  (type $pcont (;4;) (cont $pproc))
+  (type (;5;) (func (param (ref 3))))
+  (type (;6;) (func (param i64 i64) (result i64)))
+  (import "spectest" "print_i64" (func $log (;0;) (type $ghook)))
+  (import "scheduler" "yield" (tag (;0;) (type $proc)))
+  (import "scheduler" "spawn" (tag (;1;) (type 5) (param (ref 3))))
+  (import "scheduler" "scheduler" (func $scheduler (;1;) (type 5)))
+  (import "generator" "sum" (func $gsum (;2;) (type 6)))
+  (import "generator" "hook" (global $ghook (;0;) (mut (ref 0))))
+  (func $syield (;3;) (type $ghook) (param $i i64)
+    local.get $i
+    call $log
+    suspend 0
+  )
+  (func $bg-thread (;4;) (type $proc)
+    i64.const -10
+    call $log
+    loop $l ;; label = @1
+      i64.const -11
+      call $log
+      suspend 0
+      global.get $done
+      i32.eqz
+      br_if 0 (;@1;)
+    end
+    i64.const -12
+    call $log
+  )
+  (func $main (;5;) (type $pproc) (param $i i64) (param $j i64)
+    ref.func $bg-thread
+    cont.new (type $cont)
+    suspend 1
+    ref.func $syield
+    global.set $ghook
+    local.get $i
+    local.get $j
+    call $gsum
+    global.set $result
+    i32.const 1
+    global.set $done
+  )
+  (func (;6;) (type 6) (param $i i64) (param $j i64) (result i64)
+    i64.const -1
+    call $log
+    local.get $i
+    local.get $j
+    ref.func $main
+    cont.new (type $pcont)
+    cont.bind (type $cont)
+    call $scheduler
+    i64.const -2
+    call $log
+    global.get $result
+  )
+  (global $result (;1;) (mut i64) i64.const 0)
+  (global $done (;2;) (mut i32) i32.const 0)
+  (export "sum" (func 6))
+  (elem (;0;) declare func $main $bg-thread $syield)
+)
\ No newline at end of file
diff --git a/tests/snapshots/local/typed-continuations/cont.wast/31.print b/tests/snapshots/local/typed-continuations/cont.wast/31.print
new file mode 100644
index 00000000..4bd43d71
--- /dev/null
+++ b/tests/snapshots/local/typed-continuations/cont.wast/31.print
@@ -0,0 +1,39 @@
+(module
+  (type $f2 (;0;) (func (param i32 i32) (result i32 i32 i32 i32 i32 i32)))
+  (type $f4 (;1;) (func (param i32 i32 i32 i32) (result i32 i32 i32 i32 i32 i32)))
+  (type $f6 (;2;) (func (param i32 i32 i32 i32 i32 i32) (result i32 i32 i32 i32 i32 i32)))
+  (type $k2 (;3;) (cont $f2))
+  (type $k4 (;4;) (cont $f4))
+  (type $k6 (;5;) (cont $f6))
+  (type (;6;) (func (result i32 i32 i32 i32 i32 i32)))
+  (func $f (;0;) (type $f6) (param i32 i32 i32 i32 i32 i32) (result i32 i32 i32 i32 i32 i32)
+    local.get 0
+    local.get 1
+    local.get 2
+    local.get 3
+    local.get 4
+    local.get 5
+  )
+  (func (;1;) (type 6) (result i32 i32 i32 i32 i32 i32)
+    (local $k6 (ref null 5)) (local $k4 (ref null 4)) (local $k2 (ref null 3))
+    ref.func $f
+    cont.new (type $k6)
+    local.set $k6
+    i32.const 1
+    i32.const 2
+    local.get $k6
+    cont.bind (type $k4)
+    local.set $k4
+    i32.const 3
+    i32.const 4
+    local.get $k4
+    cont.bind (type $k2)
+    local.set $k2
+    i32.const 5
+    i32.const 6
+    local.get $k2
+    resume
+  )
+  (export "run" (func 1))
+  (elem (;0;) declare func $f)
+)
\ No newline at end of file
diff --git a/tests/snapshots/local/typed-continuations/cont.wast/33.print b/tests/snapshots/local/typed-continuations/cont.wast/33.print
new file mode 100644
index 00000000..5fcd7bc9
--- /dev/null
+++ b/tests/snapshots/local/typed-continuations/cont.wast/33.print
@@ -0,0 +1,42 @@
+(module
+  (type $f0 (;0;) (func (result i32 i32 i32 i32 i32 i32 i32)))
+  (type $f2 (;1;) (func (param i32 i32) (result i32 i32 i32 i32 i32 i32 i32)))
+  (type $f4 (;2;) (func (param i32 i32 i32 i32) (result i32 i32 i32 i32 i32 i32 i32)))
+  (type $f6 (;3;) (func (param i32 i32 i32 i32 i32 i32) (result i32 i32 i32 i32 i32 i32 i32)))
+  (type $k0 (;4;) (cont $f0))
+  (type $k2 (;5;) (cont $f2))
+  (type $k4 (;6;) (cont $f4))
+  (type $k6 (;7;) (cont $f6))
+  (type (;8;) (func (result i32 i32 i32 i32 i32 i32)))
+  (func $f (;0;) (type $f0) (result i32 i32 i32 i32 i32 i32 i32)
+    i32.const 0
+    suspend 0
+  )
+  (func (;1;) (type $f0) (result i32 i32 i32 i32 i32 i32 i32)
+    (local $k6 (ref null 7)) (local $k4 (ref null 6)) (local $k2 (ref null 5))
+    block $l (result (ref 7)) ;; label = @1
+      ref.func $f
+      cont.new (type $k0)
+      resume (tag 0 0 (;@1;))
+      unreachable
+    end
+    local.set $k6
+    i32.const 1
+    i32.const 2
+    local.get $k6
+    cont.bind (type $k4)
+    local.set $k4
+    i32.const 3
+    i32.const 4
+    local.get $k4
+    cont.bind (type $k2)
+    local.set $k2
+    i32.const 5
+    i32.const 6
+    local.get $k2
+    resume
+  )
+  (tag (;0;) (type 8) (result i32 i32 i32 i32 i32 i32))
+  (export "run" (func 1))
+  (elem (;0;) declare func $f)
+)
\ No newline at end of file
diff --git a/tests/snapshots/testsuite/proposals/function-references/br_on_non_null.wast/0.print b/tests/snapshots/testsuite/proposals/function-references/br_on_non_null.wast/0.print
index f8045bc6..4fa09c5a 100644
--- a/tests/snapshots/testsuite/proposals/function-references/br_on_non_null.wast/0.print
+++ b/tests/snapshots/testsuite/proposals/function-references/br_on_non_null.wast/0.print
@@ -9,7 +9,7 @@
       i32.const -1
       return
     end
-    call_ref $t
+    call_ref 0
   )
   (func $n (;1;) (type 2) (param $r (ref null 0)) (result i32)
     block $l (result (ref 0)) ;; label = @1
@@ -18,7 +18,7 @@
       i32.const -1
       return
     end
-    call_ref $t
+    call_ref 0
   )
   (func $f (;2;) (type $t) (result i32)
     i32.const 7
@@ -42,7 +42,7 @@
       i32.const -1
       return
     end
-    call_ref $t
+    call_ref 0
   )
   (export "nullable-null" (func 3))
   (export "nonnullable-f" (func 4))
diff --git a/tests/snapshots/testsuite/proposals/function-references/br_on_non_null.wast/6.print b/tests/snapshots/testsuite/proposals/function-references/br_on_non_null.wast/6.print
index e3707064..78f56a76 100644
--- a/tests/snapshots/testsuite/proposals/function-references/br_on_non_null.wast/6.print
+++ b/tests/snapshots/testsuite/proposals/function-references/br_on_non_null.wast/6.print
@@ -14,7 +14,7 @@
       br_on_non_null 0 (;@1;)
       return
     end
-    call_ref $t
+    call_ref 0
   )
   (func (;2;) (type $t) (param $n i32) (result i32)
     local.get $n
diff --git a/tests/snapshots/testsuite/proposals/function-references/br_on_null.wast/0.print b/tests/snapshots/testsuite/proposals/function-references/br_on_null.wast/0.print
index fdfd989b..37ea5986 100644
--- a/tests/snapshots/testsuite/proposals/function-references/br_on_null.wast/0.print
+++ b/tests/snapshots/testsuite/proposals/function-references/br_on_null.wast/0.print
@@ -6,7 +6,7 @@
     block $l ;; label = @1
       local.get $r
       br_on_null 0 (;@1;)
-      call_ref $t
+      call_ref 0
       return
     end
     i32.const -1
@@ -15,7 +15,7 @@
     block $l ;; label = @1
       local.get $r
       br_on_null 0 (;@1;)
-      call_ref $t
+      call_ref 0
       return
     end
     i32.const -1
@@ -39,7 +39,7 @@
     block $l ;; label = @1
       unreachable
       br_on_null 0 (;@1;)
-      call_ref $t
+      call_ref 0
       return
     end
     i32.const -1
diff --git a/tests/snapshots/testsuite/proposals/function-references/br_on_null.wast/6.print b/tests/snapshots/testsuite/proposals/function-references/br_on_null.wast/6.print
index 8be1657f..b0093ff5 100644
--- a/tests/snapshots/testsuite/proposals/function-references/br_on_null.wast/6.print
+++ b/tests/snapshots/testsuite/proposals/function-references/br_on_null.wast/6.print
@@ -11,7 +11,7 @@
       local.get $n
       local.get $r
       br_on_null 0 (;@1;)
-      call_ref $t
+      call_ref 0
       return
     end
   )
diff --git a/tests/snapshots/testsuite/proposals/function-references/call_ref.wast/0.print b/tests/snapshots/testsuite/proposals/function-references/call_ref.wast/0.print
index b5339eab..ba93d972 100644
--- a/tests/snapshots/testsuite/proposals/function-references/call_ref.wast/0.print
+++ b/tests/snapshots/testsuite/proposals/function-references/call_ref.wast/0.print
@@ -7,7 +7,7 @@
   (func $apply (;0;) (type 3) (param $f (ref 0)) (param $x i32) (result i32)
     local.get $x
     local.get $f
-    call_ref $ii
+    call_ref 0
   )
   (func $f (;1;) (type $ii) (param i32) (result i32)
     local.get 0
@@ -27,14 +27,14 @@
     local.set $rg
     local.get $x
     local.get $rf
-    call_ref $ii
+    call_ref 0
     local.get $rg
-    call_ref $ii
+    call_ref 0
   )
   (func (;4;) (type 4) (result i32)
     i32.const 1
     ref.null 0
-    call_ref $ii
+    call_ref 0
   )
   (func $fac (;5;) (type $ll) (param i64) (result i64)
     local.get 0
@@ -47,7 +47,7 @@
       i64.const 1
       i64.sub
       global.get $fac
-      call_ref $ll
+      call_ref 1
       i64.mul
     end
   )
@@ -64,7 +64,7 @@
       local.get 1
       i64.mul
       global.get $fac-acc
-      call_ref $lll
+      call_ref 2
     end
   )
   (func $fib (;7;) (type $ll) (param i64) (result i64)
@@ -78,12 +78,12 @@
       i64.const 2
       i64.sub
       global.get $fib
-      call_ref $ll
+      call_ref 1
       local.get 0
       i64.const 1
       i64.sub
       global.get $fib
-      call_ref $ll
+      call_ref 1
       i64.add
     end
   )
@@ -97,7 +97,7 @@
       i64.const 1
       i64.sub
       global.get $odd
-      call_ref $ll
+      call_ref 1
     end
   )
   (func $odd (;9;) (type $ll) (param i64) (result i64)
@@ -110,7 +110,7 @@
       i64.const 1
       i64.sub
       global.get $even
-      call_ref $ll
+      call_ref 1
     end
   )
   (global $fac (;0;) (ref 1) ref.func $fac)
diff --git a/tests/snapshots/testsuite/proposals/function-references/call_ref.wast/25.print b/tests/snapshots/testsuite/proposals/function-references/call_ref.wast/25.print
index 9b733d46..0a27b320 100644
--- a/tests/snapshots/testsuite/proposals/function-references/call_ref.wast/25.print
+++ b/tests/snapshots/testsuite/proposals/function-references/call_ref.wast/25.print
@@ -3,7 +3,7 @@
   (type (;1;) (func (result i32)))
   (func (;0;) (type 1) (result i32)
     unreachable
-    call_ref $t
+    call_ref 0
   )
   (export "unreachable" (func 0))
 )
\ No newline at end of file
diff --git a/tests/snapshots/testsuite/proposals/function-references/call_ref.wast/27.print b/tests/snapshots/testsuite/proposals/function-references/call_ref.wast/27.print
index 3f690c6f..9a52596e 100644
--- a/tests/snapshots/testsuite/proposals/function-references/call_ref.wast/27.print
+++ b/tests/snapshots/testsuite/proposals/function-references/call_ref.wast/27.print
@@ -7,7 +7,7 @@
   (func (;1;) (type 1) (result i32)
     unreachable
     ref.func $f
-    call_ref $t
+    call_ref 0
   )
   (export "unreachable" (func 1))
   (elem (;0;) declare func $f)
diff --git a/tests/snapshots/testsuite/proposals/function-references/call_ref.wast/29.print b/tests/snapshots/testsuite/proposals/function-references/call_ref.wast/29.print
index 89b7ecc2..7b0119bb 100644
--- a/tests/snapshots/testsuite/proposals/function-references/call_ref.wast/29.print
+++ b/tests/snapshots/testsuite/proposals/function-references/call_ref.wast/29.print
@@ -8,7 +8,7 @@
     unreachable
     i32.const 0
     ref.func $f
-    call_ref $t
+    call_ref 0
     drop
     i32.const 0
   )
diff --git a/tests/snapshots/testsuite/proposals/function-references/ref_as_non_null.wast/0.print b/tests/snapshots/testsuite/proposals/function-references/ref_as_non_null.wast/0.print
index d1387d3f..9926998d 100644
--- a/tests/snapshots/testsuite/proposals/function-references/ref_as_non_null.wast/0.print
+++ b/tests/snapshots/testsuite/proposals/function-references/ref_as_non_null.wast/0.print
@@ -5,12 +5,12 @@
   (func $nn (;0;) (type 1) (param $r (ref 0)) (result i32)
     local.get $r
     ref.as_non_null
-    call_ref $t
+    call_ref 0
   )
   (func $n (;1;) (type 2) (param $r (ref null 0)) (result i32)
     local.get $r
     ref.as_non_null
-    call_ref $t
+    call_ref 0
   )
   (func $f (;2;) (type $t) (result i32)
     i32.const 7
diff --git a/tests/snapshots/testsuite/proposals/function-references/return_call_ref.wast/0.print b/tests/snapshots/testsuite/proposals/function-references/return_call_ref.wast/0.print
index fb2a39b0..e74ad09f 100644
--- a/tests/snapshots/testsuite/proposals/function-references/return_call_ref.wast/0.print
+++ b/tests/snapshots/testsuite/proposals/function-references/return_call_ref.wast/0.print
@@ -51,67 +51,67 @@
   )
   (func (;12;) (type $-i32) (result i32)
     global.get $const-i32
-    return_call_ref $-i32
+    return_call_ref 1
   )
   (func (;13;) (type $-i64) (result i64)
     global.get $const-i64
-    return_call_ref $-i64
+    return_call_ref 2
   )
   (func (;14;) (type $-f32) (result f32)
     global.get $const-f32
-    return_call_ref $-f32
+    return_call_ref 3
   )
   (func (;15;) (type $-f64) (result f64)
     global.get $const-f64
-    return_call_ref $-f64
+    return_call_ref 4
   )
   (func (;16;) (type $-i32) (result i32)
     i32.const 32
     global.get $id-i32
-    return_call_ref $i32-i32
+    return_call_ref 5
   )
   (func (;17;) (type $-i64) (result i64)
     i64.const 64
     global.get $id-i64
-    return_call_ref $i64-i64
+    return_call_ref 6
   )
   (func (;18;) (type $-f32) (result f32)
     f32.const 0x1.51eb86p+0 (;=1.32;)
     global.get $id-f32
-    return_call_ref $f32-f32
+    return_call_ref 7
   )
   (func (;19;) (type $-f64) (result f64)
     f64.const 0x1.a3d70a3d70a3dp+0 (;=1.64;)
     global.get $id-f64
-    return_call_ref $f64-f64
+    return_call_ref 8
   )
   (func (;20;) (type $-i32) (result i32)
     f32.const 0x1.00ccccp+5 (;=32.1;)
     i32.const 32
     global.get $f32-i32
-    return_call_ref $f32-i32
+    return_call_ref 9
   )
   (func (;21;) (type $-i64) (result i64)
     i32.const 32
     i64.const 64
     global.get $i32-i64
-    return_call_ref $i32-i64
+    return_call_ref 10
   )
   (func (;22;) (type $-f32) (result f32)
     f64.const 0x1p+6 (;=64;)
     f32.const 0x1p+5 (;=32;)
     global.get $f64-f32
-    return_call_ref $f64-f32
+    return_call_ref 11
   )
   (func (;23;) (type $-f64) (result f64)
     i64.const 64
     f64.const 0x1.0066666666666p+6 (;=64.1;)
     global.get $i64-f64
-    return_call_ref $i64-f64
+    return_call_ref 12
   )
   (func (;24;) (type $proc)
     ref.null 0
-    return_call_ref $proc
+    return_call_ref 0
   )
   (func $fac-acc (;25;) (type $i64i64-i64) (param i64 i64) (result i64)
     local.get 0
@@ -126,7 +126,7 @@
       local.get 1
       i64.mul
       global.get $fac-acc
-      return_call_ref $i64i64-i64
+      return_call_ref 13
     end
   )
   (func $count (;26;) (type $i64-i64) (param i64) (result i64)
@@ -139,7 +139,7 @@
       i64.const 1
       i64.sub
       global.get $count
-      return_call_ref $i64-i64
+      return_call_ref 6
     end
   )
   (func $even (;27;) (type $i64-i64) (param i64) (result i64)
@@ -152,7 +152,7 @@
       i64.const 1
       i64.sub
       global.get $odd
-      return_call_ref $i64-i64
+      return_call_ref 6
     end
   )
   (func $odd (;28;) (type $i64-i64) (param i64) (result i64)
@@ -165,7 +165,7 @@
       i64.const 1
       i64.sub
       global.get $even
-      return_call_ref $i64-i64
+      return_call_ref 6
     end
   )
   (global $const-i32 (;0;) (ref 1) ref.func $const-i32)
diff --git a/tests/snapshots/testsuite/proposals/function-references/return_call_ref.wast/33.print b/tests/snapshots/testsuite/proposals/function-references/return_call_ref.wast/33.print
index db9c9d65..e22e5e4b 100644
--- a/tests/snapshots/testsuite/proposals/function-references/return_call_ref.wast/33.print
+++ b/tests/snapshots/testsuite/proposals/function-references/return_call_ref.wast/33.print
@@ -6,39 +6,39 @@
   (type $t4 (;4;) (func (result funcref)))
   (func $f11 (;0;) (type $t1) (result (ref 0))
     ref.func $f11
-    return_call_ref $t1
+    return_call_ref 1
   )
   (func $f21 (;1;) (type $t2) (result (ref null 0))
     ref.func $f11
-    return_call_ref $t1
+    return_call_ref 1
   )
   (func $f22 (;2;) (type $t2) (result (ref null 0))
     ref.func $f22
-    return_call_ref $t2
+    return_call_ref 2
   )
   (func $f31 (;3;) (type $t3) (result (ref func))
     ref.func $f11
-    return_call_ref $t1
+    return_call_ref 1
   )
   (func $f33 (;4;) (type $t3) (result (ref func))
     ref.func $f33
-    return_call_ref $t3
+    return_call_ref 3
   )
   (func $f41 (;5;) (type $t4) (result funcref)
     ref.func $f11
-    return_call_ref $t1
+    return_call_ref 1
   )
   (func $f42 (;6;) (type $t4) (result funcref)
     ref.func $f22
-    return_call_ref $t2
+    return_call_ref 2
   )
   (func $f43 (;7;) (type $t4) (result funcref)
     ref.func $f33
-    return_call_ref $t3
+    return_call_ref 3
   )
   (func $f44 (;8;) (type $t4) (result funcref)
     ref.func $f44
-    return_call_ref $t4
+    return_call_ref 4
   )
   (elem (;0;) declare func $f11 $f22 $f33 $f44)
 )
\ No newline at end of file
diff --git a/tests/snapshots/testsuite/proposals/function-references/return_call_ref.wast/40.print b/tests/snapshots/testsuite/proposals/function-references/return_call_ref.wast/40.print
index 70ed02cc..f725354e 100644
--- a/tests/snapshots/testsuite/proposals/function-references/return_call_ref.wast/40.print
+++ b/tests/snapshots/testsuite/proposals/function-references/return_call_ref.wast/40.print
@@ -2,7 +2,7 @@
   (type $t (;0;) (func (result i32)))
   (func (;0;) (type $t) (result i32)
     unreachable
-    return_call_ref $t
+    return_call_ref 0
   )
   (export "unreachable" (func 0))
 )
\ No newline at end of file
diff --git a/tests/snapshots/testsuite/proposals/function-references/return_call_ref.wast/42.print b/tests/snapshots/testsuite/proposals/function-references/return_call_ref.wast/42.print
index 09c8e10b..f439be69 100644
--- a/tests/snapshots/testsuite/proposals/function-references/return_call_ref.wast/42.print
+++ b/tests/snapshots/testsuite/proposals/function-references/return_call_ref.wast/42.print
@@ -7,7 +7,7 @@
   (func (;1;) (type 1) (result i32)
     unreachable
     ref.func $f
-    return_call_ref $t
+    return_call_ref 0
   )
   (export "unreachable" (func 1))
   (elem (;0;) declare func $f)
diff --git a/tests/snapshots/testsuite/proposals/function-references/return_call_ref.wast/44.print b/tests/snapshots/testsuite/proposals/function-references/return_call_ref.wast/44.print
index 97eaf8fe..1e11c9cc 100644
--- a/tests/snapshots/testsuite/proposals/function-references/return_call_ref.wast/44.print
+++ b/tests/snapshots/testsuite/proposals/function-references/return_call_ref.wast/44.print
@@ -8,7 +8,7 @@
     unreachable
     i32.const 0
     ref.func $f
-    return_call_ref $t
+    return_call_ref 0
     i32.const 0
   )
   (export "unreachable" (func 1))
diff --git a/tests/snapshots/testsuite/proposals/function-references/unreached-valid.wast/0.print b/tests/snapshots/testsuite/proposals/function-references/unreached-valid.wast/0.print
index 9cf18d83..0e97d968 100644
--- a/tests/snapshots/testsuite/proposals/function-references/unreached-valid.wast/0.print
+++ b/tests/snapshots/testsuite/proposals/function-references/unreached-valid.wast/0.print
@@ -62,7 +62,7 @@
   )
   (func (;7;) (type 2) (result i32)
     unreachable
-    call_ref $t
+    call_ref 0
   )
   (export "select-trap-left" (func 0))
   (export "select-trap-right" (func 1))
